/*-------------------------------------------------------------------------
   sdcc-lib.h - Top level header file for the sdcc libraries that enables
                target specific features.

   Copyright (C) 2004, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SDC51_SDCC_LIB_H
#define __SDC51_SDCC_LIB_H	1

#if defined(__SDCC_z80)
#include <asm/z80/features.h>

#elif defined(__SDCC_z180)
#include <asm/z180/features.h>

#elif defined(__SDCC_r2k)
#include <asm/r2k/features.h>

#elif defined(__SDCC_r3ka)
#include <asm/r3ka/features.h>

#elif defined(__SDCC_tlcs90)
#include <asm/tlcs90/features.h>

#elif defined(__SDCC_gbz80)
#include <asm/gbz80/features.h>

#elif defined(__SDCC_mcs51)
#include <asm/mcs51/features.h>

#elif defined(__SDCC_ds390)
#include <asm/ds390/features.h>

#elif defined(__SDCC_stm8)
#include <asm/stm8/features.h>

#else
/* PENDING */
#include <asm/default/features.h>

#endif

#endif

/*-------------------------------------------------------------------------
   stddef.h - ANSI functions forward declarations

   Copyright (C) 2004, Maarten Brock / sourceforge.brock@dse.nl
   Copyright (C) 2011, Philipp Klaus Krause / pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SDCC_STDDEF_H
#define __SDCC_STDDEF_H 1

#ifndef NULL
  #define NULL (void *)0
#endif

#ifndef __PTRDIFF_T_DEFINED
#define __PTRDIFF_T_DEFINED
#if defined (__SDCC_mcs51) || defined (__SDCC_ds390)
  typedef long int ptrdiff_t;
#else
  typedef int ptrdiff_t;
#endif
#endif

#ifndef __SIZE_T_DEFINED
#define __SIZE_T_DEFINED
  typedef unsigned int size_t;
#endif

#if __STDC_VERSION__ >= 201112L
  typedef unsigned char max_align_t;
#endif

#ifndef __WCHAR_T_DEFINED
#define __WCHAR_T_DEFINED
  typedef char wchar_t;
#endif

/* Bounds-checking interfaces from annex K of the C11 standard. */
#if defined (__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__

#ifndef __RSIZE_T_DEFINED
#define __RSIZE_T_DEFINED
typedef size_t rsize_t;
#endif

#ifndef __ERRNO_T_DEFINED
#define __ERRNO_T_DEFINED
typedef int errno_t;
#endif

#endif

#define offsetof(s, m) __builtin_offsetof (s, m)

#endif

/*-------------------------------------------------------------------------
   stdlib.h - ANSI functions forward declarations

   Copyright (C)1998, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SDC51_STDLIB_H
#define __SDC51_STDLIB_H 1

#ifndef NULL
# define NULL (void *)0
#endif

#include <malloc.h>

int abs(int j);
long int labs(long int j);

extern float atof (const char *nptr);
extern int atoi (const char *nptr);
extern long int atol (const char *nptr);
#ifdef __SDCC_LONGLONG
extern long long int atoll (const char *nptr);
#endif

extern void _uitoa(unsigned int, char*, unsigned char);
extern void _itoa(int, char*, unsigned char);

extern void _ultoa(unsigned long, char*, unsigned char);
extern void _ltoa(long, char*, unsigned char);

#define RAND_MAX 32767

int rand(void);
void srand(unsigned int seed);

/* Bounds-checking interfaces from annex K of the C11 standard. */
#if defined (__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__

#ifndef __RSIZE_T_DEFINED
#define __RSIZE_T_DEFINED
typedef size_t rsize_t;
#endif

#ifndef __ERRNO_T_DEFINED
#define __ERRNO_T_DEFINED
typedef int errno_t;
#endif

typedef void (*constraint_handler_t)(const char *restrict msg, void *restrict ptr, errno_t error);

#endif

#endif
/*-------------------------------------------------------------------------
   time.h

   Copyright (C) 2001, Johan Knol <johan.knol AT iduna.nl>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef TIME_H
#define TIME_H

#ifndef __TIME_UNSIGNED
#define __TIME_UNSIGNED 1
#endif

/* Bounds-checking interfaces from annex K of the C11 standard. */
#if defined (__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__

#ifndef __RSIZE_T_DEFINED
#define __RSIZE_T_DEFINED
typedef size_t rsize_t;
#endif

#ifndef __ERRNO_T_DEFINED
#define __ERRNO_T_DEFINED
typedef int errno_t;
#endif

#endif

#if __TIME_UNSIGNED
struct tm
{
  unsigned char tm_sec;                   /* Seconds.     [0-60]      */
  unsigned char tm_min;                   /* Minutes.     [0-59]      */
  unsigned char tm_hour;                  /* Hours.       [0-23]      */
  unsigned char tm_mday;                  /* Day.         [1-31]      */
  unsigned char tm_mon;                   /* Month.       [0-11]      */
  int tm_year;                            /* Year since 1900          */
  unsigned char tm_wday;                  /* Day of week. [0-6]       */
  int tm_yday;                            /* Days in year.[0-365]     */
  unsigned char tm_isdst;                 /* Daylight saving time     */
  unsigned char tm_hundredth;             /* not standard 1/100th sec */
};
#else
struct tm
{
  int tm_sec;                   /* Seconds.     [0-60]  */
  int tm_min;                   /* Minutes.     [0-59]  */
  int tm_hour;                  /* Hours.       [0-23]  */
  int tm_mday;                  /* Day.         [1-31]  */
  int tm_mon;                   /* Month.       [0-11]  */
  int tm_year;                  /* Year since 1900      */
  int tm_wday;                  /* Day of week. [0-6]   */
  int tm_yday;                  /* Days in year.[0-365] */
  int tm_isdst;                 /* Daylight saving time */
  char *tm_zone;                /* Abbreviated timezone */
};
#endif

typedef unsigned long time_t;

time_t time(time_t *t);
struct tm *gmtime(time_t *timep);
struct tm *localtime(time_t *timep);
time_t mktime(struct tm *timeptr);
char *asctime(struct tm *timeptr);
char *ctime(time_t *timep);

#endif /* TIME_H */
/*-------------------------------------------------------------------------
   time.h

   Copyright (C) 2001, Johan Knol <johan.knol AT iduna.nl>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef TINIBIOS_H

#define TINIBIOS_H

#include <ds80c390.h>
#include <time.h>

void Serial0Init (unsigned long baud, unsigned char buffered);
char Serial0GetChar(void);
void Serial0PutChar(char);
char Serial0CharArrived(void);
void Serial0Baud(unsigned long baud);
void Serial0SendBreak(void);
void Serial0Flush(void);

void Serial0SwitchToBuffered(void); /* ds400 only. */

void Serial1Init (unsigned long baud, unsigned char buffered);
char Serial1GetChar(void);
void Serial1PutChar(char);
char Serial1CharArrived(void);
void Serial1Baud(unsigned long baud);
void Serial1SendBreak(void);
void Serial1Flush(void);

unsigned long ClockTicks();
void ClockMilliSecondsDelay(unsigned long ms);
void ClockMicroSecondsDelay(unsigned int us);

#define SERIAL_0_BAUD 115200L
#define SERIAL_1_BAUD 9600L

/* these need to be binary numbers */
#define SERIAL_0_RECEIVE_BUFFER_SIZE 1024
#define SERIAL_1_RECEIVE_BUFFER_SIZE 64

/* I know someone is fooling with the crystals */
#if defined(__SDCC_ds400)
# define OSCILLATOR 14745600L
#else
# define OSCILLATOR 18432000L
#endif

/* Set the cpu speed in clocks per machine cycle, valid values are:
   1024: Divide-by-1024 (power management) mode (screws ALL timers and serial)
      4: Standard 8051 divide-by-4 mode
      2: Use 2x xtal multiplier
      1: Use 4x xtal multiplier (Don't do this with a TINI at 18.432MHz)
*/
#define CPU_SPEED 2
void CpuSpeed(unsigned int speed);

/* The MOVX stretch cycles, see datasheet */
#define CPU_MOVX_STRETCH 0x01

/* from rtc390.c */
#define HAVE_RTC
unsigned char RtcRead(struct tm *rtcDate);
void RtcWrite(struct tm *rtcDate);

/* from lcd390.c */
extern void LcdInit(void);
extern void LcdOn(void);
extern void LcdOff(void);
extern void LcdClear(void);
extern void LcdHome(void);
extern void LcdGoto(unsigned int collumnRow);
extern void LcdPutChar(char c);
extern void LcdPutString(char *string);
extern void LcdLPutString(unsigned int collumnRow, char *string);
extern void LcdPrintf(const char *format, ...) __reentrant;
extern void LcdLPrintf(unsigned int collumnRow, const char *format, ...) __reentrant;

/* from i2c390.c */
#define I2C_BUFSIZE 128
extern char I2CReset(void);
extern char I2CStart(void);
extern char I2CStop(void);
extern char I2CSendStop(char addr, char count,
			char send_stop);
extern char I2CReceive(char addr, char count);
extern char I2CSendReceive(char addr, char tx_count,
			   char rx_count);
/*extern char I2CByteOut(char);*/
/*extern void I2CDumpError(char);*/

/* global transfer buffers */
extern char i2cTransmitBuffer[I2C_BUFSIZE];
extern char i2cReceiveBuffer[I2C_BUFSIZE];

/* Macro for normal send transfer ending with a stop condition */
#define I2CSend(addr, count)   I2CSendStop(addr, count, 1)


/* internal functions used by tinibios.c */
unsigned char _sdcc_external_startup(void);
void Serial0IrqHandler (void) __interrupt 4;
void Serial1IrqHandler (void) __interrupt 7;

#if !defined(__SDCC_ds400)
void ClockInit();
void ClockIrqHandler (void) __interrupt 1 __naked;
#endif

#if defined(__SDCC_ds400)
/* functions for dealing with the ds400 ROM firmware. */

/* A wrapper which calls rom_init allocating all available RAM in CE0
   to the heap, sets the serial port to SERIAL_0_BAUD, sets up the
   millisecond timer, and diddles the clock multiplier. */

/* Values for the romInit "speed" parameter. */
#define SPEED_1X	0 /* no clock multiplier, normal speed. */
#define SPEED_2X	1 /* 2x clock multiplier. */
#define SPEED_4X	2 /* 4x clock, DOESN'T WORK ON TINIm400! */

unsigned char romInit(unsigned char noisy,
		      char speed);

/* Install an interrupt handler. */
void installInterrupt(void (*isrPtr)(void), unsigned char offset);
#endif


#endif /* TINIBIOS_H */
/*-------------------------------------------------------------------------
   string.h - ISO header for string library functions

   Copyright (C) 1998, Sandeep Dutta
   Copyright (C) 2009-2011, Philipp Klaus Krause pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SDCC_STRING_H
#define __SDCC_STRING_H 1

#ifndef NULL
# define NULL (void *)0
#endif

#ifndef __SIZE_T_DEFINED
# define __SIZE_T_DEFINED
  typedef unsigned int size_t;
#endif

/* Bounds-checking interfaces from annex K of the C11 standard. */
#if defined (__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__

#ifndef __RSIZE_T_DEFINED
#define __RSIZE_T_DEFINED
typedef size_t rsize_t;
#endif

#ifndef __ERRNO_T_DEFINED
#define __ERRNO_T_DEFINED
typedef int errno_t;
#endif

#endif

#if defined(__SDCC_mcs51) || defined(__SDCC_hc08) || defined(__SDCC_ds390) || defined(__SDCC_pic14) || defined(__SDCC_pic16)
#define __SDCC_BROKEN_STRING_FUNCTIONS
#endif

/* The function prototypes are ordered as in the ISO C99 standard. */

/* Todo: fix the "restrict" stuff for C99 compliance. */

/* Copying functions: */
extern void *memcpy (void * /*restrict */ dest, const void * /*restrict*/ src, size_t n);
extern void *memmove (void *dest, const void *src, size_t n);
extern char *strcpy (char * /*restrict*/ dest, const char * /*restrict*/ src);
extern char *strncpy(char * /*restrict*/ dest, const char * /*restrict*/ src, size_t n);

/* Concatenation functions: */
extern char *strcat (char * /*restrict*/ dest, const char * /*restrict*/ src);
extern char *strncat(char * /*restrict*/ dest, const char * /*restrict*/ src, size_t n);

/* Comparison functions: */
extern int memcmp (const void *s1, const void *s2, size_t n);
extern int strcmp (const char *s1, const char *s2);
#define strcoll(s1, s2) strcmp(s1, s2)
/*int strcoll(const char *s1, const char *s2) {return strcmp(s1, s2);}*/
extern int strncmp(const char *s1, const char *s2, size_t n);
extern size_t strxfrm(char *dest, const char *src, size_t n);

/* Search functions: */
extern void *memchr (const void *s, int c, size_t n);
#ifdef __SDCC_BROKEN_STRING_FUNCTIONS
extern char *strchr (const char *s, char c); /* c should be int according to standard. */
#else
extern char *strchr (const char *s, int c);
#endif
extern size_t strcspn(const char *s, const char *reject);
extern char *strpbrk(const char *s, const char *accept);
#ifdef __SDCC_BROKEN_STRING_FUNCTIONS
extern char *strrchr(const char *s, char c); /* c should be int according to standard. */
#else
extern char *strrchr(const char *s, int c);
#endif
extern size_t strspn (const char *s, const char *accept);
extern char *strstr (const char *haystack, const char *needle);
extern char *strtok (char * /* restrict*/ str, const char * /*restrict*/ delim);

/* Miscanelleous functions: */
#ifdef __SDCC_BROKEN_STRING_FUNCTIONS
extern void *memset (void *s, unsigned char c, size_t n); /* c should be int according to standard. */
#else
extern void *memset (void *s, int c, size_t n);
#endif

/* extern char *strerror(int errnum); */
extern size_t strlen (const char *s);

#ifdef __SDCC_ds390
extern void __xdata * memcpyx(void __xdata *, void __xdata *, int) __naked;
#endif

#if defined(__SDCC_z80) || defined(__SDCC_z180) || defined(__SDCC_r2k) || defined(__SDCC_r3ka)
#define memcpy(dst, src, n) __builtin_memcpy(dst, src, n)
#define strcpy(dst, src) __builtin_strcpy(dst, src)
#define strncpy(dst, src, n) __builtin_strncpy(dst, src, n)
#define strchr(s, c) __builtin_strchr(s, c)
#define memset(dst, c, n) __builtin_memset(dst, c, n)
#endif

#endif
/*-------------------------------------------------------------------------
   iso646.h

   Copyright (C) 2011, Philipp Klaus Krause . pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SDCC_ISO646_H
#define __SDCC_ISO646_H

#define and &&
#define and_eq &=
#define bitand &
#define bitor |
#define complement ~
#define not !
#define not_eq !=
#define or ||
#define or_eq |=
#define xor ^
#define xor_eq ^=

#endif

/*-------------------------------------------------------------------------
   errno.h: Error codes used in the math functions

   Copyright (C) 2001, Jesus Calvino-Fraga, jesusc@ieee.org 

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Version 1.0 - Initial release */

#ifndef _INC_ERRNO
#define _INC_ERRNO

extern int errno;

/* Error Codes: */

#define EDOM        33  /* Math argument out of domain of functions */
#define ERANGE      34  /* Math result not representable */

/* Bounds-checking interfaces from annex K of the C11 standard. */
#if defined (__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__

#ifndef __ERRNO_T_DEFINED
#define __ERRNO_T_DEFINED
typedef int errno_t;
#endif

#endif

#endif  /* _INC_ERRNO */

/*-------------------------------------------------------------------------
   typeof.h - Contains enumerations of values returned by __typeof
 
   Copyright (C) 2001, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SDC51_TYPEOF_H
#define __SDC51_TYPEOF_H 1

#define TYPEOF_INT        1
#define TYPEOF_SHORT      2
#define TYPEOF_CHAR       3
#define TYPEOF_LONG       4
#define TYPEOF_FLOAT      5
#define TYPEOF_FIXED16X16 6
#define TYPEOF_BIT        7
#define TYPEOF_BITFIELD   8
#define TYPEOF_SBIT       9
#define TYPEOF_SFR        10
#define TYPEOF_VOID       11
#define TYPEOF_STRUCT     12
#define TYPEOF_ARRAY      13
#define TYPEOF_FUNCTION   14
#define TYPEOF_POINTER    15
#define TYPEOF_FPOINTER   16
#define TYPEOF_CPOINTER   17
#define TYPEOF_GPOINTER   18
#define TYPEOF_PPOINTER   19
#define TYPEOF_IPOINTER   20
#define TYPEOF_EEPPOINTER 21

#endif
/*-------------------------------------------------------------------------
   stdio.h - ANSI functions forward declarations

   Copyright (C) 1998, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SDC51_STDIO_H
#define __SDC51_STDIO_H 1

#include <stdarg.h>

#ifdef __ds390
#include <tinibios.h>
#endif

#include <sdcc-lib.h>

#ifndef EOF
  #define EOF (-1)
#endif

#ifndef NULL
  #define NULL (void *)0
#endif

#ifndef __SIZE_T_DEFINED
#define __SIZE_T_DEFINED
  typedef unsigned int size_t;
#endif

/* Bounds-checking interfaces from annex K of the C11 standard. */
#if defined (__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__

#ifndef __RSIZE_T_DEFINED
#define __RSIZE_T_DEFINED
typedef size_t rsize_t;
#endif

#ifndef __ERRNO_T_DEFINED
#define __ERRNO_T_DEFINED
typedef int errno_t;
#endif

#endif

typedef void (*pfn_outputchar)(char c, void* p) _REENTRANT;

extern int _print_format (pfn_outputchar pfn, void* pvoid, const char *format, va_list ap);

/*-----------------------------------------------------------------------*/

extern void printf_small (char *,...) _REENTRANT;
extern int printf (const char *,...);
extern int vprintf (const char *, va_list);
extern int sprintf (char *, const char *, ...);
extern int vsprintf (char *, const char *, va_list);
extern int puts(const char *);

#if __STDC_VERSION__ < 201112L
extern char *gets(char *);
#endif

extern char getchar(void);
extern void putchar(char);

#if defined(__SDCC_mcs51) && !defined(__SDCC_USE_XSTACK)
extern void printf_fast(__code const char *fmt, ...) _REENTRANT;
extern void printf_fast_f(__code const char *fmt, ...) _REENTRANT;
extern void printf_tiny(__code const char *fmt, ...) _REENTRANT;
#endif

#endif /* __SDC51_STDIO_H */
/*-------------------------------------------------------------------------
   assert.h - header file for assert ANSI routine

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#undef assert

#ifdef NDEBUG

/* Debugging disabled -- do not evaluate assertions. */
#define assert(x) ((void)0)

#else

/* Debugging enabled -- verify assertions at run time. */
void _assert(char *, const char *, unsigned int);
#define assert(x) ((x) == 0 ? _assert(#x, __FILE__, __LINE__):(void)0)

#if __STDC_VERSION__ >= 201112L
#define static_assert _Static_assert
#endif

#endif
/*-------------------------------------------------------------------------
   limits.h - ANSI defines constants for sizes of integral types

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SDC51_LIMITS_H
#define __SDC51_LIMITS_H 1

#define CHAR_BIT      8    /* bits in a char */
#define SCHAR_MAX   127
#define SCHAR_MIN  -128
#define UCHAR_MAX   0xff
#ifdef __SDCC_CHAR_UNSIGNED
#define CHAR_MAX    UCHAR_MAX
#define CHAR_MIN    0
#else
#define CHAR_MAX    SCHAR_MAX
#define CHAR_MIN    SCHAR_MIN
#endif
#define MB_LEN_MAX  1
#define INT_MIN    -32768
#define INT_MAX     32767
#define SHRT_MAX    INT_MAX
#define SHRT_MIN    INT_MIN
#define UINT_MAX    0xffff
#define UINT_MIN    0
#define USHRT_MAX   UINT_MAX
#define USHRT_MIN   UINT_MIN
#define LONG_MIN    (-2147483647L-1)
#define LONG_MAX    2147483647L
#define ULONG_MAX   0xffffffff
#define ULONG_MIN   0
#define LLONG_MIN   (-9223372036854775807LL-1)
#define LLONG_MAX   9223372036854775807LL
#define ULLONG_MAX  18446744073709551615ULL

#endif






/*-------------------------------------------------------------------------
   malloc.h - malloc header file

   Copyright (C) 1997, Dmitry S. Obukhov <dmitry.obukhov AT gmail.com>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SDCC51_MALLOC_H
#define __SDCC51_MALLOC_H
#include <sdcc-lib.h>
#include <stddef.h>

#if _SDCC_MALLOC_TYPE_MLH

void * calloc (size_t nmemb, size_t size);
void * malloc (size_t size);
void * realloc (void * ptr, size_t size);
void free (void * ptr);

#else

extern void __xdata * calloc (size_t nmemb, size_t size);
extern void __xdata * malloc (size_t size);
extern void __xdata * realloc (void * ptr, size_t size);
extern void free (void * ptr);

#endif

#endif
/*-------------------------------------------------------------------------
   float.h - ANSI functions forward declarations

   Copyright (C) 1998, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SDC51_FLOAT_H
#define __SDC51_FLOAT_H 1

#include <limits.h>

#define FLT_RADIX       2
#define FLT_MANT_DIG    24
#define FLT_EPSILON     1.192092896E-07F
#define FLT_DIG         6
#define FLT_MIN_EXP     (-125)
#define FLT_MIN         1.175494351E-38F
#define FLT_MIN_10_EXP  (-37)
#define FLT_MAX_EXP     (+128)
#define FLT_MAX         3.402823466E+38F
#define FLT_MAX_10_EXP  (+38)

/* the following deal with IEEE single-precision numbers */
#define EXCESS		126
#define SIGNBIT		((unsigned long)0x80000000)
#define __INFINITY	((unsigned long)0x7F800000)
#define HIDDEN		(unsigned long)(1ul << 23)
#define SIGN(fp)	(((unsigned long)(fp) >> (8*sizeof(fp)-1)) & 1)
#define EXP(fp)		(((unsigned long)(fp) >> 23) & (unsigned int) 0x00FF)
#define MANT(fp)	(((fp) & (unsigned long)0x007FFFFF) | HIDDEN)
#define NORM            0xff000000
#define PACK(s,e,m)	((s) | ((unsigned long)(e) << 23) | (m))

float __uchar2fs (unsigned char);
float __schar2fs (signed char);
float __uint2fs (unsigned int);
float __sint2fs (signed int);
float __ulong2fs (unsigned long);
float __slong2fs (signed long);
unsigned char __fs2uchar (float);
signed char __fs2schar (float);
unsigned int __fs2uint (float);
signed int __fs2sint (float);
unsigned long __fs2ulong (float);
signed long __fs2slong (float);

float __fsadd (float, float);
float __fssub (float, float);
float __fsmul (float, float);
float __fsdiv (float, float);

char __fslt (float, float);
char __fseq (float, float);
char __fsgt (float, float);


#if defined(__SDCC_FLOAT_LIB) && defined(__SDCC_mcs51) && !defined(__SDCC_USE_XSTACK) && !defined(_SDCC_NO_ASM_LIB_FUNCS)

#define FLOAT_ASM_MCS51

/* This adds extra code for proper round-off, in
   an attempt to match the results from gcc. */
#define FLOAT_FULL_ACCURACY

/* This adds about 66 bytes to the code size and
   significantly speeds up shift operations more
   than 8 bits (common when subtracting numbers
   of significantly different magnitude and scaling
   to fixed point) */
#define FLOAT_SHIFT_SPEEDUP

#define sign_a  psw.1
#define sign_b  psw.5
#define exp_a dpl
#define exp_b dph
#endif	/* using mcs51 assembly */


#endif	/* __SDC51_FLOAT_H */

/*-------------------------------------------------------------------------
   setjmp.h - header file for setjmp & longjmp ANSI routines

   Copyright (C) 1999, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SDCC_SETJMP_H
#define __SDCC_SETJMP_H

#define SP_SIZE		1

#ifdef __SDCC_STACK_AUTO
#define BP_SIZE		SP_SIZE
#else
#define BP_SIZE		0
#endif

#ifdef __SDCC_USE_XSTACK
#define SPX_SIZE	1
#else
#define SPX_SIZE	0
#endif

#define BPX_SIZE	SPX_SIZE

#ifdef __SDCC_MODEL_HUGE
#define RET_SIZE	3
#else
#define RET_SIZE	2
#endif

#if defined (__SDCC_z80) || defined (__SDCC_z180) || defined (__SDCC_r2k) || defined (__SDCC_r3ka)
typedef unsigned char jmp_buf[6]; // 2 for the stack pointer, 2 for the return address, 2 for the frame pointer.
#elif defined (__SDCC_stm8)
typedef unsigned char jmp_buf[4]; // 2 for the stack pointer, 2 for the return address.
#else
typedef unsigned char jmp_buf[RET_SIZE + SP_SIZE + BP_SIZE + SPX_SIZE + BPX_SIZE];
#endif

int __setjmp (jmp_buf);

// C99 might require setjmp to be a macro. The standard seems self-contradicting on this issue.
// However, it is clear that the standards allow setjmp to be a macro.
#define setjmp(jump_buf) __setjmp(jump_buf)

#ifndef __SDCC_HIDE_LONGJMP
_Noreturn void longjmp(jmp_buf, int);
#endif

#undef RET_SIZE
#undef SP_SIZE
#undef BP_SIZE
#undef SPX_SIZE
#undef BPX_SIZE

#endif

#ifndef __SDCC_STDALIGN_H
#define __SDCC_STDALIGN_H 1

#ifndef __alignas_is_defined
#define __alignas_is_defined 1

#define alignas _Alignas

#endif


#ifndef __alignof_is_defined
#define __alignof_is_defined 1

#define alignof _Alignof

#endif

#endif

/*-------------------------------------------------------------------------
   ctype.h

   Philipp Klaus Krause, philipp@informatik.uni-frankfurt.de 2013

   (c) 2013 Goethe-UniversitÃ¤t Frankfurt

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SDCC_CTYPE_H
#define __SDCC_CTYPE_H 1

extern int isalnum (int c);
extern int isalpha (int c);
extern int iscntrl (int c);
extern int isgraph (int c);
extern int isprint (int c);
extern int ispunct (int c);
extern int isspace (int c);
extern int isalnum (int c);
extern int isalnum (int c);
extern int isxdigit (int c);

extern int tolower (int c);
extern int toupper (int c);

/* Provide inline versions for the most used functions for efficiency */
#if __STDC_VERSION__ >= 199901L

inline int isblank (int c)
{
  return ((unsigned char)c == ' ' || (unsigned char)c == '\t');
}

#ifdef EOF
_Static_assert(!((unsigned char)EOF == ' ' || (unsigned char)EOF == '\t'), "EOF out of range - ");
#endif

inline int isdigit (int c)
{
  return ((unsigned char)c >= '0' && (unsigned char)c <= '9');
}

#ifdef EOF
_Static_assert(!((unsigned char)EOF >= '0' && (unsigned char)EOF <= '9'), "EOF out of range - ");
#endif

inline int islower (int c)
{
  return ((unsigned char)c >= 'a' && (unsigned char)c <= 'z');
}

#ifdef EOF
_Static_assert(!((unsigned char)EOF >= 'a' && (unsigned char)EOF <= 'z'), "EOF out of range - ");
#endif

inline int isupper (int c)
{
  return ((unsigned char)c >= 'A' && (unsigned char)c <= 'Z');
}

#ifdef EOF
_Static_assert(!((unsigned char)EOF >= 'A' && (unsigned char)EOF <= 'Z'), "EOF out of range - ");
#endif

#else

extern int isblank (int c);
extern int isdigit (int c);
extern int islower (int c);
extern int isupper (int c);

#endif

#endif
/*-------------------------------------------------------------------------
   stdbool.h - ANSI functions forward declarations

   Copyright (C) 2004, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SDC51_STDBOOL_H
#define __SDC51_STDBOOL_H 1

#define true 1
#define false 0

#if defined (__SDCC_ds390) || defined (__SDCC_mcs51) || defined (__SDCC_xa51)
 /* The ports that have __bit and use it as an imperfect substitute for bool */
 #define _Bool __bit
 #define bool  _Bool
 #define __bool_true_false_are_defined 1
 #define __SDCC_WEIRD_BOOL 1
#else
 /* The ports that have bool */
 #define bool _Bool
 #define __bool_true_false_are_defined 1
#endif

#endif

/*-------------------------------------------------------------------------
   ds80c390.h - Register Declarations for the DALLAS DS80C390 Processor
                 far from complete, e.g. no CAN

   Copyright (C) 2000, Johan Knol <johan.knol AT iduna.nl>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef DS80C390_H
#define DS80C390_H

__sfr __at 0x80 P4; 		/* ce3..ce0, a19..a16 */
__sfr __at 0x81 SP; 		/* stack pointer */
__sfr __at 0x82 DPL; 		/* data pointer 0 lsb */
__sfr __at 0x83 DPH; 		/* data pointer 0 msb */
__sfr __at 0x84 DPL1; 		/* data pointer 1 lsb */
__sfr __at 0x85 DPH1; 		/* data pointer 1 msb */
__sfr __at 0x86 DPS; 		/* data pointer select */
__sfr __at 0x87 PCON; 		/* power control */
__sfr __at 0x88 TCON; 		/* timer/counter control */
  __sbit __at 0x88 IT0;
  __sbit __at 0x89 IE0;
  __sbit __at 0x8a IT1;
  __sbit __at 0x8b IE1;
  __sbit __at 0x8c TR0;
  __sbit __at 0x8d TF0;
  __sbit __at 0x8e TR1;
  __sbit __at 0x8f TF1;
__sfr __at 0x89 TMOD; 		/* timer mode control */
__sfr __at 0x8a TL0; 		/* timer 0 lsb */
__sfr __at 0x8b TL1; 		/* timer 1 msb */
__sfr __at 0x8c TH0; 		/* timer 0 msb */
__sfr __at 0x8d TH1; 		/* timer 1 msb */
__sfr __at 0x8e CKCON; 		/* clock control */
__sfr __at 0x90 P1;
  __sbit __at 0x90 T2;
  __sbit __at 0x91 T2EX;
  __sbit __at 0x92 RXD1;
  __sbit __at 0x93 TXD1;
  __sbit __at 0x94 INT2;
  __sbit __at 0x95 INT3;
  __sbit __at 0x96 INT4;
  __sbit __at 0x97 INT5;
__sfr __at 0x91 EXIF; 		/* external interrupt flag */
__sfr __at 0x92 P4CNT;
__sfr __at 0x93 DPX; 		/* extended datapointer 0 */
__sfr __at 0x95 DPX1; 		/* extended datapointer 1 */
__sfr __at 0x98 SCON0; 		/* serial 0 control */
  __sbit __at 0x98 RI_0;
  __sbit __at 0x99 TI_0;
  __sbit __at 0x9a RB8_0;
  __sbit __at 0x9b TB8_0;
  __sbit __at 0x9c REN_0;
  __sbit __at 0x9d SM2_0;
  __sbit __at 0x9e SM1_0;
  __sbit __at 0x9f SM0_0;
  __sbit __at 0x9f FE_0;	/* depending on SMOD0 */
__sfr __at 0x99 SBUF0;		/* serial 0 data buffer */
__sfr __at 0x9b ESP; 		/* extended stack pointer */
__sfr __at 0x9c AP; 		/* address page */
__sfr __at 0x9d ACON; 		/* address control */
__sfr __at 0xa0 P2; 		/* never mind the sbits */
__sfr __at 0xa1 P5;
__sfr __at 0xa2 P5CNT;
__sfr __at 0xa8 IE; 		/* interrupt enable */
  __sbit __at 0xa8 EX0;
  __sbit __at 0xa9 ET0;
  __sbit __at 0xaa EX1;
  __sbit __at 0xab ET1;
  __sbit __at 0xac ES0;
  __sbit __at 0xad ET2;
  __sbit __at 0xae ES1;
  __sbit __at 0xaf EA;
__sfr __at 0xb0 P3;
  __sbit __at 0xb0 RXD0;
  __sbit __at 0xb1 TXD0;
  __sbit __at 0xb2 INT0;
  __sbit __at 0xb3 INT1;
  __sbit __at 0xb4 T0;
  __sbit __at 0xb5 T1;
  __sbit __at 0xb6 WR;
  __sbit __at 0xb7 RD;
__sfr __at 0xb8 IP; 		/* interupt priority */
  __sbit __at 0xb8 PX0; 	/* external 0 */
  __sbit __at 0xb9 PT0; 	/* timer 0 */
  __sbit __at 0xba PX1; 	/* external 1 */
  __sbit __at 0xbb PT1; 	/* timer 1 */
  __sbit __at 0xbc PS0; 	/* serial port 0 */
  __sbit __at 0xbd PT2; 	/* timer 2 */
  __sbit __at 0xbe PS1; 	/* serial port 1 */
__sfr __at 0xc0 SCON1; 		/* serial 1 control */
  __sbit __at 0xc0 RI_1;
  __sbit __at 0xc1 TI_1;
  __sbit __at 0xc2 RB8_1;
  __sbit __at 0xc3 TB8_1;
  __sbit __at 0xc4 REN_1;
  __sbit __at 0xc5 SM2_1;
  __sbit __at 0xc6 SM1_1;
  __sbit __at 0xc7 SM0_1;
  __sbit __at 0xc7 FE_1;	/* depending on SMOD0 */
__sfr __at 0xc1 SBUF1; 		/* serial 1 data buffer */
__sfr __at 0xc4 PMR; 		/* power managment */
__sfr __at 0xc6 MCON; 		/* memory control register */
__sfr __at 0xc7 TA; 		/* timed access register */
__sfr __at 0xc8 T2CON; 		/* timer 2 control */
  __sbit __at 0xc8 CP_RL;	/* capture/reload */
  __sbit __at 0xc9 C_T; 	/* count/timer */
  __sbit __at 0xca TR2; 	/* stop/run */
  __sbit __at 0xcb EXEN2;
  __sbit __at 0xcc TCLK;
  __sbit __at 0xcd RCLK;
  __sbit __at 0xce EXF2;
  __sbit __at 0xcf TF2; 	/* overflow flag */
__sfr __at 0xc9 T2MOD; 		/* timer 2 mode */
__sfr __at 0xca RCAP2L; 	/* timer 2 capture/reload */
__sfr __at 0xca RTL2; 		/* depends on CP_RL */
__sfr __at 0xcb RCAP2H;
__sfr __at 0xcb RTH2;
__sfr __at 0xcc TL2; 		/* timer 2 lsb */
__sfr __at 0xcd TH2; 		/* timer 2 msb */
__sfr __at 0xd0 PSW; 		/* program status word (byte actually) */
  __sbit __at 0xd0 P; 		/* parity */
  __sbit __at 0xd1 F1; 		/* user flag 1 */
  __sbit __at 0xd2 OV; 		/* overflow flag */
  __sbit __at 0xd3 RS0; 	/* register select l */
  __sbit __at 0xd4 RS1; 	/* register select h */
  __sbit __at 0xd5 F0; 		/* user flag 0 */
  __sbit __at 0xd6 AC; 		/* auxiliary carry flag */
  __sbit __at 0xd7 CY; 		/* carry flag */
__sfr __at 0xd1 MCNT0; 		/* arithmetic accellerator */
__sfr __at 0xd2 MCNT1;
__sfr __at 0xd3 MA;
__sfr __at 0xd4 MB;
__sfr __at 0xd5 MC;
__sfr __at 0xd8 WDCON; 		/* watch dog */
  __sbit __at 0xd8 RWT;
  __sbit __at 0xd9 EWT;
  __sbit __at 0xda WDRF;
  __sbit __at 0xdb WDIF;
  __sbit __at 0xdc PFI;
  __sbit __at 0xdd EPFI;
  __sbit __at 0xde POR;
  __sbit __at 0xdf SMOD_1;
__sfr __at 0xe0 ACC; 		/* accumulator */
__sfr __at 0xe8 EIE; 		/* extended interrupt enable */
  __sbit __at 0xe8 EX2;
  __sbit __at 0xe9 EX3;
  __sbit __at 0xea EX4;
  __sbit __at 0xeb EX5;
  __sbit __at 0xec EWDI;
  __sbit __at 0xed C1IE;
  __sbit __at 0xee C0IE;
  __sbit __at 0xef CANBIE;
__sfr __at 0xea MXAX; 		/* extended address register */
__sfr __at 0xf0 B; 			/* aux accumulator */
__sfr __at 0xf8 EIP; 		/* extended interrupt priority */
  __sbit __at 0xf8 PX2;
  __sbit __at 0xf9 PX3;
  __sbit __at 0xfa PX4;
  __sbit __at 0xfb PX5;
  __sbit __at 0xfc PWDI;
  __sbit __at 0xfd C1IP;
  __sbit __at 0xfe C0IP;
  __sbit __at 0xff CANBIP;

/*  WORD/DWORD Registers  */

__sfr16 __at (0x8C8A) TMR0;  /* TIMER 0 COUNTER   				*/
__sfr16 __at (0x8D8B) TMR1;  /* TIMER 1 COUNTER                 */
__sfr16 __at (0xCDCC) TMR2;  /* TIMER 2 COUNTER                 */
__sfr16 __at (0xCBCA) RCAP2; /* TIMER 2 CAPTURE REGISTER WORD	*/

#endif /* DS80C390_H */
/*-------------------------------------------------------------------------
   math.h: Floating point math function declarations

   Copyright (C) 2001, Jesus Calvino-Fraga, jesusc@ieee.org

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/* Version 1.0 - Initial release */

#ifndef _INC_MATH
#define _INC_MATH

#define HUGE_VALF   3.402823466e+38

#define PI          3.1415926536
#define TWO_PI      6.2831853071
#define HALF_PI     1.5707963268
#define QUART_PI    0.7853981634
#define iPI         0.3183098862
#define iTWO_PI     0.1591549431
#define TWO_O_PI    0.6366197724

/* EPS=B**(-t/2), where B is the radix of the floating-point representation
   and there are t base-B digits in the significand.  Therefore, for floats
   EPS=2**(-12).  Also define EPS2=EPS*EPS. */
#define EPS 244.14062E-6
#define EPS2 59.6046E-9

union float_long
{
    float f;
    long l;
};

#if defined(__SDCC_MATH_LIB) && defined(__SDCC_mcs51) && !defined(__SDCC_USE_XSTACK) && !defined(__SDCC_STACK_AUTO) && !defined(_SDCC_NO_ASM_LIB_FUNCS)
/* Compile the mcs51 assembly version only when all these
   conditions are met.  Since not all the functions are
   reentrant, do not compile with --stack-auto is used. */
#define MATH_ASM_MCS51
#endif


/* Functions on the z80 & gbz80 are always reentrant and so the "reentrant" */
/* keyword is not defined. */
#if defined(__SDCC_z80) || defined(__SDCC_z180) || defined(__SDCC_r2k) || defined(__SDCC_r3ka) || defined(__SDCC_tlcs90) || defined(__SDCC_gbz80) || defined(__SDCC_stm8)
#define _FLOAT_FUNC_REENTRANT
#else
#define _FLOAT_FUNC_REENTRANT __reentrant
#endif

/**********************************************
 * Prototypes for float ANSI C math functions *
 **********************************************/

/* Trigonometric functions */
float sinf(float x) _FLOAT_FUNC_REENTRANT;
float cosf(float x) _FLOAT_FUNC_REENTRANT;
float tanf(float x) _FLOAT_FUNC_REENTRANT;
float cotf(float x) _FLOAT_FUNC_REENTRANT;
float asinf(float x) _FLOAT_FUNC_REENTRANT;
float acosf(float x) _FLOAT_FUNC_REENTRANT;
float atanf(float x) _FLOAT_FUNC_REENTRANT;
float atan2f(float x, float y);

/* Hyperbolic functions */
float sinhf(float x) _FLOAT_FUNC_REENTRANT;
float coshf(float x) _FLOAT_FUNC_REENTRANT;
float tanhf(float x) _FLOAT_FUNC_REENTRANT;

/* Exponential, logarithmic and power functions */
float expf(float x) _FLOAT_FUNC_REENTRANT;
float logf(float x) _FLOAT_FUNC_REENTRANT;
float log10f(float x) _FLOAT_FUNC_REENTRANT;
float powf(float x, float y);
float sqrtf(float a) _FLOAT_FUNC_REENTRANT;

/* Nearest integer, absolute value, and remainder functions */
float fabsf(float x) _FLOAT_FUNC_REENTRANT;
float frexpf(float x, int *pw2);
float ldexpf(float x, int pw2);
float ceilf(float x) _FLOAT_FUNC_REENTRANT;
float floorf(float x) _FLOAT_FUNC_REENTRANT;
float modff(float x, float * y);

#endif  /* _INC_MATH */
/*-------------------------------------------------------------------------
   stdint.h - ISO C99 7.18 Integer types <stdint.h>

   Copyright (C) 2005, Maarten Brock, sourceforge.brock@dse.nl
   Copyright (C) 2011, Philipp Klaus Krause, pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef _STDINT_H
#define _STDINT_H       1

/* Exact integral types.  */

#if !defined(__SDCC_mcs51) && !defined(__SDCC_ds390) && !defined(__SDCC_ds400) && !defined(__SDCC_pic14) && !defined(__SDCC_pic16)
#if __STDC_VERSION__ >= 199901L
#define __SDCC_LONGLONG
#endif
#endif

/* Signed.  */

typedef signed char             int8_t;
typedef short int               int16_t;
typedef long int                int32_t;
#ifdef __SDCC_LONGLONG
typedef long long int           int64_t;
#endif

/* Unsigned.  */
typedef unsigned char           uint8_t;
typedef unsigned short int      uint16_t;
typedef unsigned long int       uint32_t;
#ifdef __SDCC_LONGLONG
typedef unsigned long long int  uint64_t;
#endif

/* Small types.  */

/* Signed.  */
typedef signed char             int_least8_t;
typedef short int               int_least16_t;
typedef long int                int_least32_t;
#ifdef __SDCC_LONGLONG
typedef long long int           int_least64_t;
#endif

/* Unsigned.  */
typedef unsigned char           uint_least8_t;
typedef unsigned short int      uint_least16_t;
typedef unsigned long int       uint_least32_t;
#ifdef __SDCC_LONGLONG
typedef unsigned long long int  uint_least64_t;
#endif

/* Fast types.  */

/* Signed.  */
typedef signed char             int_fast8_t;
typedef int                     int_fast16_t;
typedef long int                int_fast32_t;
#ifdef __SDCC_LONGLONG
typedef long long int           int_fast64_t;
#endif

/* Unsigned.  */
typedef unsigned char           uint_fast8_t;
typedef unsigned int            uint_fast16_t;
typedef unsigned long int       uint_fast32_t;
#ifdef __SDCC_LONGLONG
typedef unsigned long long int  uint_fast64_t;
#endif

/* Types for `void *' pointers.  */
#if defined (__SDCC_mcs51) || defined (__SDCC_ds390)
  typedef long int              intptr_t;
  typedef unsigned long int     uintptr_t;
#else
  typedef int                   intptr_t;
  typedef unsigned int          uintptr_t;
#endif


/* Largest integral types.  */
#ifndef __SDCC_LONGLONG
typedef long int                intmax_t;
typedef unsigned long int       uintmax_t;
#else
typedef long long int           intmax_t;
typedef unsigned long long int  uintmax_t;
#endif

/* Limits of integral types.  */

/* Minimum of signed integral types.  */
#define INT8_MIN               (-128)
#define INT16_MIN              (-32767-1)
#define INT32_MIN              (-2147483647L-1)
#ifdef __SDCC_LONGLONG
#define INT64_MIN              (-9223372036854775807LL-1)
#endif

/* Maximum of signed integral types.  */
#define INT8_MAX               (127)
#define INT16_MAX              (32767)
#define INT32_MAX              (2147483647L)
#ifdef __SDCC_LONGLONG
#define INT64_MAX              (9223372036854775807LL)
#endif

/* Maximum of unsigned integral types.  */
#define UINT8_MAX              (255)
#define UINT16_MAX             (65535)
#define UINT32_MAX             (4294967295UL)
#ifdef __SDCC_LONGLONG
#define UINT64_MAX             (18446744073709551615ULL)
#endif

/* Minimum of signed integral types having a minimum size.  */
#define INT_LEAST8_MIN         INT8_MIN
#define INT_LEAST16_MIN        INT16_MIN
#define INT_LEAST32_MIN        INT32_MIN
#ifdef __SDCC_LONGLONG
#define INT_LEAST64_MIN        INT64_MIN
#endif

/* Maximum of signed integral types having a minimum size.  */
#define INT_LEAST8_MAX         INT8_MAX
#define INT_LEAST16_MAX        INT16_MAX
#define INT_LEAST32_MAX        INT32_MAX
#ifdef __SDCC_LONGLONG
#define INT_LEAST64_MAX        INT64_MAX
#endif

/* Maximum of unsigned integral types having a minimum size.  */
#define UINT_LEAST8_MAX        UINT8_MAX
#define UINT_LEAST16_MAX       UINT16_MAX
#define UINT_LEAST32_MAX       UINT32_MAX
#ifdef __SDCC_LONGLONG
#define UINT_LEAST64_MAX       UINT64_MAX
#endif

/* Minimum of fast signed integral types having a minimum size.  */
#define INT_FAST8_MIN          INT8_MIN
#define INT_FAST16_MIN         INT16_MIN
#define INT_FAST32_MIN         INT32_MIN
#ifdef __SDCC_LONGLONG
#define INT_FAST64_MIN         INT64_MIN
#endif

/* Maximum of fast signed integral types having a minimum size.  */
#define INT_FAST8_MAX          INT8_MAX
#define INT_FAST16_MAX         INT16_MAX
#define INT_FAST32_MAX         INT32_MAX
#ifdef __SDCC_LONGLONG
#define INT_FAST64_MAX         INT64_MAX
#endif

/* Maximum of fast unsigned integral types having a minimum size.  */
#define UINT_FAST8_MAX         UINT8_MAX
#define UINT_FAST16_MAX        UINT16_MAX
#define UINT_FAST32_MAX        UINT32_MAX
#ifdef __SDCC_LONGLONG
#define UINT_FAST64_MAX        UINT64_MAX
#endif

/* Values to test for integral types holding `void *' pointer.  */
#if defined (__SDCC_mcs51) || defined (__SDCC_ds390)
#define INTPTR_MIN             (-2147483647L-1)
#define INTPTR_MAX             (2147483647L)
#define UINTPTR_MAX            (4294967295UL)
#else
#define INTPTR_MIN             (-32767-1)
#define INTPTR_MAX             (32767)
#define UINTPTR_MAX            (65535)
#endif

/* Minimum for largest signed integral type.  */
#define INTMAX_MIN             (-__INT32_C(-2147483647L)-1)
/* Maximum for largest signed integral type.  */
#define INTMAX_MAX             (__INT32_C(2147483647L))

/* Maximum for largest unsigned integral type.  */
#define UINTMAX_MAX            (__UINT32_C(4294967295UL))


/* Limits of other integer types.  */

/* Limits of `ptrdiff_t' type.  */
#if defined (__SDCC_mcs51) || defined (__SDCC_ds390)
#define PTRDIFF_MIN           (-2147483647L-1)
#define PTRDIFF_MAX           (2147483647L)
#else
#define PTRDIFF_MIN           (-32767-1)
#define PTRDIFF_MAX           (32767)
#endif

/* Limit of `size_t' type.  */
#define SIZE_MAX               (65535u)

/* Signed.  */
#define INT8_C(c)      c
#define INT16_C(c)     c
#define INT32_C(c)     c ## L
#ifdef __SDCC_LONGLONG
#define INT64_C(c)     c ## LL
#endif

/* Unsigned.  */
#define UINT8_C(c)     c ## U
#define UINT16_C(c)    c ## U
#define UINT32_C(c)    c ## UL
#ifdef __SDCC_LONGLONG
#define UINT64_C(c)    c ## ULL
#endif

#define WCHAR_MIN      CHAR_MIN
#define WCHAR_MAX      CHAR_MAX

#define WINT_MIN       INT_MIN
#define WINT_MAX       INT_MAX

/* Maximal type.  */
#ifdef __SDCC_LONGLONG
#define INTMAX_C(c)    c ## LL
#define UINTMAX_C(c)   c ## ULL
#else
#define INTMAX_C(c)    c ## L
#define UINTMAX_C(c)   c ## UL
#endif

/* Bounds-checking interfaces from annex K of the C11 standard. */
#if defined (__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__
#define RSIZE_MAX SIZE_MAX
#endif

#endif /* stdint.h */

/*-------------------------------------------------------------------------
   stdarg.h - ANSI macros for variable parameter list

   Copyright (C) 2000, Michael Hope
   Copyright (C) 2011, Philipp Klaus Krause pkk@spth.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SDC51_STDARG_H
#define __SDC51_STDARG_H 1

#if defined(__SDCC_z80) || defined(__SDCC_z180) || defined(__SDCC_r2k) || defined(__SDCC_r3ka) || defined(__SDCC_tlcs90) || defined(__SDCC_gbz80) || defined(__SDCC_hc08) || defined(__SDCC_s08) || defined(__SDCC_stm8)

typedef unsigned char * va_list;
#define va_start(marker, last)  { marker = (va_list)&last + sizeof(last); }
#define va_arg(marker, type)    *((type *)((marker += sizeof(type)) - sizeof(type)))

#elif defined(__SDCC_ds390) || defined(__SDCC_ds400)

typedef unsigned char * va_list;
#define va_start(marker, first) { marker = (va_list)&first; }
#define va_arg(marker, type)    *((type *)(marker -= sizeof(type)))

#elif defined(__SDCC_USE_XSTACK)

typedef unsigned char __pdata * va_list;
#define va_start(marker, first) { marker = (va_list)&first; }
#define va_arg(marker, type)    *((type __pdata *)(marker -= sizeof(type)))

#else

typedef unsigned char __data * va_list;
#define va_start(marker, first) { marker = (va_list)&first; }
#define va_arg(marker, type)    *((type __data * )(marker -= sizeof(type)))

#endif

#define va_copy(dest, src)      { dest = src; }
#define va_end(marker)          { marker = (va_list) 0; };

#endif

#ifndef __SDCC_STDNORETURN_H
#define __SDCC_STDNORETURN_H 1

#define noreturn _Noreturn

#endif

/*-------------------------------------------------------------------------
   serial390.h

   Copyright (C) 2000, Johan Knol <johan.knol AT iduna.nl>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef SERIAL390_H
#define SERIAL390_H

#warning "Please use <tinibios.h> instead of <serial390.h>"
#include <tinibios.h>

#endif SERIAL390_H
/*-------------------------------------------------------------------------
   features.h - default features.

   Copyright (C) 2001, Michael Hope

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SDC51_ASM_FEATURES_H
#define __SDC51_ASM_FEATURES_H   1

#define _REENTRANT	__reentrant
#define _CODE		__code
#define _AUTOMEM
#define _STATMEM

#endif
/*-------------------------------------------------------------------------
   features.h - Z80 specific features.

   Copyright (C) 2001, Michael Hope

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SDCC_ASM_TLCS90_FEATURES_H
#define __SDCC_ASM_TLCS90_FEATURES_H   1

#define _REENTRANT
#define _CODE
#define _AUTOMEM
#define _STATMEM

#define _SDCC_MANGLES_SUPPORT_FUNS	1
#define _SDCC_Z80_STYLE_LIB_OPT		1

/* The following are disabled to make the dhrystone test more authentic.
 */
#define _SDCC_PORT_PROVIDES_MEMCPY	0
#define _SDCC_PORT_PROVIDES_STRCMP	0
/* Register allocator is as good as hand coded asm.  Cool. */
#define _SDCC_PORT_PROVIDES_STRCPY	0

#define _SDCC_MALLOC_TYPE_MLH		1

#endif

/*-------------------------------------------------------------------------
   features.h - PIC16 port features.

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __PIC16_ASM_FEATURES_H
#define __PIC16_ASM_FEATURES_H   1

#define _REENTRANT

#define _IL_REENTRANT
#define _FS_REENTRANT
#define _MATH_REENTRANT

#define _CODE	__code
#define _DATA	__data
#define _AUTOMEM
#define _STATMEM

#endif	/* __PIC16_ASM_FEATURES_H */
/*-------------------------------------------------------------------------
   features.h - Rabbit 3000A specific features.

   Copyright (C) 2001, Michael Hope
   
   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SDCC_ASM_R3KA_FEATURES_H
#define __SDCC_ASM_R3KA_FEATURES_H   1

#define _REENTRANT
#define _CODE
#define _AUTOMEM
#define _STATMEM

#define _SDCC_MANGLES_SUPPORT_FUNS	1
#define _SDCC_Z80_STYLE_LIB_OPT		1

/* The following are disabled to make the dhrystone test more authentic.
 */
#define _SDCC_PORT_PROVIDES_MEMCPY	0
#define _SDCC_PORT_PROVIDES_STRCMP	0
/* Register allocator is as good as hand coded asm.  Cool. */
#define _SDCC_PORT_PROVIDES_STRCPY	0

#define _SDCC_MALLOC_TYPE_MLH		1

#endif

/*-------------------------------------------------------------------------
   features.h - DS390/DS400 specific features.

   Copyright (C) 2004, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SDC51_ASM_DS390_FEATURES_H
#define __SDC51_ASM_DS390_FEATURES_H   1

#define _REENTRANT	__reentrant
#define _CODE		__code

/* define _AUTOMEM to indicate the default storage class for
   automatic variables. To be used with pointers to automatic variables.
   Cannot be used in reentrant declared functions!

   void foo(void)
   {
     char Ar[10];
     char _AUTOMEM * pAr = Ar;
   }
*/
#if defined(__SDCC_STACK_AUTO)
  #if defined(__SDCC_USE_XSTACK)
    #define _AUTOMEM __pdata
  #elif defined(__SDCC_STACK_TENBIT)
    #define _AUTOMEM __xdata
  #else
    #define _AUTOMEM __idata
  #endif
#elif defined(__SDCC_MODEL_SMALL)
  #define _AUTOMEM __data
#else
  #define _AUTOMEM __xdata
#endif

/* define _STATMEM to indicate the default storage class for
   global/static variables. To be used with pointers to static variables.

   char Ar[10];
   void foo(void)
   {
     char _STATMEM * pAr = Ar;
   }
*/
#if defined(__SDCC_MODEL_SMALL)
  #define _STATMEM __data
#else
  #define _STATMEM __xdata
#endif

#endif
/*---------------------------------------------------------------------------
   features.h: MCS51 specific features.

   Copyright (C) 2004, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SDC51_ASM_MCS51_FEATURES_H
#define __SDC51_ASM_MCS51_FEATURES_H   1

#define _REENTRANT	__reentrant
#define _CODE		__code

/* define _AUTOMEM to indicate the default storage class for
   automatic variables. To be used with pointers to automatic variables.
   Cannot be used in reentrant declared functions!

   void foo(void)
   {
     char Ar[10];
     char _AUTOMEM * pAr = Ar;
   }
*/
#if defined(__SDCC_STACK_AUTO)
  #if defined(__SDCC_USE_XSTACK)
    #define _AUTOMEM __pdata
  #else
    #define _AUTOMEM __idata
  #endif
#elif defined(__SDCC_MODEL_SMALL)
  #define _AUTOMEM __data
#elif defined(__SDCC_MODEL_MEDIUM)
  #define _AUTOMEM __pdata
#else
  #define _AUTOMEM __xdata
#endif

/* define _STATMEM to indicate the default storage class for
   global/static variables. To be used with pointers to static variables.

   char Ar[10];
   void foo(void)
   {
     char _STATMEM * pAr = Ar;
   }
*/
#if defined(__SDCC_MODEL_SMALL)
  #define _STATMEM __data
#elif defined(__SDCC_MODEL_MEDIUM)
  #define _STATMEM __pdata
#else
  #define _STATMEM __xdata
#endif


/* define _RETURN for correct returning from inline asm functions
*/
#if defined(__SDCC_MODEL_HUGE)
 #define _RETURN ljmp __sdcc_banked_ret
#else
 #define _RETURN ret
#endif


#endif
/*-------------------------------------------------------------------------
   features.h - STM8 specific features.

   Copyright (C) 2001, Michael Hope, 2013, Philipp Klaus Krause

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SDCC_ASM_STM8_FEATURES_H
#define __SDCC_ASM_STM8_FEATURES_H   1

#define _REENTRANT
#define _CODE
#define _AUTOMEM
#define _STATMEM

#define _SDCC_MANGLES_SUPPORT_FUNS	1
#define _SDCC_Z80_STYLE_LIB_OPT		1

#define _SDCC_PORT_PROVIDES_MEMCPY	0
#define _SDCC_PORT_PROVIDES_STRCMP	0
#define _SDCC_PORT_PROVIDES_STRCPY	0

#define _SDCC_MALLOC_TYPE_MLH		1

#endif

/*-------------------------------------------------------------------------
   features.h - Z80 specific features.

   Copyright (C) 2001, Michael Hope

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SDCC_ASM_Z180_FEATURES_H
#define __SDCC_ASM_Z180_FEATURES_H   1

#define _REENTRANT
#define _CODE
#define _AUTOMEM
#define _STATMEM

#define _SDCC_MANGLES_SUPPORT_FUNS	1
#define _SDCC_Z80_STYLE_LIB_OPT		1

/* The following are disabled to make the dhrystone test more authentic.
 */
#define _SDCC_PORT_PROVIDES_MEMCPY	0
#define _SDCC_PORT_PROVIDES_STRCMP	0
/* Register allocator is as good as hand coded asm.  Cool. */
#define _SDCC_PORT_PROVIDES_STRCPY	0

#define _SDCC_MALLOC_TYPE_MLH		1

#endif

/*-------------------------------------------------------------------------
   features.h - PIC16 port features.

   Copyright (C) 2004, Vangelis Rokas <vrokas AT otenet.gr>
   Adopted for pic14 port library by Raphael Neider <rneider at web.de> (2006)

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __PIC14_ASM_FEATURES_H
#define __PIC14_ASM_FEATURES_H   1

#define _REENTRANT

#define _IL_REENTRANT
#define _FS_REENTRANT
#define _MATH_REENTRANT

#define _CODE	__code
#define _DATA	__data
#define _AUTOMEM
#define _STATMEM

#endif	/* __PIC14_ASM_FEATURES_H */
/*-------------------------------------------------------------------------
   features.h - GBZ80 specific features.

   Copyright (C) 2001, Michael Hope

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SDC51_ASM_GBZ80_FEATURES_H
#define __SDC51_ASM_GBZ80_FEATURES_H   1

#define _REENTRANT
#define _CODE
#define _AUTOMEM
#define _STATMEM

#define _SDCC_MANGLES_SUPPORT_FUNS	1
#define _SDCC_Z80_STYLE_LIB_OPT		1

/* The following are disabled to make the dhrystone test more authentic.
 */
#define _SDCC_PORT_PROVIDES_MEMCPY	0
#define _SDCC_PORT_PROVIDES_STRCMP	0
/* Register allocator is as good as hand coded asm.  Cool. */
#define _SDCC_PORT_PROVIDES_STRCPY	0

#define _SDCC_MALLOC_TYPE_MLH		1

#endif
/*-------------------------------------------------------------------------
   features.h - Z80 specific features.

   Copyright (C) 2001, Michael Hope

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SDCC_ASM_R2K_FEATURES_H
#define __SDCC_ASM_R2K_FEATURES_H   1

#define _REENTRANT
#define _CODE
#define _AUTOMEM
#define _STATMEM

#define _SDCC_MANGLES_SUPPORT_FUNS	1
#define _SDCC_Z80_STYLE_LIB_OPT		1

/* The following are disabled to make the dhrystone test more authentic.
 */
#define _SDCC_PORT_PROVIDES_MEMCPY	0
#define _SDCC_PORT_PROVIDES_STRCMP	0
/* Register allocator is as good as hand coded asm.  Cool. */
#define _SDCC_PORT_PROVIDES_STRCPY	0

#define _SDCC_MALLOC_TYPE_MLH		1

#endif

/*-------------------------------------------------------------------------
   features.h - Z80 specific features.

   Copyright (C) 2001, Michael Hope

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SDCC_ASM_Z80_FEATURES_H
#define __SDCC_ASM_Z80_FEATURES_H   1

#define _REENTRANT
#define _CODE
#define _AUTOMEM
#define _STATMEM

#define _SDCC_MANGLES_SUPPORT_FUNS	1
#define _SDCC_Z80_STYLE_LIB_OPT		1

/* The following are disabled to make the dhrystone test more authentic.
 */
#define _SDCC_PORT_PROVIDES_MEMCPY	0
#define _SDCC_PORT_PROVIDES_STRCMP	0
/* Register allocator is as good as hand coded asm.  Cool. */
#define _SDCC_PORT_PROVIDES_STRCPY	0

#define _SDCC_MALLOC_TYPE_MLH		1

#endif

/*-------------------------------------------------------------------------
   at89x051.h - Register Declarations for Atmel AT89C1051, AT89C2051 and AT89C4051 Processors
   based on 8051.h (8051.h must be in mcs51 subdirectory)
   KEIL C compatible definitions are included

   Copyright (C) 2000, Bela Torok / bela.torok@kssg.ch

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef AT89Cx051_H
#define AT89Cx051_H

#include <8051.h>     /* load difinitions for the 8051 core */

#ifdef REG8051_H
#undef REG8051_H
#endif

/* remove non existing registers */

#ifdef P0				  /* P0 is defined in <8051.h> */
#undef P0				  /* AT89Cx051 has no P0 */
#undef P0_0				  /* undefine bit addressable registers in P0 */
#undef P0_1
#undef P0_2
#undef P0_3
#undef P0_4
#undef P0_5
#undef P0_6
#undef P0_7
#endif

#ifdef P2				  /* P2 is defined in <8051.h> */
#undef P2				  /* AT89Cx051 has no P2 */
#undef P2_0				  /* undefine bit addressable registers in P2 */
#undef P2_1
#undef P2_2
#undef P2_3
#undef P2_4
#undef P2_5
#undef P2_6
#undef P2_7
#endif

#endif

/*-------------------------------------------------------------------------
   p89c66x.h - This header allows to use the microcontroler Philips P89c66x
   with the compiler SDCC.

   Copyright (C), 2007 Gudjon I. Gudjonsson <gudjon AT gudjon.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------
 The registered are ordered in the same way as in the NXP data sheet
 P89C660_662_664_3.PDF, see http://www.nxp.com
-------------------------------------------------------------------------*/

#ifndef __P89c66x_H__
#define __P89c66x_H__
#include <compiler.h>

/*BYTE Registers*/
SFR(ACC, 0xE0); // Accumulator
	SBIT(ACC_7, 0xE0, 7);
	SBIT(ACC_6, 0xE0, 6);
	SBIT(ACC_5, 0xE0, 5);
	SBIT(ACC_4, 0xE0, 4);
	SBIT(ACC_3, 0xE0, 3);
	SBIT(ACC_2, 0xE0, 2);
	SBIT(ACC_1, 0xE0, 1);
	SBIT(ACC_0, 0xE0, 0);
SFR(AUXR, 0x8E); // Auxiliary
	#define EXTRAM 0x02
	#define AO     0x01
SFR(AUXR1, 0xA2); // Auxiliary 1
	#define ENBOOT 0x20
	#define GF2    0x08
	// Bit 2 must be 0
	#define DPS    0x01
SFR(B, 0xF0); // B register
	SBIT(B7, 0xF0, 7);
	SBIT(B6, 0xF0, 6);
	SBIT(B5, 0xF0, 5);
	SBIT(B4, 0xF0, 4);
	SBIT(B3, 0xF0, 3);
	SBIT(B2, 0xF0, 2);
	SBIT(B1, 0xF0, 1);
	SBIT(B0, 0xF0, 0);
SFR(CCAP0H, 0xFA); // Module 0 Capture High
SFR(CCAP1H, 0xFB); // Module 1 Capture High
SFR(CCAP2H, 0xFC); // Module 2 Capture High
SFR(CCAP3H, 0xFD); // Module 3 Capture High
SFR(CCAP4H, 0xFE); // Module 4 Capture High
SFR(CCAP0L, 0xEA); // Module 0 Capture Low
SFR(CCAP1L, 0xEB); // Module 1 Capture Low
SFR(CCAP2L, 0xEC); // Module 2 Capture Low
SFR(CCAP3L, 0xED); // Module 3 Capture Low
SFR(CCAP4L, 0xEE); // Module 4 Capture Low
SFR(CCAPM0, 0xC2); // Module 0 Mode
SFR(CCAPM1, 0xC3); // Module 1 Mode
SFR(CCAPM2, 0xC4); // Module 2 Mode
SFR(CCAPM3, 0xC5); // Module 3 Mode
SFR(CCAPM4, 0xC6); // Module 4 Mode
	#define ECOM   0x40
	#define CAPP   0x20
	#define CAPN   0x10
	#define MAT    0x08
	#define TOG    0x04
	#define PWM    0x02
	#define ECCF   0x01
SFR(CCON,   0xC0); // PCA Counter Control
	SBIT(CF,   0xC0, 7);
	SBIT(CR,   0xC0, 6);
	SBIT(CCF4, 0xC0, 4);
	SBIT(CCF3, 0xC0, 3);
	SBIT(CCF2, 0xC0, 2);
	SBIT(CCF1, 0xC0, 1);
	SBIT(CCF0, 0xC0, 0);
SFR(CH,   0xF9); // PCA Counter High
SFR(CL,   0xE9); // PCA Counter Low
SFR(CMOD, 0xC1); // PCA Counter Mode
	#define CIDL 0x80
	#define WDTE 0x40
	#define CPS1 0x04
	#define CPS0 0x02
	#define ECF  0x01
SFR(DPH,  0x83); // Data Pointer High
SFR(DPL,  0x82); // Data Pointer Low
SFR(IEN0, 0xA8); // Interrupt Enable 0
	SBIT(EA,  0xA8, 7);
	SBIT(EC,  0xA8, 6);
	SBIT(ES1, 0xA8, 5);
	SBIT(ES0, 0xA8, 4);
	SBIT(ET1, 0xA8, 3);
	SBIT(EX1, 0xA8, 2);
	SBIT(ET0, 0xA8, 1);
	SBIT(EX0, 0xA8, 0);
SFR(IEN1, 0xE8); // Interrupt Enable 1
	SBIT(ET2, 0xE8, 0);
SFR(IP, 0xB8); // Interrupt Priority
	SBIT(PT2, 0xB8, 7);
	SBIT(PPC, 0xB8, 6);
	SBIT(PS1, 0xB8, 5);
	SBIT(PS0, 0xB8, 4);
	SBIT(PT1, 0xB8, 3);
	SBIT(PX1, 0xB8, 2);
	SBIT(PT0, 0xB8, 1);
	SBIT(PX0, 0xB8, 0);
SFR(IPH, 0xB7); // Interrupt Priority High
	#define PT2H  0x80
	#define PPCH  0x40
	#define PS1H  0x20
	#define PS0H  0x10
	#define PT1H  0x08
	#define PX1H  0x04
	#define PT0H  0x02
	#define PX0H  0x01
SFR(P0, 0x80); // Port 0
	SBIT(AD7,  0x80, 7);
	SBIT(P0_7, 0x80, 7);
	SBIT(AD6,  0x80, 6);
	SBIT(P0_6, 0x80, 6);
	SBIT(AD5,  0x80, 5);
	SBIT(P0_5, 0x80, 5);
	SBIT(AD4,  0x80, 4);
	SBIT(P0_4, 0x80, 4);
	SBIT(AD3,  0x80, 3);
	SBIT(P0_3, 0x80, 3);
	SBIT(AD2,  0x80, 2);
	SBIT(P0_2, 0x80, 2);
	SBIT(AD1,  0x80, 1);
	SBIT(P0_1, 0x80, 1);
	SBIT(AD0,  0x80, 0);
	SBIT(P0_0, 0x80, 0);
SFR(P1, 0x90); // Port 1
	SBIT(T1_CEX4, 0x90, 7);
	SBIT(P1_7,    0x90, 7);
	SBIT(T0_CEX3, 0x90, 6);
	SBIT(P1_6,    0x90, 6);
	SBIT(CEX2,    0x90, 5);
	SBIT(P1_5,    0x90, 5);
	SBIT(CEX1,    0x90, 4);
	SBIT(P1_4,    0x90, 4);
	SBIT(CEX0,    0x90, 3);
	SBIT(P1_3,    0x90, 3);
	SBIT(ECI,     0x90, 2);
	SBIT(P1_2,    0x90, 2);
	SBIT(T2EX,    0x90, 1);
	SBIT(P1_1,    0x90, 1);
	SBIT(T2,      0x90, 0);
	SBIT(P1_0,    0x90, 0);
SFR(P2, 0xA0); // Port 2
	SBIT(AD15, 0xA0, 7);
	SBIT(P2_7, 0xA0, 7);
	SBIT(AD14, 0xA0, 6);
	SBIT(P2_6, 0xA0, 6);
	SBIT(AD13, 0xA0, 5);
	SBIT(P2_5, 0xA0, 5);
	SBIT(AD12, 0xA0, 4);
	SBIT(P2_4, 0xA0, 4);
	SBIT(AD11, 0xA0, 3);
	SBIT(P2_3, 0xA0, 3);
	SBIT(AD10, 0xA0, 2);
	SBIT(P2_2, 0xA0, 2);
	SBIT(AD9,  0xA0, 1);
	SBIT(P2_1, 0xA0, 1);
	SBIT(AD8,  0xA0, 0);
	SBIT(P2_0, 0xA0, 0);
SFR(P3, 0xB0); // Port 3
	SBIT(RD,   0xB0, 7);
	SBIT(P3_7, 0xB0, 7);
	SBIT(WR,   0xB0, 6);
	SBIT(P3_6, 0xB0, 6);
	SBIT(T1,   0xB0, 5);
	SBIT(P3_5, 0xB0, 5);
	SBIT(T0,   0xB0, 4);
	SBIT(P3_4, 0xB0, 4);
	SBIT(INT1, 0xB0, 3);
	SBIT(P3_3, 0xB0, 3);
	SBIT(INT0, 0xB0, 2);
	SBIT(P3_2, 0xB0, 2);
	SBIT(TXD,  0xB0, 1);
	SBIT(P3_1, 0xB0, 1);
	SBIT(RXD,  0xB0, 0);
	SBIT(P3_0, 0xB0, 0);
SFR(PCON, 0x87); // Power Control
	#define SMOD1 0x80
	#define SMOD0 0x40
	#define POF   0x10
	#define GF1   0x80
	#define GF0   0x40
	#define PD    0x20
	#define IDL   0x10
SFR(PSW, 0xD0); // Program Status Word
	SBIT(CY,  0xD0, 7);
	SBIT(AC,  0xD0, 6);
	SBIT(F0,  0xD0, 5);
	SBIT(RS1, 0xD0, 4);
	SBIT(RS0, 0xD0, 3);
	SBIT(OV,  0xD0, 2);
	SBIT(F1,  0xD0, 1);
	SBIT(P,   0xD0, 0);
SFR(RCAP2H, 0xCB); // Timer 2 Capture High
SFR(RCAP2L, 0xCA); // Timer 2 Capture Low
SFR(SADDR,  0xA9); // I2C Slave Address
SFR(SADEN,  0xB9); // I2C Slave Address Mask
SFR(S0BUF,  0x99); // Serial Data Buffer
SFR(S0CON,  0x98); // Serial Control
	SBIT(SM0_FE, 0x98, 7);
	SBIT(SM1,    0x98, 6);
	SBIT(SM2,    0x98, 5);
	SBIT(REN,    0x98, 4);
	SBIT(TB8,    0x98, 3);
	SBIT(RB8,    0x98, 2);
	SBIT(TI,     0x98, 1);
	SBIT(RI,     0x98, 0);
SFR(SP,    0x81); // Stack Pointer
SFR(S1DAT, 0xDA); // I2C Serial 1 Data
SFR(S1IST, 0xDC); // I2C Serial 1 Internal Status
SFR(S1ADR, 0xDB); // I2C Serial 1 Address
	#define GC  0x01
SFR(S1STA, 0xD9); // I2C Serial 1 Status
	#define SC4 0x80
	#define SC3 0x40
	#define SC2 0x20
	#define SC1 0x10
	#define SC0 0x08
SFR(S1CON, 0xD8); // I2C Serial 1 Control
	SBIT(CR2,  0xD8, 7);
	SBIT(ENS1, 0xD8, 6);
	SBIT(STA,  0xD8, 5);
	SBIT(STO,  0xD8, 4);
	SBIT(SI,   0xD8, 3);
	SBIT(AA,   0xD8, 2);
	SBIT(CR1,  0xD8, 1);
	SBIT(CR0,  0xD8, 0);
SFR(TCON, 0x88); // Timer Control
	SBIT(TF1, 0x88, 7);
	SBIT(TR1, 0x88, 6);
	SBIT(TF0, 0x88, 5);
	SBIT(TR0, 0x88, 4);
	SBIT(IE1, 0x88, 3);
	SBIT(IT1, 0x88, 2);
	SBIT(IE0, 0x88, 1);
	SBIT(IT0, 0x88, 0);
SFR(T2CON, 0xC8); // Timer 2 Control
	SBIT(TF2,    0xC8, 7);
	SBIT(EXF2,   0xC8, 6);
	SBIT(RCLK,   0xC8, 5);
	SBIT(TCLK,   0xC8, 4);
	SBIT(EXEN2,  0xC8, 3);
	SBIT(TR2,    0xC8, 2);
	SBIT(C_T2,   0xC8, 1);
	SBIT(CP_RL2, 0xC8, 0);
SFR(T2MOD,  0xC9); // Timer 2 Mode Control
	#define T2OE 0x02
	#define DCEN 0x01
SFR(TH0 ,   0x8C); // Timer High 0
SFR(TH1,    0x8D); // Timer High 1
SFR(TH2,    0xCD); // Timer High 2
SFR(TL0,    0x8A); // Timer Low 0
SFR(TL1,    0x8B); // Timer Low 1
SFR(TL2,    0xCC); // Timer Low 2
SFR(TMOD,   0x89); // Timer Mode
	#define GATE_1 0x80
	#define C_T_1  0x40
	#define M1_1   0x20
	#define M0_1   0x10
	#define GATE_0 0x08
	#define C_T_0  0x04
	#define M1_0   0x02
	#define M0_0   0x01
SFR(WDTRST, 0xA6); // Watchdog Timer Reset

#endif
/*-------------------------------------------------------------------------
   msm8xc154s.h - Register Declarations for the Oki MSM80C154S and
   MSM83C154S

   Copyright (C) 2005,  Matthias Arndt / marndt@asmsoftware.de

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef MSM8xC154S_H
#define MSM8xC154S_H

#include <8052.h>     /* load definitions for the 8052 core */

#ifdef REG8052_H
#undef REG8052_H
#endif

/* byte SFRs */
__sfr __at (0xf8) 	IOCON;	/* IOCON register */

/* bit locations */
__sbit __at (0xf8)	ALF;	/* floating status on power down control */
__sbit __at (0xf9)	P1HZ;	/* P1 high impedance input control */
__sbit __at (0xfa)	P2HZ;	/* P2 high impedance input control */
__sbit __at (0xfb)	P3HZ;	/* P3 high impedance input control */
__sbit __at (0xfc)	IZC;	/* 10kO pull-up resistor control */
__sbit __at (0xfd)	SERR;	/* Serial port reception flag */
__sbit __at (0xfe)	T32;	/* interconnect T0 and T1 to 32bit timer/counter */

/* Bits in IP (0xb8) */
__sbit __at (0xbf)	PCT;	/* Priority interrupt circuit control bit */

/* Bits in PCON (0x87) */
#define RPD 0x20            /* Bit used to specify cancellation of CPU power down mode */
#define HPD 0x40            /* The hard power down setting mode is enabled when this bit is set to "1". */

#endif
/*-------------------------------------------------------------------------
   C8051F920.h -Register Declarations for the SiLabs C8051F92x-93x
   Processor Range

   Copyright (C) 2009, Steven Borley, steven.borley@partnerelectronics.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef C8051F920_H
#define C8051F920_H

#include <compiler.h>


/*  BYTE Registers  */

/* Page 0x00 (and all pages) */
SFR(       P0, 0x80 )  ; /* PORT 0 */
SFR(       SP, 0x81 )  ; /* STACK POINTER */
SFR(      DPL, 0x82 )  ; /* DATA POINTER - LOW BYTE */
SFR(      DPH, 0x83 )  ; /* DATA POINTER - HIGH BYTE */
SFR(  SPI1CFG, 0x84 )  ; /* SPI1 Configuration */
SFR(  SPI1CKR, 0x85 )  ; /* SPI1 Clock Rate Control */
SFR(  SPI1DAT, 0x86 )  ; /* SPI1 Data */
SFR(     PCON, 0x87 )  ; /* POWER CONTROL */
SFR(     TCON, 0x88 )  ; /* TIMER CONTROL */
SFR(     TMOD, 0x89 )  ; /* TIMER MODE */
SFR(      TL0, 0x8A )  ; /* TIMER 0 - LOW BYTE */
SFR(      TL1, 0x8B )  ; /* TIMER 1 - LOW BYTE */
SFR(      TH0, 0x8C )  ; /* TIMER 0 - HIGH BYTE */
SFR(      TH1, 0x8D )  ; /* TIMER 1 - HIGH BYTE */
SFR(    CKCON, 0x8E )  ; /* CLOCK CONTROL */
SFR(    PSCTL, 0x8F )  ; /* Program Store R/W Control */
SFR(       P1, 0x90 )  ; /* PORT 1 */
SFR(   TMR3CN, 0x91 )  ; /* TIMER 3 CONTROL */
SFR(  TMR3RLL, 0x92 )  ; /* TIMER 3 CAPTURE REGISTER - LOW BYTE */
SFR(  TMR3RLH, 0x93 )  ; /* TIMER 3 CAPTURE REGISTER - HIGH BYTE */
SFR(    TMR3L, 0x94 )  ; /* TIMER 3 - LOW BYTE */
SFR(    TMR3H, 0x95 )  ; /* TIMER 3 - HIGH BYTE */
SFR(    DC0CF, 0x96 )  ; /* DC0 (DC-DC Converter) Configuration  */
SFR(    DC0CN, 0x97 )  ; /* DC0 (DC-DC Converter) Control  */
SFR(    SCON0, 0x98 )  ; /* Serial Port Control */
SFR(    SBUF0, 0x99 )  ; /* Serial Port Buffer */
SFR(   CPT1CN, 0x9A )  ; /* Comparator 1 Control  */
SFR(   CPT0CN, 0x9B )  ; /* Comparator 0 Control  */
SFR(   CPT1MD, 0x9C )  ; /* Comparator 1 Mode Selection  */
SFR(   CPT0MD, 0x9D )  ; /* Comparator 0 Mode Selection */
SFR(   CPT1MX, 0x9E )  ; /* Comparator 1 mux selection */
SFR(   CPT0MX, 0x9F )  ; /* Comparator 0 mux selection */
SFR(       P2, 0xA0 )  ; /* PORT 2 */
SFR(  SPI0CFG, 0xA1 )  ; /* SPI0 CONFIGURATION */
SFR(  SPI0CKR, 0xA2 )  ; /* SPI0 Clock Rate Control */
SFR(  SPI0DAT, 0xA3 )  ; /* SPI0 Data */
SFR(  P0MDOUT, 0xA4 )  ; /* PORT 0 OUTPUT MODE CONFIGURATION */
SFR(  P1MDOUT, 0xA5 )  ; /* PORT 1 OUTPUT MODE CONFIGURATION */
SFR(  P2MDOUT, 0xA6 )  ; /* PORT 2 OUTPUT MODE CONFIGURATION */
SFR(  SFRPAGE, 0xA7 )  ; /* SFR Page */
SFR(       IE, 0xA8 )  ; /* INTERRUPT ENABLE */
SFR(   CLKSEL, 0xA9 )  ; /* SYSTEM CLOCK SELECT */
SFR(   EMI0CN, 0xAA )  ; /* EMIF Control */
SFR(   _XPAGE, 0xAA )  ; /* XDATA/PDATA page alias for SDCC */
SFR(   EMI0CF, 0xAB )  ; /* EMIF Configuration  */
SFR(  RTC0ADR, 0xAC )  ; /* RTC0 Address  */
SFR(  RTC0DAT, 0xAD )  ; /* RTC0 Data */
SFR(  RTC0KEY, 0xAE )  ; /* RTC0 Key */
SFR(   EMI0TC, 0xAF )  ; /* EMIF Timing Control */
SFR(   SPI1CN, 0xB0 )  ; /* SPI1 Control  */
SFR(   OSCXCN, 0xB1 )  ; /* EXTERNAL OSCILLATOR CONTROL */
SFR(   OSCICN, 0xB2 )  ; /* INTERNAL OSCILLATOR CONTROL */
SFR(   OSCICL, 0xB3 )  ; /* INTERNAL OSCILLATOR CALIBRATION */
SFR(   PMU0CF, 0xB5 )  ; /* PMU0 Configuration */
SFR(    FLSCL, 0xB6 )  ; /* IFlash Scale  */
SFR(    FLKEY, 0xB7 )  ; /* Flash Lock And Key */
SFR(       IP, 0xB8 )  ; /* INTERRUPT PRIORITY */
SFR(  IREF0CN, 0xB9 )  ; /* Current Reference IREF Control  */
SFR(   ADC0AC, 0xBA )  ; /* ADC0 Accumulator Configuration  */
SFR(   ADC0MX, 0xBB )  ; /* AMUX0 Channel Select  */
SFR(   ADC0CF, 0xBC )  ; /* ADC 0 CONFIGURATION */
SFR(    ADC0L, 0xBD )  ; /* ADC 0 DATA - LOW BYTE */
SFR(    ADC0H, 0xBE )  ; /* ADC 0 DATA - HIGH BYTE */
SFR(   P1MASK, 0xBF )  ; /* Port 1 Mask */
SFR(   SMB0CN, 0xC0 )  ; /* SMBUS CONTROL */
SFR(   SMB0CF, 0xC1 )  ; /* SMBUS CONFIGURATION */
SFR(  SMB0DAT, 0xC2 )  ; /* SMBUS DATA */
SFR(  ADC0GTL, 0xC3 )  ; /* ADC 0 GREATER-THAN REGISTER - LOW BYTE */
SFR(  ADC0GTH, 0xC4 )  ; /* ADC 0 GREATER-THAN REGISTER - HIGH BYTE */
SFR(  ADC0LTL, 0xC5 )  ; /* ADC 0 LESS-THAN REGISTER - LOW BYTE */
SFR(  ADC0LTH, 0xC6 )  ; /* ADC 0 LESS-THAN REGISTER - HIGH BYTE */
SFR(   P0MASK, 0xC7 )  ; /* Port 0 Mask */
SFR(   TMR2CN, 0xC8 )  ; /* Timer 2 control  */
SFR(   REG0CN, 0xC9 )  ; /* Voltage Regulator (VREG0) Control */
SFR(  TMR2RLL, 0xCA )  ; /* Timer 2 capture register - low byte  */
SFR(  TMR2RLH, 0xCB )  ; /* Timer 2 capture register - high byte */
SFR(    TMR2L, 0xCC )  ; /* Timer 2 - low byte*/
SFR(    TMR2H, 0xCD )  ; /* Timer 2 - high byte */
SFR( PCA0CPM5, 0xCE )  ; /* PCA0 Module 5 Mode Register  */
SFR(    P1MAT, 0xCF )  ; /* Port 1 Match  */
SFR(      PSW, 0xD0 )  ; /* PROGRAM STATUS WORD */
SFR(   REF0CN, 0xD1 )  ; /* VOLTAGE REFERENCE 0 CONTROL */
SFR( PCA0CPL5, 0xD2 )  ; /* PCA0 Capture 5 Low */
SFR( PCA0CPH5, 0xD3 )  ; /* PCA0 Capture 5 High */
SFR(   P0SKIP, 0xD4 )  ; /* PORT 0 SKIP */
SFR(   P1SKIP, 0xD5 )  ; /* PORT 1 SKIP */
SFR(   P2SKIP, 0xD6 )  ; /* PORT 2 SKIP */
SFR(    P0MAT, 0xD7 )  ; /* Port 0 Match */
SFR(   PCA0CN, 0xD8 )  ; /* PCA CONTROL */
SFR(   PCA0MD, 0xD9 )  ; /* PCA MODE */
SFR( PCA0CPM0, 0xDA )  ; /* PCA0 Module 0 Mode Register */
SFR( PCA0CPM1, 0xDB )  ; /* PCA0 Module 1 Mode Register */
SFR( PCA0CPM2, 0xDC )  ; /* PCA0 Module 2 Mode Register  */
SFR( PCA0CPM3, 0xDD )  ; /* PCA0 Module 3 Mode Register */
SFR( PCA0CPM4, 0xDE )  ; /* PCA0 Module 4 Mode Register  */
SFR(  PCA0PWM, 0xDF )  ; /* PCA0 PWM Configuration  */
SFR(      ACC, 0xE0 )  ; /* ACCUMULATOR */
SFR(     XBR0, 0xE1 )  ; /* Port Mux Configuration Register 0 */
SFR(     XBR1, 0xE2 )  ; /* Port Mux Configuration Register 1 */
SFR(     XBR2, 0xE3 )  ; /* Port Mux Configuration Register 2 */
SFR(  INT01CF, 0xE4 )  ; /* INT0/INT1 Configuration Register */
SFR(     EIE1, 0xE6 )  ; /* EXTERNAL INTERRUPT ENABLE 1 */
SFR(     EIE2, 0xE7 )  ; /* EXTERNAL INTERRUPT ENABLE 2 */
SFR(   ADC0CN, 0xE8 )  ; /* ADC 0 CONTROL */
SFR( PCA0CPL1, 0xE9 )  ; /* PCA CAPTURE 1 LOW */
SFR( PCA0CPH1, 0xEA )  ; /* PCA CAPTURE 1 HIGH */
SFR( PCA0CPL2, 0xEB )  ; /* PCA CAPTURE 2 LOW */
SFR( PCA0CPH2, 0xEC )  ; /* PCA CAPTURE 2 HIGH */
SFR( PCA0CPL3, 0xED )  ; /* PCA0 Capture 3 Low */
SFR( PCA0CPH3, 0xEE )  ; /* PCA0 Capture 3 High */
SFR(   RSTSRC, 0xEF )  ; /* RESET SOURCE */
SFR(        B, 0xF0 )  ; /* B REGISTER */
SFR(   P0MDIN, 0xF1 )  ; /* Port 0 Input Mode Configuration */
SFR(   P1MDIN, 0xF2 )  ; /* Port 1 Input Mode Configuration  */
SFR(   P2MDIN, 0xF3 )  ; /* Port 2 Input Mode Configuration  */
SFR(  SMB0ADR, 0xF4 )  ; /* SMBus Slave Address */
SFR(  SMB0ADM, 0xF5 )  ; /* SMBus Slave Address Mask  */
SFR(     EIP1, 0xF6 )  ; /* EXTERNAL INTERRUPT PRIORITY REGISTER 1 */
SFR(     EIP2, 0xF7 )  ; /* EXTERNAL INTERRUPT PRIORITY REGISTER 2 */
SFR(   SPI0CN, 0xF8 )  ; /* SPI0 Control  */
SFR(    PCA0L, 0xF9 )  ; /* PCA COUNTER LOW */
SFR(    PCA0H, 0xFA )  ; /* PCA COUNTER HIGH */
SFR( PCA0CPL0, 0xFB )  ; /* PCA CAPTURE 0 LOW */
SFR( PCA0CPH0, 0xFC )  ; /* PCA CAPTURE 0 HIGH */
SFR( PCA0CPL4, 0xFD )  ; /* PCA0 Capture 4 Low */
SFR( PCA0CPH4, 0xFE )  ; /* PCA0 Capture 4 High */
SFR(   VDM0CN, 0xFF )  ; /* VDD Monitor Control */

/* Page 0x0F only */
SFR(    TOFFL, 0x85 )  ; /* Temperature Offset Low */
SFR(    TOFFH, 0x86 )  ; /* Temperature Offset High */
SFR(  CRC0DAT, 0x91 )  ; /* CRC0 Data  */
SFR(   CRC0CN, 0x92 )  ; /* CRC0 Control */
SFR(   CRC0IN, 0x93 )  ; /* CRC0 Input */
SFR( CRC0FLIP, 0x95 )  ; /* CRC0 Flip */
SFR( CRC0AUTO, 0x96 )  ; /* CRC0 Automatic Control */
SFR(  CRC0CNT, 0x97 )  ; /* CRC0 Automatic Flash Sector Count  */
SFR(    P0DRV, 0xA4 )  ; /* Port 0 Drive Strength */
SFR(    P1DRV, 0xA5 )  ; /* Port 1 Drive Strength */
SFR(    P2DRV, 0xA6 )  ; /* Port 2 Drive Strength */
SFR(  ADC0PWR, 0xBA)  ; /* ADC0 Burst Mode Power-Up Time */
SFR(   ADC0TK, 0xBD)  ; /* ADC0 Tracking Control */


/*  WORD/DWORD Registers  */

/* page 0x00 */
SFR16E(     TMR0, 0x8C8A )  ; /* TIMER 0 COUNTER */
SFR16E(     TMR1, 0x8D8B )  ; /* TIMER 1 COUNTER */
SFR16E(   TMR3RL, 0x9392 )  ; /* Timer 3 reload word */
SFR16E(     TMR3, 0x9594 )  ; /* Timer 3 counter word */
SFR16E(     ADC0, 0xBEBD )  ; /* ADC0 word */
SFR16E(   ADC0GT, 0xC4C3 )  ; /* ADC 0 GREATER-THAN REGISTER WORD */
SFR16E(   ADC0LT, 0xC6C5 )  ; /* ADC 0 LESS-THAN REGISTER WORD */
SFR16E(   TMR2RL, 0xCBCA )  ; /* Timer 2 reload word */
SFR16E(     TMR2, 0xCDCC )  ; /* Timer 2 counter word */
SFR16E(   TMR2RL, 0xCBCA )  ; /* Timer 2 Reload word */
SFR16E(     PCA0, 0xFAF9 )  ; /* PCA0 counter word */
SFR16E(  PCA0CP0, 0xFCFB )  ; /* PCA0 Capture 0 word */
SFR16E(  PCA0CP1, 0xEAE9 )  ; /* PCA0 Capture 1 word */
SFR16E(  PCA0CP2, 0xECEB )  ; /* PCA0 Capture 2 word */
SFR16E(  PCA0CP3, 0xEEED )  ; /* PCA0 Capture 3 word */
SFR16E(  PCA0CP4, 0xFEFD )  ; /* PCA0 Capture 4 word */
SFR16E(  PCA0CP5, 0xD3D4 )  ; /* PCA0 Capture 5 word */

/* Page 0x0F */
SFR16E(     TOFF, 0x8685 )  ; /* TEMPERATURE SENSOR OFFSET WORD */

/*  BIT Registers  */

/*  P0  0x80 */
SBIT(     P0_0, 0x80, 0 )  ;
SBIT(     P0_1, 0x80, 1 )  ;
SBIT(     P0_2, 0x80, 2 )  ;
SBIT(     P0_3, 0x80, 3 )  ;
SBIT(     P0_4, 0x80, 4 )  ;
SBIT(     P0_5, 0x80, 5 )  ;
SBIT(     P0_6, 0x80, 6 )  ;
SBIT(     P0_7, 0x80, 7 )  ;

/*  TCON  0x88 */
SBIT(      IT0, 0x88, 0 )  ; /* TCON.0 - EXT. INTERRUPT 0 TYPE */
SBIT(      IE0, 0x88, 1 )  ; /* TCON.1 - EXT. INTERRUPT 0 EDGE FLAG */
SBIT(      IT1, 0x88, 2 )  ; /* TCON.2 - EXT. INTERRUPT 1 TYPE */
SBIT(      IE1, 0x88, 3 )  ; /* TCON.3 - EXT. INTERRUPT 1 EDGE FLAG */
SBIT(      TR0, 0x88, 4 )  ; /* TCON.4 - TIMER 0 ON/OFF CONTROL */
SBIT(      TF0, 0x88, 5 )  ; /* TCON.5 - TIMER 0 OVERFLOW FLAG */
SBIT(      TR1, 0x88, 6 )  ; /* TCON.6 - TIMER 1 ON/OFF CONTROL */
SBIT(      TF1, 0x88, 7 )  ; /* TCON.7 - TIMER 1 OVERFLOW FLAG */

/*  P1  0x90 */
SBIT(     P1_0, 0x90, 0 )  ;
SBIT(     P1_1, 0x90, 1 )  ;
SBIT(     P1_2, 0x90, 2 )  ;
SBIT(     P1_3, 0x90, 3 )  ;
SBIT(     P1_4, 0x90, 4 )  ;
SBIT(     P1_5, 0x90, 5 )  ;
SBIT(     P1_6, 0x90, 6 )  ;
SBIT(     P1_7, 0x90, 7 )  ;

/*  SCON0  0x98 */
SBIT(       RI, 0x98, 0 )  ; /* SCON.0 - RECEIVE INTERRUPT FLAG */
SBIT(      RI0, 0x98, 0 )  ; /* SCON.0 - RECEIVE INTERRUPT FLAG */
SBIT(       TI, 0x98, 1 )  ; /* SCON.1 - TRANSMIT INTERRUPT FLAG */
SBIT(      TI0, 0x98, 1 )  ; /* SCON.1 - TRANSMIT INTERRUPT FLAG */
SBIT(      RB8, 0x98, 2 )  ; /* SCON.2 - RECEIVE BIT 8 */
SBIT(     RB80, 0x98, 2 )  ; /* SCON.2 - RECEIVE BIT 8 */
SBIT(      TB8, 0x98, 3 )  ; /* SCON.3 - TRANSMIT BIT 8 */
SBIT(     TB80, 0x98, 3 )  ; /* SCON.3 - TRANSMIT BIT 8 */
SBIT(      REN, 0x98, 4 )  ; /* SCON.4 - RECEIVE ENABLE */
SBIT(     REN0, 0x98, 4 )  ; /* SCON.4 - RECEIVE ENABLE */
SBIT(      SM2, 0x98, 5 )  ; /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE */
SBIT(     MCE0, 0x98, 5 )  ; /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE */
SBIT(      SM0, 0x98, 7 )  ; /* SCON.7 - SERIAL MODE CONTROL BIT 0 */
SBIT(   S0MODE, 0x98, 7 )  ; /* SCON.7 - SERIAL MODE CONTROL BIT 0 */

/*  P2  0xA0 */
SBIT(     P2_0, 0xA0, 0 )  ;
SBIT(     P2_1, 0xA0, 1 )  ;
SBIT(     P2_2, 0xA0, 2 )  ;
SBIT(     P2_3, 0xA0, 3 )  ;
SBIT(     P2_4, 0xA0, 4 )  ;
SBIT(     P2_5, 0xA0, 5 )  ;
SBIT(     P2_6, 0xA0, 6 )  ;
SBIT(     P2_7, 0xA0, 7 )  ;

/*  IE  0xA8 */
SBIT(      EX0, 0xA8, 0 )  ; /* IE.0 - EXTERNAL INTERRUPT 0 ENABLE */
SBIT(      ET0, 0xA8, 1 )  ; /* IE.1 - TIMER 0 INTERRUPT ENABLE */
SBIT(      EX1, 0xA8, 2 )  ; /* IE.2 - EXTERNAL INTERRUPT 1 ENABLE */
SBIT(      ET1, 0xA8, 3 )  ; /* IE.3 - TIMER 1 INTERRUPT ENABLE */
SBIT(       ES, 0xA8, 4 )  ; /* IE.4 - SERIAL PORT INTERRUPT ENABLE */
SBIT(      ES0, 0xA8, 4 )  ; /* IE.4 - SERIAL PORT INTERRUPT ENABLE */
SBIT(      ET2, 0xA8, 5 )  ; /* IE.5 - TIMER 2 INTERRUPT ENABLE */
SBIT(    IEGF0, 0xA8, 6 )  ; /* IE.6 - GENERAL PURPOSE FLAG 0 */
SBIT(       EA, 0xA8, 7 )  ; /* IE.7 - GLOBAL INTERRUPT ENABLE */

/* SPI1CN 0xB0 */
SBIT(   SPI1EN, 0xB0, 0 )  ; /* SPI1 Enable */
SBIT(   TXBMT1, 0xB0, 1 )  ; /* SPI1 Transmit Buffer Empty */
SBIT(  NSS1MD0, 0xB0, 2 )  ; /* SPI1 Slave Select Mode bit-0 */
SBIT(  NSS1MD1, 0xB0, 3 )  ; /* SPI1 Slave Select Mode bit-1 */
SBIT(  RXOVRN1, 0xB0, 4 )  ; /* SPI1 Receive Overrun Flag */
SBIT(    MODF1, 0xB0, 5 )  ; /* SPI1 Mode Fault Flag */
SBIT(    WCOL1, 0xB0, 6 )  ; /* SPI1 Write Collision Flag */
SBIT(    SPIF1, 0xB0, 7 )  ; /* SPI1 Interrupt Flag */

/*  IP  0xB8 */
SBIT(      PX0, 0xB8, 0 )  ; /* IP.0 - EXTERNAL INTERRUPT 0 PRIORITY */
SBIT(      PT0, 0xB8, 1 )  ; /* IP.1 - TIMER 0 PRIORITY */
SBIT(      PX1, 0xB8, 2 )  ; /* IP.2 - EXTERNAL INTERRUPT 1 PRIORITY */
SBIT(      PT1, 0xB8, 3 )  ; /* IP.3 - TIMER 1 PRIORITY */
SBIT(       PS, 0xB8, 4 )  ; /* IP.4 - SERIAL PORT PRIORITY */
SBIT(      PS0, 0xB8, 4 )  ; /* IP.4 - SERIAL PORT PRIORITY */
SBIT(      PT2, 0xB8, 5 )  ; /* IP.5 - TIMER 2 PRIORITY */

/*  SMB0CN  0xC0 */
SBIT(       SI, 0xC0, 0 )  ; /* SMB0CN.0 - SMBUS 0 INTERRUPT PENDING FLAG */
SBIT(      ACK, 0xC0, 1 )  ; /* SMB0CN.1 - SMBUS 0 ACKNOWLEDGE FLAG */
SBIT(  ARBLOST, 0xC0, 2 )  ; /* SMB0CN.2 - SMBUS 0 ARBITRATION LOST INDICATOR */
SBIT(    ACKRQ, 0xC0, 3 )  ; /* SMB0CN.3 - SMBUS 0 ACKNOWLEDGE REQUEST */
SBIT(      STO, 0xC0, 4 )  ; /* SMB0CN.4 - SMBUS 0 STOP FLAG */
SBIT(      STA, 0xC0, 5 )  ; /* SMB0CN.5 - SMBUS 0 START FLAG */
SBIT(   TXMODE, 0xC0, 6 )  ; /* SMB0CN.6 - SMBUS 0 TRANSMIT MODE INDICATOR */
SBIT(   MASTER, 0xC0, 7 )  ; /* SMB0CN.7 - SMBUS 0 MASTER/SLAVE INDICATOR */

/*  TMR2CN  0xC8 */
SBIT(   T2XCLK, 0xC8, 0 )  ; /* TMR2CN.0 - TIMER 2 EXTERNAL CLOCK SELECT */
SBIT(      TR2, 0xC8, 2 )  ; /* TMR2CN.2 - TIMER 2 ON/OFF CONTROL */
SBIT(  T2SPLIT, 0xC8, 3 )  ; /* TMR2CN.3 - TIMER 2 SPLIT MODE ENABLE */
SBIT(   TF2LEN, 0xC8, 5 )  ; /* TMR2CN.5 - TIMER 2 LOW BYTE INTERRUPT ENABLE */
SBIT(     TF2L, 0xC8, 6 )  ; /* TMR2CN.6 - TIMER 2 LOW BYTE OVERFLOW FLAG */
SBIT(      TF2, 0xC8, 7 )  ; /* TMR2CN.7 - TIMER 2 OVERFLOW FLAG */
SBIT(     TF2H, 0xC8, 7 )  ; /* TMR2CN.7 - TIMER 2 HIGH BYTE OVERFLOW FLAG */

/*  PSW  0xD0 */
SBIT(   PARITY, 0xD0, 0 )  ; /* PSW.0 - ACCUMULATOR PARITY FLAG */
SBIT(       F1, 0xD0, 1 )  ; /* PSW.1 - FLAG 1 */
SBIT(       OV, 0xD0, 2 )  ; /* PSW.2 - OVERFLOW FLAG */
SBIT(      RS0, 0xD0, 3 )  ; /* PSW.3 - REGISTER BANK SELECT 0 */
SBIT(      RS1, 0xD0, 4 )  ; /* PSW.4 - REGISTER BANK SELECT 1 */
SBIT(       F0, 0xD0, 5 )  ; /* PSW.5 - FLAG 0 */
SBIT(       AC, 0xD0, 6 )  ; /* PSW.6 - AUXILIARY CARRY FLAG */
SBIT(       CY, 0xD0, 7 )  ; /* PSW.7 - CARRY FLAG */

/*  PCA0CN  0xD8 */
SBIT(     CCF0, 0xD8, 0 )  ; /* PCA0CN.0 - PCA MODULE 0 CAPTURE/COMPARE FLAG */
SBIT(     CCF1, 0xD8, 1 )  ; /* PCA0CN.1 - PCA MODULE 1 CAPTURE/COMPARE FLAG */
SBIT(     CCF2, 0xD8, 2 )  ; /* PCA0CN.2 - PCA MODULE 2 CAPTURE/COMPARE FLAG */
SBIT(       CR, 0xD8, 6 )  ; /* PCA0CN.6 - PCA COUNTER/TIMER RUN CONTROL */
SBIT(       CF, 0xD8, 7 )  ; /* PCA0CN.7 - PCA COUNTER/TIMER OVERFLOW FLAG */

/*  ADC0CN  0xE8 */
SBIT(   AD0CM0, 0xE8, 0 )  ; /* ADC0CN.0 - ADC 0 START OF CONV. MODE BIT 0 */
SBIT(   AD0CM1, 0xE8, 1 )  ; /* ADC0CN.1 - ADC 0 START OF CONV. MODE BIT 1 */
SBIT(   AD0CM2, 0xE8, 2 )  ; /* ADC0CN.2 - ADC 0 START OF CONV. MODE BIT 2 */
SBIT(  AD0WINT, 0xE8, 3 )  ; /* ADC0CN.3 - ADC 0 WINDOW COMPARE INT. FLAG */
SBIT(  AD0BUSY, 0xE8, 4 )  ; /* ADC0CN.4 - ADC 0 BUSY FLAG */
SBIT(   AD0INT, 0xE8, 5 )  ; /* ADC0CN.5 - ADC 0 CONV. COMPLETE INT. FLAG */
SBIT(    AD0TM, 0xE8, 6 )  ; /* ADC0CN.6 - ADC 0 TRACK MODE */
SBIT(    AD0EN, 0xE8, 7 )  ; /* ADC0CN.7 - ADC 0 ENABLE */

/*  SPI0CN  0xF8 */
SBIT(   SPI0EN, 0xF8, 0 )  ; /* SPI0 Enable */
SBIT(   TXBMT0, 0xF8, 1 )  ; /* SPI0 Transmit Buffer Empty */
SBIT(  NSS0MD0, 0xF8, 2 )  ; /* SPI0 Slave Select Mode bit-0 */
SBIT(  NSS0MD1, 0xF8, 3 )  ; /* SPI0 Slave Select Mode bit-1 */
SBIT(  RXOVRN0, 0xF8, 4 )  ; /* SPI0 Receive Overrun Flag */
SBIT(    MODF0, 0xF8, 5 )  ; /* SPI0 Mode Fault Flag */
SBIT(    WCOL0, 0xF8, 6 )  ; /* SPI0 Write Collision Flag */
SBIT(    SPIF0, 0xF8, 7 )  ; /* SPI0 Interrupt Flag */


/* Indirectly accessed registers */

/* smaRTClock Internal Registers */
#define CAPTURE0         0x00    /* smaRTClock Capture register 0 */
#define CAPTURE1         0x01    /* smaRTClock Capture register 1 */
#define CAPTURE2         0x02    /* smaRTClock Capture register 2 */
#define CAPTURE3         0x03    /* smaRTClock Capture register 3 */
#define RTC0CN           0x04    /* smaRTClock Control */
#define RTC0XCN          0x05    /* smaRTClock Oscillator Control */
#define RTC0XCF          0x06    /* smaRTClock Oscillator Configuration */
#define RTC0PIN          0x07    /* smaRTClock Pin Configuration */
#define ALARM0           0x08    /* smaRTClock Alarm Register 0 */
#define ALARM1           0x09    /* smaRTClock Alarm Register 1 */
#define ALARM2           0x0A    /* smaRTClock Alarm Register 2 */
#define ALARM3           0x0B    /* smaRTClock Alarm Register 3 */


/* Predefined SFR Bit Masks */

/* PCON 0x87 */
#define PCON_IDLE       (1<<0)    /* PCON                                */
#define PCON_STOP       (1<<1)    /* PCON                                */

/* CKON 0x8E  */
#define T0M             (1<<2)    /* CKCON  Timer 0 Clock Select         */
#define T1M             (1<<3)    /* CKCON  Timer 1 Clock Select         */

/* PSCTL 0x8F */
#define PSWE            (1<<0)    /* Program Store Write Enable          */
#define PSEE            (1<<1)    /* Program Store Erase Enable          */
#define SFLE            (1<<2)    /* Scratchpad Flash Access Enable      */

/* EIE1 0xE6 */
#define ESMB0           (1<<0)    /* Enable SMBus (SMB0) Interrupt       */
#define ERTC0A          (1<<1)    /* Enable smaRTClock Alarm Interrupts  */
#define EWADC0          (1<<2)    /* Enable Window Comparison ADC0 Int.  */
#define EADC0           (1<<3)    /* Enable ADC0 Convert Complete Int.   */
#define EPCA0           (1<<4)    /* Enable PCA0 Interrupt               */
#define ECP0            (1<<5)    /* Enable Comparator0 (CP0) Interrupt  */
#define ECP1            (1<<6)    /* Enable Comparator1 (CP1) Interrupt  */
#define ET3             (1<<7)    /* Enable Timer 3 Interrupt            */

/* RSTSRC */
#define PINRSF          (1<<0)    /* HW Pin Reset Flag                   */
#define PORSF           (1<<1)    /* Power-on/fail Reset Rlag            */
#define MCDRSF          (1<<2)    /* Missing Clock Detector Reset Rlag   */
#define WDTRSF          (1<<3)    /* Watchdog Timer Reset Rlag           */
#define SWRSF           (1<<4)    /* Software Force/Reset Rlag           */
#define C0RSEF          (1<<5)    /* Comparator0 Reset Rlag              */
#define FERROR          (1<<6)    /* Flash Error Reset Rlag              */
#define RTC0RE          (1<<7)    /* smaRTClock Reset Rlag               */

/* PCA0CPMn */
#define ECCF            (1<<0)    /* Capture/Compare Flag Interrupt En.  */
#define PWM             (1<<1)    /* Pulse Width Modulation Mode Enable  */
#define TOG             (1<<2)    /* Toggle Function Enable              */
#define MAT             (1<<3)    /* Match Function Enable               */
#define CAPN            (1<<4)    /* Capture Negative Function Enable    */
#define CAPP            (1<<5)    /* Capture Positive Function Enable.   */
#define ECOM            (1<<6)    /* Comparator Function Enable.         */
#define PWM16           (1<<7)    /* 16-bit Pulse Width Modulation Enable*/

/* XBR0 0xE1 */
#define URT0E           (1<<0)    /* UART0 I/O enable                    */
#define SPI0E           (1<<1)    /* SPI0 I/O Enable                     */
#define SMB0E           (1<<2)    /* SMBus I/O Enable                    */
#define SYSCKE          (1<<3)    /* SYSCLK Output Enable.               */
#define CP0E            (1<<4)    /* Comparator0 Output Enable           */
#define CP0AE           (1<<5)    /* Comparator0 Asynchronous Output En. */
#define CP1E            (1<<6)    /* Comparator1 Output Enable           */
#define CP1AE           (1<<7)    /* Comparator1 Asynchronous Output En. */

/* XBR1 0xE2 */
#define PCA0ME0         (1<<0)    /* PCA0 Module I/O Enable bit-0        */
#define PCA0ME1         (1<<1)    /* PCA0 Module I/O Enable bit-1        */
#define PCA0ME2         (1<<2)    /* PCA0 Module I/O Enable bit-2        */
#define ECIE            (1<<3)    /* PCA0 Ext. Counter Input Enable      */
#define T0E             (1<<4)    /* Timer0 Input Enable                 */
#define T1E             (1<<5)    /* Timer1 Input Enable                 */
#define SPI1E           (1<<6)    /* SPI1 I/O Enable                     */

/* XBR2 0xE3 */
#define XBARE           (1<<6)    /* Crossbar Enable                     */
#define WEAKPUD         (1<<7)    /* Port I/O Weak Pullup Disable        */

/* Interrupts */

#define INT_EXT0          0       /* External Interrupt 0*/
#define INT_TIMER0        1       /* Timer0 Overflow */
#define INT_EXT1          2       /* External Interrupt 1 */
#define INT_TIMER1        3       /* Timer1 Overflow */
#define INT_UART0         4       /* Serial Port 0 */
#define INT_TIMER2        5       /* Timer2 Overflow */
#define INT_SPI0          6       /* SPI0 */
#define INT_SMBUS0        7       /* SMBus0 Interface */
#define INT_ALARM         8       /* smaRTClock Alarm  */
#define INT_ADC0_WINDOW   9       /* ADC0 Window Comparison */
#define INT_ADC0_EOC     10       /* ADC0 End Of Conversion */
#define INT_PCA0         11       /* PCA0 Peripheral */
#define INT_CP0          12       /* Comparator 0 */
#define INT_CP1          13       /* Comparator 1 */
#define INT_TIMER3       14       /* Timer3 Overflow */
#define INT_VWARN        15       /* VDD/DC+ Supply Monitor early warning */
#define INT_MATCH        16       /* Port Match */
#define INT_OSCFAIL      17       /* smaRTClock Oscillator Fail */
#define INT_SPI1         18       /* SPI1 */

/* aliases - these map alternative names to names use in the datasheet */
#define SCON             SCON0    /* Serial Port Control */
#define SBUF             SBUF0    /* Serial Port Buffer */
#define T2CON            TMR2CN	  /* Timer 2 control */
#define RCAP2            TMR2RL   /* Timer 2 capture register word */
#define RCAP2L           TMR2RLL  /* Timer 2 capture register - low byte */
#define RCAP2H           TMR2RLH  /* Timer 2 capture register - high byte */
#define T2               TMR2     /* Timer 2 - word */
#define TL2              TMR2L    /* Timer 2 - low byte */
#define TH2              TMR2H    /* Timer 2 - high byte */
#define PRT0MX           XBR0     /* Port Mux Configuration Register 0 */
#define PRT1MX           XBR1	  /* Port Mux Configuration Register 1 */
#define PRT2MX           XBR2	  /* Port Mux Configuration Register 2 */
#define IT01CF           INT01CF  /* INT0/INT1 Configuration Register */
#define P0MODE           P0MDIN   /* Port 0 Input Mode Configuration */
#define P1MODE           P1MDIN   /* Port 1 Input Mode Configuration */
#define P2MODE           P2MDIN   /* Port 2 Input Mode Configuration */
#define CP0OEN           CP0E     /* Comparator 0 Output Enable bit */
#define CP0AOEN          CP0AE    /* Comparator 0 Asynchronous Output En. bit */


#endif /* C8051F920_H */
/*-------------------------------------------------------------------------
   at89x52.h - register declarations for ATMEL 89x52 processors

   Copyright (C) 1999, Bernd Bartmann <bernd.bartmann AT gmail.com>

   Based on reg51.h by Sandeep Dutta sandeep.dutta AT usa.net
   KEIL C compatible definitions are included

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef AT89x52_H
#define AT89x52_H

/* BYTE addressable registers */
__sfr __at 0x80 P0          ;
__sfr __at 0x81 SP          ;
__sfr __at 0x82 DPL         ;
__sfr __at 0x83 DPH         ;
__sfr __at 0x87 PCON        ;
__sfr __at 0x88 TCON        ;
__sfr __at 0x89 TMOD        ;
__sfr __at 0x8A TL0         ;
__sfr __at 0x8B TL1         ;
__sfr __at 0x8C TH0         ;
__sfr __at 0x8D TH1         ;
__sfr __at 0x90 P1          ;
__sfr __at 0x98 SCON        ;
__sfr __at 0x99 SBUF        ;
__sfr __at 0xA0 P2          ;
__sfr __at 0xA8 IE          ;
__sfr __at 0xB0 P3          ;
__sfr __at 0xB8 IP          ;
__sfr __at 0xC8 T2CON       ;
__sfr __at 0xC9 T2MOD       ;
__sfr __at 0xCA RCAP2L      ;
__sfr __at 0xCB RCAP2H      ;
__sfr __at 0xCC TL2         ;
__sfr __at 0xCD TH2         ;
__sfr __at 0xD0 PSW         ;
__sfr __at 0xE0 ACC         ;
__sfr __at 0xE0 A           ;
__sfr __at 0xF0 B           ;


/* BIT addressable registers */
/* P0 */
__sbit __at 0x80 P0_0       ;
__sbit __at 0x81 P0_1       ;
__sbit __at 0x82 P0_2       ;
__sbit __at 0x83 P0_3       ;
__sbit __at 0x84 P0_4       ;
__sbit __at 0x85 P0_5       ;
__sbit __at 0x86 P0_6       ;
__sbit __at 0x87 P0_7       ;

/* TCON */
__sbit __at 0x88 IT0        ;
__sbit __at 0x89 IE0        ;
__sbit __at 0x8A IT1        ;
__sbit __at 0x8B IE1        ;
__sbit __at 0x8C TR0        ;
__sbit __at 0x8D TF0        ;
__sbit __at 0x8E TR1        ;
__sbit __at 0x8F TF1        ;

/* P1 */
__sbit __at 0x90 P1_0       ;
__sbit __at 0x91 P1_1       ;
__sbit __at 0x92 P1_2       ;
__sbit __at 0x93 P1_3       ;
__sbit __at 0x94 P1_4       ;
__sbit __at 0x95 P1_5       ;
__sbit __at 0x96 P1_6       ;
__sbit __at 0x97 P1_7       ;

__sbit __at 0x90 T2         ;
__sbit __at 0x91 T2EX       ;

/* SCON */
__sbit __at 0x98 RI         ;
__sbit __at 0x99 TI         ;
__sbit __at 0x9A RB8        ;
__sbit __at 0x9B TB8        ;
__sbit __at 0x9C REN        ;
__sbit __at 0x9D SM2        ;
__sbit __at 0x9E SM1        ;
__sbit __at 0x9F SM0        ;

/* P2 */
__sbit __at 0xA0 P2_0       ;
__sbit __at 0xA1 P2_1       ;
__sbit __at 0xA2 P2_2       ;
__sbit __at 0xA3 P2_3       ;
__sbit __at 0xA4 P2_4       ;
__sbit __at 0xA5 P2_5       ;
__sbit __at 0xA6 P2_6       ;
__sbit __at 0xA7 P2_7       ;

/* IE */
__sbit __at 0xA8 EX0        ;
__sbit __at 0xA9 ET0        ;
__sbit __at 0xAA EX1        ;
__sbit __at 0xAB ET1        ;
__sbit __at 0xAC ES         ;
__sbit __at 0xAD ET2        ;
__sbit __at 0xAF EA         ;

/* P3 */
__sbit __at 0xB0 P3_0       ;
__sbit __at 0xB1 P3_1       ;
__sbit __at 0xB2 P3_2       ;
__sbit __at 0xB3 P3_3       ;
__sbit __at 0xB4 P3_4       ;
__sbit __at 0xB5 P3_5       ;
__sbit __at 0xB6 P3_6       ;
__sbit __at 0xB7 P3_7       ;

__sbit __at 0xB0 RXD        ;
__sbit __at 0xB1 TXD        ;
__sbit __at 0xB2 INT0       ;
__sbit __at 0xB3 INT1       ;
__sbit __at 0xB4 T0         ;
__sbit __at 0xB5 T1         ;
__sbit __at 0xB6 WR         ;
__sbit __at 0xB7 RD         ;

/* IP */ 
__sbit __at 0xB8 PX0        ;
__sbit __at 0xB9 PT0        ;
__sbit __at 0xBA PX1        ;
__sbit __at 0xBB PT1        ;
__sbit __at 0xBC PS         ;
__sbit __at 0xBD PT2        ;

/* T2CON */
__sbit __at 0xC8 T2CON_0    ;
__sbit __at 0xC9 T2CON_1    ;
__sbit __at 0xCA T2CON_2    ;
__sbit __at 0xCB T2CON_3    ;
__sbit __at 0xCC T2CON_4    ;
__sbit __at 0xCD T2CON_5    ;
__sbit __at 0xCE T2CON_6    ;
__sbit __at 0xCF T2CON_7    ;

__sbit __at 0xC8 CP_RL2     ;
__sbit __at 0xC9 C_T2       ;
__sbit __at 0xCA TR2        ;
__sbit __at 0xCB EXEN2      ;
__sbit __at 0xCC TCLK       ;
__sbit __at 0xCD RCLK       ;
__sbit __at 0xCE EXF2       ;
__sbit __at 0xCF TF2        ;

/* PSW */
__sbit __at 0xD0 P          ;
__sbit __at 0xD1 FL         ;
__sbit __at 0xD2 OV         ;
__sbit __at 0xD3 RS0        ;
__sbit __at 0xD4 RS1        ;
__sbit __at 0xD5 F0         ;
__sbit __at 0xD6 AC         ;
__sbit __at 0xD7 CY         ;


/* BIT definitions for bits that are not directly accessible */
/* PCON bits */
#define IDL             0x01
#define PD              0x02
#define GF0             0x04
#define GF1             0x08
#define SMOD            0x80

#define IDL_            0x01
#define PD_             0x02
#define GF0_            0x04
#define GF1_            0x08
#define SMOD_           0x80

/* TMOD bits */
#define M0_0            0x01
#define M1_0            0x02
#define C_T0            0x04
#define GATE0           0x08
#define M0_1            0x10
#define M1_1            0x20
#define C_T1            0x40
#define GATE1           0x80

#define M0_0_           0x01
#define M1_0_           0x02
#define C_T0_           0x04
#define GATE0_          0x08
#define M0_1_           0x10
#define M1_1_           0x20
#define C_T1_           0x40
#define GATE1_          0x80

#define T0_M0           0x01
#define T0_M1           0x02
#define T0_CT           0x04
#define T0_GATE         0x08
#define T1_M0           0x10
#define T1_M1           0x20
#define T1_CT           0x40
#define T1_GATE         0x80

#define T0_M0_          0x01
#define T0_M1_          0x02
#define T0_CT_          0x04
#define T0_GATE_        0x08
#define T1_M0_          0x10
#define T1_M1_          0x20
#define T1_CT_          0x40
#define T1_GATE_        0x80

#define T0_MASK         0x0F
#define T1_MASK         0xF0

#define T0_MASK_        0x0F
#define T1_MASK_        0xF0

/* T2MOD bits */
#define DCEN            0x01
#define T2OE            0x02

#define DCEN_           0x01
#define T2OE_           0x02


/* Interrupt numbers: address = (number * 8) + 3 */
#define IE0_VECTOR      0       /* 0x03 external interrupt 0 */
#define TF0_VECTOR      1       /* 0x0b timer 0 */
#define IE1_VECTOR      2       /* 0x13 external interrupt 1 */
#define TF1_VECTOR      3       /* 0x1b timer 1 */
#define SI0_VECTOR      4       /* 0x23 serial port 0 */
#define TF2_VECTOR      5       /* 0x2B timer 2 */
#define EX2_VECTOR      5       /* 0x2B external interrupt 2 */
 
#endif
/*-------------------------------------------------------------------------
   C8051F360.h - Register Declarations for the SiLabs C8051F36x
   Processor Range

   Copyright (C) 2007, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef C8051F360_H
#define C8051F360_H

#include <compiler.h>

/*  All Pages */

SFR(P0,         0x80);      // Port 0
   SBIT(P0_0,     0x80, 0); // Port 0 bit 0
   SBIT(P0_1,     0x80, 1); // Port 0 bit 1
   SBIT(P0_2,     0x80, 2); // Port 0 bit 2
   SBIT(P0_3,     0x80, 3); // Port 0 bit 3
   SBIT(P0_4,     0x80, 4); // Port 0 bit 4
   SBIT(P0_5,     0x80, 5); // Port 0 bit 5
   SBIT(P0_6,     0x80, 6); // Port 0 bit 6
   SBIT(P0_7,     0x80, 7); // Port 0 bit 7
SFR(SP,         0x81);      // Stack Pointer
SFR(DPL,        0x82);      // Data Pointer Low Byte
SFR(DPH,        0x83);      // Data Pointer High Byte
SFR(SFRNEXT,    0x85);      // SFR Stack Next Page
SFR(SFRLAST,    0x86);      // SFR Stack Last Page
SFR(PCON,       0x87);      // Power Mode Control
SFR(TCON,       0x88);      // Timer Control
   SBIT(IT0,      0x88, 0); // Ext. Interrupt 0 Type Select
   SBIT(IE0,      0x88, 1); // Ext. Interrupt 0 Flag
   SBIT(IT1,      0x88, 2); // Ext. Interrupt 1 Type Select
   SBIT(IE1,      0x88, 3); // Ext. Interrupt 1 Flag
   SBIT(TR0,      0x88, 4); // Timer 0 Run Control
   SBIT(TF0,      0x88, 5); // Timer 0 Overflow Flag
   SBIT(TR1,      0x88, 6); // Timer 1 Run Control
   SBIT(TF1,      0x88, 7); // Timer 1 Overflow Flag
SFR(TMOD,       0x89);      // Timer Mode
SFR16E(TMR0,    0x8C8A);    // Timer/Counter 0 Word
   SFR(TL0,       0x8A);    // Timer/Counter 0 Low Byte
   SFR(TH0,       0x8C);    // Timer/Counter 0 High Byte
SFR16E(TMR1,    0x8D8B);    // Timer/Counter 1 Word
   SFR(TL1,       0x8B);    // Timer/Counter 1 Low Byte
   SFR(TH1,       0x8D);    // Timer/Counter 1 High Byte
SFR(CKCON,      0x8E);      // Clock Control
SFR(P1,         0x90);      // Port 1
   SBIT(P1_0,     0x90, 0); // Port 1 bit 0
   SBIT(P1_1,     0x90, 1); // Port 1 bit 1
   SBIT(P1_2,     0x90, 2); // Port 1 bit 2
   SBIT(P1_3,     0x90, 3); // Port 1 bit 3
   SBIT(P1_4,     0x90, 4); // Port 1 bit 4
   SBIT(P1_5,     0x90, 5); // Port 1 bit 5
   SBIT(P1_6,     0x90, 6); // Port 1 bit 6
   SBIT(P1_7,     0x90, 7); // Port 1 bit 7
SFR(TMR3CN,     0x91);      // Timer 3 Control
SFR16(TMR3RL,   0x92);      // Timer 3 Reload Register Word
   SFR(TMR3RLL,    0x92);   // Timer 3 Reload Register Low Byte
   SFR(TMR3RLH,    0x93);   // Timer 3 Reload Register High Byte
SFR16(TMR3,     0x94);      // Timer 3 Word
   SFR(TMR3L,      0x94);   // Timer 3 Low Byte
   SFR(TMR3H,      0x95);   // Timer 3 High Byte
SFR16(IDA0,     0x96);      // IDAC 0 Word
   SFR(IDA0L,      0x96);   // IDAC 0 Low Byte
   SFR(IDA0H,      0x97);   // IDAC 0 High Byte
SFR(SCON0,      0x98);      // Serial Port 0 Control
   SBIT(RI0,      0x98, 0); // Receive Interrupt Flag
   SBIT(TI0,      0x98, 1); // Transmit Interrupt Flag
   SBIT(RB80,     0x98, 2); // Ninth Receive Bit
   SBIT(TB80,     0x98, 3); // Ninth Transmission Bit
   SBIT(REN0,     0x98, 4); // Receive Enable
   SBIT(MCE0,     0x98, 5); // Multiprocessor Communication Enable
   SBIT(S0MODE,   0x98, 7); // Serial Port 0 Operation Mode
SFR(SBUF0,      0x99);      // Serial Port 0 Data Buffer
SFR(CPT1CN,     0x9A);      // Comparator 1 Control
SFR(CPT0CN,     0x9B);      // Comparator 0 Control
SFR(CPT1MD,     0x9C);      // Comparator 1 Mode Selection
SFR(CPT0MD,     0x9D);      // Comparator 0 Mode Selection
SFR(CPT1MX,     0x9E);      // Comparator 1 MUX Selection
SFR(CPT0MX,     0x9F);      // Comparator 0 MUX Selection
SFR(P2,         0xA0);      // Port 2
   SBIT(P2_0,     0xA0, 0); // Port 2 bit 0
   SBIT(P2_1,     0xA0, 1); // Port 2 bit 1
   SBIT(P2_2,     0xA0, 2); // Port 2 bit 2
   SBIT(P2_3,     0xA0, 3); // Port 2 bit 3
   SBIT(P2_4,     0xA0, 4); // Port 2 bit 4
   SBIT(P2_5,     0xA0, 5); // Port 2 bit 5
   SBIT(P2_6,     0xA0, 6); // Port 2 bit 6
   SBIT(P2_7,     0xA0, 7); // Port 2 bit 7
SFR(SPI0CFG,    0xA1);      // SPI Configuration
SFR(SPI0CKR,    0xA2);      // SPI Clock Rate Control
SFR(SPI0DAT,    0xA3);      // SPI Data
SFR(SFRPAGE,    0xA7);      // SFR Page Select
SFR(IE,         0xA8);      // Interrupt Enable
   SBIT(EX0,      0xA8, 0); // Enable External Interrupt 0
   SBIT(ET0,      0xA8, 1); // Enable Timer 0 Interrupt
   SBIT(EX1,      0xA8, 2); // Enable External Interrupt 1
   SBIT(ET1,      0xA8, 3); // Enable Timer 1 Interrupt
   SBIT(ES0,      0xA8, 4); // Enable Serial Port Interrupt
   SBIT(ET2,      0xA8, 5); // Enable Timer 2 Interrupt
   SBIT(ESPI0,    0xA8, 6); // Enable SPI0 Interrupt
   SBIT(EA,       0xA8, 7); // Global Interrupt Enable
SFR(EMI0CN,     0xAA);      // EMIF Control
SFR(_XPAGE,     0xAA);      // SDCC: XDATA/PDATA Page
SFR(P3,         0xB0);      // Port 3
   SBIT(P3_0,     0xB0, 0); // Port 3 bit 0
   SBIT(P3_1,     0xB0, 1); // Port 3 bit 1
   SBIT(P3_2,     0xB0, 2); // Port 3 bit 2
   SBIT(P3_3,     0xB0, 3); // Port 3 bit 3
   SBIT(P3_4,     0xB0, 4); // Port 3 bit 4
   SBIT(P3_5,     0xB0, 5); // Port 3 bit 5
   SBIT(P3_6,     0xB0, 6); // Port 3 bit 6
   SBIT(P3_7,     0xB0, 7); // Port 3 bit 7
SFR(P4,         0xB5);      // Port 4
SFR(IP,         0xB8);      // Interrupt Priority
   SBIT(PX0,      0xB8, 0); // External Interrupt 0 Priority
   SBIT(PT0,      0xB8, 1); // Timer 0 Interrupt Priority
   SBIT(PX1,      0xB8, 2); // External Interrupt 1 Priority
   SBIT(PT1,      0xB8, 3); // Timer 1 Interrupt Priority
   SBIT(PS0,      0xB8, 4); // Serial Port Interrupt Priority
   SBIT(PT2,      0xB8, 5); // Timer 2 Interrupt Priority
   SBIT(PSPI0,    0xB8, 6); // SPI0 Interrupt Priority
SFR(IDA0CN,     0xB9);      // IDAC 0 Control
SFR(AMX0N,      0xBA);      // AMUX 0 Negative Channel Select
SFR(AMX0P,      0xBB);      // AMUX 0 Positive Channel Select
SFR(ADC0CF,     0xBC);      // ADC0 Configuration
SFR16(ADC0,     0xBD);      // ADC0 Word
   SFR(ADC0L,     0xBD);    // ADC0 Low Byte
   SFR(ADC0H,     0xBE);    // ADC0 High Byte
SFR(SMB0CN,     0xC0);      // SMBus Control
   SBIT(SI,       0xC0, 0); // SMBus Interrupt Flag
   SBIT(ACK,      0xC0, 1); // SMBus Acknowledge Flag
   SBIT(ARBLOST,  0xC0, 2); // SMBus Arbitration Lost Indicator
   SBIT(ACKRQ,    0xC0, 3); // SMBus Acknowledge Request
   SBIT(STO,      0xC0, 4); // SMBus Stop Flag
   SBIT(STA,      0xC0, 5); // SMBus Start Flag
   SBIT(TXMODE,   0xC0, 6); // SMBus Transmit Mode Indicator
   SBIT(MASTER,   0xC0, 7); // SMBus Master/Slave Indicator
SFR(SMB0CF,     0xC1);      // SMBus Configuration
SFR(SMB0DAT,    0xC2);      // SMBus Data
SFR16(ADC0GT,   0xC3);      // ADC0 Greater-Than Data Word
   SFR(ADC0GTL,   0xC3);    // ADC0 Greater-Than Data Low Byte
   SFR(ADC0GTH,   0xC4);    // ADC0 Greater-Than Data High Byte
SFR16(ADC0LT,   0xC5);      // ADC0 Less-Than Data Word
   SFR(ADC0LTL,   0xC5);    // ADC0 Less-Than Data Low Byte
   SFR(ADC0LTH,   0xC6);    // ADC0 Less-Than Data High Byte
SFR(TMR2CN,     0xC8);      // Timer/Counter 2 Control
   SBIT(T2XCLK,   0xC8, 0); // Timer 2 External Clock Select
   SBIT(TR2,      0xC8, 2); // Timer 2 Run Control
   SBIT(T2SPLIT,  0xC8, 3); // Timer 2 Split Mode Enable
   SBIT(TF2CEN,   0xC8, 4); // Timer 2 Low-Frequency Oscillator Capture Enable
   SBIT(TF2LEN,   0xC8, 5); // Timer 2 Low Byte Interrupt Enable
   SBIT(TF2L,     0xC8, 6); // Timer 2 Low Byte Overflow Flag
   SBIT(TF2H,     0xC8, 7); // Timer 2 High Byte Overflow Flag
SFR16(TMR2RL,   0xCA);      // Timer/Counter 2 Reload Word
   SFR(TMR2RLL,   0xCA);    // Timer/Counter 2 Reload Low Byte
   SFR(TMR2RLH,   0xCB);    // Timer/Counter 2 Reload High Byte
SFR16(TMR2,     0xCC);      // Timer/Counter 2 Word
   SFR(TMR2L,     0xCC);    // Timer/Counter 2 Low Byte
   SFR(TMR2H,     0xCD);    // Timer/Counter 2 High Byte
SFR(PSW,        0xD0);      // Program Status Word
   SBIT(P,        0xD0, 0); // Parity Flag
   SBIT(F1,       0xD0, 1); // User-Defined Flag
   SBIT(OV,       0xD0, 2); // Overflow Flag
   SBIT(RS0,      0xD0, 3); // Register Bank Select 0
   SBIT(RS1,      0xD0, 4); // Register Bank Select 1
   SBIT(F0,       0xD0, 5); // User-Defined Flag
   SBIT(AC,       0xD0, 6); // Auxiliary Carry Flag
   SBIT(CY,       0xD0, 7); // Carry Flag
SFR(REF0CN,     0xD1);      // Voltage Reference Control
SFR(PCA0CN,     0xD8);      // PCA Control
   SBIT(CCF0,     0xD8, 0); // PCA Module 0 Capture/Compare Flag
   SBIT(CCF1,     0xD8, 1); // PCA Module 1 Capture/Compare Flag
   SBIT(CCF2,     0xD8, 2); // PCA Module 2 Capture/Compare Flag
   SBIT(CCF3,     0xD8, 3); // PCA Module 3 Capture/Compare Flag
   SBIT(CCF4,     0xD8, 4); // PCA Module 4 Capture/Compare Flag
   SBIT(CCF5,     0xD8, 5); // PCA Module 5 Capture/Compare Flag
   SBIT(CR,       0xD8, 6); // PCA Counter/Timer Run Control
   SBIT(CF,       0xD8, 7); // PCA Counter/Timer Overflow Flag
SFR(PCA0MD,     0xD9);      // PCA Mode
SFR(PCA0CPM0,   0xDA);      // PCA Module 0 Mode
SFR(PCA0CPM1,   0xDB);      // PCA Module 1 Mode
SFR(PCA0CPM2,   0xDC);      // PCA Module 2 Mode
SFR(PCA0CPM3,   0xDD);      // PCA Module 3 Mode
SFR(PCA0CPM4,   0xDE);      // PCA Module 4 Mode
SFR(PCA0CPM5,   0xDF);      // PCA Module 5 Mode
SFR(ACC,        0xE0);      // Accumulator
SFR(IT01CF,     0xE4);      // INT0/INT1 Configuration
SFR(EIE1,       0xE6);      // Extended Interrupt Enable 1
SFR(EIE2,       0xE7);      // Extended Interrupt Enable 2
SFR(ADC0CN,     0xE8);      // ADC0 Control
   SBIT(AD0CM0,   0xE8, 0); // ADC0 Conversion Start Mode Select Bit 0
   SBIT(AD0CM1,   0xE8, 1); // ADC0 Conversion Start Mode Select Bit 1
   SBIT(AD0CM2,   0xE8, 2); // ADC0 Conversion Start Mode Select Bit 2
   SBIT(AD0WINT,  0xE8, 3); // ADC0 Window Compare Interrupt Flag
   SBIT(AD0BUSY,  0xE8, 4); // ADC0 Busy Bit
   SBIT(AD0INT,   0xE8, 5); // ADC0 Conversion Complete Interrupt Flag
   SBIT(AD0TM,    0xE8, 6); // ADC0 Track Mode Bit
   SBIT(AD0EN,    0xE8, 7); // ADC0 Enable Bit
SFR16(PCA0CP1,  0xE9);      // PCA Capture 1 Word
   SFR(PCA0CPL1,  0xE9);    // PCA Capture 1 Low Byte
   SFR(PCA0CPH1,  0xEA);    // PCA Capture 1 High Byte
SFR16(PCA0CP2,  0xEB);      // PCA Capture 2 Word
   SFR(PCA0CPL2,  0xEB);    // PCA Capture 2 Low Byte
   SFR(PCA0CPH2,  0xEC);    // PCA Capture 2 High Byte
SFR16(PCA0CP3,  0xED);      // PCA Capture 3 Word
   SFR(PCA0CPL3,  0xED);    // PCA Capture 3 Low Byte
   SFR(PCA0CPH3,  0xEE);    // PCA Capture 3 High Byte
SFR(RSTSRC,     0xEF);      // Reset Source Configuration/Status
SFR(B,          0xF0);      // B Register
SFR16(PCA0CP5,  0xF5);      // PCA Capture 5 Word
   SFR(PCA0CPL5,  0xF5);    // PCA Capture 5 Low Byte
   SFR(PCA0CPH5,  0xF6);    // PCA Capture 5 High Byte
SFR(SPI0CN,     0xF8);      // SPI0 Control
   SBIT(SPIEN,    0xF8, 0); // SPI0 Enable
   SBIT(TXBMT,    0xF8, 1); // SPI0 Transmit Buffer Empty
   SBIT(NSSMD0,   0xF8, 2); // SPI0 Slave Select Mode Bit 0
   SBIT(NSSMD1,   0xF8, 3); // SPI0 Slave Select Mode Bit 1
   SBIT(RXOVRN,   0xF8, 4); // SPI0 Receive Overrun Flag
   SBIT(MODF,     0xF8, 5); // SPI0 Mode Fault Flag
   SBIT(WCOL,     0xF8, 6); // SPI0 Write Collision Flag
   SBIT(SPIF,     0xF8, 7); // SPI0 Interrupt Flag
SFR16(PCA0,     0xF9);      // PCA Counter Word
   SFR(PCA0L,     0xF9);    // PCA Counter Low Byte
   SFR(PCA0H,     0xFA);    // PCA Counter High Byte
SFR16(PCA0CP0,  0xFB);      // PCA Capture 0 Word
   SFR(PCA0CPL0,  0xFB);    // PCA Capture 0 Low Byte
   SFR(PCA0CPH0,  0xFC);    // PCA Capture 0 High Byte
SFR16(PCA0CP4,  0xFD);      // PCA Capture 4 Word
   SFR(PCA0CPL4,  0xFD);    // PCA Capture 4 Low Byte
   SFR(PCA0CPH4,  0xFE);    // PCA Capture 4 High Byte
SFR(VDM0CN,     0xFF);      // VDD Monitor Control

/*  Page 0x00 */

SFR(PSCTL,      0x8F);      // Program Store R/W Control
SFR16(MAC0A,    0xA4);      // MAC0 A Register Word
   SFR(MAC0AL,    0xA4);    // MAC0 A Register Low Byte
   SFR(MAC0AH,    0xA5);    // MAC0 A Register High Byte
SFR16(MAC0RND,  0xAE);      // MAC0 Rounding Register Word
   SFR(MAC0RNDL,  0xAE);    // MAC0 Rounding Register Low Byte
   SFR(MAC0RNDH,  0xAF);    // MAC0 Rounding Register High Byte
SFR(P2MAT,      0xB1);      // Port 2 Match
SFR(P2MASK,     0xB2);      // Port 2 Mask
SFR(FLSCL,      0xB6);      // Flash Scale
SFR(FLKEY,      0xB7);      // Flash Lock and Key
SFR(MAC0STA,    0xCF);      // MAC0 Status Register
SFR32(MAC0ACC,  0xD2);      // MAC0 Accumulator Long Word
   SFR(MAC0ACC0,  0xD2);    // MAC0 Accumulator Byte 0 (LSB)
   SFR(MAC0ACC1,  0xD3);    // MAC0 Accumulator Byte 1
   SFR(MAC0ACC2,  0xD4);    // MAC0 Accumulator Byte 2
   SFR(MAC0ACC3,  0xD5);    // MAC0 Accumulator Byte 3 (MSB)
SFR(MAC0OVR,    0xD6);      // MAC0 Accumulator Overflow
SFR(MAC0CF,     0xD7);      // MAC0 Configuration
SFR(P1MAT,      0xE1);      // Port 1 Match
SFR(P1MASK,     0xE2);      // Port 1 Mask
// No sfr16 definition for MAC0B because MAC0BL must be written last
   SFR(MAC0BL,    0xF1);    // MAC0 B Register Low Byte
   SFR(MAC0BH,    0xF2);    // MAC0 B Register High Byte
SFR(P0MAT,      0xF3);      // Port 0 Match
SFR(P0MASK,     0xF4);      // Port 0 Mask

/*  Page 0x0F */

SFR(CCH0CN,     0x84);      // Cache Control
SFR(CLKSEL,     0x8F);      // Clock Select
SFR(P0MDOUT,    0xA4);      // Port 0 Output Mode Configuration
SFR(P1MDOUT,    0xA5);      // Port 1 Output Mode Configuration
SFR(P2MDOUT,    0xA6);      // Port 2 Output Mode Configuration
SFR(PLL0DIV,    0xA9);      // PLL Divider
SFR(FLSTAT,     0xAC);      // Flash Status
SFR(OSCLCN,     0xAD);      // Internal Low-Frequency Oscillator Control
SFR(P4MDOUT,    0xAE);      // Port 4 Output Mode Configuration
SFR(P3MDOUT,    0xAF);      // Port 3 Output Mode Configuration
SFR(PLL0MUL,    0xB1);      // PLL Multiplier
SFR(PLL0FLT,    0xB2);      // PLL Filter
SFR(PLL0CN,     0xB3);      // PLL Control
SFR(OSCXCN,     0xB6);      // External Oscillator Control
SFR(OSCICN,     0xB7);      // Internal Oscillator Control
SFR(OSCICL,     0xBF);      // Internal Oscillator Calibration
SFR(EMI0CF,     0xC7);      // EMIF Configuration
SFR(CCH0TN,     0xC9);      // Cache Tuning
SFR(EIP1,       0xCE);      // Extended Interrupt Priority 1
SFR(EIP2,       0xCF);      // Extended Interrupt Priority 2
SFR(CCH0LC,     0xD2);      // Cache Lock
SFR(CCH0MA,     0xD3);      // Cache Miss Accumulator
SFR(P0SKIP,     0xD4);      // Port 0 Skip
SFR(P1SKIP,     0xD5);      // Port 1 Skip
SFR(P2SKIP,     0xD6);      // Port 2 Skip
SFR(P3SKIP,     0xD7);      // Port 3 Skip
SFR(XBR0,       0xE1);      // Port I/O Crossbar Control 0
SFR(XBR1,       0xE2);      // Port I/O Crossbar Control 1
SFR(SFR0CN,     0xE5);      // SFR Page Control
SFR(P0MDIN,     0xF1);      // Port 0 Input Mode Configuration
SFR(P1MDIN,     0xF2);      // Port 1 Input Mode Configuration
SFR(P2MDIN,     0xF3);      // Port 2 Input Mode Configuration
SFR(P3MDIN,     0xF4);      // Port 3 Input Mode Configuration
SFR(EMI0TC,     0xF7);      // EMIF Timing Control

/* Predefined SFR Bit Masks */

#define PCON_IDLE         0x01    /* PCON                                */
#define PCON_STOP         0x02    /* PCON                                */
#define T1M               0x08    /* CKCON                               */
#define PSWE              0x01    /* PSCTL                               */
#define PSEE              0x02    /* PSCTL                               */
#define PORSF             0x02    /* RSTSRC                              */
#define SWRSF             0x10    /* RSTSRC                              */
#define ECCF              0x01    /* PCA0CPMn                            */
#define PWM               0x02    /* PCA0CPMn                            */
#define TOG               0x04    /* PCA0CPMn                            */
#define MAT               0x08    /* PCA0CPMn                            */
#define CAPN              0x10    /* PCA0CPMn                            */
#define CAPP              0x20    /* PCA0CPMn                            */
#define ECOM              0x40    /* PCA0CPMn                            */
#define PWM16             0x80    /* PCA0CPMn                            */
#define CP0E              0x10    /* XBR0                                */
#define CP0AE             0x20    /* XBR0                                */

/* Interrupts */

#define INT_EXT0          0       // External Interrupt 0
#define INT_TIMER0        1       // Timer0 Overflow
#define INT_EXT1          2       // External Interrupt 1
#define INT_TIMER1        3       // Timer1 Overflow
#define INT_UART0         4       // Serial Port 0
#define INT_TIMER2        5       // Timer2 Overflow
#define INT_SPI0          6       // Serial Peripheral Interface 0
#define INT_SMBUS0        7       // SMBus0 Interface
//                        8          Reserved
#define INT_ADC0_WINDOW   9       // ADC0 Window Comparison
#define INT_ADC0_EOC      10      // ADC0 End Of Conversion
#define INT_PCA0          11      // PCA0 Peripheral
#define INT_COMPARATOR0   12      // Comparator0
#define INT_COMPARATOR1   13      // Comparator1
#define INT_TIMER3        14      // Timer3 Overflow
//                        15         Reserved
#define INT_PORT_MATCH    16      // Port Match

#endif
/*------------------------------------------------------------------//--------
P89LPC922.H
(English)
This header allows to use the microcontroler Philips P89LPC922
with the compiler SDCC.

Copyright (c) 2005 Omar Espinosa--e-mail: opiedrahita2003 AT yahoo.com.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

(Spanish-Español)
Archivo encabezador para el ucontrolador Philips P89LPC922.
Derechos de copy (DC) 2005.  OMAR ESPINOSA P.  E-mail: opiedrahita2003 AT yahoo.com
Uso libre
//------------------------------------------------------------------//--//------*/
#ifndef __REG922_H__
#define __REG922_H__

//*  BYTE Registers  *//
__sfr __at (0x80) P0     ;
__sfr __at (0x90) P1     ;
__sfr __at (0xB0) P3     ;
__sfr __at (0xD0) PSW    ;
__sfr __at (0xE0) ACC    ;
__sfr __at (0xF0) B      ;
__sfr __at (0x81) SP     ;
__sfr __at (0x82) DPL    ;
__sfr __at (0x83) DPH    ;
__sfr __at (0x87) PCON   ;
__sfr __at (0x88) TCON   ;
__sfr __at (0x89) TMOD   ;
__sfr __at (0x8A) TL0    ;
__sfr __at (0x8B) TL1    ;
__sfr __at (0x8C) TH0    ;
__sfr __at (0x8D) TH1    ;
__sfr __at (0xA8) IEN0   ;
__sfr __at (0xB8) IP0    ;
__sfr __at (0x98) SCON   ;
__sfr __at (0x99) SBUF   ;


__sfr __at (0xA2) AUXR1  ;
__sfr __at (0xA9) SADDR  ;
__sfr __at (0xB9) SADEN  ;
__sfr __at (0xBE) BRGR0  ;
__sfr __at (0xBF) BRGR1  ;
__sfr __at (0xBD) BRGCON ;
__sfr __at (0xAC) CMP1   ;
__sfr __at (0xAD) CMP2   ;
__sfr __at (0x95) DIVM   ;
__sfr __at (0xE7) FMADRH ;
__sfr __at (0xE6) FMADRL ;
__sfr __at (0xE4) FMCON  ;
__sfr __at (0xE5) FMDATA ;
__sfr __at (0xDB) I2ADR  ;
__sfr __at (0xD8) I2CON  ;
__sfr __at (0xDA) I2DAT  ;
__sfr __at (0xDD) I2SCLH ;
__sfr __at (0xDC) I2SCLL ;
__sfr __at (0xD9) I2STAT ;
__sfr __at (0xF8) IP1    ;
__sfr __at (0xF7) IP1H   ;
__sfr __at (0x94) KBCON  ;
__sfr __at (0x86) KBMASK ;
__sfr __at (0x93) KBPATN ;
__sfr __at (0x84) P0M1   ;
__sfr __at (0x85) P0M2   ;
__sfr __at (0x91) P1M1   ;
__sfr __at (0x92) P1M2   ;
__sfr __at (0xB1) P3M1   ;
__sfr __at (0xB2) P3M2   ;
__sfr __at (0xB5) PCONA  ;
__sfr __at (0xF6) PT0AD  ;
__sfr __at (0xDF) RSTSRC ;
__sfr __at (0xD1) RTCCON ;
__sfr __at (0xD2) RTCH   ;
__sfr __at (0xD3) RTCL   ;
__sfr __at (0xBA) SSTAT  ;
__sfr __at (0x8F) TAMOD  ;
__sfr __at (0x96) TRIM   ;
__sfr __at (0xA7) WDCON  ;
__sfr __at (0xC1) WDL    ;
__sfr __at (0xC2) WFEED1 ;
__sfr __at (0xC3) WFEED2 ;
__sfr __at (0xB7) IP0H   ;
__sfr __at (0xE8) IEN1   ;

/*  BIT Registers  */
/*  PSW   */
__sbit __at (0xD0) PSW_0   ;
__sbit __at (0xD1) PSW_1   ;
__sbit __at (0xD2) PSW_2   ;
__sbit __at (0xD3) PSW_3   ;
__sbit __at (0xD4) PSW_4   ;
__sbit __at (0xD5) PSW_5   ;
__sbit __at (0xD6) PSW_6   ;
__sbit __at (0xD7) PSW_7   ;

#define CY    PSW_7
#define AC    PSW_6
#define F0    PSW_5
#define RS1   PSW_4
#define RS0   PSW_3
#define OV    PSW_2
#define F1    PSW_1
#define P     PSW_0

/*  TCON  */
__sbit __at (0x8F) TCON_7  ;
__sbit __at (0x8E) TCON_6  ;
__sbit __at (0x8D) TCON_5  ;
__sbit __at (0x8C) TCON_4  ;
__sbit __at (0x8B) TCON_3  ;
__sbit __at (0x8A) TCON_2  ;
__sbit __at (0x89) TCON_1  ;
__sbit __at (0x88) TCON_0  ;

#define TF1   TCON_7
#define TR1   TCON_6
#define TF0   TCON_5
#define TR0   TCON_4
#define IE1   TCON_3
#define IT1   TCON_2
#define IE0   TCON_1
#define IT0   TCON_0

/*  IEN0   */
__sbit __at (0xAF) IEN0_7  ;
__sbit __at (0xAE) IEN0_6  ;
__sbit __at (0xAD) IEN0_5  ;
__sbit __at (0xAC) IEN0_4  ;
__sbit __at (0xAB) IEN0_3  ;
__sbit __at (0xAA) IEN0_2  ;
__sbit __at (0xA9) IEN0_1  ;
__sbit __at (0xA8) IEN0_0  ;

#define EA    IEN0_7
#define EWDRT IEN0_6
#define EBO   IEN0_5
#define ES    IEN0_4    // alternatively "ESR"
#define ESR   IEN0_4
#define ET1   IEN0_3
#define EX1   IEN0_2
#define ET0   IEN0_1
#define EX0   IEN0_0

/*  IEN1   */
__sbit __at (0xEA) IEN1_2  ;
__sbit __at (0xE9) IEN1_1  ;
__sbit __at (0xE8) IEN1_0  ;

#define EC    IEN1_2
#define EKBI  IEN1_1
#define EI2C  IEN1_0

/*  IP1   */
__sbit __at (0xFE) IP1_6   ;
__sbit __at (0xFA) IP1_2   ;
__sbit __at (0xF9) IP1_1   ;
__sbit __at (0xF8) IP1_0   ;

#define PST   IP1_6
#define PC    IP1_2
#define PKBI  IP1_1
#define PI2C  IP1_0

/*  IP0   */
__sbit __at (0xBE) IP0_6   ;
__sbit __at (0xBD) IP0_5   ;
__sbit __at (0xBC) IP0_4   ; // alternatively "PSR"
__sbit __at (0xBB) IP0_3   ;
__sbit __at (0xBA) IP0_2   ;
__sbit __at (0xB9) IP0_1   ;
__sbit __at (0xB8) IP0_0   ;

#define PWDRT IP0_6
#define PBO   IP0_5
#define PS    IP0_4      // alternatively "PSR"
#define PSR   IP0_4
#define PT1   IP0_3
#define PX1   IP0_2
#define PT0   IP0_1
#define PX0   IP0_0

/*  SCON  */
__sbit __at (0x98) SCON_0  ;
__sbit __at (0x99) SCON_1  ;
__sbit __at (0x9A) SCON_2  ;
__sbit __at (0x9B) SCON_3  ;
__sbit __at (0x9C) SCON_4  ;
__sbit __at (0x9D) SCON_5  ;
__sbit __at (0x9E) SCON_6  ;
__sbit __at (0x9F) SCON_7  ;

#define SM0   SCON_7  // alternatively "FE"
#define FE    SCON_7
#define SM1   SCON_6
#define SM2   SCON_5
#define REN   SCON_4
#define TB8   SCON_3
#define RB8   SCON_2
#define TI    SCON_1
#define RI    SCON_0

/*  I2CON  */
__sbit __at (0xDE) I2CON_6 ;
__sbit __at (0xDD) I2CON_5 ;
__sbit __at (0xDC) I2CON_4 ;
__sbit __at (0xDB) I2CON_3 ;
__sbit __at (0xDA) I2CON_2 ;
__sbit __at (0xD8) I2CON_0 ;

#define I2EN  I2CON_6
#define STA   I2CON_5
#define STO   I2CON_4
#define SI    I2CON_3
#define AA    I2CON_2
#define CRSEL I2CON_0

/*  P0    */
__sbit __at (0x80) P0_0    ;
__sbit __at (0x81) P0_1    ;
__sbit __at (0x82) P0_2    ;
__sbit __at (0x83) P0_3    ;
__sbit __at (0x84) P0_4    ;
__sbit __at (0x85) P0_5    ;
__sbit __at (0x86) P0_6    ;
__sbit __at (0x87) P0_7    ;

#define	KB7   P0_7   // alternatively "T1"
#define T1    P0_7
#define KB6   P0_6   // alternatively "CMP_1"
#define CMP_1 P0_6
#define KB5   P0_5
#define KB4   P0_4
#define KB3   P0_3
#define KB2   P0_2
#define KB1   P0_1
#define KB0   P0_0   // alternatively "CMP_2"
#define CMP_2 P0_0

/*  P1  */
__sbit __at (0x90) P1_0    ;
__sbit __at (0x91) P1_1    ;
__sbit __at (0x92) P1_2    ;
__sbit __at (0x93) P1_3    ;
__sbit __at (0x94) P1_4    ;
__sbit __at (0x95) P1_5    ;
__sbit __at (0x96) P1_6    ;
__sbit __at (0x97) P1_7    ;

#define RST   P1_5
#define INT1  P1_4
#define INT0  P1_3   // alternatively "SDA"
#define SDA   P1_3
#define T0    P1_2   // alternatively "SCL"
#define SCL   P1_2
#define RxD   P1_1
#define TxD   P1_0

/*  P3  */
__sbit __at (0xB0)  P3_0   ;
__sbit __at (0xB1)  P3_1   ;

#define XTAL1 P3_1
#define XTAL2 P3_0

#endif
/*-------------------------------------------------------------------------
   8051.h: Register Declarations for the Intel 8051 Processor

   Copyright (C) 2000, Bela Torok / bela.torok@kssg.ch

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef REG8051_H
#define REG8051_H

/*  BYTE Register  */
__sfr __at (0x80) P0   ;
__sfr __at (0x81) SP   ;
__sfr __at (0x82) DPL  ;
__sfr __at (0x83) DPH  ;
__sfr __at (0x87) PCON ;
__sfr __at (0x88) TCON ;
__sfr __at (0x89) TMOD ;
__sfr __at (0x8A) TL0  ;
__sfr __at (0x8B) TL1  ;
__sfr __at (0x8C) TH0  ;
__sfr __at (0x8D) TH1  ;
__sfr __at (0x90) P1   ;
__sfr __at (0x98) SCON ;
__sfr __at (0x99) SBUF ;
__sfr __at (0xA0) P2   ;
__sfr __at (0xA8) IE   ;
__sfr __at (0xB0) P3   ;
__sfr __at (0xB8) IP   ;
__sfr __at (0xD0) PSW  ;
__sfr __at (0xE0) ACC  ;
__sfr __at (0xF0) B    ;


/*  BIT Register  */
/* P0 */
__sbit __at (0x80) P0_0 ;
__sbit __at (0x81) P0_1 ;
__sbit __at (0x82) P0_2 ;
__sbit __at (0x83) P0_3 ;
__sbit __at (0x84) P0_4 ;
__sbit __at (0x85) P0_5 ;
__sbit __at (0x86) P0_6 ;
__sbit __at (0x87) P0_7 ;

/*  TCON  */
__sbit __at (0x88) IT0  ;
__sbit __at (0x89) IE0  ;
__sbit __at (0x8A) IT1  ;
__sbit __at (0x8B) IE1  ;
__sbit __at (0x8C) TR0  ;
__sbit __at (0x8D) TF0  ;
__sbit __at (0x8E) TR1  ;
__sbit __at (0x8F) TF1  ;

/* P1 */
__sbit __at (0x90) P1_0 ;
__sbit __at (0x91) P1_1 ;
__sbit __at (0x92) P1_2 ;
__sbit __at (0x93) P1_3 ;
__sbit __at (0x94) P1_4 ;
__sbit __at (0x95) P1_5 ;
__sbit __at (0x96) P1_6 ;
__sbit __at (0x97) P1_7 ;

/*  SCON  */
__sbit __at (0x98) RI   ;
__sbit __at (0x99) TI   ;
__sbit __at (0x9A) RB8  ;
__sbit __at (0x9B) TB8  ;
__sbit __at (0x9C) REN  ;
__sbit __at (0x9D) SM2  ;
__sbit __at (0x9E) SM1  ;
__sbit __at (0x9F) SM0  ;

/* P2 */
__sbit __at (0xA0) P2_0 ;
__sbit __at (0xA1) P2_1 ;
__sbit __at (0xA2) P2_2 ;
__sbit __at (0xA3) P2_3 ;
__sbit __at (0xA4) P2_4 ;
__sbit __at (0xA5) P2_5 ;
__sbit __at (0xA6) P2_6 ;
__sbit __at (0xA7) P2_7 ;

/*  IE   */
__sbit __at (0xA8) EX0  ;
__sbit __at (0xA9) ET0  ;
__sbit __at (0xAA) EX1  ;
__sbit __at (0xAB) ET1  ;
__sbit __at (0xAC) ES   ;
__sbit __at (0xAF) EA   ;

/*  P3  */
__sbit __at (0xB0) P3_0 ;
__sbit __at (0xB1) P3_1 ;
__sbit __at (0xB2) P3_2 ;
__sbit __at (0xB3) P3_3 ;
__sbit __at (0xB4) P3_4 ;
__sbit __at (0xB5) P3_5 ;
__sbit __at (0xB6) P3_6 ;
__sbit __at (0xB7) P3_7 ;

__sbit __at (0xB0) RXD  ;
__sbit __at (0xB1) TXD  ;
__sbit __at (0xB2) INT0 ;
__sbit __at (0xB3) INT1 ;
__sbit __at (0xB4) T0   ;
__sbit __at (0xB5) T1   ;
__sbit __at (0xB6) WR   ;
__sbit __at (0xB7) RD   ;

/*  IP   */
__sbit __at (0xB8) PX0  ;
__sbit __at (0xB9) PT0  ;
__sbit __at (0xBA) PX1  ;
__sbit __at (0xBB) PT1  ;
__sbit __at (0xBC) PS   ;

/*  PSW   */
__sbit __at (0xD0) P    ;
__sbit __at (0xD1) F1   ;
__sbit __at (0xD2) OV   ;
__sbit __at (0xD3) RS0  ;
__sbit __at (0xD4) RS1  ;
__sbit __at (0xD5) F0   ;
__sbit __at (0xD6) AC   ;
__sbit __at (0xD7) CY   ;

/* BIT definitions for bits that are not directly accessible */
/* PCON bits */
#define IDL             0x01
#define PD              0x02
#define GF0             0x04
#define GF1             0x08
#define SMOD            0x80

/* TMOD bits */
#define T0_M0           0x01
#define T0_M1           0x02
#define T0_CT           0x04
#define T0_GATE         0x08
#define T1_M0           0x10
#define T1_M1           0x20
#define T1_CT           0x40
#define T1_GATE         0x80

#define T0_MASK         0x0F
#define T1_MASK         0xF0

/* Interrupt numbers: address = (number * 8) + 3 */
#define IE0_VECTOR      0       /* 0x03 external interrupt 0 */
#define TF0_VECTOR      1       /* 0x0b timer 0 */
#define IE1_VECTOR      2       /* 0x13 external interrupt 1 */
#define TF1_VECTOR      3       /* 0x1b timer 1 */
#define SI0_VECTOR      4       /* 0x23 serial port 0 */

#endif
/*-----------------------------------------------------------------------------
   lint.h - Include file to allow parsing mcs51 specific code with syntax
   checking tools 

   Copyright (c) 2005, Dr. Frieder Ferlemann <Frieder.Ferlemann AT web.de>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef _LINT_H
#define _LINT_H

  #if !defined(__SDCC_mcs51)

    #define __data
    #define __near
    #define __idata
    #define __xdata
    #define __far
    #define __pdata
    #define __code
    #define __bit bool
    #define __sfr volatile unsigned char
    #define __sbit volatile bool
    #define __critical
    #define __at(x)             /* use "__at (0xab)" instead of "__at 0xab" */
    #define __using(x)
    #define __interrupt(x)
    #define __naked

    #define data
    #define near 
    #define idata
    #define xdata
    #define far
    #define pdata
    #define code
    #define bit bool
    #define sfr volatile unsigned char
    #define sbit volatile bool
    #define critical
    #define at(x)
    #define using(x)
    #define interrupt(x)
    #define naked

    /* The tool Splint is available at http://www.splint.org
       Other tools might also be used for statically checking c-sources.
       Traditionally they could have "lint" in their name.
     */
    #if defined(S_SPLINT_S)

      /* Behaviour of splint can be modified by special comments.
         Some examples are shown below.

         Note 1: most probably you'll want to copy this complete file into
         your source directory, adapt the settings to your needs and use
         #include "lint.h" as the first include in your source file(s).
         You should then be able to either directly compile your file
         or to run a check with splint over it without other changes.

         Note 2: you need brackets around arguments for special
         keywords, so f.e. it's "interrupt (1)" instead of "interrupt 1".
       */

      /*@ +charindex @*/

    #endif

  #endif

#endif
/*--------------------------------------------------------------------------
P89LPC901.H
(English)
This header allows to use the microcontroler Philips P89LPC901
with the compiler SDCC.

Copyright (c) 2005 Omar Espinosa--e-mail: opiedrahita2003 AT yahoo.com.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

(Spanish-Español)
Archivo encabezador para el ucontrolador Philips P89LPC901.
Derechos de copy (DC) 2005.  OMAR ESPINOSA P.  E-mail: opiedrahita2003 AT yahoo.com
Uso libre
--------------------------------------------------------------------------*/

#ifndef __REG901_H__
#define __REG901_H__

/*  BYTE Registers  */
__sfr __at (0x80) P0       ;
__sfr __at (0x84) P0M1     ;
__sfr __at (0x85) P0M2     ;

__sfr __at (0x90) P1       ;
__sfr __at (0x91) P1M1     ;
__sfr __at (0x92) P1M2     ;

__sfr __at (0xB0) P3       ;
__sfr __at (0xB1) P3M1     ;
__sfr __at (0xB2) P3M2     ;
//------------------
__sfr __at (0xD0) PSW      ;
__sfr __at (0xE0) ACC      ;
__sfr __at (0xF0) B        ;
__sfr __at (0x81) SP       ;
__sfr __at (0x82) DPL      ;
__sfr __at (0x83) DPH      ;
//------------------
__sfr __at (0xA2) AUXR1    ;
__sfr __at (0xAC) CMP1     ;
__sfr __at (0x95) DIVM     ;

__sfr __at (0xE7) FMADRH   ;
__sfr __at (0xE6) FMADRL   ;
__sfr __at (0xE4) FMCON    ;
__sfr __at (0xE5) FMDATA   ;

__sfr __at (0xA8) IEN0     ;
__sfr __at (0xE8) IEN1     ;

__sfr __at (0xB8) IP0      ;
__sfr __at (0xB7) IP0H     ;
__sfr __at (0xF8) IP1      ;
__sfr __at (0xF7) IP1H     ;

__sfr __at (0x94) KBCON    ;
__sfr __at (0x86) KBMASK   ;
__sfr __at (0x93) KBPATN   ;

__sfr __at (0x87) PCON     ;
__sfr __at (0xB5) PCONA    ;
__sfr __at (0xB6) PCONB    ;

__sfr __at (0xF6) PT0AD    ;
__sfr __at (0xDF) RSTSRC   ;

__sfr __at (0xD1) RTCCON   ;
__sfr __at (0xD2) RTCH     ;
__sfr __at (0xD3) RTCL     ;

__sfr __at (0x8F) TAMOD    ;
__sfr __at (0x88) TCON     ;
__sfr __at (0x8A) TL0      ;
__sfr __at (0x8B) TL1      ;
__sfr __at (0x8C) TH0      ;
__sfr __at (0x8D) TH1      ;
__sfr __at (0x89) TMOD     ;
__sfr __at (0x96) TRIM     ;

__sfr __at (0xA7) WDCON    ;
__sfr __at (0xC1) WDL      ;
__sfr __at (0xC2) WFEED1   ;
__sfr __at (0xC3) WFEED2   ;


/*  BIT Registers  */
/*  PSW   */
__sbit __at (0xD7)    PSW_7;
__sbit __at (0xD6)    PSW_6;
__sbit __at (0xD5)    PSW_5;
__sbit __at (0xD4)    PSW_4;
__sbit __at (0xD3)    PSW_3;
__sbit __at (0xD2)    PSW_2;
__sbit __at (0xD1)    PSW_1;
__sbit __at (0xD0)    PSW_0;

#define  CY      PSW_7
#define  AC      PSW_6
#define  F0      PSW_5
#define  RS1     PSW_4
#define  RS0     PSW_3
#define  OV      PSW_2
#define  F1      PSW_1
#define  P       PSW_0

/*  TCON  */
__sbit __at (0x8F)    TCON_7;
__sbit __at (0x8E)    TCON_6;
__sbit __at (0x8D)    TCON_5;
__sbit __at (0x8C)    TCON_4;

#define TF1      TCON_7
#define TR1      TCON_6
#define TF0      TCON_5
#define TR0      TCON_4

/*  IEN0   */
__sbit __at (0xAF)    IEN0_7;
__sbit __at (0xAE)    IEN0_6;
__sbit __at (0xAD)    IEN0_5;
__sbit __at (0xAB)    IEN0_3;
__sbit __at (0xA9)    IEN0_1;

#define EA       IEN0_7
#define EWDRT    IEN0_6
#define EBO      IEN0_5
#define ET1      IEN0_3
#define ET0      IEN0_1

/*  IEN1   */
__sbit __at (0xEA)    IEN1_2;
__sbit __at (0xE9)    IEN1_1;

#define EC       IEN1_2
#define EKBI     IEN1_1

/*  IP0   */
__sbit __at (0xBE)    IP0_6;
__sbit __at (0xBD)    IP0_5;
__sbit __at (0xBB)    IP0_3;
__sbit __at (0xB9)    IP0_1;

#define PWDRT    IP0_6
#define PB0      IP0_5
#define PT1      IP0_3
#define PT0      IP0_1

/*  P0  */
__sbit __at (0x85)    P0_5;
__sbit __at (0x84)    P0_4;

#define KB5      P0_5
#define CMPREF   P0_5
#define KB4      P0_4
#define CIN1A    P0_4

/*  P1  */
__sbit __at (0x95)    P1_5;
__sbit __at (0x92)    P1_2;

#define RST      P1_5
#define T0       P1_2

/*  P3  */
__sbit __at (0xB1)    P3_1;
__sbit __at (0xB0)    P3_0;

#define XTAL1    P3_1
#define XTAL2    P3_0

#endif
/*-------------------------------------------------------------------------
   ADuC84x.h: Register Declarations for Analog Devices
   ADuC841/ADuC842/ADuC843 (Based on datasheet Rev 0, 11/2003 )

   Copyright (C) 2007, Jesus Calvino-Fraga / jesusc at ece.ubc.ca

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef REG_ADUC84X_H
#define REG_ADUC84X_H

#include <compiler.h>

SFR(CFG841, 0xAF); // ADuC841 Configuration SFR.
SFR(CFG842, 0xAF); // ADuC842/ADuC843 Configuration SFR.
	//For the two SFRs above these are the bits.  Warning: some are different for
	//the ADuC841 and ADuC842/ADuC843.  Check the datasheet!
    #define EPM2   0x10 // Flash/EE Controller and PWM Clock Frequency Configuration Bit 2.
    #define EPM1   0x08 // Flash/EE Controller and PWM Clock Frequency Configuration Bit 1.
    #define EPM0   0x04 // Flash/EE Controller and PWM Clock Frequency Configuration Bit 0.
    #define EXSP   0x80 // Extended SP Enable.
    #define PWPO   0x40 // PWM Pin Out Selection.
    #define DBUF   0x20 // DAC Output Buffer.
    #define EXTCLK 0x10 // Set by the user to 1 to select an external clock input on P3.4.
    #define MSPI   0x02 // Set to 1 by the user to move the SPI functionality of.
    #define XRAMEN 0x01 // XRAM Enable Bit.

SFR(SP,    0x81); // Stack Pointer.
SFR(SPH,   0xB7); // Stack pointer high.

SFR(DPL,   0x82); // Data Pointer Low.
SFR(DPH,   0x83); // Data Pointer High.
SFR(DPP,   0x84); // Data Pointer Page Byte.
SFR(DPCON, 0xA7); // Data Pointer Control SFR.

SFR(PCON, 0x87); // Power Control.
   #define SMOD   0x80 //Double UART Baud Rate.
   #define SERIPD 0x40 //I2C/SPI Power-Down Interrupt Enable.
   #define INT0PD 0x20 //INT0 Power-Down Interrupt Enable.
   #define ALEOFF 0x10 //Disable ALE Output.
   #define GF1    0x08 //General-Purpose Flag Bit.
   #define GF0    0x04 //General-Purpose Flag Bit.
   #define PD     0x02 //Power-Down Mode Enable.
   #define IDL    0x01 //Idle Mode Enable.

SFR(TCON, 0x88); // Timer/Counter Control.
    SBIT(TF1, 0x88, 7); // Timer 1 overflow flag.
    SBIT(TR1, 0x88, 6); // Timer 1 run control flag.
    SBIT(TF0, 0x88, 5); // Timer 0 overflow flag.
    SBIT(TR0, 0x88, 4); // Timer 0 run control flag.
    SBIT(IE1, 0x88, 3); // Interrupt 1 flag.
    SBIT(IT1, 0x88, 2); // Interrupt 1 type control bit.
    SBIT(IE0, 0x88, 1); // Interrupt 0 flag.
    SBIT(IT0, 0x88, 0); // Interrupt 0 type control bit.

SFR(TMOD, 0x89); // Timer/Counter Mode Control.
   #define GATE1 0x80 // External enable for timer 1.
   #define C_T1  0x40 // Timer or counter select for timer 1.
   #define M1_1  0x20 // Operation mode bit 1 for timer 1.
   #define M0_1  0x10 // Operation mode bit 0 for timer 1.
   #define GATE0 0x08 // External enable for timer 0.
   #define C_T0  0x04 // Timer or counter select for timer 0.
   #define M1_0  0x02 // Operation mode bit 1 for timer 0.
   #define M0_0  0x01 // Operation mode bit 0 for timer 0.

SFR(TL0, 0x8A); // Timer 0 LSB.
SFR(TL1, 0x8B); // Timer 1 LSB.
SFR(TH0, 0x8C); // Timer 0 MSB.
SFR(TH1, 0x8D); // Timer 1 MSB.

SFR(P0, 0x80); // Port 0
    SBIT(P0_0, 0x80, 0); // Port 0 bit 0.
    SBIT(P0_1, 0x80, 1); // Port 0 bit 1.
    SBIT(P0_2, 0x80, 2); // Port 0 bit 2.
    SBIT(P0_3, 0x80, 3); // Port 0 bit 3.
    SBIT(P0_4, 0x80, 4); // Port 0 bit 4.
    SBIT(P0_5, 0x80, 5); // Port 0 bit 5.
    SBIT(P0_6, 0x80, 6); // Port 0 bit 6.
    SBIT(P0_7, 0x80, 7); // Port 0 bit 7.

SFR(P1, 0x90); // Port 1
    SBIT(P1_0, 0x90, 0); // Port 1 bit 0.
    SBIT(P1_1, 0x90, 1); // Port 1 bit 1.
    SBIT(P1_2, 0x90, 2); // Port 1 bit 2.
    SBIT(P1_3, 0x90, 3); // Port 1 bit 3.
    SBIT(P1_4, 0x90, 4); // Port 1 bit 4.
    SBIT(P1_5, 0x90, 5); // Port 1 bit 5.
    SBIT(P1_6, 0x90, 6); // Port 1 bit 6.
    SBIT(P1_7, 0x90, 7); // Port 1 bit 7.
    // Alternate names
    SBIT(T2EX, 0x90, 1); //Capture/reload trigger for Counter 2.
    SBIT(T2,   0x90, 0); //Input to Timer/Counter 2.

SFR(P2, 0xA0); // Port 2
   SBIT(P2_0, 0xA0, 0); // Port 2 bit 0.
   SBIT(P2_1, 0xA0, 1); // Port 2 bit 1.
   SBIT(P2_2, 0xA0, 2); // Port 2 bit 2.
   SBIT(P2_3, 0xA0, 3); // Port 2 bit 3.
   SBIT(P2_4, 0xA0, 4); // Port 2 bit 4.
   SBIT(P2_5, 0xA0, 5); // Port 2 bit 5.
   SBIT(P2_6, 0xA0, 6); // Port 2 bit 6.
   SBIT(P2_7, 0xA0, 7); // Port 2 bit 7.

SFR(P3, 0xB0); // Port 3
   SBIT(P3_0, 0xB0, 0); // Port 3 bit 0.
   SBIT(P3_1, 0xB0, 1); // Port 3 bit 1.
   SBIT(P3_2, 0xB0, 2); // Port 3 bit 2.
   SBIT(P3_3, 0xB0, 3); // Port 3 bit 3.
   SBIT(P3_4, 0xB0, 4); // Port 3 bit 4.
   SBIT(P3_5, 0xB0, 5); // Port 3 bit 5.
   SBIT(P3_6, 0xB0, 6); // Port 3 bit 6.
   SBIT(P3_7, 0xB0, 7); // Port 3 bit 7.
   // Alternate names.
   SBIT(RXD,  0xB0, 0);
   SBIT(TXD,  0xB0, 1);
   SBIT(INT0, 0xB0, 2);
   SBIT(INT1, 0xB0, 3);
   SBIT(T0,   0xB0, 4);
   SBIT(T1,   0xB0, 5);
   SBIT(WR,   0xB0, 6);
   SBIT(RD,   0xB0, 7);

SFR(I2CADD,  0x9B); // I2C Address Register 1.
SFR(I2CADD1, 0x91); // I2C Address Register 2.
SFR(I2CADD2, 0x92); // I2C Address Register 3.
SFR(I2CADD3, 0x93); // I2C Address Register 4.
SFR(I2CDAT,  0x9A); // I2C Data Register.

SFR(SCON, 0x98); // Serial Port Control.
   SBIT(SM0, 0x98, 7); // Serial Port Mode Bit 0.
   SBIT(SM1, 0x98, 6); // Serial Port Mode Bit 1.
   SBIT(SM2, 0x98, 5); // Serial Port Mode Bit 2.
   SBIT(REN, 0x98, 4); // Enables serial reception.
   SBIT(TB8, 0x98, 3); // The 9th data bit that will be transmitted in Modes 2 and 3.
   SBIT(RB8, 0x98, 2); // In Modes 2 and 3, the 9th data bit that was received.
   SBIT(TI,  0x98, 1); // Transmit interrupt flag.
   SBIT(RI,  0x98, 0); // Receive interrupt flag.

SFR(SBUF, 0x99); // Serial Data Buffer.

//For these two, you may want to check page 68 of the datasheet...
SFR(T3FD,  0x9D);       // Fractional divider ratio.
SFR(T3CON, 0x9E);       // T3CON is the baud rate control SFR, allowing Timer 3 to be
                        // used to set up the UART baud rate, and setting up the binary
                        // divider (DIV).
#define T3BAUDEN 0x80   // T3 UART BAUD Enable.
#define DIV2 0x04       // Binary Divider Factor bit 3.
#define DIV1 0x02       // Binary Divider Factor bit 2.
#define DIV0 0x01       // Binary Divider Factor bit 1.

SFR(TIMECON, 0xA1); // TIC Control Register.
    #define TFH  0x40 // Twenty-Four Hour Select Bit.
    #define ITS1 0x20 // Interval Timebase Selection Bit 1.
    #define ITS0 0x10 // Interval Timebase Selection Bit 1.
    #define STI  0x08 // Single Time Interval Bit.
    #define TII  0x04 // TIC Interrupt Bit.
    #define TIEN 0x02 // Time Interval Enable Bit.
    #define TCEN 0x01 // Time Clock Enable Bit.

SFR(HTHSEC, 0xA2); // Hundredths Seconds Time Register.
SFR(SEC,    0xA3); // Seconds Time Register.
SFR(MIN,    0xA4); // Minutes Time Register.
SFR(HOUR,   0xA5); // Hours Time Register.
SFR(INTVAL, 0xA6); // User Time Interval Select Register.

SFR(IE,  0xA8); // Interrupt Enable.
   SBIT(EA,   0xA8, 7); // Global Interrupt Enable.
   SBIT(EADC, 0xA8, 6); // ADC Interrupt Enable.
   SBIT(ET2,  0xA8, 5); // Timer 2 Interrupt Enable.
   SBIT(ES,   0xA8, 4); // Serial Interrupt Enable.
   SBIT(ET1,  0xA8, 3); // Timer 1 Interrupt Enable.
   SBIT(EX1,  0xA8, 2); // External 1 Interrupt Enable.
   SBIT(ET0,  0xA8, 1); // Timer 0 Interrupt Enable.
   SBIT(EX0,  0xA8, 0); // External 0 Interrupt Enable.

SFR(IEIP2, 0xA9); // Secondary Interrupt Enable Register
    #define PTI   0x40 // Priority for time interval interrupt.
    #define PPSM  0x20 // Priority for power supply monitor interrupt.
    #define PSI2  0x10 // Priority for SPI/I2C interrupt. Same name as bit in IP???
    #define ETI   0x04 // Enable time interval counter interrupts.
    #define EPSMI 0x02 // Enable power supply monitor interrupts.
    #define ESI   0x01 // Enable SPI or I2C serial port interrupts.

SFR(PWMCON, 0xAE); //PWM control.
    #define SNGL  0x80 // Turns off PMW output at P2.6 or P3.4.
    #define MD2   0x40 // PWM Mode Bit 2.
    #define MD1   0x20 // PWM Mode Bit 2.
    #define MD0   0x10 // PWM Mode Bit 2.
    #define CDIV1 0x08 // PWM Clock Divider bit 1.
    #define CDIV0 0x04 // PWM Clock Divider bit 1.
    #define CSEL1 0x02 // PWM Clock Select bit 1. (Typo in datasheet???)
    #define CSEL0 0x01 // PWM Clock Select bit 0.

SFR(PWM0L, 0xB1); // PWM 0 duty cycle low.
SFR(PWM0H, 0xB2); // PWM 0 duty cycle high.
SFR(PWM1L, 0xB3); // PWM 1 duty cycle low.
SFR(PWM1H, 0xB4); // PWM 1 duty cycle high.

SFR(IP,  0xB8); // Interrupt Priority Reg.
   SBIT(PSI,  0xB8, 7); // Priority for SPI/I2C interrupt.
   SBIT(PADC, 0xB8, 6); // ADC interrupt priority bit.
   SBIT(PT2,  0xB8, 5); // Timer 2 interrupt priority bit.
   SBIT(PS,   0xB8, 4); // Serial Port interrupt priority bit.
   SBIT(PT1,  0xB8, 3); // Timer 1 interrupt priority bit.
   SBIT(PX1,  0xB8, 2); // External interrupt 1 priority bit.
   SBIT(PT0,  0xB8, 1); // Timer 0 interrupt priority bit.
   SBIT(PX0,  0xB8, 0); // External interrupt 0 priority bit.

SFR(ECON,   0xB9); // Flash/EE Memory Control SFR.
SFR(EDATA1, 0xBC); // EE page data byte 1.
SFR(EDATA2, 0xBD); // EE page data byte 2.
SFR(EDATA3, 0xBE); // EE page data byte 3.
SFR(EDATA4, 0xBF); // EE page data byte 4.
SFR(EADRL,  0xC6); // EE address low.
SFR(EADRH,  0xC7); // EE address high.

SFR(WDCON, 0xC0); //Watchdog Timer Control Register.
    SBIT(PRE3, 0xc0, 7); // Timeout period bit 4.
    SBIT(PRE2, 0xc0, 6); // Timeout period bit 3.
    SBIT(PRE1, 0xc0, 5); // Timeout period bit 2.
    SBIT(PRE0, 0xc0, 4); // Timeout period bit 1.
    SBIT(WDIR, 0xc0, 3); // Watchdog Interrupt Response Enable Bit.
    SBIT(WDS,  0xc0, 2); // Watchdog Status Bit.
    SBIT(WDE,  0xc0, 1); // Watchdog Enable Bit.
    SBIT(WDWR, 0xc0, 0); // Watchdog Write Enable Bit.

SFR(CHIPID, 0xC2); // System Self-Identification? WARNING: No description in the datasheet.

SFR(T2CON, 0xC8); // Timer / Counter 2 Control.
   SBIT(TF2,   0xC8, 7); // Timer 2 overflow flag.
   SBIT(EXF2,  0xC8, 6); // Timer 2 external flag.
   SBIT(RCLK,  0xC8, 5); // Receive clock flag.
   SBIT(TCLK,  0xC8, 4); // Transmit clock flag.
   SBIT(EXEN2, 0xC8, 3); // Timer 2 external enable flag.
   SBIT(TR2,   0xC8, 2); // Start/stop control for timer 2.
   SBIT(CNT2,  0xC8, 1); // Timer or coutner select.
   SBIT(CAP2,  0xC8, 0); // Capture/reload flag.

SFR(RCAP2L, 0xCA); // Timer 2 Capture LSB.
SFR(RCAP2H, 0xCB); // Timer 2 Capture MSB.
SFR(TL2,    0xCC); // Timer 2 LSB.
SFR(TH2,    0xCD); // Timer 2 MSB.

SFR(PSW, 0xD0); // Program Status Word.
   SBIT(CY,  0xD0, 7); // Carry Flag.
   SBIT(AC,  0xD0, 6); // Auxiliary Carry Flag.
   SBIT(F0,  0xD0, 5); // User-Defined Flag.
   SBIT(RS1, 0xD0, 4); // Register Bank Select 1.
   SBIT(RS0, 0xD0, 3); // Register Bank Select 0.
   SBIT(OV,  0xD0, 2); // Overflow Flag.
   SBIT(F1,  0xD0, 1); // User-Defined Flag.
   SBIT(P,   0xD0, 0); // Parity Flag.

SFR(DMAL,   0xD2); // DMA mode address pointer low.
SFR(DMAH,   0xD3); // DMA mode address pointer high.
SFR(DMAP,   0xD4); // DMA mode address pointer page. (?)
SFR(PLLCON, 0xD7); // PLL Control Register.

SFR(PSMCON, 0xDF); // Power supply monitor.
    #define CMPD  0x40 // DVDD Comparator Bit.
    #define PSMI  0x20 // Power Supply Monitor Interrupt Bit.
    #define TPD1  0x10 // DVDD Trip Point Selection Bit 2.
    #define TPD0  0x08 // DVDD Trip Point Selection Bit 1.
    #define PSMEN 0x01 // Power Supply Monitor Enable Bit.

SFR(ACC, 0xE0); // Accumulator
   SBIT(ACC_0, 0xE0, 0); // Accumulator bit 0.
   SBIT(ACC_1, 0xE0, 1); // Accumulator bit 1.
   SBIT(ACC_2, 0xE0, 2); // Accumulator bit 2.
   SBIT(ACC_3, 0xE0, 3); // Accumulator bit 3.
   SBIT(ACC_4, 0xE0, 4); // Accumulator bit 4.
   SBIT(ACC_5, 0xE0, 5); // Accumulator bit 5.
   SBIT(ACC_6, 0xE0, 6); // Accumulator bit 6.
   SBIT(ACC_7, 0xE0, 7); // Accumulator bit 7.

SFR(I2CCON, 0xE8); // I2C Control Register
    // Master mode
    SBIT(MDO,    0xE8, 7); // I2C Software Master Data Output Bit.
    SBIT(MDE,    0xE8, 6); // I2C Software Master Data Output Enable Bit.
    SBIT(MCO,    0xE8, 5); // I2C Software Master Clock Output Bit.
    SBIT(MDI,    0xE8, 4); // I2C Software Master Data Input Bit.
    // Slave mode
    SBIT(I2CSI,  0xE8, 7); // I2C Stop Interrupt Enable Bit.
    SBIT(I2CGC,  0xE8, 6); // I2C General Call Status Bit.
    SBIT(I2CID1, 0xE8, 5); // I2C Interrupt Decode Bit 2.
    SBIT(I2CID0, 0xE8, 4); // I2C Interrupt Decode Bit 1.
    SBIT(I2CM,   0xE8, 3); // I2C Master/Slave Mode Bit.
    SBIT(I2CRS,  0xE8, 2); // I2C Reset Bit.
    SBIT(I2CTX,  0xE8, 1); // I2C Direction Transfer Bit.
    SBIT(I2CI,   0xE8, 0); // I2C Interrupt Bit.

SFR(B,   0xF0); // B Register
   SBIT(B_0, 0xF0, 0); // Register B bit 0.
   SBIT(B_1, 0xF0, 1); // Register B bit 1.
   SBIT(B_2, 0xF0, 2); // Register B bit 2.
   SBIT(B_3, 0xF0, 3); // Register B bit 3.
   SBIT(B_4, 0xF0, 4); // Register B bit 4.
   SBIT(B_5, 0xF0, 5); // Register B bit 5.
   SBIT(B_6, 0xF0, 6); // Register B bit 6.
   SBIT(B_7, 0xF0, 7); // Register B bit 7.

SFR(ADCCON1,  0xEF); //ADC Control SFR 1
	//WARNING: bit 7 is named MD1 in the datasheet, but that name is already used.
    #define MD      0x80 // The mode bit selects the active operating mode of the ADC.
    #define EXT_REF 0x40 // Set by the user to select an external reference.
    #define CK1     0x20 // The ADC clock divide bit 1.
    #define CK0     0x10 // The ADC clock divide bit 0.
    #define AQ1     0x08 // ADC acquisition select bit 1.
    #define AQ0     0x04 // ADC acquisition select bit 0.
    #define T2C     0x02 // The Timer 2 conversion bit.
    #define EXC     0x01 // The external trigger enable bit.

SFR(ADCCON2,  0xD8); // ADC Control SFR 2.
    SBIT(ADCI,  0xD8, 7); // ADC Interrupt Bit.
    SBIT(DMA,   0xD8, 6); // DMA Mode Enable Bit.
    SBIT(CCONV, 0xD8, 5); // Continuous Conversion Bit.
    SBIT(SCONV, 0xD8, 4); // Single Conversion Bit.
    SBIT(CS3,   0xD8, 3); // Channel Selection Bit 4.
    SBIT(CS2,   0xD8, 2); // Channel Selection Bit 3.
    SBIT(CS1,   0xD8, 1); // Channel Selection Bit 2.
    SBIT(CS0,   0xD8, 0); // Channel Selection Bit 1.

SFR(ADCCON3,  0xF5); //ADC Control SFR 3
    #define BUSY    0x80 // ADC Busy Status Bit.
    #define AVGS1   0x20 // Number of Average Selection Bit 2.
    #define AVGS0   0x10 // Number of Average Selection Bit 1.
    #define TYPICAL 0x02 // Calibration Type Select Bit.
    #define SCAL    0x01 // Start Calibration Cycle Bit.

SFR(ADCDATAL, 0xD9); // ADC Result byte low.
SFR(ADCDATAH, 0xDA); // ADC Result byte high.  WARNING: bits 4 to 7 are the ADC channel!
SFR(ADCOFSL,  0xF1); // Offset calibration coefficient byte (low).
SFR(ADCOFSH,  0xF2); // Offset calibration coefficient byte (high).
SFR(ADCGAINL, 0xF3); // Gain calibration coefficient byte (low).
SFR(ADCGAINH, 0xF4); // Gain calibration coefficient byte (high).

SFR(SPIDAT, 0xF7); // SPI Data Register.

SFR(SPICON, 0xF8); // SPI Control Register.
    SBIT(ISPI, 0xF8, 7); // SPI Interrupt Bit.
    SBIT(WCOL, 0xF8, 6); // Write Collision Error Bit.
    SBIT(SPE,  0xF8, 5); // SPI Interface Enable Bit.
    SBIT(SPIM, 0xF8, 4); // SPI Master/Slave Mode Select Bit.
    SBIT(CPOL, 0xF8, 3); // Clock Polarity Select Bit.
    SBIT(CPHA, 0xF8, 2); // Clock Phase Select Bit.
    SBIT(SPR1, 0xF8, 1); // SPI Bit Rate Select Bit 2.
    SBIT(SPR0, 0xF8, 0); // SPI Bit Rate Select Bit 1.

SFR(DAC0L,  0xF9); // DAC0 Data Low Byte.
SFR(DAC0H,  0xFA); // DAC0 Data High Byte.
SFR(DAC1L,  0xFB); // DAC1 Data Low Byte.
SFR(DAC1H,  0xFC); // DAC1 Data High Byte.
SFR(DACCON, 0xFD); // DAC Control Register.
    #define MODE 0x80 // 8/12 bit selection.
    #define RNG1 0x40 // DAC1 Range Select Bit.
    #define RNG0 0x20 // DAC0 Range Select Bit.
    #define CLR1 0x10 // DAC1 Clear Bit.
    #define CLR0 0x08 // DAC0 Clear Bit.
    #define SYNC 0x04 // DAC0/1 Update Synchronization Bit.
    #define PD1  0x02 // DAC1 Power-Down Bit.
    #define PD0  0x01 // DAC0 Power-Down Bit.

#endif //REG_ADUC84X_H
/*-------------------------------------------------------------------------
   uPSD33xx.h - Register Declarations for ST's uPSD33xx "Fast 8032 MCU with
   Programmable Logic"
   (Based on preliminary datasheet from Jan/2005 )

   Copyright (C) 2007, Jesus Calvino-Fraga / jesusc at ece.ubc.ca

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef REG_UPSD33XX_H
#define REG_UPSD33XX_H

#include <compiler.h>

//Interrupt vector numbers (see table 16 on datasheet)
#define EXT0_INTERRUPT   ((0x03-3)/8)
#define TIMER0_INTERRUPT ((0x0B-3)/8)
#define EXT1_INTERRUPT   ((0x13-3)/8)
#define TIMER1_INTERRUPT ((0x1B-3)/8)
#define UART0_INTERRUPT  ((0x23-3)/8)
#define TIMER2_INTERRUPT ((0x2B-3)/8)
#define TX2_INTERRUPT    ((0x2B-3)/8)
#define SPI_INTERRUPT    ((0x53-3)/8)
#define I2C_INTERRUPT    ((0x43-3)/8)
#define ADC_INTERRUPT    ((0x3B-3)/8)
#define PCA_INTERRUPT    ((0x5B-3)/8)
#define UART1_INTERRUPT  ((0x4B-3)/8)

SFR(SP,   0x81); // Stack Pointer.
SFR(DPL,  0x82); // Data Pointer Low.
SFR(DPH,  0x83); // Data Pointer High.

SFR(DPTC, 0x85); // Data Pointer Control Register.
SFR(DPS,  0x85); // Data Pointer Control Register alias for SDCC
    #define AT 0x40 //0:Manually Select Data Pointer / 1:Auto Toggle between DPTR0 and DPTR1
    #define DPSE0 0x01 // 0:DPTR0 Selected for use as DPTR / 1:DPTR1 Selected for use as DPTR

SFR(DPTM, 0x86); // Data Pointer Mode Register.
    #define DP1_1 0x08 // DPTR1 Mode Bit 1.
    #define DP1_0 0x04 // DPTR1 Mode Bit 0.
    #define DP0_1 0x02 // DPTR0 Mode Bit 1.
    #define DP0_0 0x01 // DPTR0 Mode Bit 0.
    // DPx_1 DPx_0
    //   0     0  : DPTRx No Change
    //   0     1  : Reserved
    //   1     0  : DPTRx Auto Increment
    //   1     1  : DPTRx Auto Decrement

SFR(PCON, 0x87); // Power Control.
    #define SMOD0  0x80 //Baud Rate Double Bit (UART0)
    #define SMOD1  0x40 //Baud Rate Double Bit (UART1)
    #define POR    0x10 //Only a power-on reset sets this bit (cold reset).
    #define RCLK1  0x08 //Receive Clock Flag (UART1)
    #define TCLK1  0x04 //Transmit Clock Flag (UART1)
    #define PD     0x02 //Power-Down Mode Enable.
    #define IDL    0x01 //Idle Mode Enable.

SFR(TCON, 0x88); // Timer/Counter Control.
    SBIT(TF1, 0x88, 7); // Timer 1 overflow flag.
    SBIT(TR1, 0x88, 6); // Timer 1 run control flag.
    SBIT(TF0, 0x88, 5); // Timer 0 overflow flag.
    SBIT(TR0, 0x88, 4); // Timer 0 run control flag.
    SBIT(IE1, 0x88, 3); // Interrupt 1 flag.
    SBIT(IT1, 0x88, 2); // Interrupt 1 type control bit.
    SBIT(IE0, 0x88, 1); // Interrupt 0 flag.
    SBIT(IT0, 0x88, 0); // Interrupt 0 type control bit.

SFR(TMOD, 0x89); // Timer/Counter Mode Control.
    #define GATE1 0x80 // External enable for timer 1.
    #define C_T1  0x40 // Timer or counter select for timer 1.
    #define M1_1  0x20 // Operation mode bit 1 for timer 1.
    #define M0_1  0x10 // Operation mode bit 0 for timer 1.
    #define GATE0 0x08 // External enable for timer 0.
    #define C_T0  0x04 // Timer or counter select for timer 0.
    #define M1_0  0x02 // Operation mode bit 1 for timer 0.
    #define M0_0  0x01 // Operation mode bit 0 for timer 0.

SFR(TL0, 0x8A); // Timer 0 LSB.
SFR(TL1, 0x8B); // Timer 1 LSB.
SFR(TH0, 0x8C); // Timer 0 MSB.
SFR(TH1, 0x8D); // Timer 1 MSB.

//For P1SFS0 and P1SFS1 SFRs details check datasheet Table 31.
SFR(P1SFS0, 0x8E); //Port 1 Special Function Select 0 Register.
    #define P1SF07 0x80
    #define P1SF06 0x40
    #define P1SF05 0x20
    #define P1SF04 0x10
    #define P1SF03 0x08
    #define P1SF02 0x04
    #define P1SF01 0x02
    #define P1SF00 0x01
SFR(P1SFS1, 0x8F); //Port 1 Special Function Select 1 Register.
    #define P1SF17 0x80
    #define P1SF16 0x40
    #define P1SF15 0x20
    #define P1SF14 0x10
    #define P1SF13 0x08
    #define P1SF12 0x04
    #define P1SF11 0x02
    #define P1SF10 0x01

SFR(P1, 0x90); // Port 1
    SBIT(P1_0, 0x90, 0); // Port 1 bit 0.
    SBIT(P1_1, 0x90, 1); // Port 1 bit 1.
    SBIT(P1_2, 0x90, 2); // Port 1 bit 2.
    SBIT(P1_3, 0x90, 3); // Port 1 bit 3.
    SBIT(P1_4, 0x90, 4); // Port 1 bit 4.
    SBIT(P1_5, 0x90, 5); // Port 1 bit 5.
    SBIT(P1_6, 0x90, 6); // Port 1 bit 6.
    SBIT(P1_7, 0x90, 7); // Port 1 bit 7.
    //Alternate names (from figure 3)
    SBIT(T2,     0x90, 0); //Input to Timer/Counter 2.
    SBIT(T2X,    0x90, 1); //Capture/reload trigger for Counter 2.
    SBIT(RXD1,   0x90, 2);
    SBIT(TXD1,   0x90, 3);
    SBIT(SPICLK, 0x90, 4);
    SBIT(SPIRXD, 0x90, 5);
    SBIT(SPITXD, 0x90, 6);
    SBIT(SPISEL, 0x90, 7);

SFR(P3SFS, 0x91); // Port 3 Special Function Select Register
    #define P3SF7 0x80
    #define P3SF6 0x40
    #define P3SF5 0x20
    #define P3SF4 0x10
    #define P3SF3 0x08
    #define P3SF2 0x04
    #define P3SF1 0x02
    #define P3SF0 0x01

//For P4SFS0 and P4SFS1 SFRs details check datasheet Table 34.
SFR(P4SFS0, 0x92); //Port 4 Special Function Select 0 Register.
    #define P4SF07 0x80
    #define P4SF06 0x40
    #define P4SF05 0x20
    #define P4SF04 0x10
    #define P4SF03 0x08
    #define P4SF02 0x04
    #define P4SF01 0x02
    #define P4SF00 0x01
SFR(P4SFS1, 0x93); //Port 4 Special Function Select 1 Register.
    #define P4SF17 0x80
    #define P4SF16 0x40
    #define P4SF15 0x20
    #define P4SF14 0x10
    #define P4SF13 0x08
    #define P4SF12 0x04
    #define P4SF11 0x02
    #define P4SF10 0x01

SFR(ADCPS, 0x94); // ADC pre-scaller?
    #define ADCCE  0x08 // ADC Conversion Reference Clock Enable.
    //ADC Reference Clock PreScaler. Only three Prescaler values are allowed:
    #define ADCPS2 0x02 // Resulting ADC clock is fOSC.
    #define ADCPS1 0x01 // Resulting ADC clock is fOSC/2.
    #define ADCPS0 0x00 // Resulting ADC clock is fOSC/4.

SFR(ADAT0, 0x95); // A/D result register (bits 0 to 7).
SFR(ADAT1, 0x96); // A/D result register (bits 8 and 9).
SFR(ACON,  0x97); // A/D control register.
    #define AINTF  0x80 // ADC Interrupt flag. This bit must be cleared with software.
    #define AINTEN 0x40 // ADC Interrupt Enable.
    #define ADEN   0x20 // ADC Enable Bit.
    #define ADS2   0x10 // Analog channel Select bit 3.
    #define ADS1   0x08 // Analog channel Select bit 2.
    #define ADS0   0x04 // Analog channel Select bit 1.
    #define ADST   0x02 // ADC Start Bit.
    #define ADSF   0x01 // ADC Status Bit.

SFR(SCON, 0x98); // For compatibity with legacy code
SFR(SCON0, 0x98); // Serial Port UART0 Control Register
    SBIT(SM0, 0x98, 7); // Serial Port Mode Bit 0.
    SBIT(SM1, 0x98, 6); // Serial Port Mode Bit 1.
    SBIT(SM2, 0x98, 5); // Serial Port Mode Bit 2.
    SBIT(REN, 0x98, 4); // Enables serial reception.
    SBIT(TB8, 0x98, 3); // The 9th data bit that will be transmitted in Modes 2 and 3.
    SBIT(RB8, 0x98, 2); // In Modes 2 and 3, the 9th data bit that was received.
    SBIT(TI,  0x98, 1); // Transmit interrupt flag.
    SBIT(RI,  0x98, 0); // Receive interrupt flag.

SFR(SBUF, 0x99);  // For compatibity with legacy code.
SFR(SBUF0, 0x99); // Serial Port UART0 Data Buffer.

SFR(BUSCON, 0x9D); // Bus Control Register.
    #define EPFQ  0x80 // Enable Pre-Fetch Queue.
    #define EBC   0x40 // Enable Branch Cache.
    #define WRW1  0x20 // WR Wait bit 2.
    #define WRW0  0x10 // WR Wait bit 1.
    #define RDW1  0x08 // RD Wait bit 2.
    #define RDW0  0x04 // RD Wait bit 1.
    #define CW1   0x02 // PSEN Wait bit 2.
    #define CW0   0x01 // PSEN Wait bit 1.

SFR(PCACL0,  0xA2); // The low 8 bits of PCA 0 16-bit counter.
SFR(PCACH0,  0xA3); // The high 8 bits of PCA 0 16-bit counter.
SFR(PCACON0, 0xA4); // PCA 0 Control Register.
SFR(PCASTA,  0xA5); // PCA 0 and PCA 1 Status Register.
SFR(PCACL1,  0xBA); // The low 8 bits of PCA 1 16-bit counter.
SFR(PCACH1,  0xBB); // The high 8 bits of PCA 1 16-bit counter.
SFR(PCACON1, 0xBC); // PCA 1 Control Register.

SFR(IEA, 0xA7); // Interrupt Enable Addition Register.
    #define EADC 0x80 // Enable ADC Interrupt.
    #define ESPI 0x40 // Enable SPI Interrupt.
    #define EPCA 0x20 // Enable Programmable Counter Array Interrupt.
    #define ES1  0x10 // Enable UART1 Interrupt.
    #define EI2C 0x02 // Enable I2C Interrupt.

SFR(IE, 0xA8); // Interrupt Enable Register.
    SBIT(EA,  0xA8, 7); // Global disable bit.
    SBIT(ET2, 0xA8, 5); // Enable Timer 2 Interrupt.
    SBIT(ES0, 0xA8, 4); // Enable UART0 Interrupt.
    SBIT(ET1, 0xA8, 3); // Enable Timer 1 Interrupt.
    SBIT(EX1, 0xA8, 2); // Enable External Interrupt INT1.
    SBIT(ET0, 0xA8, 1); // Enable Timer 0 Interrupt.
    SBIT(EX0, 0xA8, 0); // Enable External Interrupt INT0.

SFR(TCMMODE0, 0xA9); // TCM 0 Mode.
SFR(TCMMODE1, 0xAA); // TCM 1 Mode.
SFR(TCMMODE2, 0xAB); // TCM 2 Mode.
SFR(TCMMODE3, 0xBD); // TCM 3 Mode.
SFR(TCMMODE4, 0xBE); // TCM 4 Mode.
SFR(TCMMODE5, 0xBF); // TCM 5 Mode.
//These are the bits for the six SFRs above:
    #define EINTF  0x80  // Enable the interrupt flags (INTF) in the Status Register to generate an interrupt.
    #define E_COMP 0x40  // Enable the comparator when set.
    #define CAP_PE 0x20  // Enable Capture Mode, a positive edge on the CEXn pin.
    #define CAP_NE 0x20  // Enable Capture Mode, a negative edge on the CEXn pin.
    #define MATCH  0x08  // A match from the comparator sets the INTF bits in the Status Register.
    #define TOGGLE 0x04  // A match on the comparator results in a toggling output on CEXn pin.
    #define PWM1   0x02  // PWM mode bit 2.
    #define PWM0   0x01  // PWM mode bit 1.

SFR(CAPCOML0, 0xAC); // Capture/Compare register low of TCM 0.
SFR(CAPCOMH0, 0xAD); // Capture/Compare register High of TCM 0.
SFR(CAPCOML1, 0xAF); // Capture/Compare register low of TCM 1.
SFR(CAPCOMH1, 0xB1); // Capture/Compare register High of TCM 1.
SFR(CAPCOML2, 0xB2); // Capture/Compare register low of TCM 2.
SFR(CAPCOMH2, 0xB3); // Capture/Compare register High of TCM 2.
SFR(CAPCOML3, 0xC1); // Capture/Compare register low of TCM 3.
SFR(CAPCOMH3, 0xC2); // Capture/Compare register High of TCM 3.
SFR(CAPCOML4, 0xC3); // Capture/Compare register low of TCM 4.
SFR(CAPCOMH4, 0xC4); // Capture/Compare register High of TCM 4.
SFR(CAPCOML5, 0xC5); // Capture/Compare register low of TCM 5.
SFR(CAPCOMH5, 0xC6); // Capture/Compare register High of TCM 5.

SFR(IPA, 0xB7); // Interrupt Priority Addition register.
    #define PADC 0x80 // ADC Interrupt priority level.
    #define PSPI 0x40 // SPI Interrupt priority level.
    #define PPCA 0x20 // PCA Interrupt level.
    #define PS1  0x10 // UART1 Interrupt priority.
    #define PI2C 0x02 // I2C Interrupt priority level.

SFR(IP, 0xB8);  // Interrupt Priority Register.
    SBIT(PT2, 0xB8, 5); // Timer 2 Interrupt priority level.
    SBIT(PS0, 0xB8, 4); // UART0 Interrupt priority level.
    SBIT(PT1, 0xB8, 3); // Timer 1 Interrupt priority level.
    SBIT(PX1, 0xB8, 2); // External Interrupt INT1 priority level.
    SBIT(PT0, 0xB8, 1); // Timer 0 Interrupt priority level.
    SBIT(PX0, 0xB8, 0); // External Interrupt INT0 priority level.

SFR(WDTRST, 0xA6);   // Watchdog Timer Reset Counter Register.
SFR(WDTKEY, 0xAE);   //Watchdog Timer Key Register.

SFR(P3, 0xB0); // I/O Port 3 Register
    SBIT(P3_0, 0xB0, 0); // Port 3 bit 0.
    SBIT(P3_1, 0xB0, 1); // Port 3 bit 1.
    SBIT(P3_2, 0xB0, 2); // Port 3 bit 2.
    SBIT(P3_3, 0xB0, 3); // Port 3 bit 3.
    SBIT(P3_4, 0xB0, 4); // Port 3 bit 4.
    SBIT(P3_5, 0xB0, 5); // Port 3 bit 5.
    SBIT(P3_6, 0xB0, 6); // Port 3 bit 6.
    SBIT(P3_7, 0xB0, 7); // Port 3 bit 7.

SFR(P4, 0xC0); // I/O Port 4 Register
    SBIT(P4_0, 0xC0, 0); // Port 4 bit 0.
    SBIT(P4_1, 0xC0, 1); // Port 4 bit 1.
    SBIT(P4_2, 0xC0, 2); // Port 4 bit 2.
    SBIT(P4_3, 0xC0, 3); // Port 4 bit 3.
    SBIT(P4_4, 0xC0, 4); // Port 4 bit 4.
    SBIT(P4_5, 0xC0, 5); // Port 4 bit 5.
    SBIT(P4_6, 0xC0, 6); // Port 4 bit 6.
    SBIT(P4_7, 0xC0, 7); // Port 4 bit 7.

SFR(PWMF0, 0xB4); // PWM frequency register 0.
SFR(PWMF1, 0xC7); // PWM frequency register 1.

SFR(T2CON, 0xC8); // Timer / Counter 2 Control.
    SBIT(TF2,   0xC8, 7); // Timer 2 overflow flag.
    SBIT(EXF2,  0xC8, 6); // Timer 2 external flag.
    SBIT(RCLK,  0xC8, 5); // Receive clock flag.
    SBIT(TCLK,  0xC8, 4); // Transmit clock flag.
    SBIT(EXEN2, 0xC8, 3); // Timer 2 external enable flag.
    SBIT(TR2,   0xC8, 2); // Start/stop control for timer 2.
    SBIT(CNT2,  0xC8, 1); // Timer or coutner select.
    SBIT(CAP2,  0xC8, 0); // Capture/reload flag.

SFR(RCAP2L, 0xCA); // Timer 2 Capture LSB.
SFR(RCAP2H, 0xCB); // Timer 2 Capture MSB.
SFR(TL2,    0xCC); // Timer 2 LSB.
SFR(TH2,    0xCD); // Timer 2 MSB.

SFR(IRDACON, 0xCE); //IrDA control register
    #define IRDAEN 0x40 // IrDA Enable bit
    #define PULSE  0x20 // IrDA Pulse Modulation Select. 0: 1.627us, 1: 3/16 bit time pulses.
    #define CDIV4  0x10 //Specify Clock Divider bit 5.
    #define CDIV3  0x08 //Specify Clock Divider bit 4.
    #define CDIV2  0x04 //Specify Clock Divider bit 3.
    #define CDIV1  0x02 //Specify Clock Divider bit 2.
    #define CDIV0  0x01 //Specify Clock Divider bit 1.

SFR(CCON0, 0xF9); // Clock Control Register.
    #define DBGCE 0x10  // Debug Unit Breakpoint Comparator Enable.
    #define CPUAR 0x08  // Automatic MCU Clock Recovery.
    #define CPUPS2 0x04 // MCUCLK Pre-Scaler bit 3.
    #define CPUPS1 0x02 // MCUCLK Pre-Scaler bit 2.
    #define CPUPS0 0x01 // MCUCLK Pre-Scaler bit 1.

SFR(CCON2, 0xFB); // Pre-scaler value for PCA0.
    #define PCA0CE  0x10 // PCA0 Clock Enable.
    #define PCA0PS3 0x08 // PCA0 Pre-Scaler bit 4.
    #define PCA0PS2 0x04 // PCA0 Pre-Scaler bit 3.
    #define PCA0PS1 0x02 // PCA0 Pre-Scaler bit 2.
    #define PCA0PS0 0x01 // PCA0 Pre-Scaler bit 1.

SFR(CCON3, 0xFC); // Pre-scaler value for PCA1.
    #define PCA1CE  0x10 // PCA1 Clock Enable.
    #define PCA1PS3 0x08 // PCA1 Pre-Scaler bit 4.
    #define PCA1PS2 0x04 // PCA1 Pre-Scaler bit 3.
    #define PCA1PS1 0x02 // PCA1 Pre-Scaler bit 2.
    #define PCA1PS0 0x01 // PCA1 Pre-Scaler bit 1.

SFR(SPICLKD, 0xD2); // SPI Prescaler (Clock Divider) Register.
    #define DIV128 0x80
    #define DIV64  0x40
    #define DIV32  0x20
    #define DIV16  0x10
    #define DIV8   0x08
    #define DIV4   0x04

SFR(SPISTAT, 0xD3); // SPI Interface Status Register.
    #define BUSY   0x10 // SPI Busy.
    #define TEISF  0x08 // Transmission End Interrupt Source flag.
    #define RORISF 0x04 // Receive Overrun Interrupt Source flag.
    #define TISF   0x02 // Transfer Interrupt Source flag.
    #define RISF   0x01 // Receive Interrupt Source flag.

SFR(SPITDR, 0xD4); // SPI transmit data register.
SFR(SPIRDR, 0xD5); // SPI receive data register.

SFR(SPICON0, 0xD6); // SPI Control Register 0.
    #define TE    0x40 // Transmitter Enable.
    #define RE    0x20 // Receiver Enable.
    #define SPIEN 0x10 // SPI Enable.
    #define SSEL  0x08 // Slave Selection.
    #define FLSB  0x04 // First LSB.
    #define SPO   0x02 // Sampling Polarity.

SFR(SPICON1, 0xD7); // SPI Interface Control Register 1.
    #define TEIE  0x08 // Transmission End Interrupt Enable.
    #define RORIE 0x04 // Receive Overrun Interrupt Enable.
    #define TIE   0x02 // Transmission Interrupt Enable.
    #define RIE   0x01 // Reception Interrupt Enable.

SFR(SCON1, 0x98); // Serial Port Control.
    SBIT(SM0, 0x98, 7); // Serial Port Mode Bit 0.
    SBIT(SM1, 0x98, 6); // Serial Port Mode Bit 1.
    SBIT(SM2, 0x98, 5); // Serial Port Mode Bit 2.
    SBIT(REN, 0x98, 4); // Enables serial reception.
    SBIT(TB8, 0x98, 3); // The 9th data bit that will be transmitted in Modes 2 and 3.
    SBIT(RB8, 0x98, 2); // In Modes 2 and 3, the 9th data bit that was received.
    SBIT(TI,  0x98, 1); // Transmit interrupt flag.
    SBIT(RI,  0x98, 0); // Receive interrupt flag.

SFR(SBUF1, 0xD9);   // Data buffer for UART1.
SFR(S1SETUP, 0xDB); // I2C START Condition Sample Setup register.
    #define EN_SS     0x80 // Enable Sample Setup.
    #define SMPL_SET6 0x40 // Sample Setting bit 7.
    #define SMPL_SET5 0x20 // Sample Setting bit 6.
    #define SMPL_SET4 0x10 // Sample Setting bit 5.
    #define SMPL_SET3 0x08 // Sample Setting bit 4.
    #define SMPL_SET2 0x04 // Sample Setting bit 3.
    #define SMPL_SET1 0x02 // Sample Setting bit 2.
    #define SMPL_SET0 0x01 // Sample Setting bit 1.

SFR(S1CON, 0xDC); // I2C Interface Control Register.
    #define CR2  0x80 // SCL clock frequency select bit 3.
    #define ENI1 0x40 // I2C Interface Enable.
    #define STA  0x20 // START flag.
    #define STO  0x10 // STOP flag.
    #define ADDR 0x08 // Slave mode address.
    #define AA   0x04 // Assert Acknowledge enable.
    #define CR1  0x02 // SCL clock frequency select bit 2.
    #define CR0  0x01 // SCL clock frequency select bit 1.

SFR(S1STA, 0xDD); // I2C Interface Status Register.
    #define GC       0x80 // General Call flag.
    #define STOP     0x40 // STOP flag.
    #define INTR     0x20 // Interrupt flag.
    #define TX_MODE  0x10 // Transmission Mode flag.
    #define BBUSY    0x08 // Bus Busy flag.
    #define BLOST    0x04 // Bus Lost flag.
    #define ACK_RESP 0x02 // Not Acknowledge Response flag.
    #define SLV      0x01 // Slave Mode flag.

SFR(S1DAT, 0xDE); // I2C Data Shift Register.
SFR(S1ADR, 0xDF); // I2C Address Register (bit 0 not used).

SFR(PSW, 0xD0); // Program Status Word.
    SBIT(CY,  0xD0, 7); // Carry Flag.
    SBIT(AC,  0xD0, 6); // Auxiliary Carry Flag.
    SBIT(F0,  0xD0, 5); // User-Defined Flag.
    SBIT(RS1, 0xD0, 4); // Register Bank Select 1.
    SBIT(RS0, 0xD0, 3); // Register Bank Select 0.
    SBIT(OV,  0xD0, 2); // Overflow Flag.
    SBIT(P,   0xD0, 0); // Parity Flag.

SFR(A, 0xE0);
SFR(ACC, 0xE0); // Accumulator
    SBIT(ACC_0, 0xE0, 0); // Accumulator bit 0.
    SBIT(ACC_1, 0xE0, 1); // Accumulator bit 1.
    SBIT(ACC_2, 0xE0, 2); // Accumulator bit 2.
    SBIT(ACC_3, 0xE0, 3); // Accumulator bit 3.
    SBIT(ACC_4, 0xE0, 4); // Accumulator bit 4.
    SBIT(ACC_5, 0xE0, 5); // Accumulator bit 5.
    SBIT(ACC_6, 0xE0, 6); // Accumulator bit 6.
    SBIT(ACC_7, 0xE0, 7); // Accumulator bit 7.

SFR(B, 0xF0); // B Register
    SBIT(B_0, 0xF0, 0); // Register B bit 0.
    SBIT(B_1, 0xF0, 1); // Register B bit 1.
    SBIT(B_2, 0xF0, 2); // Register B bit 2.
    SBIT(B_3, 0xF0, 3); // Register B bit 3.
    SBIT(B_4, 0xF0, 4); // Register B bit 4.
    SBIT(B_5, 0xF0, 5); // Register B bit 5.
    SBIT(B_6, 0xF0, 6); // Register B bit 6.
    SBIT(B_7, 0xF0, 7); // Register B bit 7.

// PSD registers definition - by Jan Waclawek - wek at efton dot sk - May 2007
// all defines here are with PSD_ prefix to identify them as PSD-related
//
// Based on uPSD33xx datasheet (preliminary) - Jan 2005, Table 79 at pages 145/146
// and subsequent text

// requires to have PSD_CSIOP defined to the base address of the PSD IO area,
//     as defined in PSDSoftExpress or CUPS
#ifndef PSD_CSIOP
#error PSD_CSIOP has to be #define-d (before #include-ing this file) to the base address of the PSD registers area, according to csiop setting in CUPS/PSDSoftExpress
#else
                                         //  -- Port A not available on 52-pin uPSD33xx devices
SFRX(PSD_DATAIN_A,    PSD_CSIOP+0x00);   // MCU I/O Mode Port A Data In Register
                                         //   reads 0 if pin is log.0, 1 if pin is log. 1
                                         //   READ only
SFRX(PSD_DATAOUT_A,   PSD_CSIOP+0x04);   // MCU I/O Mode Port A Data Out Register 
                                         //   write 0 to set pin to log. 0, 1 to set pin to log. 1 
                                         //   read back written value
                                         //   reset default = 00
SFRX(PSD_DIRECTION_A, PSD_CSIOP+0x06);   // MCU I/O Mode Port A Direction Register 
                                         //   write 1 to set pin as output, 0 to set pin as input
                                         //   read back written value
                                         //   reset default = 00
SFRX(PSD_DRIVE_A,     PSD_CSIOP+0x08);   // Select Open Drain or High Slew Rate for port A
                                         //   PA0-PA3: write 0 to select standard push-pull CMOS output, 1 to select High Slew Rate push-pull CMOS output
                                         //   PA4-PA7: write 0 to select standard push-pull CMOS output, 1 to select Open Drain output
                                         //   reset default = 00
SFRX(PSD_CONTROL_A,   PSD_CSIOP+0x02);   // Selects MCU I/O or Latched Address Out mode for port A
                                         //   write 0 to select standard I/O pin, 1 to drive demultiplexed address signal on pin
                                         //   read back written value
                                         //   reset default = 00
SFRX(PSD_OUTENABLE_A, PSD_CSIOP+0x0C);   // Read state of Output Enable Logic on each I/O port driver of Port A
                                         //   1 - driver output is enabled, 0 - driver is off (high impedance)  
                                         //   READ only

                                         // -- for comment on individual registers, see above Port A
SFRX(PSD_DATAIN_B,    PSD_CSIOP+0x01);   // MCU I/O Mode Port B Data In Register
SFRX(PSD_DATAOUT_B,   PSD_CSIOP+0x05);   // MCU I/O Mode Port B Data Out Register 
SFRX(PSD_DIRECTION_B, PSD_CSIOP+0x07);   // MCU I/O Mode Port B Direction Register 
SFRX(PSD_DRIVE_B,     PSD_CSIOP+0x09);   // Select Open Drain or High Slew Rate for port B
                                         // PB0-PB3: standard/High Slew Rate, PB4-PB7: standard/Open Drain
SFRX(PSD_CONTROL_B,   PSD_CSIOP+0x03);   // Selects MCU I/O or Latched Address Out mode for port B
SFRX(PSD_OUTENABLE_B, PSD_CSIOP+0x0D);   // Read state of Output Enable Logic on each I/O port driver of Port B

                                         // -- for comment on individual registers, see above Port A
                                         // only pins PC2, PC3, PC4, PC7 available; other bits in registers are undefined
SFRX(PSD_DATAIN_C,    PSD_CSIOP+0x10);   // MCU I/O Mode Port C Data In Register
SFRX(PSD_DATAOUT_C,   PSD_CSIOP+0x12);   // MCU I/O Mode Port C Data Out Register 
SFRX(PSD_DIRECTION_C, PSD_CSIOP+0x14);   // MCU I/O Mode Port C Direction Register 
SFRX(PSD_DRIVE_C,     PSD_CSIOP+0x16);   // Select Open Drain for port C
SFRX(PSD_OUTENABLE_C, PSD_CSIOP+0x1A);   // Read state of Output Enable Logic on each I/O port driver of Port C

                                         // -- for comment on individual registers, see above Port A
                                         // only pins PD1, PD2 available (PD2 not available on 52-pin package); other bits in registers are undefined
SFRX(PSD_DATAIN_D,    PSD_CSIOP+0x11);   // MCU I/O Mode Port D Data In Register
SFRX(PSD_DATAOUT_D,   PSD_CSIOP+0x13);   // MCU I/O Mode Port D Data Out Register 
SFRX(PSD_DIRECTION_D, PSD_CSIOP+0x15);   // MCU I/O Mode Port D Direction Register 
SFRX(PSD_DRIVE_D,     PSD_CSIOP+0x17);   // Select High Slew Rate for port D
SFRX(PSD_OUTENABLE_D, PSD_CSIOP+0x1B);   // Read state of Output Enable Logic on each I/O port driver of Port D

SFRX(PSD_IMC_A,       PSD_CSIOP+0x0A);   // Read to obtain logic state of Input Macrocells connected to Port A
                                         //   READ only
SFRX(PSD_IMC_B,       PSD_CSIOP+0x0B);   // Read to obtain logic state of Input Macrocells connected to Port B
SFRX(PSD_IMC_C,       PSD_CSIOP+0x18);   // Read to obtain logic state of Input Macrocells connected to Port C
                                         //   only pins PC2, PC3, PC4, PC7 available; other bits in register are undefined
SFRX(PSD_OMC_AB,      PSD_CSIOP+0x20);   // Read logic state of macrocells AB. Write to load macrocell AB flip-flops.
SFRX(PSD_OMC_BC,      PSD_CSIOP+0x21);   // Read logic state of macrocells BC. Write to load macrocell BC flip-flops.
SFRX(PSD_OMCMASK_AB,  PSD_CSIOP+0x22);   // Write to set mask for macrocell AB. 
                                         //    1 blocks READs/WRITEs of OMF, 0 will pass OMF value
                                         //    Read back written value.
SFRX(PSD_OMCMASK_BC,  PSD_CSIOP+0x23);   // Write to set mask for macrocell BC.

// -- all three Power Management Register are set to 00 after PowerUp, but unchanged during reset (/RST)
SFRX(PSD_PMMR0,       PSD_CSIOP+0xB0);   // -- Power Management Register 0 - write/read
// bit 0 unused and should be set to 0
#define PSD_APD_ENA            0x02      // 0 - Automatic Power Down (APD) counter is disabled, 1 - APD enabled
// bit 2 unused and should be set to 0
#define PSD_TURBO_DISA         0x08      // 0 - PSD Turbo mode enabled, 1 - Turbo mode off, saving power
#define PSD_BLOCK_CLKIN_PLD    0x10      // 0 - CLKIN to PLD not blocked, 1 - no CLKIN to PLD Input Bus, saving power
#define PSD_BLOCK_CLKIN_OMC    0x20      // 0 - CLKIN to Output Macrocells not blocked, 1 - blocked, saving power
// bits 6 and 7 unused and should be set to 0

SFRX(PSD_PMMR2,       PSD_CSIOP+0xB4);   // -- Power Management Register 2 - write/read
// bits 0 and 1 unused and should be set to 0
#define PSD_BLOCK_WR_PLD       0x04      // 0 - /WR from 8032 to PLD Input Bus not blocked, 1 - blocked, saving power
#define PSD_BLOCK_RD_PLD       0x08      // 0 - /RD from 8032 to PLD Input Bus not blocked, 1 - blocked, saving power
#define PSD_BLOCK_PSEN_PLD     0x10      // 0 - /PSEN from 8032 to PLD Input Bus not blocked, 1 - blocked, saving power
#define PSD_BLOCK_ALE_PLD      0x20      // 0 - ALE from 8032 to PLD Input Bus not blocked, 1 - blocked, saving power
#define PSD_BLOCK_PC7_PDL      0x40      // 0 - input from Port C pin 7 to PLD Input Bus not blocked, 1 - blocked, saving power
// bit 7 unused and should be set to 0

SFRX(PSD_PMMR3,       PSD_CSIOP+0xC7);   // -- Power Management Register 3 - write/read
// bit 0 unused and should be set to 0
#define PSD_FORCE_PD           0x02      // 0 - APD counter, if enabled, will cause powerdown, 1 - powerdown will be entered immediately
                                         //   - once set, cleared only by reset condition
// bit 2 not defined by datasheet
// bits 3 to 7 unused and should be set to 0

SFRX(PSD_MAINPROTECT, PSD_CSIOP+0xC0);   // -- Main Flash Memory Protection Definition
                                         //   bit 0 to bit 7 - sector 0 to sector 7 protection status
                                         //      - 1 - flash sector write protected, 0 - not write protected
                                         //   READ only
SFRX(PSD_ALTPROTECT,  PSD_CSIOP+0xC2);   // -- Secondary Flash Memory Protection Definition
                                         //   bit 0 to bit 3 - sector 0 to sector 3 protection status
                                         //      - 1 - flash sector write protected, 0 - not write protected
                                         //   bit 7 - Security Bit
                                         //      - 1 - device is secured against external reading and writing, 0 - not secured
                                         //   READ only

SFRX(PSD_PAGE,        PSD_CSIOP+0xE0);   // -- Memory Page Register

SFRX(PSD_VM,          PSD_CSIOP+0xE2);   // -- Memory Mapping Register
                                         //   Places PSD Module memories into 8032 Program Address Space 
                                         //   and/or 8032 XDATA Address Space
                                         //   Default value of bits 0 to 4 is loaded from Non-Volatile 
                                         //   setting as specified from PSDsoft Express upon any reset 
                                         //   or power-up condition. The default value of these bits 
                                         //   can be overridden by 8032 at run-time.
#define PSD_VM_SRAM_CODE       0x01      // 0 - SRAM not accessible as CODE (/PSEN) memory, 1 - SRAM accessible as CODE memory
#define PSD_VM_ALT_CODE        0x02      // 0 - secondary FLASH not accessible as CODE (/PSEN) memory, 1 - secondary FLASH accessible as CODE memory
#define PSD_VM_MAIN_CODE       0x04      // 0 - primary FLASH not accessible as CODE (/PSEN) memory, 1 - primary FLASH accessible as CODE memory
#define PSD_VM_ALT_XDATA       0x08      // 0 - secondary FLASH not accessible as XDATA (/RD/WR) memory, 1 - secondary FLASH accessible as XDATA memory
#define PSD_VM_MAIN_XDATA      0x10      // 0 - primary FLASH not accessible as XDATA (/RD/WR) memory, 1 - primary FLASH accessible as XDATA memory
// bits 5 and 6 unused
#define PSD_VM_PIO_EN          0x80      // 0 - disable, 1- enable peripheral I/O mode on Port A

// another terminology for FLASH - MAIN/ALTERNATIVE -> PRIMARY/SECONDARY
#define PSD_VM_PRI_CODE   PSD_VM_MAIN_CODE
#define PSD_VM_SEC_CODE   PSD_VM_ALT_CODE
#define PSD_VM_PRI_XDATA  PSD_VM_MAIN_XDATA
#define PSD_VM_SEC_XDATA  PSD_VM_ALT_XDATA

#endif

#endif //REG_UPSD33XX_H
/*-------------------------------------------------------------------------
   at89s8253.h - register Declarations for ATMEL 89S8253 Processors

   Copyright (C) 2006, Krzysztof Polomka <del_p AT op.pl>
     based on at89S8252.h By - Dipl.-Ing. (FH) Michael Schmitt

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef AT89S8253_H
#define AT89S8253_H

/* BYTE addressable registers */
__sfr __at (0x80) P0          ;
__sfr __at (0x81) SP          ;
__sfr __at (0x82) DPL         ;
__sfr __at (0x82) DP0L        ; /* as called by Atmel */
__sfr __at (0x83) DPH         ;
__sfr __at (0x83) DP0H        ; /* as called by Atmel */
__sfr __at (0x84) DP1L        ; /* at89S8253 specific register */
__sfr __at (0x85) DP1H        ; /* at89S8253 specific register */
__sfr __at (0x86) SPDR        ; /* at89S8253 specific register */
__sfr __at (0x87) PCON        ;
__sfr __at (0x88) TCON        ;
__sfr __at (0x89) TMOD        ;
__sfr __at (0x8A) TL0         ;
__sfr __at (0x8B) TL1         ;
__sfr __at (0x8C) TH0         ;
__sfr __at (0x8D) TH1         ;
__sfr __at (0x8E) AUXR        ; /* at89S8253 specific register */
__sfr __at (0x8F) CLKREG      ; /* at89S8253 specific register */
__sfr __at (0x90) P1          ;
__sfr __at (0x96) EECON       ; /* at89S8253 specific register */
__sfr __at (0x98) SCON        ;
__sfr __at (0x99) SBUF        ;
__sfr __at (0xA0) P2          ;
__sfr __at (0xA6) WDTRST      ; /* at89S8253 specific register */
__sfr __at (0xA7) WDTCON      ; /* at89S8253 specific register */
__sfr __at (0xA8) IE          ;
__sfr __at (0xA9) SADDR       ; /* at89S8253 specific register */
__sfr __at (0xAA) SPSR        ; /* at89S8253 specific register */
__sfr __at (0xB0) P3          ;
__sfr __at (0xB7) IPH         ; /* at89S8253 specific register */
__sfr __at (0xB8) IP          ;
__sfr __at (0xB9) SADEN       ; /* at89S8253 specific register */
__sfr __at (0xC8) T2CON       ;
__sfr __at (0xC9) T2MOD       ;
__sfr __at (0xCA) RCAP2L      ;
__sfr __at (0xCB) RCAP2H      ;
__sfr __at (0xCC) TL2         ;
__sfr __at (0xCD) TH2         ;
__sfr __at (0xD0) PSW         ;
__sfr __at (0xD5) SPCR        ; /* at89S8253 specific register */
__sfr __at (0xE0) ACC         ;
__sfr __at (0xE0) A           ;
__sfr __at (0xF0) B           ;


/* BIT addressable registers */
/* P0 */
__sbit __at (0x80) P0_0       ;
__sbit __at (0x81) P0_1       ;
__sbit __at (0x82) P0_2       ;
__sbit __at (0x83) P0_3       ;
__sbit __at (0x84) P0_4       ;
__sbit __at (0x85) P0_5       ;
__sbit __at (0x86) P0_6       ;
__sbit __at (0x87) P0_7       ;

/* TCON */
__sbit __at (0x88) IT0        ;
__sbit __at (0x89) IE0        ;
__sbit __at (0x8A) IT1        ;
__sbit __at (0x8B) IE1        ;
__sbit __at (0x8C) TR0        ;
__sbit __at (0x8D) TF0        ;
__sbit __at (0x8E) TR1        ;
__sbit __at (0x8F) TF1        ;

/* P1 */
__sbit __at (0x90) P1_0       ;
__sbit __at (0x91) P1_1       ;
__sbit __at (0x92) P1_2       ;
__sbit __at (0x93) P1_3       ;
__sbit __at (0x94) P1_4       ;
__sbit __at (0x95) P1_5       ;
__sbit __at (0x96) P1_6       ;
__sbit __at (0x97) P1_7       ;

__sbit __at (0x90) T2         ;
__sbit __at (0x91) T2EX       ;

/* P1 SPI portpins */
__sbit __at (0x94) SS         ; /* SPI: SS - Slave port select input */
__sbit __at (0x95) MOSI       ; /* SPI: MOSI - Master data output, slave data input */
__sbit __at (0x96) MISO       ; /* SPI: MISO - Master data input, slave data output */
__sbit __at (0x97) SCK        ; /* SPI: SCK - Master clock output, slave clock input */


/* SCON */
__sbit __at (0x98) RI         ;
__sbit __at (0x99) TI         ;
__sbit __at (0x9A) RB8        ;
__sbit __at (0x9B) TB8        ;
__sbit __at (0x9C) REN        ;
__sbit __at (0x9D) SM2        ;
__sbit __at (0x9E) SM1        ;
__sbit __at (0x9F) SM0        ;

/* P2 */
__sbit __at (0xA0) P2_0       ;
__sbit __at (0xA1) P2_1       ;
__sbit __at (0xA2) P2_2       ;
__sbit __at (0xA3) P2_3       ;
__sbit __at (0xA4) P2_4       ;
__sbit __at (0xA5) P2_5       ;
__sbit __at (0xA6) P2_6       ;
__sbit __at (0xA7) P2_7       ;

/* IE */
__sbit __at (0xA8) EX0        ;
__sbit __at (0xA9) ET0        ;
__sbit __at (0xAA) EX1        ;
__sbit __at (0xAB) ET1        ;
__sbit __at (0xAC) ES         ;
__sbit __at (0xAD) ET2        ;
__sbit __at (0xAF) EA         ;

/* P3 */
__sbit __at (0xB0) P3_0       ;
__sbit __at (0xB1) P3_1       ;
__sbit __at (0xB2) P3_2       ;
__sbit __at (0xB3) P3_3       ;
__sbit __at (0xB4) P3_4       ;
__sbit __at (0xB5) P3_5       ;
__sbit __at (0xB6) P3_6       ;
__sbit __at (0xB7) P3_7       ;

__sbit __at (0xB0) RXD        ;
__sbit __at (0xB1) TXD        ;
__sbit __at (0xB2) INT0       ;
__sbit __at (0xB3) INT1       ;
__sbit __at (0xB4) T0         ;
__sbit __at (0xB5) T1         ;
__sbit __at (0xB6) WR         ;
__sbit __at (0xB7) RD         ;

/* IP */
__sbit __at (0xB8) PX0        ;
__sbit __at (0xB9) PT0        ;
__sbit __at (0xBA) PX1        ;
__sbit __at (0xBB) PT1        ;
__sbit __at (0xBC) PS         ;
__sbit __at (0xBD) PT2        ;

/* T2CON */
__sbit __at (0xC8) T2CON_0    ;
__sbit __at (0xC9) T2CON_1    ;
__sbit __at (0xCA) T2CON_2    ;
__sbit __at (0xCB) T2CON_3    ;
__sbit __at (0xCC) T2CON_4    ;
__sbit __at (0xCD) T2CON_5    ;
__sbit __at (0xCE) T2CON_6    ;
__sbit __at (0xCF) T2CON_7    ;

__sbit __at (0xC8) CP_RL2     ;
__sbit __at (0xC9) C_T2       ;
__sbit __at (0xCA) TR2        ;
__sbit __at (0xCB) EXEN2      ;
__sbit __at (0xCC) TCLK       ;
__sbit __at (0xCD) RCLK       ;
__sbit __at (0xCE) EXF2       ;
__sbit __at (0xCF) TF2        ;

/* PSW */
__sbit __at (0xD0) P          ;
__sbit __at (0xD1) FL         ;
__sbit __at (0xD2) OV         ;
__sbit __at (0xD3) RS0        ;
__sbit __at (0xD4) RS1        ;
__sbit __at (0xD5) F0         ;
__sbit __at (0xD6) AC         ;
__sbit __at (0xD7) CY         ;

/* B */
__sbit __at (0xF0) BREG_F0    ;
__sbit __at (0xF1) BREG_F1    ;
__sbit __at (0xF2) BREG_F2    ;
__sbit __at (0xF3) BREG_F3    ;
__sbit __at (0xF4) BREG_F4    ;
__sbit __at (0xF5) BREG_F5    ;
__sbit __at (0xF6) BREG_F6    ;
__sbit __at (0xF7) BREG_F7    ;


/* BIT definitions for bits that are not directly accessible */
/* PCON bits */
#define IDL             0x01
#define PD              0x02
#define GF0             0x04
#define GF1             0x08
#define SMOD            0x80

#define IDL_            0x01
#define PD_             0x02
#define GF0_            0x04
#define GF1_            0x08
#define SMOD_           0x80

/* TMOD bits */
#define M0_0            0x01
#define M1_0            0x02
#define C_T0            0x04
#define GATE0           0x08
#define M0_1            0x10
#define M1_1            0x20
#define C_T1            0x40
#define GATE1           0x80

#define M0_0_           0x01
#define M1_0_           0x02
#define C_T0_           0x04
#define GATE0_          0x08
#define M0_1_           0x10
#define M1_1_           0x20
#define C_T1_           0x40
#define GATE1_          0x80

#define T0_M0           0x01
#define T0_M1           0x02
#define T0_CT           0x04
#define T0_GATE         0x08
#define T1_M0           0x10
#define T1_M1           0x20
#define T1_CT           0x40
#define T1_GATE         0x80

#define T0_M0_          0x01
#define T0_M1_          0x02
#define T0_CT_          0x04
#define T0_GATE_        0x08
#define T1_M0_          0x10
#define T1_M1_          0x20
#define T1_CT_          0x40
#define T1_GATE_        0x80

#define T0_MASK         0x0F
#define T1_MASK         0xF0

#define T0_MASK_        0x0F
#define T1_MASK_        0xF0

/* T2MOD bits */
#define DCEN            0x01
#define T2OE            0x02

#define DCEN_           0x01
#define T2OE_           0x02

/* EECON bits */
#define EECON_WRTINH    0x01
#define EECON_RDY       0x02
#define EECON_DPS       0x04
#define EECON_EEMEN     0x08
#define EECON_EEMWE     0x10
#define EECON_EELD      0x20

/* WDTCON bits */
#define WDTCON_WDTEN    0x01
#define WDTCON_WSWRST   0x02
#define WDTCON_HWDT     0x04
#define WDTCON_DISRTO   0x08
#define WDTCON_WDIDLE   0x10
#define WDTCON_PS0      0x20
#define WDTCON_PS1      0x40
#define WDTCON_PS2      0x80

/* SPCR-SPI bits */
#define SPCR_SPR0       0x01
#define SPCR_SPR1       0x02
#define SPCR_CPHA       0x04
#define SPCR_CPOL       0x08
#define SPCR_MSTR       0x10
#define SPCR_DORD       0x20
#define SPCR_SPE        0x40
#define SPCR_SPIE       0x80

/* SPSR-SPI bits */
#define SPSR_ENH        0x01
#define SPSR_DISSO      0x02
#define SPSR_LDEN       0x20
#define SPSR_WCOL       0x40
#define SPSR_SPIF       0x80

/* SPDR-SPI bits */
#define SPDR_SPD0       0x01
#define SPDR_SPD1       0x02
#define SPDR_SPD2       0x04
#define SPDR_SPD3       0x08
#define SPDR_SPD4       0x10
#define SPDR_SPD5       0x20
#define SPDR_SPD6       0x40
#define SPDR_SPD7       0x80

/* IPH bits */
#define IPH_PX0H        0x01
#define IPH_PT0H        0x02
#define IPH_PX1H        0x04
#define IPH_PT1H        0x08
#define IPH_PSH         0x10
#define IPH_PT2H        0x20

/* Interrupt numbers: address = (number * 8) + 3 */
#define IE0_VECTOR      0       /* 0x03 external interrupt 0 */
#define EX0_VECTOR      0       /* 0x03 external interrupt 0 */
#define TF0_VECTOR      1       /* 0x0b timer 0 */
#define IE1_VECTOR      2       /* 0x13 external interrupt 1 */
#define EX1_VECTOR      2       /* 0x13 external interrupt 1 */
#define TF1_VECTOR      3       /* 0x1b timer 1 */
#define SI0_VECTOR      4       /* 0x23 serial port 0 */
#define TF2_VECTOR      5       /* 0x2B timer 2 */
#define EX2_VECTOR      5       /* 0x2B external interrupt 2 */

/* AUXR bits */
#define AUXR_DISALE          0x01
#define AUXR_INTEL_PWD_EXIT  0x02

/* CLKREG bits */
#define CLKREG_X2         0x01

/* This is one of the addons coming from Bernd Krueger-Knauber   */

/* ALE (0x8E) Bit Values */
__sfr __at (0x8E) ALE;      /* at89S8252 specific register */

/* Macro to enable and disable the toggling of the ALE-pin (EMV) */

/* Explanation : Original Intel 8051 Cores (Atmel has to use the */
/* Intel Core) have a feature that ALE is only active during     */
/* MOVX or MOVC instruction. Otherwise the ALE-Pin is weakly     */
/* pulled high. This can be used to force some external devices  */
/* into standby mode and reduced EMI noise                       */

#define ALE_OFF  ALE = ALE | 0x01
#define ALE_ON   ALE = ALE & 0xFE

#endif
/*-------------------------------------------------------------------------
   Register Declarations for the Atmel AT89C513xA Processor Range

   Copyright (C) 2010 - Anirban Brahmachari, a.brahmachari@gmail.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef AT89C5131AUM_H
#define AT89C5131AUM_H

#include <compiler.h>

SFR(P0,         0x80);      // Port 0
   SBIT(P0_0,     0x80, 0); // Port 0 bit 0
   SBIT(P0_1,     0x80, 1); // Port 0 bit 1
   SBIT(P0_2,     0x80, 2); // Port 0 bit 2
   SBIT(P0_3,     0x80, 3); // Port 0 bit 3
   SBIT(P0_4,     0x80, 4); // Port 0 bit 4
   SBIT(P0_5,     0x80, 5); // Port 0 bit 5
   SBIT(P0_6,     0x80, 6); // Port 0 bit 6
   SBIT(P0_7,     0x80, 7); // Port 0 bit 7
SFR(SP,         0x81);      // Stack Pointer ; LSB of SPX
SFR(DPL,        0x82);      // Data Pointer Low Byte
SFR(DPH,        0x83);      // Data Pointer High Byte
SFR(PCON,       0x87);      // Power Mode Control
SFR(TCON,       0x88);      // Timer Control
   SBIT(IT0,      0x88, 0); // Ext. Interrupt 0 Type Select
   SBIT(IE0,      0x88, 1); // Ext. Interrupt 0 Flag
   SBIT(IT1,      0x88, 2); // Ext. Interrupt 1 Type Select
   SBIT(IE1,      0x88, 3); // Ext. Interrupt 1 Flag
   SBIT(TR0,      0x88, 4); // Timer 0 Run Control
   SBIT(TF0,      0x88, 5); // Timer 0 Overflow Flag
   SBIT(TR1,      0x88, 6); // Timer 1 Run Control
   SBIT(TF1,      0x88, 7); // Timer 1 Overflow Flag
SFR(TMOD,       0x89);      // Timer Mode
SFR16E(TMR0,    0x8C8A);    // Timer/Counter 0 Word
   SFR(TL0,       0x8A);    // Timer/Counter 0 Low Byte
   SFR(TH0,       0x8C);    // Timer/Counter 0 High Byte
SFR16E(TMR1,    0x8D8B);    // Timer/Counter 1 Word
   SFR(TL1,       0x8B);    // Timer/Counter 1 Low Byte
   SFR(TH1,       0x8D);    // Timer/Counter 1 High Byte
SFR(AUXR,       0x8E);      // Auxiliary Register
SFR(CKCON0,     0x8F);      // Clock Control 0
SFR(P1,         0x90);      // Port 1
   SBIT(P1_0,     0x90, 0); // Port 1 bit 0
   SBIT(P1_1,     0x90, 1); // Port 1 bit 1
   SBIT(P1_2,     0x90, 2); // Port 1 bit 2
   SBIT(P1_3,     0x90, 3); // Port 1 bit 3
   SBIT(P1_4,     0x90, 4); // Port 1 bit 4
   SBIT(P1_5,     0x90, 5); // Port 1 bit 5
   SBIT(P1_6,     0x90, 6); // Port 1 bit 6
   SBIT(P1_7,     0x90, 7); // Port 1 bit 7
SFR(SSCON,      0x93);      // Synchronous Serial Control
SFR(SSCS,       0x94);      // Synchronous Serial Control-Status
SFR(SSDAT,      0x95);      // Synchronous Serial Data
SFR(SSADR,      0x96);      // Synchronous Serial Address
SFR(SCON,       0x98);      // Serial Port 0 Control
   SBIT(RI,       0x98, 0); // Receive Interrupt Flag
   SBIT(TI,       0x98, 1); // Transmit Interrupt Flag
   SBIT(RB8,      0x98, 2); // Ninth Receive Bit
   SBIT(TB8,      0x98, 3); // Ninth Transmission Bit
   SBIT(REN,      0x98, 4); // Receive Enable
   SBIT(SM2,      0x98, 5); // Multiprocessor Communication Enable
   SBIT(SM1,      0x98, 6); // Serial Port Mode 1
   SBIT(SM0,      0x98, 7); // Serial Port Mode 0
   SBIT(FE,       0x98, 7); // Framing Error
SFR(SBUF,       0x99);      // Serial Port Data Buffer
SFR(BRL,        0x9A);      // Baud Rate Reload
SFR(BDRCON,     0x9B);      // Baud Rate Control
SFR(KBLS,       0x9C);      // Keyboard Level Selector Register
SFR(KBE,        0x9D);      // Keyboard Input Enable Register
SFR(KBF,        0x9E);      // Keyboard Flag Register
SFR(P2,         0xA0);      // Port 2
   SBIT(P2_0,     0xA0, 0); // Port 2 bit 0
   SBIT(P2_1,     0xA0, 1); // Port 2 bit 1
   SBIT(P2_2,     0xA0, 2); // Port 2 bit 2
   SBIT(P2_3,     0xA0, 3); // Port 2 bit 3
   SBIT(P2_4,     0xA0, 4); // Port 2 bit 4
   SBIT(P2_5,     0xA0, 5); // Port 2 bit 5
   SBIT(P2_6,     0xA0, 6); // Port 2 bit 6
   SBIT(P2_7,     0xA0, 7); // Port 2 bit 7
SFR(AUXR1,      0xA2);      // Auxiliary Register 1
SFR(PLLCON,     0xA3);      // PLL Control
SFR(PLLDIV,     0xA4);      // PLL Divider
SFR(WDTRST,     0xA6);      // Watchdog Timer Reset
SFR(WDTPRG,     0xA7);      // Watchdog Timer Program
SFR(IE,         0xA8);      // Interrupt Enable (traditional 8051 name)
SFR(IEN0,       0xA8);      // Interrupt Enable Control 0
   SBIT(EX0,      0xA8, 0); // Enable External Interrupt 0
   SBIT(ET0,      0xA8, 1); // Enable Timer 0 Interrupt
   SBIT(EX1,      0xA8, 2); // Enable External Interrupt 1
   SBIT(ET1,      0xA8, 3); // Enable Timer 1 Interrupt
   SBIT(ES,       0xA8, 4); // Enable Serial Port Interrupt
   SBIT(ET2,      0xA8, 5); // Enable Timer 2 Interrupt
   SBIT(EC,       0xA8, 6); // Enable PCA Interrupt
   SBIT(EA,       0xA8, 7); // Global Interrupt Enable
SFR(SADDR,      0xA9);      // Slave Address
SFR(CKCON1,     0xAF);      // Clock Control 1
SFR(P3,         0xB0);      // Port 3
   SBIT(P3_0,     0xB0, 0); // Port 3 bit 0
   SBIT(P3_1,     0xB0, 1); // Port 3 bit 1
   SBIT(P3_2,     0xB0, 2); // Port 3 bit 2
   SBIT(P3_3,     0xB0, 3); // Port 3 bit 3
   SBIT(P3_4,     0xB0, 4); // Port 3 bit 4
   SBIT(P3_5,     0xB0, 5); // Port 3 bit 5
   SBIT(P3_6,     0xB0, 6); // Port 3 bit 6
   SBIT(P3_7,     0xB0, 7); // Port 3 bit 7
SFR(IEN1,       0xB1);      // Interrupt Enable Control 1
SFR(IPL1,       0xB2);      // Interrupt Priority Control Low 1
SFR(IPH1,       0xB3);      // Interrupt Priority Control High 1
SFR(IPH0,       0xB7);      // Interrupt Priority Control High 0
SFR(IPL0,       0xB8);      // Interrupt Priority Control Low 0
   SBIT(PX0L,     0xB8, 0); // External interrupt 0 Priority bit
   SBIT(PT0L,     0xB8, 1); // Timer 0 overflow interrupt Priority bit
   SBIT(PX1L,     0xB8, 2); // External interrupt 1 Priority bit
   SBIT(PT1L,     0xB8, 3); // Timer 1 overflow interrupt Priority bit
   SBIT(PSL,      0xB8, 4); // Serial port Priority bit
   SBIT(PT2L,     0xB8, 5); // Timer 2 overflow interrupt Priority bit
   SBIT(PPCL,     0xB8, 6); // PCA interrupt Priority bit
SFR(SADEN,      0xB9);      // Slave Address Mask
SFR16E(UFNUM,   0xBBBA);    // USB Frame Number Word
   SFR(UFNUML,    0xBA);    // USB Frame Number Low
   SFR(UFNUMH,    0xBB);    // USB Frame Number High
SFR(USBCON,     0xBC);      // USB Global Control
SFR(USBINT,     0xBD);      // USB Global Interrupt
SFR(USBIEN,     0xBE);      // USB Global Interrupt Enable
SFR(P4,         0xC0);      // Port 4
   SBIT(P4_0,     0xC0, 0); // Port 4 bit 0
   SBIT(P4_1,     0xC0, 1); // Port 4 bit 1
SFR(UEPIEN,     0xC2);      // USB Endpoint Interrupt Enable
SFR(SPCON,      0xC3);      // Serial Peripheral Control
SFR(SPSTA,      0xC4);      // Serial Peripheral Status-Control
SFR(SPDAT,      0xC5);      // Serial Peripheral Data
SFR(USBADDR,    0xC6);      // USB Address
SFR(UEPNUM,     0xC7);      // USB Endpoint Number
SFR(T2CON,      0xC8);      // Timer 2 Control
   SBIT(CP_RL2,   0xC8, 0); // Timer 2 Capture/Reload bit
   SBIT(C_T2,     0xC8, 1); // Timer/Counter 2 select bit
   SBIT(TR2,      0xC8, 2); // Timer 2 Run control bit
   SBIT(EXEN2,    0xC8, 3); // Timer 2 External Enable bit
   SBIT(TCLK,     0xC8, 4); // Transmit Clock bit
   SBIT(RCLK,     0xC8, 5); // Receive Clock bit
   SBIT(EXF2,     0xC8, 6); // Timer 2 External Flag
   SBIT(TF2,      0xC8, 7); // Timer 2 overflow Flag
SFR(T2MOD,      0xC9);      // Timer 2 Mode
SFR16E(RCAP2,   0xCBCA);    // Timer/Counter 2 Reload/Capture Word
   SFR(RCAP2L,    0xCA);    // Timer/Counter 2 Reload/Capture Low byte
   SFR(RCAP2H,    0xCB);    // Timer/Counter 2 Reload/Capture High byte
SFR16E(TMR2,    0xCDCC);    // Timer/Counter 2 Word
   SFR(TL2,     0xCC);      // Timer/Counter 2 Low Byte
   SFR(TH2,     0xCD);      // Timer/Counter 2 High Byte
SFR(UEPSTAX,    0xCE);      // USB Endpoint X Status
SFR(UEPDATX,    0xCF);      // USB Endpoint X FIFO Data
SFR(PSW,        0xD0);      // Program Status Word
   SBIT(P,        0xD0, 0); // Parity Flag
   SBIT(F1,       0xD0, 1); // User-Defined Flag
   SBIT(OV,       0xD0, 2); // Overflow Flag
   SBIT(RS0,      0xD0, 3); // Register Bank Select 0
   SBIT(RS1,      0xD0, 4); // Register Bank Select 1
   SBIT(F0,       0xD0, 5); // User-Defined Flag
   SBIT(AC,       0xD0, 6); // Auxiliary Carry Flag
   SBIT(CY,       0xD0, 7); // Carry Flag
SFR(FCON,       0xD1);      // Flash Control
SFR(EECON,      0xD2);      // EEPROM Contol
SFR(UEPCONX,    0xD4);      // USB Endpoint X Control
SFR(UEPRST,     0xD5);      // USB Endpoint Reset
SFR(CCON,       0xD8);      // PCA Timer/Counter Control
   SBIT(CCF0,     0xD8,0);  // PCA Module 0 interrupt flag
   SBIT(CCF1,     0xD8,1);  // PCA Module 1 interrupt flag
   SBIT(CCF2,     0xD8,2);  // PCA Module 2 interrupt flag
   SBIT(CCF3,     0xD8,3);  // PCA Module 3 interrupt flag
   SBIT(CCF4,     0xD8,4);  // PCA Module 4 interrupt flag
   SBIT(CR,       0xD8,6);  // PCA Counter Run control bit
   SBIT(CF,       0xD8,7);  // PCA Counter Overflow flag
SFR(CMOD,       0xD9);      // PCA Timer/Counter Mode
SFR(CCAPM0,     0xDA);      // PCA Timer/Counter 0 Mode
SFR(CCAPM1,     0xDB);      // PCA Timer/Counter 1 Mode
SFR(CCAPM2,     0xDC);      // PCA Timer/Counter 2 Mode
SFR(CCAPM3,     0xDD);      // PCA Timer/Counter 3 Mode
SFR(CCAPM4,     0xDE);      // PCA Timer/Counter 4 Mode
SFR(ACC,        0xE0);      // Accumulator
SFR16E(UBYCTX,  0xE3E2);    // USB Byte Counter Word
   SFR(UBYCTLX,   0xE2);    // USB Byte Counter Low
   SFR(UBYCTHX,   0xE3);    // USB Byte Counter High
SFR16E(PCA,     0xF9E9);    // PCA Timer/Counter Word
   SFR(CL,        0xE9);    // PCA Timer/Counter Low byte
   SFR(CH,        0xF9);    // PCA Timer/Counter High byte
SFR16E(CCAP0,   0xFAEA);    // PCA Compare Capture Module 0 Word
   SFR(CCAP0L,    0xEA);    // PCA Compare Capture Module 0 Low byte
   SFR(CCAP0H,    0xFA);    // PCA Compare Capture Module 0 High byte
SFR16E(CCAP1,   0xFBEB);    // PCA Compare Capture Module 1 Word
   SFR(CCAP1L,    0xEB);    // PCA Compare Capture Module 1 Low byte
   SFR(CCAP1H,    0xFB);    // PCA Compare Capture Module 1 High byte
SFR16E(CCAP2,   0xFCEC);    // PCA Compare Capture Module 2 Word
   SFR(CCAP2L,    0xEC);    // PCA Compare Capture Module 2 Low byte
   SFR(CCAP2H,    0xFC);    // PCA Compare Capture Module 2 High byte
SFR16E(CCAP3,   0xFDED);    // PCA Compare Capture Module 3 Word
   SFR(CCAP3L,    0xED);    // PCA Compare Capture Module 3 Low byte
   SFR(CCAP3H,    0xFD);    // PCA Compare Capture Module 3 High byte
SFR16E(CCAP4,   0xFEEE);    // PCA Compare Capture Module 4 Word
   SFR(CCAP4L,    0xEE);    // PCA Compare Capture Module 4 Low byte
   SFR(CCAP4H,    0xFE);    // PCA Compare Capture Module 4 High byte
SFR(B,          0xF0);      // B Register
SFR(LEDCON,     0xF1);      // LED Control
SFR(UEPINT,     0xF8);      // USB Endpoint Interrupt
   SBIT(EP0INT,   0xF8,0);  // Endpoint 0 Interrupt
   SBIT(EP1INT,   0xF8,1);  // Endpoint 1 Interrupt
   SBIT(EP2INT,   0xF8,2);  // Endpoint 2 Interrupt
   SBIT(EP3INT,   0xF8,3);  // Endpoint 3 Interrupt
   SBIT(EP4INT,   0xF8,4);  // Endpoint 4 Interrupt
   SBIT(EP5INT,   0xF8,5);  // Endpoint 5 Interrupt
   SBIT(EP6INT,   0xF8,6);  // Endpoint 6 Interrupt

/* Predefined SFR Bit Masks */

#define PCON_IDLE         0x01    /* PCON                                */
#define PCON_STOP         0x02    /* PCON                                */

/* Interrupts */
#define INT_RESET         0       // Reset
#define INT_EXT0          1       // External Interrupt 0
#define INT_TIMER0        2       // Timer0 Overflow
#define INT_EXT1          3       // External Interrupt 1
#define INT_TIMER1        4       // Timer1 Overflow
#define INT_UART0         5       // Serial Port 0
#define INT_TIMER2        6       // Timer2 Overflow
#define INT_PCA           7       // Programmable Counter Array
#define INT_KEYBOARD      8       // Keyboard on P1
#define INT_TWI           9       // Two Wire Interface
#define INT_SPI           10      // Serial Peripheral Interface
//                        11         Reserved
//                        12         Reserved
//                        13         Reserved
#define INT_USB           14      // USB events
//                        15         Reserved

#endif
/*-------------------------------------------------------------------------
   C8051T630.h - Register Declarations for the SiLabs C8051T63x Processor
   Range
 
   Copyright (C) 2008, Steven Borley, steven.borley@partnerelectronics.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef C8051T630_H
#define C8051T630_H

#include <compiler.h>

/*  BYTE Registers  */

SFR(       P0, 0x80 )  ; /* PORT 0 */
SFR(       SP, 0x81 )  ; /* STACK POINTER */
SFR(      DPL, 0x82 )  ; /* DATA POINTER - LOW BYTE */
SFR(      DPH, 0x83 )  ; /* DATA POINTER - HIGH BYTE */
SFR(    TOFFL, 0x85 )  ; /* TEMPERATURE SENSOR OFFSET - LOW BYTE */
SFR(    TOFFH, 0x86 )  ; /* TEMPERATURE SENSOR OFFSET - HIGH BYTE */
SFR(     PCON, 0x87 )  ; /* POWER CONTROL */
SFR(     TCON, 0x88 )  ; /* TIMER CONTROL */
SFR(     TMOD, 0x89 )  ; /* TIMER MODE */
SFR(      TL0, 0x8A )  ; /* TIMER 0 - LOW BYTE */
SFR(      TL1, 0x8B )  ; /* TIMER 1 - LOW BYTE */
SFR(      TH0, 0x8C )  ; /* TIMER 0 - HIGH BYTE */
SFR(      TH1, 0x8D )  ; /* TIMER 1 - HIGH BYTE */
SFR(    CKCON, 0x8E )  ; /* CLOCK CONTROL */
SFR(    PSCTL, 0x8F )  ; /* PROGRAM STORE R/W CONTROL */
SFR(       P1, 0x90 )  ; /* PORT 1 */
SFR(   TMR3CN, 0x91 )  ; /* TIMER 3 CONTROL */
SFR(  TMR3RLL, 0x92 )  ; /* TIMER 3 CAPTURE REGISTER - LOW BYTE */
SFR(  TMR3RLH, 0x93 )  ; /* TIMER 3 CAPTURE REGISTER - HIGH BYTE */
SFR(    TMR3L, 0x94 )  ; /* TIMER 3 - LOW BYTE */
SFR(    TMR3H, 0x95 )  ; /* TIMER 3 - HIGH BYTE */
SFR(    IDA0L, 0x96 )  ; /* CURRENT MODE DAC 0 - LOW BYTE */
SFR(    IDA0H, 0x97 )  ; /* CURRENT MODE DAC 0 - HIGH BYTE */
SFR(     SCON, 0x98 )  ; /* SERIAL PORT CONTROL */
SFR(    SCON0, 0x98 )  ; /* SERIAL PORT CONTROL */
SFR(     SBUF, 0x99 )  ; /* SERIAL PORT BUFFER */
SFR(    SBUF0, 0x99 )  ; /* SERIAL PORT BUFFER */
SFR(   CPT0CN, 0x9B )  ; /* COMPARATOR 0 CONTROL */
SFR(   CPT0MD, 0x9D )  ; /* COMPARATOR 0 MODE SELECTION */
SFR(   CPT0MX, 0x9F )  ; /* COMPARATOR 0 MUX SELECTION */
SFR(       P2, 0xA0 )  ; /* PORT 2 */
SFR(  SPI0CFG, 0xA1 )  ; /* SPI0 CONFIGURATION */
SFR(  SPI0CKR, 0xA2 )  ; /* SPI0 CLOCK RATE CONTROL */
SFR(  SPI0DAT, 0xA3 )  ; /* SPI0 DATA */
SFR(  P0MDOUT, 0xA4 )  ; /* PORT 0 OUTPUT MODE CONFIGURATION */
SFR(  P1MDOUT, 0xA5 )  ; /* PORT 1 OUTPUT MODE CONFIGURATION */
SFR(  P2MDOUT, 0xA6 )  ; /* PORT 2 OUTPUT MODE CONFIGURATION */
SFR(       IE, 0xA8 )  ; /* INTERRUPT ENABLE */
SFR(   CLKSEL, 0xA9 )  ; /* SYSTEM CLOCK SELECT */
SFR(   EMI0CN, 0xAA )  ; /* EXTERNAL MEMORY INTERFACE CONTROL */
SFR(   _XPAGE, 0xAA )  ; /* XDATA/PDATA PAGE */
SFR(   OSCXCN, 0xB1 )  ; /* EXTERNAL OSCILLATOR CONTROL */
SFR(   OSCICN, 0xB2 )  ; /* INTERNAL OSCILLATOR CONTROL */
SFR(   OSCICL, 0xB3 )  ; /* INTERNAL OSCILLATOR CALIBRATION */
SFR(       IP, 0xB8 )  ; /* INTERRUPT PRIORITY */
SFR(   IDA0CN, 0xB9 )  ; /* CURRENT MODE DAC 0 - CONTROL */
SFR(    AMX0P, 0xBB )  ; /* ADC 0 MUX POSITIVE CHANNEL SELECTION */
SFR(   ADC0CF, 0xBC )  ; /* ADC 0 CONFIGURATION */
SFR(    ADC0L, 0xBD )  ; /* ADC 0 DATA WORD LSB */
SFR(    ADC0H, 0xBE )  ; /* ADC 0 DATA WORD MSB */
SFR(   SMB0CN, 0xC0 )  ; /* SMBUS CONTROL */
SFR(   SMB0CF, 0xC1 )  ; /* SMBUS CONFIGURATION */
SFR(  SMB0DAT, 0xC2 )  ; /* SMBUS DATA */
SFR(  ADC0GTL, 0xC3 )  ; /* ADC 0 GREATER-THAN LOW BYTE */
SFR(  ADC0GTH, 0xC4 )  ; /* ADC 0 GREATER-THAN HIGH BYTE */
SFR(  ADC0LTL, 0xC5 )  ; /* ADC 0 LESS-THAN LOW BYTE */
SFR(  ADC0LTH, 0xC6 )  ; /* ADC 0 LESS-THAN HIGH BYTE */
SFR(   REG0CN, 0xC7 )  ; /* Voltage Regulator Control */
SFR(    T2CON, 0xC8 )  ; /* TIMER 2 CONTROL */
SFR(   TMR2CN, 0xC8 )  ; /* TIMER 2 CONTROL */
SFR(   RCAP2L, 0xCA )  ; /* TIMER 2 CAPTURE REGISTER - LOW BYTE */
SFR(  TMR2RLL, 0xCA )  ; /* TIMER 2 CAPTURE REGISTER - LOW BYTE */
SFR(   RCAP2H, 0xCB )  ; /* TIMER 2 CAPTURE REGISTER - HIGH BYTE */
SFR(  TMR2RLH, 0xCB )  ; /* TIMER 2 CAPTURE REGISTER - HIGH BYTE */
SFR(      TL2, 0xCC )  ; /* TIMER 2 - LOW BYTE */
SFR(    TMR2L, 0xCC )  ; /* TIMER 2 - LOW BYTE */
SFR(      TH2, 0xCD )  ; /* TIMER 2 - HIGH BYTE */
SFR(    TMR2H, 0xCD )  ; /* TIMER 2 - HIGH BYTE */
SFR(      PSW, 0xD0 )  ; /* PROGRAM STATUS WORD */
SFR(   REF0CN, 0xD1 )  ; /* VOLTAGE REFERENCE 0 CONTROL */
SFR(   P0SKIP, 0xD4 )  ; /* PORT 0 SKIP */
SFR(   P1SKIP, 0xD5 )  ; /* PORT 1 SKIP */
SFR(  SMB0ADR, 0xD7 )  ; /* SMBUS SLAVE ADDRESS */
SFR(   PCA0CN, 0xD8 )  ; /* PCA CONTROL */
SFR(   PCA0MD, 0xD9 )  ; /* PCA MODE */
SFR( PCA0CPM0, 0xDA )  ; /* PCA MODULE 0 MODE REGISTER */
SFR( PCA0CPM1, 0xDB )  ; /* PCA MODULE 1 MODE REGISTER */
SFR( PCA0CPM2, 0xDC )  ; /* PCA MODULE 2 MODE REGISTER */
SFR(      ACC, 0xE0 )  ; /* ACCUMULATOR */
SFR(     XBR0, 0xE1 )  ; /* PORT MUX CONFIGURATION REGISTER 0 */
SFR(     XBR1, 0xE2 )  ; /* PORT MUX CONFIGURATION REGISTER 1 */
SFR(   OSCLCN, 0xE3 )  ; /* LOW-FREQUENCY OSCILLATOR CONTROL */
SFR(   IT01CF, 0xE4 )  ; /* INT0/INT1 CONFIGURATION REGISTER */
SFR(  INT01CF, 0xE4 )  ; /* INT0/INT1 CONFIGURATION REGISTER */
SFR(     EIE1, 0xE6 )  ; /* EXTERNAL INTERRUPT ENABLE 1 */
SFR(  SMB0ADM, 0xE7 )  ; /* SMBUS SLAVE ADDRESS MASK */
SFR(   ADC0CN, 0xE8 )  ; /* ADC 0 CONTROL */
SFR( PCA0CPL1, 0xE9 )  ; /* PCA CAPTURE 1 LOW */
SFR( PCA0CPH1, 0xEA )  ; /* PCA CAPTURE 1 HIGH */
SFR( PCA0CPL2, 0xEB )  ; /* PCA CAPTURE 2 LOW */
SFR( PCA0CPH2, 0xEC )  ; /* PCA CAPTURE 2 HIGH */
SFR(    P1MAT, 0xED )  ; /* PORT 1 MATCH REGISTER */
SFR(   P1MASK, 0xEE )  ; /* PORT 1 MASK REGISTER */
SFR(   RSTSRC, 0xEF )  ; /* RESET SOURCE */
SFR(        B, 0xF0 )  ; /* B REGISTER */
SFR(   P0MODE, 0xF1 )  ; /* PORT 0 INPUT MODE CONFIGURATION */
SFR(   P0MDIN, 0xF1 )  ; /* PORT 0 INPUT MODE CONFIGURATION */
SFR(   P1MODE, 0xF2 )  ; /* PORT 1 INPUT MODE CONFIGURATION */
SFR(   P1MDIN, 0xF2 )  ; /* PORT 1 INPUT MODE CONFIGURATION */
SFR(     EIP1, 0xF6 )  ; /* EXTERNAL INTERRUPT PRIORITY REGISTER 1 */
SFR(  PCA0PWM, 0xF7 )  ; /* PCA PWM CONFIGURATION */
SFR(   SPI0CN, 0xF8 )  ; /* SPI0 CONTROL */
SFR(    PCA0L, 0xF9 )  ; /* PCA COUNTER LOW */
SFR(    PCA0H, 0xFA )  ; /* PCA COUNTER HIGH */
SFR( PCA0CPL0, 0xFB )  ; /* PCA CAPTURE 0 LOW */
SFR( PCA0CPH0, 0xFC )  ; /* PCA CAPTURE 0 HIGH */
SFR(    P0MAT, 0xFD )  ; /* PORT 0 MATCH REGISTER */
SFR(   P0MASK, 0xFE )  ; /* PORT 0 MASK REGISTER */
SFR(   VDM0CN, 0xFF )  ; /* VDD MONITOR CONTROL */


/*  WORD/DWORD Registers  */

SFR16E(     TOFF, 0x8685 )  ; /* TEMPERATURE SENSOR OFFSET WORD */
SFR16E(     TMR0, 0x8C8A )  ; /* TIMER 0 COUNTER */
SFR16E(     TMR1, 0x8D8B )  ; /* TIMER 1 COUNTER */
SFR16E(     TMR2, 0xCDCC )  ; /* TIMER 2 COUNTER */
SFR16E(    RCAP2, 0xCBCA )  ; /* TIMER 2 CAPTURE REGISTER WORD */
SFR16E(   TMR2RL, 0xCBCA )  ; /* TIMER 2 CAPTURE REGISTER WORD */
SFR16E(     TMR3, 0x9594 )  ; /* TIMER 3 COUNTER */
SFR16E(   TMR3RL, 0x9392 )  ; /* TIMER 3 CAPTURE REGISTER WORD */
SFR16E(     IDA0, 0x9796 )  ; /* CURRENT MODE DAC 0 DATA WORD */
SFR16E(     ADC0, 0xBEBD )  ; /* ADC 0 DATA WORD */
SFR16E(   ADC0GT, 0xC4C3 )  ; /* ADC 0 GREATER-THAN REGISTER WORD */
SFR16E(   ADC0LT, 0xC6C5 )  ; /* ADC 0 LESS-THAN REGISTER WORD */
SFR16E(     PCA0, 0xFAF9 )  ; /* PCA COUNTER */
SFR16E(  PCA0CP0, 0xFCFB )  ; /* PCA CAPTURE 0 WORD */
SFR16E(  PCA0CP1, 0xEAE9 )  ; /* PCA CAPTURE 1 WORD */
SFR16E(  PCA0CP2, 0xECEB )  ; /* PCA CAPTURE 2 WORD */


/*  BIT Registers  */

/*  P0  0x80 */
SBIT(     P0_0, 0x80, 0 )  ;
SBIT(     P0_1, 0x80, 1 )  ;
SBIT(     P0_2, 0x80, 2 )  ;
SBIT(     P0_3, 0x80, 3 )  ;
SBIT(     P0_4, 0x80, 4 )  ;
SBIT(     P0_5, 0x80, 5 )  ;
SBIT(     P0_6, 0x80, 6 )  ;
SBIT(     P0_7, 0x80, 7 )  ;

/*  TCON  0x88 */
SBIT(      IT0, 0x88, 0 )  ; /* TCON.0 - EXT. INTERRUPT 0 TYPE */
SBIT(      IE0, 0x88, 1 )  ; /* TCON.1 - EXT. INTERRUPT 0 EDGE FLAG */
SBIT(      IT1, 0x88, 2 )  ; /* TCON.2 - EXT. INTERRUPT 1 TYPE */
SBIT(      IE1, 0x88, 3 )  ; /* TCON.3 - EXT. INTERRUPT 1 EDGE FLAG */
SBIT(      TR0, 0x88, 4 )  ; /* TCON.4 - TIMER 0 ON/OFF CONTROL */
SBIT(      TF0, 0x88, 5 )  ; /* TCON.5 - TIMER 0 OVERFLOW FLAG */
SBIT(      TR1, 0x88, 6 )  ; /* TCON.6 - TIMER 1 ON/OFF CONTROL */
SBIT(      TF1, 0x88, 7 )  ; /* TCON.7 - TIMER 1 OVERFLOW FLAG */

/*  P1  0x90 */
SBIT(     P1_0, 0x90, 0 )  ;
SBIT(     P1_1, 0x90, 1 )  ;
SBIT(     P1_2, 0x90, 2 )  ;
SBIT(     P1_3, 0x90, 3 )  ;
SBIT(     P1_4, 0x90, 4 )  ;
SBIT(     P1_5, 0x90, 5 )  ;
SBIT(     P1_6, 0x90, 6 )  ;
SBIT(     P1_7, 0x90, 7 )  ;

/*  SCON  0x98 */
SBIT(       RI, 0x98, 0 )  ; /* SCON.0 - RECEIVE INTERRUPT FLAG */
SBIT(      RI0, 0x98, 0 )  ; /* SCON.0 - RECEIVE INTERRUPT FLAG */
SBIT(       TI, 0x98, 1 )  ; /* SCON.1 - TRANSMIT INTERRUPT FLAG */
SBIT(      TI0, 0x98, 1 )  ; /* SCON.1 - TRANSMIT INTERRUPT FLAG */
SBIT(      RB8, 0x98, 2 )  ; /* SCON.2 - RECEIVE BIT 8 */
SBIT(     RB80, 0x98, 2 )  ; /* SCON.2 - RECEIVE BIT 8 */
SBIT(      TB8, 0x98, 3 )  ; /* SCON.3 - TRANSMIT BIT 8 */
SBIT(     TB80, 0x98, 3 )  ; /* SCON.3 - TRANSMIT BIT 8 */
SBIT(      REN, 0x98, 4 )  ; /* SCON.4 - RECEIVE ENABLE */
SBIT(     REN0, 0x98, 4 )  ; /* SCON.4 - RECEIVE ENABLE */
SBIT(      SM2, 0x98, 5 )  ; /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE */
SBIT(     MCE0, 0x98, 5 )  ; /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE */
SBIT(      SM0, 0x98, 7 )  ; /* SCON.7 - SERIAL MODE CONTROL BIT 0 */
SBIT(   S0MODE, 0x98, 7 )  ; /* SCON.7 - SERIAL MODE CONTROL BIT 0 */

/*  P2  0xA0 */
SBIT(     P2_0, 0xA0, 0 )  ;
SBIT(     P2_1, 0xA0, 1 )  ;
SBIT(     P2_2, 0xA0, 2 )  ;
SBIT(     P2_3, 0xA0, 3 )  ;
SBIT(     P2_4, 0xA0, 4 )  ;
SBIT(     P2_5, 0xA0, 5 )  ;
SBIT(     P2_6, 0xA0, 6 )  ;
SBIT(     P2_7, 0xA0, 7 )  ;

/*  IE  0xA8 */
SBIT(      EX0, 0xA8, 0 )  ; /* IE.0 - EXTERNAL INTERRUPT 0 ENABLE */
SBIT(      ET0, 0xA8, 1 )  ; /* IE.1 - TIMER 0 INTERRUPT ENABLE */
SBIT(      EX1, 0xA8, 2 )  ; /* IE.2 - EXTERNAL INTERRUPT 1 ENABLE */
SBIT(      ET1, 0xA8, 3 )  ; /* IE.3 - TIMER 1 INTERRUPT ENABLE */
SBIT(       ES, 0xA8, 4 )  ; /* IE.4 - SERIAL PORT INTERRUPT ENABLE */
SBIT(      ES0, 0xA8, 4 )  ; /* IE.4 - SERIAL PORT INTERRUPT ENABLE */
SBIT(      ET2, 0xA8, 5 )  ; /* IE.5 - TIMER 2 INTERRUPT ENABLE */
SBIT(    ESPI0, 0xA8, 6 )  ; /* IE.6 - SPI0 INTERRUPT ENABLE */
SBIT(       EA, 0xA8, 7 )  ; /* IE.7 - GLOBAL INTERRUPT ENABLE */

/*  IP  0xB8 */
SBIT(      PX0, 0xB8, 0 )  ; /* IP.0 - EXTERNAL INTERRUPT 0 PRIORITY */
SBIT(      PT0, 0xB8, 1 )  ; /* IP.1 - TIMER 0 PRIORITY */
SBIT(      PX1, 0xB8, 2 )  ; /* IP.2 - EXTERNAL INTERRUPT 1 PRIORITY */
SBIT(      PT1, 0xB8, 3 )  ; /* IP.3 - TIMER 1 PRIORITY */
SBIT(       PS, 0xB8, 4 )  ; /* IP.4 - SERIAL PORT PRIORITY */
SBIT(      PS0, 0xB8, 4 )  ; /* IP.4 - SERIAL PORT PRIORITY */
SBIT(      PT2, 0xB8, 5 )  ; /* IP.5 - TIMER 2 PRIORITY */
SBIT(    PSPI0, 0xB8, 6 )  ; /* IP.6 - SPI0 PRIORITY */

/*  SMB0CN  0xC0 */
SBIT(       SI, 0xC0, 0 )  ; /* SMB0CN.0 - SMBUS 0 INTERRUPT PENDING FLAG */
SBIT(      ACK, 0xC0, 1 )  ; /* SMB0CN.1 - SMBUS 0 ACKNOWLEDGE FLAG */
SBIT(  ARBLOST, 0xC0, 2 )  ; /* SMB0CN.2 - SMBUS 0 ARBITRATION LOST INDICATOR */
SBIT(    ACKRQ, 0xC0, 3 )  ; /* SMB0CN.3 - SMBUS 0 ACKNOWLEDGE REQUEST */
SBIT(      STO, 0xC0, 4 )  ; /* SMB0CN.4 - SMBUS 0 STOP FLAG */
SBIT(      STA, 0xC0, 5 )  ; /* SMB0CN.5 - SMBUS 0 START FLAG */
SBIT(   TXMODE, 0xC0, 6 )  ; /* SMB0CN.6 - SMBUS 0 TRANSMIT MODE INDICATOR */
SBIT(   MASTER, 0xC0, 7 )  ; /* SMB0CN.7 - SMBUS 0 MASTER/SLAVE INDICATOR */

/*  TMR2CN  0xC8 */
SBIT(   T2XCLK, 0xC8, 0 )  ; /* TMR2CN.0 - TIMER 2 EXTERNAL CLOCK SELECT */
SBIT(      TR2, 0xC8, 2 )  ; /* TMR2CN.2 - TIMER 2 ON/OFF CONTROL */
SBIT(  T2SPLIT, 0xC8, 3 )  ; /* TMR2CN.3 - TIMER 2 SPLIT MODE ENABLE */
SBIT(   TF2CEN, 0xC8, 4 )  ; /* TMR2CN.4 - TIMER 2 LOW-FREQ OSC CAPTURE ENABLE*/
SBIT(   TF2LEN, 0xC8, 5 )  ; /* TMR2CN.5 - TIMER 2 LOW BYTE INTERRUPT ENABLE */
SBIT(     TF2L, 0xC8, 6 )  ; /* TMR2CN.6 - TIMER 2 LOW BYTE OVERFLOW FLAG */
SBIT(      TF2, 0xC8, 7 )  ; /* TMR2CN.7 - TIMER 2 OVERFLOW FLAG */
SBIT(     TF2H, 0xC8, 7 )  ; /* TMR2CN.7 - TIMER 2 HIGH BYTE OVERFLOW FLAG */

/*  PSW  0xD0 */
SBIT(   PARITY, 0xD0, 0 )  ; /* PSW.0 - ACCUMULATOR PARITY FLAG */
SBIT(       F1, 0xD0, 1 )  ; /* PSW.1 - FLAG 1 */
SBIT(       OV, 0xD0, 2 )  ; /* PSW.2 - OVERFLOW FLAG */
SBIT(      RS0, 0xD0, 3 )  ; /* PSW.3 - REGISTER BANK SELECT 0 */
SBIT(      RS1, 0xD0, 4 )  ; /* PSW.4 - REGISTER BANK SELECT 1 */
SBIT(       F0, 0xD0, 5 )  ; /* PSW.5 - FLAG 0 */
SBIT(       AC, 0xD0, 6 )  ; /* PSW.6 - AUXILIARY CARRY FLAG */
SBIT(       CY, 0xD0, 7 )  ; /* PSW.7 - CARRY FLAG */

/*  PCA0CN  0xD8 */
SBIT(     CCF0, 0xD8, 0 )  ; /* PCA0CN.0 - PCA MODULE 0 CAPTURE/COMPARE FLAG */
SBIT(     CCF1, 0xD8, 1 )  ; /* PCA0CN.1 - PCA MODULE 1 CAPTURE/COMPARE FLAG */
SBIT(     CCF2, 0xD8, 2 )  ; /* PCA0CN.2 - PCA MODULE 2 CAPTURE/COMPARE FLAG */
SBIT(       CR, 0xD8, 6 )  ; /* PCA0CN.6 - PCA COUNTER/TIMER RUN CONTROL */
SBIT(       CF, 0xD8, 7 )  ; /* PCA0CN.7 - PCA COUNTER/TIMER OVERFLOW FLAG */

/*  ADC0CN  0xE8 */
SBIT(   AD0CM0, 0xE8, 0 )  ; /* ADC0CN.0 - ADC 0 START OF CONV. MODE BIT 0 */
SBIT(   AD0CM1, 0xE8, 1 )  ; /* ADC0CN.1 - ADC 0 START OF CONV. MODE BIT 1 */
SBIT(   AD0CM2, 0xE8, 2 )  ; /* ADC0CN.2 - ADC 0 START OF CONV. MODE BIT 2 */
SBIT(  AD0WINT, 0xE8, 3 )  ; /* ADC0CN.3 - ADC 0 WINDOW COMPARE INT. FLAG */
SBIT(  AD0BUSY, 0xE8, 4 )  ; /* ADC0CN.4 - ADC 0 BUSY FLAG */
SBIT(   AD0INT, 0xE8, 5 )  ; /* ADC0CN.5 - ADC 0 CONV. COMPLETE INT. FLAG */
SBIT(    AD0TM, 0xE8, 6 )  ; /* ADC0CN.6 - ADC 0 TRACK MODE */
SBIT(    AD0EN, 0xE8, 7 )  ; /* ADC0CN.7 - ADC 0 ENABLE */

/*  SPI0CN  0xF8 */
SBIT(    SPIEN, 0xF8, 0 )  ; /* SPI0CN.0 - SPI0 ENABLE */
SBIT(    TXBMT, 0xF8, 1 )  ; /* SPI0CN.1 - TRANSMIT BUFFER EMPTY */
SBIT(   NSSMD0, 0xF8, 2 )  ; /* SPI0CN.2 - SLAVE SELECT MODE BIT 0 */
SBIT(   NSSMD1, 0xF8, 3 )  ; /* SPI0CN.3 - SLAVE SELECT MODE BIT 1 */
SBIT(   RXOVRN, 0xF8, 4 )  ; /* SPI0CN.4 - RECEIVE OVERRUN FLAG */
SBIT(     MODF, 0xF8, 5 )  ; /* SPI0CN.5 - MODE FAULT FLAG */
SBIT(     WCOL, 0xF8, 6 )  ; /* SPI0CN.6 - WRITE COLLISION FLAG */
SBIT(     SPIF, 0xF8, 7 )  ; /* SPI0CN.7 - SPI0 INTERRUPT FLAG */


/* Predefined SFR Bit Masks */

#define PCON_IDLE         0x01    /* PCON                                */
#define PCON_STOP         0x02    /* PCON                                */
#define T1M               0x08    /* CKCON                               */
#define PSWE              0x01    /* PSCTL                               */
#define PSEE              0x02    /* PSCTL                               */
#define ECP0              0x20    /* EIE1                                */
#define PORSF             0x02    /* RSTSRC                              */
#define SWRSF             0x10    /* RSTSRC                              */
#define ECCF              0x01    /* PCA0CPMn                            */
#define PWM               0x02    /* PCA0CPMn                            */
#define TOG               0x04    /* PCA0CPMn                            */
#define MAT               0x08    /* PCA0CPMn                            */
#define CAPN              0x10    /* PCA0CPMn                            */
#define CAPP              0x20    /* PCA0CPMn                            */
#define ECOM              0x40    /* PCA0CPMn                            */
#define PWM16             0x80    /* PCA0CPMn                            */
#define CP0E              0x10    /* XBR0                                */
#define CP0OEN            0x10    /* XBR0                                */
#define CP0AE             0x20    /* XBR0                                */
#define CP0AOEN           0x20    /* XBR0                                */

/* Interrupts */

#define INT_EXT0          0       /* External Interrupt 0 */
#define INT_TIMER0        1       /* Timer0 Overflow */
#define INT_EXT1          2       /* External Interrupt 1 */
#define INT_TIMER1        3       /* Timer1 Overflow */
#define INT_UART0         4       /* Serial Port 0 */
#define INT_TIMER2        5       /* Timer2 Overflow */
#define INT_SPI0          6       /* Serial Peripheral Interface 0 */
#define INT_SMBUS0        7       /* SMBus0 Interface */
#define INT_PMAT          8       /* Port match */
#define INT_ADC0_WINDOW   9       /* ADC0 Window Comparison */
#define INT_ADC0_EOC      10      /* ADC0 End Of Conversion */
#define INT_PCA0          11      /* PCA0 Peripheral */
#define INT_COMPARATOR0   12      /* Comparator0 */
/*                        13         Reserved */
#define INT_TIMER3        14      /* Timer3 Overflow */

#endif
/*-------------------------------------------------------------------------
   p89lpc9351.h - Register Declarations for NXP  the P89LPC9351/P89LPC9361
   (Based on user manual (UM10308_3) Rev. 03  17 June 2009)

   Copyright (C) 2009, Jesus Calvino-Fraga / jesusc at ece.ubc.ca

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef REG_P89LPC9351_H
#define REG_P89LPC9351_H

#include <compiler.h>

SFR(ACC,     0xe0); // Accumulator
    SBIT(ACC_7,   0xe0, 7);
    SBIT(ACC_6,   0xe0, 6);
    SBIT(ACC_5,   0xe0, 5);
    SBIT(ACC_4,   0xe0, 4);
    SBIT(ACC_3,   0xe0, 3);
    SBIT(ACC_2,   0xe0, 2);
    SBIT(ACC_1,   0xe0, 1);
    SBIT(ACC_0,   0xe0, 0);
SFR(ADCON0,  0x8e); // A/D control register 0
    #define ENBI0    0x80
    #define ENADCI0  0x40
    #define TMM0     0x20
    #define EDGE0    0x10
    #define ADCI0    0x08
    #define ENADC0   0x04
    #define ADCS01   0x02
    #define ADCS00   0x01
SFR(ADCON1,  0x97); // A/D control register 1
    #define ENBI1    0x80
    #define ENADCI1  0x40
    #define TMM1     0x20
    #define EDGE1    0x10
    #define ADCI1    0x08
    #define ENADC1   0x04
    #define ADCS11   0x02
    #define ADCS10   0x01
SFR(ADINS,   0xa3); // A/D input select
    #define ADI13    0x80
    #define ADI12    0x40
    #define ADI11    0x20
    #define ADI10    0x10
    #define ADI03    0x08
    #define ADI02    0x04
    #define ADI01    0x02
    #define ADI00    0x01
SFR(ADMODA,  0xc0); // A/D mode register A
    SBIT(ADMODA_7, 0xc0, 7);
    SBIT(ADMODA_6, 0xc0, 6);
    SBIT(ADMODA_5, 0xc0, 5);
    SBIT(ADMODA_4, 0xc0, 4);
    SBIT(ADMODA_3, 0xc0, 3);
    SBIT(ADMODA_2, 0xc0, 2);
    SBIT(ADMODA_1, 0xc0, 1);
    SBIT(ADMODA_0, 0xc0, 0);
    SBIT(BNDI1,   0xc0, 7);
    SBIT(BURST1,  0xc0, 6);
    SBIT(SCC1,    0xc0, 5);
    SBIT(SCAN1,   0xc0, 4);
    SBIT(BNDI0,   0xc0, 3);
    SBIT(BURST0,  0xc0, 2);
    SBIT(SCC0,    0xc0, 1);
    SBIT(SCAN0,   0xc0, 0);
SFR(ADMODB,  0xa1); // A/D mode register B
    #define CLK2     0x80
    #define CLK1     0x40
    #define CLK0     0x20
    #define INBND0   0x10
    #define ENDAC1   0x08
    #define ENDAC0   0x04
    #define BSA1     0x02
    #define BSA0     0x01
SFR(AD0BH,   0xbb); // A/D_0 boundary high register
SFR(AD0BL,   0xa6); // A/D_0 boundary low register
SFR(AD0DAT0, 0xc5); // A/D_0 data register 0
SFR(AD0DAT1, 0xc6); // A/D_0 data register 1
SFR(AD0DAT2, 0xc7); // A/D_0 data register 2
SFR(AD0DAT3, 0xf4); // A/D_0 data register 3
SFR(AD1BH,   0xc4); // A/D_1 boundary high register
SFR(AD1BL,   0xbc); // A/D_1 boundary low register
SFR(AD1DAT0, 0xd5); // A/D_1 data register 0
SFR(AD1DAT1, 0xd6); // A/D_1 data register 1
SFR(AD1DAT2, 0xd7); // A/D_1 data register 2
SFR(AD1DAT3, 0xf5); // A/D_1 data register 3
SFR(AUXR1,   0xa2); // Auxiliary function register
    #define CLKLP    0x80
    #define EBRR     0x40
    #define ENT1     0x20
    #define ENT0     0x10
    #define SRST     0x08
    #define DPS      0x01
SFR(B,       0xf0); // B register
    SBIT(B_7,     0xf0, 7);
    SBIT(B_6,     0xf0, 6);
    SBIT(B_5,     0xf0, 5);
    SBIT(B_4,     0xf0, 4);
    SBIT(B_3,     0xf0, 3);
    SBIT(B_2,     0xf0, 2);
    SBIT(B_1,     0xf0, 1);
    SBIT(B_0,     0xf0, 0);
SFR(BRGR0,   0xbe); // Baud rate generator 0 rate low
SFR(BRGR1,   0xbf); // Baud rate generator 0 rate high
SFR(BRGCON,  0xbd); // Baud rate generator 0 control
    #define SBRGS    0x02
    #define BRGEN    0x01
SFR(CCCRA,   0xea); // Capture compare A control register
    #define ICECA2   0x80
    #define ICECA1   0x40
    #define ICECA0   0x20
    #define ICESA    0x10
    #define ICNFA    0x08
    #define FCOA     0x04
    #define OCMA1    0x02
    #define OCMA0    0x01
SFR(CCCRB,   0xeb); // Capture compare B control register
    #define ICECB2   0x80
    #define ICECB1   0x40
    #define ICECB0   0x20
    #define ICESB    0x10
    #define ICNFB    0x08
    #define FCOB     0x04
    #define OCMB1    0x02
    #define OCMB0    0x01
SFR(CCCRC,   0xec); // Capture compare C control register
    #define FCOC     0x04
    #define OCMC1    0x02
    #define OCMC0    0x01
SFR(CCCRD,   0xed); // Capture compare D control register
    #define FCOD     0x04
    #define OCMD1    0x02
    #define OCMD0    0x01
SFR(CMP1,    0xac); // Comparator 1 control register
    #define CE1      0x20
    #define CP1      0x10
    #define CN1      0x08
    #define OE1      0x04
    #define CO1      0x02
    #define CMF1     0x01
SFR(CMP2,    0xad); // Comparator 2 control register
    #define CE2      0x20
    #define CP2      0x10
    #define CN2      0x08
    #define OE2      0x04
    #define CO2      0x02
    #define CMF2     0x01
SFR(DEECON,  0xf1); // Data EEPROM control register
    #define EEIF     0x80
    #define HVERR    0x40
    #define ECTL1    0x20
    #define ECTL0    0x10
    #define EWERR1   0x04
    #define EWERR0   0x02
    #define EADR8    0x01
SFR(DEEDAT,  0xf2); // Data EEPROM data register
SFR(DEEADR,  0xf3); // Data EEPROM address register
SFR(DIVM,    0x95); // CPU clock divide-by-M control
SFR(DPH,     0x83); // Data pointer high
SFR(DPL,     0x82); // Data pointer low
SFR(FMADRH,  0xe7); // Program flash address high
SFR(FMADRL,  0xe6); // Program flash address low
SFR(FMCON,   0xe4); // Program flash control Read
    #define BUSY     0x80
    #define HVA      0x08
    #define HVE      0x04
    #define SV       0x02
    #define OI       0x01
    #define FMCMD_7  0x80
    #define FMCMD_6  0x40
    #define FMCMD_5  0x20
    #define FMCMD_4  0x10
    #define FMCMD_3  0x08
    #define FMCMD_2  0x04
    #define FMCMD_1  0x02
    #define FMCMD_0  0x01
SFR(FMDATA,  0xe5); // Program flash data
SFR(I2ADR,   0xdb); // I2C-bus slave address register
    #define I2ADR_6  0x80
    #define I2ADR_5  0x40
    #define I2ADR_4  0x20
    #define I2ADR_3  0x10
    #define I2ADR_2  0x08
    #define I2ADR_1  0x04
    #define I2ADR_0  0x02
    #define GC       0x01
SFR(I2CON,   0xd8); // I2C-bus control register
    SBIT(I2CON_7, 0xd8, 7);
    SBIT(I2CON_6, 0xd8, 6);
    SBIT(I2CON_5, 0xd8, 5);
    SBIT(I2CON_4, 0xd8, 4);
    SBIT(I2CON_3, 0xd8, 3);
    SBIT(I2CON_2, 0xd8, 2);
    SBIT(I2CON_1, 0xd8, 1);
    SBIT(I2CON_0, 0xd8, 0);
    SBIT(I2EN,    0xd8, 6);
    SBIT(STA,     0xd8, 5);
    SBIT(STO,     0xd8, 4);
    SBIT(SI,      0xd8, 3);
    SBIT(AA,      0xd8, 2);
    SBIT(CRSEL,   0xd8, 0);
SFR(I2DAT,   0xda); // I2C-bus data register
SFR(I2SCLH,  0xdd); // Serial clock generator/SCL duty cycle register high
SFR(I2SCLL,  0xdc); // Serial clock generator/SCL duty cycle register low
SFR(I2STAT,  0xd9); // I2C-bus status register
    #define STA_4    0x80
    #define STA_3    0x40
    #define STA_2    0x20
    #define STA_1    0x10
    #define STA_0    0x08
SFR(ICRAH,   0xab); // Input capture A register high
SFR(ICRAL,   0xaa); // Input capture A register low
SFR(ICRBH,   0xaf); // Input capture B register high
SFR(ICRBL,   0xae); // Input capture B register low
SFR(IEN0,    0xa8); // Interrupt enable 0
    SBIT(IEN0_7,  0xa8, 7);
    SBIT(IEN0_6,  0xa8, 6);
    SBIT(IEN0_5,  0xa8, 5);
    SBIT(IEN0_4,  0xa8, 4);
    SBIT(IEN0_3,  0xa8, 3);
    SBIT(IEN0_2,  0xa8, 2);
    SBIT(IEN0_1,  0xa8, 1);
    SBIT(IEN0_0,  0xa8, 0);
    SBIT(EA,      0xa8, 7);
    SBIT(EWDRT,   0xa8, 6);
    SBIT(EBO,     0xa8, 5);
    SBIT(ES,      0xa8, 4);
    SBIT(ESR,     0xa8, 4);
    SBIT(ET1,     0xa8, 3);
    SBIT(EX1,     0xa8, 2);
    SBIT(ET0,     0xa8, 1);
    SBIT(EX0,     0xa8, 0);
SFR(IEN1,    0xe8); // Interrupt enable 1
    SBIT(IEN1_7,  0xe8, 7);
    SBIT(IEN1_6,  0xe8, 6);
    SBIT(IEN1_5,  0xe8, 5);
    SBIT(IEN1_4,  0xe8, 4);
    SBIT(IEN1_3,  0xe8, 3);
    SBIT(IEN1_2,  0xe8, 2);
    SBIT(IEN1_1,  0xe8, 1);
    SBIT(IEN1_0,  0xe8, 0);
    SBIT(EADEE,   0xe8, 7);
    SBIT(EST,     0xe8, 6);
    SBIT(ECCU,    0xe8, 4);
    SBIT(ESPI,    0xe8, 3);
    SBIT(EC,      0xe8, 2);
    SBIT(EKBI,    0xe8, 1);
    SBIT(EI2C,    0xe8, 0);
SFR(IP0,     0xb8); // Interrupt priority 0
    SBIT(IP0_7,   0xb8, 7);
    SBIT(IP0_6,   0xb8, 6);
    SBIT(IP0_5,   0xb8, 5);
    SBIT(IP0_4,   0xb8, 4);
    SBIT(IP0_3,   0xb8, 3);
    SBIT(IP0_2,   0xb8, 2);
    SBIT(IP0_1,   0xb8, 1);
    SBIT(IP0_0,   0xb8, 0);
    SBIT(PWDRT,   0xb8, 6);
    SBIT(PBO,     0xb8, 5);
    SBIT(PS,      0xb8, 4);
    SBIT(PSR,     0xb8, 4);
    SBIT(PT1,     0xb8, 3);
    SBIT(PX1,     0xb8, 2);
    SBIT(PT0,     0xb8, 1);
    SBIT(PX0,     0xb8, 0);
SFR(IP0H,    0xb7); // Interrupt priority 0 high
    #define PWDRTH   0x40
    #define PBOH     0x20
    #define PSH      0x10
    #define PSRH     0x10
    #define PT1H     0x08
    #define PX1H     0x04
    #define PT0H     0x02
    #define PX0H     0x01
SFR(IP1,     0xf8); // Interrupt priority 1
    SBIT(IP1_7,   0xf8, 7);
    SBIT(IP1_6,   0xf8, 6);
    SBIT(IP1_5,   0xf8, 5);
    SBIT(IP1_4,   0xf8, 4);
    SBIT(IP1_3,   0xf8, 3);
    SBIT(IP1_2,   0xf8, 2);
    SBIT(IP1_1,   0xf8, 1);
    SBIT(IP1_0,   0xf8, 0);
    SBIT(PADEE,   0xf8, 7);
    SBIT(PST,     0xf8, 6);
    SBIT(PCCU,    0xf8, 4);
    SBIT(PSPI,    0xf8, 3);
    SBIT(PC,      0xf8, 2);
    SBIT(PKBI,    0xf8, 1);
    SBIT(PI2C,    0xf8, 0);
SFR(IP1H,    0xf7); // Interrupt priority 1 high
    #define PAEEH    0x80
    #define PSTH     0x40
    #define PCCUH    0x10
    #define PSPIH    0x08
    #define PCH      0x04
    #define PKBIH    0x02
    #define PI2CH    0x01
SFR(KBCON,   0x94); // Keypad control register
    #define PATN     0x02
    #define _SEL     0x01
SFR(KBMASK,  0x86); // Keypad interrupt mask register
SFR(KBPATN,  0x93); // Keypad pattern register
SFR(OCRAH,   0xef); // Output compare A register high
SFR(OCRAL,   0xee); // Output compare A register low
SFR(OCRBH,   0xfb); // Output compare B register high
SFR(OCRBL,   0xfa); // Output compare B register low
SFR(OCRCH,   0xfd); // Output compare C register high
SFR(OCRCL,   0xfc); // Output compare C register low
SFR(OCRDH,   0xff); // Output compare D register high
SFR(OCRDL,   0xfe); // Output compare D register low
SFR(P0,      0x80); // Port 0
    SBIT(P0_7,    0x80, 7);
    SBIT(P0_6,    0x80, 6);
    SBIT(P0_5,    0x80, 5);
    SBIT(P0_4,    0x80, 4);
    SBIT(P0_3,    0x80, 3);
    SBIT(P0_2,    0x80, 2);
    SBIT(P0_1,    0x80, 1);
    SBIT(P0_0,    0x80, 0);
    SBIT(T1,      0x80, 7);
    SBIT(KB7,     0x80, 7);
    SBIT(CMP_1,   0x80, 6);
    SBIT(KB6,     0x80, 6);
    SBIT(CMPREF,  0x80, 5);
    SBIT(KB5,     0x80, 5);
    SBIT(CIN1A,   0x80, 4);
    SBIT(KB4,     0x80, 4);
    SBIT(CIN1B,   0x80, 3);
    SBIT(KB3,     0x80, 3);
    SBIT(CIN2A,   0x80, 2);
    SBIT(KB2,     0x80, 2);
    SBIT(CIN2B,   0x80, 1);
    SBIT(KB1,     0x80, 1);
    SBIT(CMP_2,   0x80, 0);
    SBIT(KB0,     0x80, 0);
SFR(P1,      0x90); // Port 1
    SBIT(P1_7,    0x90, 7);
    SBIT(P1_6,    0x90, 6);
    SBIT(P1_5,    0x90, 5);
    SBIT(P1_4,    0x90, 4);
    SBIT(P1_3,    0x90, 3);
    SBIT(P1_2,    0x90, 2);
    SBIT(P1_1,    0x90, 1);
    SBIT(P1_0,    0x90, 0);
    SBIT(OCC,     0x90, 7);
    SBIT(OCB,     0x90, 6);
    SBIT(RST,     0x90, 5);
    SBIT(INT1,    0x90, 4);
    SBIT(INT0,    0x90, 3);
    SBIT(SDA,     0x90, 3);
    SBIT(T0,      0x90, 2);
    SBIT(SCL,     0x90, 2);
    SBIT(RXD,     0x90, 1);
    SBIT(TXD,     0x90, 0);
SFR(P2,      0xa0); // Port 2
    SBIT(P2_7,    0xa0, 7);
    SBIT(P2_6,    0xa0, 6);
    SBIT(P2_5,    0xa0, 5);
    SBIT(P2_4,    0xa0, 4);
    SBIT(P2_3,    0xa0, 3);
    SBIT(P2_2,    0xa0, 2);
    SBIT(P2_1,    0xa0, 1);
    SBIT(P2_0,    0xa0, 0);
    SBIT(ICA,     0xa0, 7);
    SBIT(OCA,     0xa0, 6);
    SBIT(SPICLK,  0xa0, 5);
    SBIT(SS,      0xa0, 4);
    SBIT(MISO,    0xa0, 3);
    SBIT(MOSI,    0xa0, 2);
    SBIT(OCD,     0xa0, 1);
    SBIT(ICB,     0xa0, 0);
SFR(P3,      0xb0); // Port 3
    SBIT(P3_7,    0xb0, 7);
    SBIT(P3_6,    0xb0, 6);
    SBIT(P3_5,    0xb0, 5);
    SBIT(P3_4,    0xb0, 4);
    SBIT(P3_3,    0xb0, 3);
    SBIT(P3_2,    0xb0, 2);
    SBIT(P3_1,    0xb0, 1);
    SBIT(P3_0,    0xb0, 0);
    SBIT(XTAL1,   0xb0, 1);
    SBIT(XTAL2,   0xb0, 0);
SFR(P0M1,    0x84); // Port 0 output mode 1
    #define P0M1_7   0x80
    #define P0M1_6   0x40
    #define P0M1_5   0x20
    #define P0M1_4   0x10
    #define P0M1_3   0x08
    #define P0M1_2   0x04
    #define P0M1_1   0x02
    #define P0M1_0   0x01
SFR(P0M2,    0x85); // Port 0 output mode 2
    #define P0M2_7   0x80
    #define P0M2_6   0x40
    #define P0M2_5   0x20
    #define P0M2_4   0x10
    #define P0M2_3   0x08
    #define P0M2_2   0x04
    #define P0M2_1   0x02
    #define P0M2_0   0x01
SFR(P1M1,    0x91); // Port 1 output mode 1
    #define P1M1_7   0x80
    #define P1M1_6   0x40
    #define P1M1_4   0x10
    #define P1M1_3   0x08
    #define P1M1_2   0x04
    #define P1M1_1   0x02
    #define P1M1_0   0x01
SFR(P1M2,    0x92); // Port 1 output mode 2
    #define P1M2_7   0x80
    #define P1M2_6   0x40
    #define P1M2_4   0x10
    #define P1M2_3   0x08
    #define P1M2_2   0x04
    #define P1M2_1   0x02
    #define P1M2_0   0x01
SFR(P2M1,    0xa4); // Port 2 output mode 1
    #define P2M1_7   0x80
    #define P2M1_6   0x40
    #define P2M1_5   0x20
    #define P2M1_4   0x10
    #define P2M1_3   0x08
    #define P2M1_2   0x04
    #define P2M1_1   0x02
    #define P2M1_0   0x01
SFR(P2M2,    0xa5); // Port 2 output mode 2
    #define P2M2_7   0x80
    #define P2M2_6   0x40
    #define P2M2_5   0x20
    #define P2M2_4   0x10
    #define P2M2_3   0x08
    #define P2M2_2   0x04
    #define P2M2_1   0x02
    #define P2M2_0   0x01
SFR(P3M1,    0xb1); // Port 3 output mode 1
    #define P3M1_1   0x02
    #define P3M1_0   0x01
SFR(P3M2,    0xb2); // Port 3 output mode 2
    #define P3M2_1   0x02
    #define P3M2_0   0x01
SFR(PCON,    0x87); // Power control register
    #define SMOD1    0x80
    #define SMOD0    0x40
    #define BOI      0x10
    #define GF1      0x08
    #define GF0      0x04
    #define PMOD1    0x02
    #define PMOD0    0x01
SFR(PCONA,   0xb5); // Power control register A
    #define RTCPD    0x80
    #define DEEPD    0x40
    #define VCPD     0x20
    #define ADPD     0x10
    #define I2PD     0x08
    #define SPPD     0x04
    #define SPD      0x02
    #define CCUPD    0x01
SFR(PSW,     0xd0); // Program status word
    SBIT(PSW_7,   0xd0, 7);
    SBIT(PSW_6,   0xd0, 6);
    SBIT(PSW_5,   0xd0, 5);
    SBIT(PSW_4,   0xd0, 4);
    SBIT(PSW_3,   0xd0, 3);
    SBIT(PSW_2,   0xd0, 2);
    SBIT(PSW_1,   0xd0, 1);
    SBIT(PSW_0,   0xd0, 0);
    SBIT(CY,      0xd0, 7);
    SBIT(AC,      0xd0, 6);
    SBIT(F0,      0xd0, 5);
    SBIT(RS1,     0xd0, 4);
    SBIT(RS0,     0xd0, 3);
    SBIT(OV,      0xd0, 2);
    SBIT(F1,      0xd0, 1);
    SBIT(P,       0xd0, 0);
SFR(PT0AD,   0xf6); // Port 0 digital input disable
    #define PT0AD_5  0x20
    #define PT0AD_4  0x10
    #define PT0AD_3  0x08
    #define PT0AD_2  0x04
    #define PT0AD_1  0x02
SFR(RSTSRC,  0xdf); // Reset source register
    #define BOIF     0x40
    #define BOF      0x20
    #define POF      0x10
    #define R_BK     0x08
    #define R_WD     0x04
    #define R_SF     0x02
    #define R_EX     0x01
SFR(RTCCON,  0xd1); // RTC control
    #define RTCF     0x80
    #define RTCS1    0x40
    #define RTCS0    0x20
    #define ERTC     0x02
    #define RTCEN    0x01
SFR(RTCH,    0xd2); // RTC register high
SFR(RTCL,    0xd3); // RTC register low
SFR(SADDR,   0xa9); // Serial port address register
SFR(SADEN,   0xb9); // Serial port address enable
SFR(SBUF,    0x99); // Serial Port data buffer register
SFR(SCON,    0x98); // Serial port control
    SBIT(SCON_7,  0x98, 7);
    SBIT(SCON_6,  0x98, 6);
    SBIT(SCON_5,  0x98, 5);
    SBIT(SCON_4,  0x98, 4);
    SBIT(SCON_3,  0x98, 3);
    SBIT(SCON_2,  0x98, 2);
    SBIT(SCON_1,  0x98, 1);
    SBIT(SCON_0,  0x98, 0);
    SBIT(SM0,     0x98, 7);
    SBIT(FE,      0x98, 7);
    SBIT(SM1,     0x98, 6);
    SBIT(SM2,     0x98, 5);
    SBIT(REN,     0x98, 4);
    SBIT(TB8,     0x98, 3);
    SBIT(RB8,     0x98, 2);
    SBIT(TI,      0x98, 1);
    SBIT(RI,      0x98, 0);
SFR(SSTAT,   0xba); // Serial port extended status register
    #define DBMOD    0x80
    #define INTLO    0x40
    #define CIDIS    0x20
    #define DBISEL   0x10
    #define FE       0x08
    #define BR       0x04
    #define OE       0x02
    #define STINT    0x01
SFR(SP,      0x81); // Stack pointer
SFR(SPCTL,   0xe2); // SPI control register
    #define SSIG     0x80
    #define SPEN     0x40
    #define DORD     0x20
    #define MSTR     0x10
    #define CPOL     0x08
    #define CPHA     0x04
    #define SPR1     0x02
    #define SPR0     0x01
SFR(SPSTAT,  0xe1); // SPI status register
    #define SPIF     0x80
    #define WCOL     0x40
SFR(SPDAT,   0xe3); // SPI data register
SFR(TAMOD,   0x8f); // Timer 0 and 1 auxiliary mode
    #define T1M2     0x10
    #define T0M2     0x01
SFR(TCON,    0x88); // Timer 0 and 1 control
    SBIT(TCON_7,  0x88, 7);
    SBIT(TCON_6,  0x88, 6);
    SBIT(TCON_5,  0x88, 5);
    SBIT(TCON_4,  0x88, 4);
    SBIT(TCON_3,  0x88, 3);
    SBIT(TCON_2,  0x88, 2);
    SBIT(TCON_1,  0x88, 1);
    SBIT(TCON_0,  0x88, 0);
    SBIT(TF1,     0x88, 7);
    SBIT(TR1,     0x88, 6);
    SBIT(TF0,     0x88, 5);
    SBIT(TR0,     0x88, 4);
    SBIT(IE1,     0x88, 3);
    SBIT(IT1,     0x88, 2);
    SBIT(IE0,     0x88, 1);
    SBIT(IT0,     0x88, 0);
SFR(TCR20,   0xc8); // CCU control register 0
    SBIT(TCR20_7, 0xc8, 7);
    SBIT(TCR20_6, 0xc8, 6);
    SBIT(TCR20_5, 0xc8, 5);
    SBIT(TCR20_4, 0xc8, 4);
    SBIT(TCR20_3, 0xc8, 3);
    SBIT(TCR20_2, 0xc8, 2);
    SBIT(TCR20_1, 0xc8, 1);
    SBIT(TCR20_0, 0xc8, 0);
    SBIT(PLEEN,   0xc8, 7);
    SBIT(HLTRN,   0xc8, 6);
    SBIT(HLTEN,   0xc8, 5);
    SBIT(ALTCD,   0xc8, 4);
    SBIT(ALTAB,   0xc8, 3);
    SBIT(TDIR2,   0xc8, 2);
    SBIT(TMOD21,  0xc8, 1);
    SBIT(TMOD20,  0xc8, 0);
SFR(TCR21,   0xf9); // CCU control register 1
    #define TCOU2    0x80
    #define PLLDV_3  0x08
    #define PLLDV_2  0x04
    #define PLLDV_1  0x02
    #define PLLDV_0  0x01
SFR(TH0,     0x8c); // Timer 0 high
SFR(TH1,     0x8d); // Timer 1 high
SFR(TH2,     0xcd); // CCU timer high
SFR(TICR2,   0xc9); // CCU interrupt control register
    #define TOIE2    0x80
    #define TOCIE2D  0x40
    #define TOCIE2C  0x20
    #define TOCIE2B  0x10
    #define TOCIE2A  0x08
    #define TICIE2B  0x02
    #define TICIE2A  0x01
SFR(TIFR2,   0xe9); // CCU interrupt flag register
    #define TOIF2    0x80
    #define TOCF2D   0x40
    #define TOCF2C   0x20
    #define TOCF2B   0x10
    #define TOCF2A   0x08
    #define TICF2B   0x02
    #define TICF2A   0x01
SFR(TISE2,   0xde); // CCU interrupt status encode register
    #define ENCINT_2 0x04
    #define ENCINT_1 0x02
    #define ENCINT_0 0x01
SFR(TL0,     0x8a); // Timer 0 low
SFR(TL1,     0x8b); // Timer 1 low
SFR(TL2,     0xcc); // CCU timer low
SFR(TMOD,    0x89); // Timer 0 and 1 mode
    #define T1GATE   0x80
    #define T1C_T    0x40
    #define T1M1     0x20
    #define T1M0     0x10
    #define T0GATE   0x08
    #define T0C_T    0x04
    #define T0M1     0x02
    #define T0M0     0x01
SFR(TOR2H,   0xcf); // CCU reload register high
SFR(TOR2L,   0xce); // CCU reload register low
SFR(TPCR2H,  0xcb); // Prescaler control register high
    #define TPCR2H_1 0x02
    #define TPCR2H_0 0x01
SFR(TPCR2L,  0xca); // Prescaler control register low
    #define TPCR2L_7 0x80
    #define TPCR2L_6 0x40
    #define TPCR2L_5 0x20
    #define TPCR2L_4 0x10
    #define TPCR2L_3 0x08
    #define TPCR2L_2 0x04
    #define TPCR2L_1 0x02
    #define TPCR2L_0 0x01
SFR(TRIM,    0x96); // Internal oscillator trim register
    #define RCCLK    0x80
    #define ENCLK    0x40
    #define TRIM_5   0x20
    #define TRIM_4   0x10
    #define TRIM_3   0x08
    #define TRIM_2   0x04
    #define TRIM_1   0x02
    #define TRIM_0   0x01
SFR(WDCON,   0xa7); // Watchdog control register
    #define PRE2     0x80
    #define PRE1     0x40
    #define PRE0     0x20
    #define WDRUN    0x04
    #define WDTOF    0x02
    #define WDCLK    0x01
SFR(WDL,     0xc1); // Watchdog load
SFR(WFEED1,  0xc2); // Watchdog feed 1
SFR(WFEED2,  0xc3); // Watchdog feed 2
SFRX(BODCFG,  0xffc8); // BOD configuration register
    #define BOICFG1  0x02
    #define BOICFG0  0x01
SFRX(CLKCON,  0xffde); // CLOCK Control register
    #define CLKOK    0x80
    #define XTALWD   0x10
    #define CLKDBL   0x08
    #define FOSC2    0x04
    #define FOSC1    0x02
    #define FOSC0    0x01
SFRX(PGACON1, 0xffe1); // PGA1 control register
    #define ENPGA1   0x80
    #define PGASEL1_1 0x40
    #define PGASEL1_0 0x20
    #define PGATRIM_1 0x10
    #define PGAG11   0x02
    #define PGAG10   0x01
SFRX(PGACON1B, 0xffe4); // PGA1 control register B
    #define PGAENO   0x01
    #define FF1      0x01
SFRX(PGA1TRIM8X16X, 0xffe3); // PGA1 trim register
    #define PGA1_16XTRIM3 0x80
    #define PGA1_16XTRIM2 0x40
    #define PGA1_16XTRIM1 0x20
    #define PGA1_16XTRIM0 0x10
    #define PGA1_8XTRIM3 0x08
    #define PGA1_8XTRIM2 0x04
    #define PGA1_8XTRIM1 0x02
    #define PGA1_8XTRIM0 0x01
SFRX(PGA1TRIM2X4X, 0xffe2); // PGA1 trim register
    #define PGA1_4XTRIM3 0x80
    #define PGA1_4XTRIM2 0x40
    #define PGA1_4XTRIM1 0x20
    #define PGA1_4XTRIM0 0x10
    #define PGA1_2XTRIM3 0x08
    #define PGA1_2XTRIM2 0x04
    #define PGA1_2XTRIM1 0x02
    #define PGA1_2XTRIM0 0x01
SFRX(PGACON0, 0xffca); // PGA0 control register
    #define ENPGA0   0x80
    #define PGASEL0_1 0x40
    #define PGASEL0_0 0x20
    #define PGATRIM_0 0x10
    #define TSEL1    0x08
    #define TSEL0    0x04
    #define PGAG01   0x02
    #define PGAG00   0x01
SFRX(PGACON0B, 0xffce); // PGA0 control register B
    #define PGAENO   0x01
    #define FF0      0x01
SFRX(PGA0TRIM8X16X, 0xffcd); // PGA0 trim register
    #define PGA0_16XTRIM3 0x80
    #define PGA0_16XTRIM2 0x40
    #define PGA0_16XTRIM1 0x20
    #define PGA0_16XTRIM0 0x10
    #define PGA0_8XTRIM3 0x08
    #define PGA0_8XTRIM2 0x04
    #define PGA0_8XTRIM1 0x02
    #define PGA0_8XTRIM0 0x01
SFRX(PGA0TRIM2X4X, 0xffcc); // PGA0 trim register
    #define PGA0_4XTRIM3 0x80
    #define PGA0_4XTRIM2 0x40
    #define PGA0_4XTRIM1 0x20
    #define PGA0_4XTRIM0 0x10
    #define PGA0_2XTRIM3 0x08
    #define PGA0_2XTRIM2 0x04
    #define PGA0_2XTRIM1 0x02
    #define PGA0_2XTRIM0 0x01
SFRX(RTCDATH, 0xffbf); // Real-time clock data register high
SFRX(RTCDATL, 0xffbe); // Real-time clock data register low
#endif /*REG_P89LPC9351_H*/
/*-------------------------------------------------------------------------
   ser_ir.h - header file for serial routines

   Copyright (C) 1999, Josef Wolf <jw AT raven.inka.de>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __SER_IR_H
#define __SER_IR_H

/* call this one first on startup */
void ser_init (void);

/* the following ones should be obvious */
void ser_putc (unsigned char c);
void ser_puts (unsigned char *s);
void ser_gets (unsigned char *s, unsigned char len);
unsigned char ser_getc (void);

/* return the number of chars that can be received/transmitted without
* blocking.
*/
unsigned char ser_can_rcv (void);
unsigned char ser_can_xmt (void);

/* needs to be defined somewhere :-() */
void ser_handler (void) __interrupt 4;

#endif  /* __SER_IR_H */
/*-------------------------------------------------------------------------
   cc2430.h - Register Declarations for Chipcon CC2430
   (Based on CC2430 PRELIMINARY Data Sheet (rev. 1.03) SWRS036A)

   Copyright (C) 2006, Jesus Calvino-Fraga / jesusc at ece.ubc.ca

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef REG_CC2430_H
#define REG_CC2430_H

#include <compiler.h>

// Interrupt Vectors

#define RFERR_VECTOR    0   // RF TX FIFO underflow and RX FIFO overflow.
#define ADC_VECTOR      1   // ADC end of conversion
#define URX0_VECTOR     2   // USART0 RX complete
#define URX1_VECTOR     3   // USART1 RX complete
#define ENC_VECTOR      4   // AES encryption/decryption complete
#define ST_VECTOR       5   // Sleep Timer compare
#define P2INT_VECTOR    6   // Port 2 inputs
#define UTX0_VECTOR     7   // USART0 TX complete
#define DMA_VECTOR      8   // DMA transfer complete
#define T1_VECTOR       9   // Timer 1 (16-bit) capture/compare/overflow
#define T2_VECTOR       10  // Timer 2 (MAC Timer)
#define T3_VECTOR       11  // Timer 3 (8-bit) capture/compare/overflow
#define T4_VECTOR       12  // Timer 4 (8-bit) capture/compare/overflow
#define P0INT_VECTOR    13  // Port 0 inputs
#define UTX1_VECTOR     14  // USART1 TX complete
#define P1INT_VECTOR    15  // Port 1 inputs
#define RF_VECTOR       16  // RF general interrupts
#define WDT_VECTOR      17  // Watchdog overflow in timer mode

// SFR Registers and BITs

SFR(P0,       0x80); // Port 0
   SBIT(P0_0,     0x80, 0); // Port 0 bit 0
   SBIT(P0_1,     0x80, 1); // Port 0 bit 1
   SBIT(P0_2,     0x80, 2); // Port 0 bit 2
   SBIT(P0_3,     0x80, 3); // Port 0 bit 3
   SBIT(P0_4,     0x80, 4); // Port 0 bit 4
   SBIT(P0_5,     0x80, 5); // Port 0 bit 5
   SBIT(P0_6,     0x80, 6); // Port 0 bit 6
   SBIT(P0_7,     0x80, 7); // Port 0 bit 7
SFR(SP,       0x81); // Stack Pointer
SFR(DPL0,     0x82); // Data Pointer 0 Low Byte
SFR(DPH0,     0x83); // Data Pointer 0 High Byte
SFR(DPL1,     0x84); // Data Pointer 1 Low Byte
SFR(DPH1,     0x85); // Data Pointer 1 High Byte
SFR(U0CSR,    0x86); // USART 0 Control and Status
SFR(PCON,     0x87); // Power Mode Control
SFR(TCON,     0x88); // Interrupt Flags
   SBIT(IT0,      0x88, 0); // reserved (must always be set to 1)
   SBIT(RFERRIF,  0x88, 1); // RFERR  RF TX/RX FIFO interrupt flag
   SBIT(IT1,      0x88, 2); // reserved (must always be set to 1)
   SBIT(URX0IF,   0x88, 3); // USART0 RX Interrupt Flag
   SBIT(ADCIF,    0x88, 5); // ADC Interrupt Flag
   SBIT(URX1IF,   0x88, 7); // USART1 RX Interrupt Flag
SFR(P0IFG,    0x89); // Port 0 Interrupt Status Flag
SFR(P1IFG,    0x8A); // Port 1 Interrupt Status Flag
SFR(P2IFG,    0x8B); // Port 2 Interrupt Status Flag
SFR(PICTL,    0x8C); // Port Interrupt Control
SFR(P1IEN,    0x8D); // Port 1 Interrupt Mask
SFR(P0INP,    0x8F); // Port 0 Input Mode
SFR(P1,       0x90); // Port 1
   SBIT(P1_0,     0x90, 0); // Port 1 bit 0
   SBIT(P1_1,     0x90, 1); // Port 1 bit 1
   SBIT(P1_2,     0x90, 2); // Port 1 bit 2
   SBIT(P1_3,     0x90, 3); // Port 1 bit 3
   SBIT(P1_4,     0x90, 4); // Port 1 bit 4
   SBIT(P1_5,     0x90, 5); // Port 1 bit 5
   SBIT(P1_6,     0x90, 6); // Port 1 bit 6
   SBIT(P1_7,     0x90, 7); // Port 1 bit 7
SFR(RFIM,     0x91); // RF Interrupt Mask
SFR(DPS,      0x92); // Data Pointer Select
SFR(MPAGE,    0x93); // Memory Page Select
SFR(_XPAGE,   0x93); // Memory Page Select under the name SDCC needs it
SFR(T2CMP,    0x94); // Timer 2 Compare Value
SFR(ST0,      0x95); // Sleep Timer 0
SFR(ST1,      0x96); // Sleep Timer 1
SFR(ST2,      0x97); // Sleep Timer 2
SFR(S0CON,    0x98); // Interrupt Flags 2
   SBIT(ENCIF_0,  0x98, 0); // AES Interrupt Flag 0
   SBIT(ENCIF_1,  0x98, 1); // AES Interrupt Flag 1
SFR(IEN2,     0x9A); // Interrupt Enable 2
SFR(S1CON,    0x9B); // Interrupt Flags 3
SFR(T2PEROF0, 0x9C); // Timer 2 Overflow Capture/Compare 0
SFR(T2PEROF1, 0x9D); // Timer 2 Overflow Capture/Compare 1
SFR(T2PEROF2, 0x9E); // Timer 2 Overflow Capture/Compare 2
SFR(FMAP    , 0x9F); // Flash Bank Map
SFR(P2,       0xA0); // Port 2
   SBIT(P2_0,     0xA0, 0); // Port 2 bit 0
   SBIT(P2_1,     0xA0, 1); // Port 2 bit 1
   SBIT(P2_2,     0xA0, 2); // Port 2 bit 2
   SBIT(P2_3,     0xA0, 3); // Port 2 bit 3
   SBIT(P2_4,     0xA0, 4); // Port 2 bit 4
   SBIT(P2_5,     0xA0, 5); // Port 2 bit 5
   SBIT(P2_6,     0xA0, 6); // Port 2 bit 6
   SBIT(P2_7,     0xA0, 7); // Port 2 bit 7
SFR(T2OF0,    0xA1); // Timer 2 Overflow Count 0
SFR(T2OF1,    0xA2); // Timer 2 Overflow Count 1
SFR(T2OF2,    0xA3); // Timer 2 Overflow Count 2
SFR(T2CAPLPL, 0xA4); // Timer 2 Period Low Byte
SFR(T2CAPHPH, 0xA5); // Timer 2 Period High Byte
SFR(T2TLD,    0xA6); // Timer 2 Timer Value Low Byte
SFR(T2THD,    0xA7); // Timer 2 Timer Value High Byte
SFR(IEN0,     0xA8); // Interrupt Enable 0
   SBIT(RFERRIE,  0xA8, 0); // RF TX/RX FIFO interrupt enable
   SBIT(ADCIE,    0xA8, 1); // ADC Interrupt Enable
   SBIT(URX0IE,   0xA8, 2); // USART0 RX Interrupt Enable
   SBIT(URX1IE,   0xA8, 3); // USART1 RX Interrupt Enable
   SBIT(ENCIE,    0xA8, 4); // AES Encryption/Decryption Interrupt Enable
   SBIT(STIE,     0xA8, 5); // Sleep Timer Interrupt Enable
   SBIT(EA,       0xA8, 7); // Global Interrupt Enable
SFR(IP0,      0xA9); // Interrupt Priority 0
SFR(FWT,      0xAB); // Flash Write Timing
SFR(FADDRL,   0xAC); // Flash Address Low Byte
SFR(FADDRH,   0xAD); // Flash Address High Byte
SFR(FCTL,     0xAE); // Flash Control
SFR(FWDATA,   0xAF); // Flash Write Data
SFR(ENCDI,    0xB1); // Encryption Input Data
SFR(ENCDO,    0xB2); // Encryption Output Data
SFR(ENCCS,    0xB3); // Encryption Control and Status
SFR(ADCCON1,  0xB4); // ADC Control 1
SFR(ADCCON2,  0xB5); // ADC Control 2
SFR(ADCCON3,  0xB6); // ADC Control 3
SFR(IEN1,     0xB8); // Interrupt Enable 1
   SBIT(DMAIE,    0xB8, 0); // DMA Transfer Interrupt Enable
   SBIT(T1IE,     0xB8, 1); // Timer 1 Interrupt Enable
   SBIT(T2IE,     0xB8, 2); // Timer 2 Interrupt Enable
   SBIT(T3IE,     0xB8, 3); // Timer 3 Interrupt Enable
   SBIT(T4IE,     0xB8, 4); // Timer 4 Interrupt Enable
   SBIT(P0IE,     0xB8, 5); // Port 0 Interrupt Enable
SFR(IP1,      0xB9); // Interrupt Priority 1
SFR(ADCL,     0xBA); // ADC Data Low
SFR(ADCH,     0xBB); // ADC Data High
SFR(RNDL,     0xBC); // Random Number Generator Data Low Byte
SFR(RNDH,     0xBD); // Random Number Generator Data High Byte
SFR(SLEEP,    0xBE); // Sleep Mode Control
SFR(IRCON,    0xC0); // Interrupt Flags 4
   SBIT(DMAIF,    0xC0, 0); // DMA Complete Interrupt Flag
   SBIT(T1IF,     0xC0, 1); // Timer 1 Interrupt Flag
   SBIT(T2IF,     0xC0, 2); // Timer 2 Interrupt Flag
   SBIT(T3IF,     0xC0, 3); // Timer 3 Interrupt Flag
   SBIT(T4IF,     0xC0, 4); // Timer 4 Interrupt Flag
   SBIT(P0IF,     0xC0, 5); // Port 0 Interrupt Flag
   SBIT(STIF,     0xC0, 7); // Sleep Timer Interrupt Flag
SFR(U0DBUF,   0xC1); // USART 0 Receive/Transmit Data Buffer
SFR(U0BAUD,   0xC2); // USART 0 Baud Rate Control
SFR(T2CNF,    0xC3); // Timer 2 Configuration
SFR(U0UCR,    0xC4); // USART 0 UART Control
SFR(U0GCR,    0xC5); // USART 0 Generic Control
SFR(CLKCON,   0xC6); // Clock Control
SFR(MEMCTR,   0xC7); // Memory Arbiter Control
SFR(WDCTL,    0xC9); // Watchdog Timer Control
SFR(T3CNT,    0xCA); // Timer 3 Counter
SFR(T3CTL,    0xCB); // Timer 3 Control
SFR(T3CCTL0,  0xCC); // Timer 3 Channel 0 Capture/Compare Control
SFR(T3CC0,    0xCD); // Timer 3 Channel 0 Capture/Compare Value
SFR(T3CCTL1,  0xCE); // Timer 3 Channel 1 Capture/Compare Control
SFR(T3CC1,    0xCF); // Timer 3 Channel 1 Capture/Compare Value
SFR(PSW,      0xD0); // Program Status Word
   SBIT(P,        0xD0, 0); // Parity Flag
   SBIT(F1,       0xD0, 1); // User-Defined Flag
   SBIT(OV,       0xD0, 2); // Overflow Flag
   SBIT(RS0,      0xD0, 3); // Register Bank Select 0
   SBIT(RS1,      0xD0, 4); // Register Bank Select 1
   SBIT(F0,       0xD0, 5); // User-Defined Flag
   SBIT(AC,       0xD0, 6); // Auxiliary Carry Flag
   SBIT(CY,       0xD0, 7); // Carry Flag
SFR(DMAIRQ,   0xD1); // DMA Interrupt Flag
SFR(DMA1CFGL, 0xD2); // DMA Channel 1-4 Configuration Address Low Byte
SFR(DMA1CFGH, 0xD3); // DMA Channel 1-4 Configuration Address High Byte
SFR(DMA0CFGL, 0xD4); // DMA Channel 0 Configuration Address Low Byte
SFR(DMA0CFGH, 0xD5); // DMA Channel 0 Configuration Address High Byte
SFR(DMAARM,   0xD6); // DMA Channel Arm
SFR(DMAREQ,   0xD7); // DMA Channel Start Request and Status
SFR(TIMIF,    0xD8); // Timers 1/3/4 Interrupt Mask/Flag
   SBIT(T3OVFIF,  0xD8, 0); // Timer 3 overflow interrupt flag 0:no pending 1:pending
   SBIT(T3CH0IF,  0xD8, 1); // Timer 3 channel 0 interrupt flag 0:no pending 1:pending
   SBIT(T3CH1IF,  0xD8, 2); // Timer 3 channel 1 interrupt flag 0:no pending 1:pending
   SBIT(T4OVFIF,  0xD8, 3); // Timer 4 overflow interrupt flag 0:no pending 1:pending
   SBIT(T4CH0IF,  0xD8, 4); // Timer 4 channel 0 interrupt flag 0:no pending 1:pending
   SBIT(T4CH1IF,  0xD8, 5); // Timer 4 channel 1 interrupt flag 0:no pending 1:pending
   SBIT(OVFIM,    0xD8, 6); // Timer 1 overflow interrupt mask
SFR(RFD,      0xD9); // RF Data
SFR(T1CC0L,   0xDA); // Timer 1 Channel 0 Capture/Compare Value Low
SFR(T1CC0H,   0xDB); // Timer 1 Channel 0 Capture/Compare Value High
SFR(T1CC1L,   0xDC); // Timer 1 Channel 1 Capture/Compare Value Low
SFR(T1CC1H,   0xDD); // Timer 1 Channel 1 Capture/Compare Value High
SFR(T1CC2L,   0xDE); // Timer 1 Channel 2 Capture/Compare Value Low
SFR(T1CC2H,   0xDF); // Timer 1 Channel 2 Capture/Compare Value High
SFR(ACC,      0xE0); // Accumulator
   SBIT(ACC_0,    0xE0, 0); // Accumulator bit 0
   SBIT(ACC_1,    0xE0, 1); // Accumulator bit 1
   SBIT(ACC_2,    0xE0, 2); // Accumulator bit 2
   SBIT(ACC_3,    0xE0, 3); // Accumulator bit 3
   SBIT(ACC_4,    0xE0, 4); // Accumulator bit 4
   SBIT(ACC_5,    0xE0, 5); // Accumulator bit 5
   SBIT(ACC_6,    0xE0, 6); // Accumulator bit 6
   SBIT(ACC_7,    0xE0, 7); // Accumulator bit 7
SFR(RFST,     0xE1); // RF CSMA-CA / Strobe Processor
SFR(T1CNTL,   0xE2); // Timer 1 Counter Low
SFR(T1CNTH,   0xE3); // Timer 1 Counter High
SFR(T1CTL,    0xE4); // Timer 1 Control and Status
SFR(T1CCTL0,  0xE5); // Timer 1 Channel 0 Capture/Compare Control
SFR(T1CCTL1,  0xE6); // Timer 1 Channel 1 Capture/Compare Control
SFR(T1CCTL2,  0xE7); // Timer 1 Channel 2 Capture/Compare Control
SFR(IRCON2,   0xE8); // Interrupt Flags 5
   SBIT(P2IF,     0xE8, 0); // Port 2 Interrupt Flag
   SBIT(UTX0IF,   0xE8, 1); // USART0 TX Interrupt Flag
   SBIT(UTX1IF,   0xE8, 2); // USART1 TX Interrupt Flag
   SBIT(P1IF,     0xE8, 3); // Port 1 Interrupt Flag
   SBIT(WDTIF,    0xE8, 4); // Watchdog Timer Interrupt Flag
SFR(RFIF,     0xE9); // RF Interrupt Flags
SFR(T4CNT,    0xEA); // Timer 4 Counter
SFR(T4CTL,    0xEB); // Timer 4 Control
SFR(T4CCTL0,  0xEC); // Timer 4 Channel 0 Capture/Compare Control
SFR(T4CC0,    0xED); // Timer 4 Channel 0 Capture/Compare Value
SFR(T4CCTL1,  0xEE); // Timer 4 Channel 1 Capture/Compare Control
SFR(T4CC1,    0xEF); // Timer 4 Channel 1 Capture/Compare Value
SFR(B,        0xF0); // B Register
   SBIT(B_0,      0xF0, 0); // Register B bit 0
   SBIT(B_1,      0xF0, 1); // Register B bit 1
   SBIT(B_2,      0xF0, 2); // Register B bit 2
   SBIT(B_3,      0xF0, 3); // Register B bit 3
   SBIT(B_4,      0xF0, 4); // Register B bit 4
   SBIT(B_5,      0xF0, 5); // Register B bit 5
   SBIT(B_6,      0xF0, 6); // Register B bit 6
   SBIT(B_7,      0xF0, 7); // Register B bit 7
SFR(PERCFG,   0xF1); // Peripheral Control
SFR(ADCCFG,   0xF2); // ADC Input Configuration
SFR(P0SEL,    0xF3); // Port 0 Function Select
SFR(P1SEL,    0xF4); // Port 1 Function Select
SFR(P2SEL,    0xF5); // Port 2 Function Select
SFR(P1INP,    0xF6); // Port 1 Input Mode
SFR(P2INP,    0xF7); // Port 2 Input Mode
SFR(U1CSR,    0xF8); // USART 1 Control and Status
   SBIT(ACTIVE,   0xF8, 0); // USART transmit/receive active status 0:idle 1:busy
   SBIT(TX_BYTE,  0xF8, 1); // Transmit byte status 0:Byte not transmitted 1:Last byte transmitted
   SBIT(RX_BYTE,  0xF8, 2); // Receive byte status 0:No byte received 1:Received byte ready
   SBIT(ERR,      0xF8, 3); // UART parity error status 0:No error 1:parity error
   SBIT(FE,       0xF8, 4); // UART framing error status 0:No error 1:incorrect stop bit level
   SBIT(SLAVE,    0xF8, 5); // SPI master or slave mode select 0:master 1:slave
   SBIT(RE,       0xF8, 6); // UART receiver enable 0:disabled 1:enabled
   SBIT(MODE,     0xF8, 7); // USART mode select 0:SPI 1:UART
SFR(U1DBUF,   0xF9); // USART 1 Receive/Transmit Data Buffer
SFR(U1BAUD,   0xFA); // USART 1 Baud Rate Control
SFR(U1UCR,    0xFB); // USART 1 UART Control
SFR(U1GCR,    0xFC); // USART 1 Generic Control
SFR(P0DIR,    0xFD); // Port 0 Direction
SFR(P1DIR,    0xFE); // Port 1 Direction
SFR(P2DIR,    0xFF); // Port 2 Direction

// From Table 45 : Overview of RF registers

SFRX(MDMCTRL0H,  0xDF02); // Modem Control 0,  high
SFRX(MDMCTRL0L,  0xDF03); // Modem Control 0,  low
SFRX(MDMCTRL1H,  0xDF04); // Modem Control 1,  high
SFRX(MDMCTRL1L,  0xDF05); // Modem Control 1,  low
SFRX(RSSIH,      0xDF06); // RSSI and CCA Status and Control,  high
SFRX(RSSIL,      0xDF07); // RSSI and CCA Status and Control,  low
SFRX(SYNCWORDH,  0xDF08); // Synchronisation Word Control,  high
SFRX(SYNCWORDL,  0xDF09); // Synchronisation Word Control,  low
SFRX(TXCTRLH,    0xDF0A); // Transmit Control,  high
SFRX(TXCTRLL,    0xDF0B); // Transmit Control,  low
SFRX(RXCTRL0H,   0xDF0C); // Receive Control 0,  high
SFRX(RXCTRL0L,   0xDF0D); // Receive Control 0,  low
SFRX(RXCTRL1H,   0xDF0E); // Receive Control 1,  high
SFRX(RXCTRL1L,   0xDF0F); // Receive Control 1,  low
SFRX(FSCTRLH,    0xDF10); // Frequency Synthesizer Control and Status,  high
SFRX(FSCTRLL,    0xDF11); // Frequency Synthesizer Control and Status,  low
SFRX(CSPX,       0xDF12); // CSP X Data
SFRX(CSPY,       0xDF13); // CSP Y Data
SFRX(CSPZ,       0xDF14); // CSP Z Data
SFRX(CSPCTRL,    0xDF15); // CSP Control
SFRX(CSPT,       0xDF16); // CSP T Data
SFRX(RFPWR,      0xDF17); // RF Power Control
SFRX(FSMTCH,     0xDF20); // Finite State Machine Time Constants,  high
SFRX(FSMTCL,     0xDF21); // Finite State Machine Time Constants,  low
SFRX(MANANDH,    0xDF22); // Manual AND Override,  high
SFRX(MANANDL,    0xDF23); // Manual AND Override,  low
SFRX(MANORH,     0xDF24); // Manual OR Override,  high
SFRX(MANORL,     0xDF25); // Manual OR Override,  low
SFRX(AGCCTRLH,   0xDF26); // AGC Control,  high
SFRX(AGCCTRLL,   0xDF27); // AGC Control,  low
SFRX(FSMSTATE,   0xDF39); // Finite State Machine State Status
SFRX(ADCTSTH,    0xDF3A); // ADC Test,  high
SFRX(ADCTSTL,    0xDF3B); // ADC Test,  low
SFRX(DACTSTH,    0xDF3C); // DAC Test,  high
SFRX(DACTSTL,    0xDF3D); // DAC Test,  low
SFRX(IEEE_ADDR0, 0xDF43); // IEEE Address 0
SFRX(IEEE_ADDR1, 0xDF44); // IEEE Address 1
SFRX(IEEE_ADDR2, 0xDF45); // IEEE Address 2
SFRX(IEEE_ADDR3, 0xDF46); // IEEE Address 3
SFRX(IEEE_ADDR4, 0xDF47); // IEEE Address 4
SFRX(IEEE_ADDR5, 0xDF48); // IEEE Address 5
SFRX(IEEE_ADDR6, 0xDF49); // IEEE Address 6
SFRX(IEEE_ADDR7, 0xDF4A); // IEEE Address 7
SFRX(PANIDH,     0xDF4B); // PAN Identifier,  high
SFRX(PANIDL,     0xDF4C); // PAN Identifier,  low
SFRX(SHORTADDRH, 0xDF4D); // Short Address,  high
SFRX(SHORTADDRL, 0xDF4E); // Short Address,  low
SFRX(IOCFG0,     0xDF4F); // I/O Configuration 0
SFRX(IOCFG1,     0xDF50); // I/O Configuration 1
SFRX(IOCFG2,     0xDF51); // I/O Configuration 2
SFRX(IOCFG3,     0xDF52); // I/O Configuration 3
SFRX(RXFIFOCNT,  0xDF53); // RX FIFO Count
SFRX(FSMTC1,     0xDF54); // Finite State Machine Control
SFRX(CHVER,      0xDF60); // Chip Version
SFRX(CHIPID,     0xDF61); // Chip Identification
SFRX(RFSTATUS,   0xDF62); // RF Status

// SFRs also accesible through XDATA space

SFRX(X_U0CSR,    0xDF86); // USART 0 Control and Status
SFRX(X_P0IFG,    0xDF89); // Port 0 Interrupt Status Flag
SFRX(X_P1IFG,    0xDF8A); // Port 1 Interrupt Status Flag
SFRX(X_P2IFG,    0xDF8B); // Port 2 Interrupt Status Flag
SFRX(X_PICTL,    0xDF8C); // Port Interrupt Control
SFRX(X_P1IEN,    0xDF8D); // Port 1 Interrupt Mask
SFRX(X_P0INP,    0xDF8F); // Port 0 Input Mode
SFRX(X_RFIM,     0xDF91); // RF Interrupt Mask
SFRX(X_MPAGE,    0xDF93); // Memory Page Select
SFRX(X_T2CMP,    0xDF94); // Timer 2 Compare Value
SFRX(X_ST0,      0xDF95); // Sleep Timer 0
SFRX(X_ST1,      0xDF96); // Sleep Timer 1
SFRX(X_ST2,      0xDF97); // Sleep Timer 2
SFRX(X_T2PEROF0, 0xDF9C); // Timer 2 Overflow Capture/Compare 0
SFRX(X_T2PEROF1, 0xDF9D); // Timer 2 Overflow Capture/Compare 1
SFRX(X_T2PEROF2, 0xDF9E); // Timer 2 Overflow Capture/Compare 2
SFRX(X_T2OF0,    0xDFA1); // Timer 2 Overflow Count 0
SFRX(X_T2OF1,    0xDFA2); // Timer 2 Overflow Count 1
SFRX(X_T2OF2,    0xDFA3); // Timer 2 Overflow Count 2
SFRX(X_T2CAPLPL, 0xDFA4); // Timer 2 Period Low Byte
SFRX(X_T2CAPHPH, 0xDFA5); // Timer 2 Period High Byte
SFRX(X_T2TLD,    0xDFA6); // Timer 2 Timer Value Low Byte
SFRX(X_T2THD,    0xDFA7); // Timer 2 Timer Value High Byte
SFRX(X_FWT,      0xDFAB); // Flash Write Timing
SFRX(X_FADDRL,   0xDFAC); // Flash Address Low Byte
SFRX(X_FADDRH,   0xDFAD); // Flash Address High Byte
SFRX(X_FCTL,     0xDFAE); // Flash Control
SFRX(X_FWDATA,   0xDFAF); // Flash Write Data
SFRX(X_ENCDI,    0xDFB1); // Encryption Input Data
SFRX(X_ENCDO,    0xDFB2); // Encryption Output Data
SFRX(X_ENCCS,    0xDFB3); // Encryption Control and Status
SFRX(X_ADCCON1,  0xDFB4); // ADC Control 1
SFRX(X_ADCCON2,  0xDFB5); // ADC Control 2
SFRX(X_ADCCON3,  0xDFB6); // ADC Control 3
SFRX(X_ADCL,     0xDFBA); // ADC Data Low
SFRX(X_ADCH,     0xDFBB); // ADC Data High
SFRX(X_RNDL,     0xDFBC); // Random Number Generator Data Low Byte
SFRX(X_RNDH,     0xDFBD); // Random Number Generator Data High Byte
SFRX(X_SLEEP,    0xDFBE); // Sleep Mode Control
SFRX(X_U0DBUF,   0xDFC1); // USART 0 Receive/Transmit Data Buffer
SFRX(X_U0BAUD,   0xDFC2); // USART 0 Baud Rate Control
SFRX(X_T2CNF,    0xDFC3); // Timer 2 Configuration
SFRX(X_U0UCR,    0xDFC4); // USART 0 UART Control
SFRX(X_U0GCR,    0xDFC5); // USART 0 Generic Control
SFRX(X_CLKCON,   0xDFC6); // Clock Control
SFRX(X_MEMCTR,   0xDFC7); // Memory Arbiter Control
SFRX(X_WDCTL,    0xDFC9); // Watchdog Timer Control
SFRX(X_T3CNT,    0xDFCA); // Timer 3 Counter
SFRX(X_T3CTL,    0xDFCB); // Timer 3 Control
SFRX(X_T3CCTL0,  0xDFCC); // Timer 3 Channel 0 Capture/Compare Control
SFRX(X_T3CC0,    0xDFCD); // Timer 3 Channel 0 Capture/Compare Value
SFRX(X_T3CCTL1,  0xDFCE); // Timer 3 Channel 1 Capture/Compare Control
SFRX(X_T3CC1,    0xDFCF); // Timer 3 Channel 1 Capture/Compare Value
SFRX(X_DMAIRQ,   0xDFD1); // DMA Interrupt Flag
SFRX(X_DMA1CFGL, 0xDFD2); // DMA Channel 1-4 Configuration Address Low Byte
SFRX(X_DMA1CFGH, 0xDFD3); // DMA Channel 1-4 Configuration Address High Byte
SFRX(X_DMA0CFGL, 0xDFD4); // DMA Channel 0 Configuration Address Low Byte
SFRX(X_DMA0CFGH, 0xDFD5); // DMA Channel 0 Configuration Address High Byte
SFRX(X_DMAARM,   0xDFD6); // DMA Channel Arm
SFRX(X_DMAREQ,   0xDFD7); // DMA Channel Start Request and Status
SFRX(X_TIMIF,    0xDFD8); // Timers 1/3/4 Interrupt Mask/Flag
SFRX(X_RFD,      0xDFD9); // RF Data
SFRX(X_T1CC0L,   0xDFDA); // Timer 1 Channel 0 Capture/Compare Value Low
SFRX(X_T1CC0H,   0xDFDB); // Timer 1 Channel 0 Capture/Compare Value High
SFRX(X_T1CC1L,   0xDFDC); // Timer 1 Channel 1 Capture/Compare Value Low
SFRX(X_T1CC1H,   0xDFDD); // Timer 1 Channel 1 Capture/Compare Value High
SFRX(X_T1CC2L,   0xDFDE); // Timer 1 Channel 2 Capture/Compare Value Low
SFRX(X_T1CC2H,   0xDFDF); // Timer 1 Channel 2 Capture/Compare Value High
SFRX(X_RFST,     0xDFE1); // RF CSMA-CA / Strobe Processor
SFRX(X_T1CNTL,   0xDFE2); // Timer 1 Counter Low
SFRX(X_T1CNTH,   0xDFE3); // Timer 1 Counter High
SFRX(X_T1CTL,    0xDFE4); // Timer 1 Control and Status
SFRX(X_T1CCTL0,  0xDFE5); // Timer 1 Channel 0 Capture/Compare Control
SFRX(X_T1CCTL1,  0xDFE6); // Timer 1 Channel 1 Capture/Compare Control
SFRX(X_T1CCTL2,  0xDFE7); // Timer 1 Channel 2 Capture/Compare Control
SFRX(X_RFIF,     0xDFE9); // RF Interrupt Flags
SFRX(X_T4CNT,    0xDFEA); // Timer 4 Counter
SFRX(X_T4CTL,    0xDFEB); // Timer 4 Control
SFRX(X_T4CCTL0,  0xDFEC); // Timer 4 Channel 0 Capture/Compare Control
SFRX(X_T4CC0,    0xDFED); // Timer 4 Channel 0 Capture/Compare Value
SFRX(X_T4CCTL1,  0xDFEE); // Timer 4 Channel 1 Capture/Compare Control
SFRX(X_T4CC1,    0xDFEF); // Timer 4 Channel 1 Capture/Compare Value
SFRX(X_PERCFG,   0xDFF1); // Peripheral Control
SFRX(X_ADCCFG,   0xDFF2); // ADC Input Configuration
SFRX(X_P0SEL,    0xDFF3); // Port 0 Function Select
SFRX(X_P1SEL,    0xDFF4); // Port 1 Function Select
SFRX(X_P2SEL,    0xDFF5); // Port 2 Function Select
SFRX(X_P1INP,    0xDFF6); // Port 1 Input Mode
SFRX(X_P2INP,    0xDFF7); // Port 2 Input Mode
SFRX(X_U1CSR,    0xDFF8); // USART 1 Control and Status
SFRX(X_U1DBUF,   0xDFF9); // USART 1 Receive/Transmit Data Buffer
SFRX(X_U1BAUD,   0xDFFA); // USART 1 Baud Rate Control
SFRX(X_U1UCR,    0xDFFB); // USART 1 UART Control
SFRX(X_U1GCR,    0xDFFC); // USART 1 Generic Control
SFRX(X_P0DIR,    0xDFFD); // Port 0 Direction
SFRX(X_P1DIR,    0xDFFE); // Port 1 Direction
SFRX(X_P2DIR,    0xDFFF); // Port 2 Direction

#endif //REG_CC2430_H
/*-------------------------------------------------------------------------
   SST89x5xRDx.h Register Declarations for SST SST89E516RD2, ST89E516RD,
   SST89V516RD2, and SST89V516RD Processors
   (Based on datasheed S71273-03-000 1/07)

   Copyright (C) 2007, Jesus Calvino-Fraga / jesusc at ece.ubc.ca

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef REG_SST89x5xRDx_H
#define REG_SST89x5xRDx_H

#include <compiler.h>

// From TABLE 3-5: CPU related SFRs

SFR(ACC, 0xE0); // Accumulator
   SBIT(ACC_0, 0xE0, 0); // Accumulator bit 0
   SBIT(ACC_1, 0xE0, 1); // Accumulator bit 1
   SBIT(ACC_2, 0xE0, 2); // Accumulator bit 2
   SBIT(ACC_3, 0xE0, 3); // Accumulator bit 3
   SBIT(ACC_4, 0xE0, 4); // Accumulator bit 4
   SBIT(ACC_5, 0xE0, 5); // Accumulator bit 5
   SBIT(ACC_6, 0xE0, 6); // Accumulator bit 6
   SBIT(ACC_7, 0xE0, 7); // Accumulator bit 7
SFR(B,   0xF0); // B Register
   SBIT(B_0, 0xF0, 0); // Register B bit 0
   SBIT(B_1, 0xF0, 1); // Register B bit 1
   SBIT(B_2, 0xF0, 2); // Register B bit 2
   SBIT(B_3, 0xF0, 3); // Register B bit 3
   SBIT(B_4, 0xF0, 4); // Register B bit 4
   SBIT(B_5, 0xF0, 5); // Register B bit 5
   SBIT(B_6, 0xF0, 6); // Register B bit 6
   SBIT(B_7, 0xF0, 7); // Register B bit 7
SFR(PSW, 0xD0); // Program Status Word
   SBIT(P,   0xD0, 0); // Parity Flag
   SBIT(F1,  0xD0, 1); // User-Defined Flag
   SBIT(OV,  0xD0, 2); // Overflow Flag
   SBIT(RS0, 0xD0, 3); // Register Bank Select 0
   SBIT(RS1, 0xD0, 4); // Register Bank Select 1
   SBIT(F0,  0xD0, 5); // User-Defined Flag
   SBIT(AC,  0xD0, 6); // Auxiliary Carry Flag
   SBIT(CY,  0xD0, 7); // Carry Flag
SFR(SP,  0x81); // Stack Pointer
SFR(DPL, 0x82); // Data Pointer Low
SFR(DPH, 0x83); // Data Pointer High
SFR(IE,  0xA8); // Interrupt Enable
   SBIT(EA,   0xA8, 7); // Global Interrupt Enable
   SBIT(EC,   0xA8, 6); // PCA Interrupt Enable
   SBIT(ET2,  0xA8, 5); // Timer 2 Interrupt Enable
   SBIT(ES,   0xA8, 4); // Serial Interrupt Enable
   SBIT(ET1,  0xA8, 3); // Timer 1 Interrupt Enable
   SBIT(EX1,  0xA8, 2); // External 1 Interrupt Enable
   SBIT(ET0,  0xA8, 1); // Timer 0 Interrupt Enable
   SBIT(EX0,  0xA8, 0); // External 0 Interrupt Enable
SFR(IEA, 0xE8); // Interrupt Enable A
   SBIT(EBO,  0xE8, 3); // Brown-out Interrupt Enable. (Vector is 0x00b4)
SFR(IP,  0xB8); // Interrupt Priority Reg
   SBIT(PPC,  0xB8, 6); // PCA interrupt priority bit
   SBIT(PT2,  0xB8, 5); // Timer 2 interrupt priority bit
   SBIT(PS,   0xB8, 4); // Serial Port interrupt priority bit
   SBIT(PT1,  0xB8, 3); // Timer 1 interrupt priority bit
   SBIT(PX1,  0xB8, 2); // External interrupt 1 priority bit
   SBIT(PT0,  0xB8, 1); // Timer 0 interrupt priority bit
   SBIT(PX0,  0xB8, 0); // External interrupt 0 priority bit
SFR(IPH, 0xB7); // Interrupt Priority Reg High
   #define PPCH 0x40   // PCA Interrupt Priority High Bit
   #define PT2H 0x20   // Timer 2 Interrupt Interrupt Priority High Bit
   #define PSH  0x10   // Serial Port Interrupt Priority High Bit
   #define PT1H 0x08   // Timer 1 Interrupt Priority High Bit
   #define PX1H 0x04   // External Interrupt 1 Priority High Bit
   #define PT0H 0x02   // Timer 0 Interrupt Priority High Bit
   #define PX0H 0x01   // External Interrupt 0 Priority High Bit
SFR(IP1, 0xF8); // Interrupt Priority Reg A
   SBIT(PBO, 0xF8, 4);   // Brown-out interrupt priority bit
   SBIT(PX2, 0xF8, 1);   // External Interrupt 2 priority bit
   SBIT(PX3, 0xF8, 2);   // External Interrupt 3 priority bit
SFR(IP1H, 0xF7); // Interrupt Priority Reg A High
   #define PBOH 0x08   // Brown-out Interrupt priority bit high
   #define PX2H 0x02   // External Interrupt 2 priority bit high
   #define PX3H 0x04   // External Interrupt 3 priority bit high
SFR(PCON, 0x87); // Power Control
   #define SMOD1 0x80  // Double Baud rate bit
   #define SMOD0 0x40  // FE/SM0 Selection bit
   #define BOF   0x20  // Brown-out detection status bit
   #define POF   0x10  // Power-on reset status bit
   #define GF1   0x08  // General-purpose flag bit
   #define GF0   0x04  // General-purpose flag bit
   #define PD    0x02  // Power-down bit
   #define IDL   0x01  // Idle mode bit
SFR(AUXR, 0x8E); // Auxiliary Reg
   #define EXTRAM 0x02 // Internal/External RAM access
   #define AO     0x01 // Disable/Enable ALE
SFR(AUXR1, 0xA2); // Auxiliary Reg 1
   #define GF2    0x08 // General purpose user-defined flag
   #define DPS    0x01 // DPTR registers select bit
SFR(XICON, 0xAE); // External Interrupt Control
   #define EX2 0x04
   #define IE2 0x02
   #define IT2 0x01
   #define EX3 0x40
   #define IE3 0x20
   #define IT3 0x10

// TABLE 3-6: Flash Memory Programming SFRs

SFR(SFCF, 0xB1); // SuperFlash Configuration
   #define IAPEN  0x40 // Enable IAP operation
   #define SWR    0x02 // Software Reset
   #define BSEL   0x01 // Program memory block switching bit
SFR(SFCM, 0xB2); // SuperFlash Command
   #define FIE                 0x80 // Flash Interrupt Enable
   #define CHIP_ERASE          0x01
   #define SECTOR_ERASE        0x0B
   #define BLOCK_ERASE         0x0D
   #define BYTE_VERIFY         0x0C
   #define BYTE_PROGRAM        0x0E
   #define PROG_SB1            0x0F
   #define PROG_SB2            0x03
   #define PROG_SB3            0x05
   #define PROG_SC0            0x09
   #define ENABLE_CLOCK_DOUBLE 0x08
SFR(SFAL, 0xB3); // SuperFlash Address Low Register - A7 to A0
SFR(SFAH, 0xB4); // SuperFlash Address High Register - A15 to A8
SFR(SFDT, 0xB5); // SuperFlash Data Register
SFR(SFST, 0xB6); // SuperFlash Status
   #define SB1_i      0x80 // Security Bit 1 status (inverse of SB1 bit)
   #define SB2_i      0x40 // Security Bit 2 status (inverse of SB2 bit)
   #define SB3_i      0x20 // Security Bit 3 status (inverse of SB3 bit)
   #define EDC_i      0x08 // Double Clock Status
   #define FLASH_BUSY 0x04 // Flash operation completion polling bit

// TABLE 3-7: Watchdog Timer SFRs

SFR(WDTC, 0xC0); // Watchdog Timer Control
   SBIT(WDOUT, 0xC0, 4); // Watchdog output enable
   SBIT(WDRE,  0xC0, 3); // Watchdog timer reset enable
   SBIT(WDTS,  0xC0, 2); // Watchdog timer reset flag
   SBIT(WDT,   0xC0, 1); // Watchdog timer refresh
   SBIT(SWDT,  0xC0, 0); // Start watchdog timer
SFR(WDTD, 0x85); // Watchdog Timer Data/Reload

// TABLE 3-8: Timer/Counters SFRs

SFR(TMOD,   0x89); // Timer/Counter Mode Control GATE C/T# M1 M0 GATE C/T# M1 M0
   #define GATE1 0x80 // External enable for timer 1
   #define C_T1  0x40 // Timer or counter select for timer 1
   #define M1_1  0x20 // Operation mode bit 1 for timer 1
   #define M0_1  0x10 // Operation mode bit 0 for timer 1
   #define GATE0 0x08 // External enable for timer 0
   #define C_T0  0x04 // Timer or counter select for timer 0
   #define M1_0  0x02 // Operation mode bit 1 for timer 0
   #define M0_0  0x01 // Operation mode bit 0 for timer 0
SFR(TCON,   0x88); // Timer/Counter Control  TF1 TR1 TF0 TR0 IE1 IT1 IE0 IT0
   SBIT(TF1, 0x88, 7); // Timer 1 overflow flag
   SBIT(TR1, 0x88, 6); // Timer 1 run control flag
   SBIT(TF0, 0x88, 5); // Timer 0 overflow flag
   SBIT(TR0, 0x88, 4); // Timer 0 run control flag
   SBIT(IE1, 0x88, 3); // Interrupt 1 flag
   SBIT(IT1, 0x88, 2); // Interrupt 1 type control bit
   SBIT(IE0, 0x88, 1); // Interrupt 0 flag
   SBIT(IT0, 0x88, 0); // Interrupt 0 type control bit
SFR(TH0,   0x8C); // Timer 0 MSB
SFR(TL0,   0x8A); // Timer 0 LSB
SFR(TH1,   0x8D); // Timer 1 MSB
SFR(TL1,   0x8B); // Timer 1 LSB
SFR(T2CON, 0xC8); // Timer / Counter 2 Control
   SBIT(TF2,   0xC8, 7); // Timer 2 overflow flag
   SBIT(EXF2,  0xC8, 6); // Timer 2 external flag
   SBIT(RCLK,  0xC8, 5); // Receive clock flag
   SBIT(TCLK,  0xC8, 4); // Transmit clock flag
   SBIT(EXEN2, 0xC8, 3); // Timer 2 external enable flag
   SBIT(TR2,   0xC8, 2); // Start/stop control for timer 2
   SBIT(C_T2,  0xC8, 1); // Timer or coutner select
   SBIT(CP_RL2,0xC8, 0); // Capture/reload flag
SFR(T2MOD,  0xC9); // Timer 2 Mode Control
   #define DCEN  0x02 // Down count enable bit
   #define T2OE  0x01 // Timer 2 output enable bit
SFR(TH2,    0xCD); // Timer 2 MSB
SFR(TL2,    0xCC); // Timer 2 LSB
SFR(RCAP2H, 0xCB); // Timer 2 Capture MSB
SFR(RCAP2L, 0xCA); // Timer 2 Capture LSB

// TABLE 3-9: Interface SFRs

SFR(SBUF, 0x99); // Serial Data Buffer
SFR(SCON, 0x98); // Serial Port Control
   SBIT(FE,  0x98, 7); // Framing Error when reading, SM0 when writing
   SBIT(SM0, 0x98, 7); // Serial Port Mode Bit 0
   SBIT(SM1, 0x98, 6); // Serial Port Mode Bit 1
   SBIT(SM2, 0x98, 5); // Serial Port Mode Bit 2
   SBIT(REN, 0x98, 4); // Enables serial reception
   SBIT(TB8, 0x98, 3); // The 9th data bit that will be transmitted in Modes 2 and 3
   SBIT(RB8, 0x98, 2); // In Modes 2 and 3, the 9th data bit that was received
   SBIT(TI,  0x98, 1); // Transmit interrupt flag
   SBIT(RI,  0x98, 0); // Receive interrupt flag
SFR(SADDR, 0xA9); // Slave Address
SFR(SADEN, 0xB9); // Slave Address Mask
SFR(SPCR,  0xD5); // SPI Control Register
   #define SPIE 0x80 // If both SPIE and ES are set to one, SPI interrupts are enabled
   #define SPE  0x40 // SPI enable bit.  When set enables SPI
   #define DORD 0x20 // Data trans. order. 0=MSB first; 1=LSB first
   #define MSTR 0x10 // 1=master mode.  0=slave mode
   #define CPOL 0x08 // 1=SCK is high when idle (active low), 0=SCK is low when idle (active high)
   #define CPHA 0x04 // 1=shift triggered on the trailing edge of SCK.  0=shift trig. on leading edge
   #define SPR1 0x02 // SPI Clork Rate select bit 1
   #define SPR0 0x01 // SPI Clork Rate select bit 0
                     // 00 = Fosc/4
                     // 01 = Fosc/16
                     // 10 = Fosc/64
                     // 11 = Fosc/128
SFR(SPSR, 0xAA); // SPI Status Register
   #define SPIF 0x80 // SPI interrupt flag
   #define WCOL 0x40 // Write collision Flag
SFR(SPDR, 0x86); // SPI Data Register
SFR(P0, 0x80); // Port 0
   SBIT(P0_0, 0x80, 0); // Port 0 bit 0
   SBIT(P0_1, 0x80, 1); // Port 0 bit 1
   SBIT(P0_2, 0x80, 2); // Port 0 bit 2
   SBIT(P0_3, 0x80, 3); // Port 0 bit 3
   SBIT(P0_4, 0x80, 4); // Port 0 bit 4
   SBIT(P0_5, 0x80, 5); // Port 0 bit 5
   SBIT(P0_6, 0x80, 6); // Port 0 bit 6
   SBIT(P0_7, 0x80, 7); // Port 0 bit 7
SFR(P1, 0x90); // Port 1
   SBIT(P1_0, 0x90, 0); // Port 1 bit 0
   SBIT(P1_1, 0x90, 1); // Port 1 bit 1
   SBIT(P1_2, 0x90, 2); // Port 1 bit 2
   SBIT(P1_3, 0x90, 3); // Port 1 bit 3
   SBIT(P1_4, 0x90, 4); // Port 1 bit 4
   SBIT(P1_5, 0x90, 5); // Port 1 bit 5
   SBIT(P1_6, 0x90, 6); // Port 1 bit 6
   SBIT(P1_7, 0x90, 7); // Port 1 bit 7
   // Alternate names
   SBIT(T2,   0x90, 0); // Port 1 bit 0
   SBIT(T2EX, 0x90, 1); // Port 1 bit 1
   SBIT(ECI,  0x90, 2); // Port 1 bit 2
   SBIT(CEX0, 0x90, 3); // Port 1 bit 3
   SBIT(CEX1, 0x90, 4); // Port 1 bit 4
   SBIT(CEX2, 0x90, 5); // Port 1 bit 5
   SBIT(CEX3, 0x90, 6); // Port 1 bit 6
   SBIT(CEX4, 0x90, 7); // Port 1 bit 7
   // More alternate names
   SBIT(SS,   0x90, 4); // Port 1 bit 4
   SBIT(MOSI, 0x90, 5); // Port 1 bit 5
   SBIT(MISO, 0x90, 6); // Port 1 bit 6
   SBIT(SCK,  0x90, 7); // Port 1 bit 7
SFR(P2, 0xA0); // Port 2
   SBIT(P2_0, 0xA0, 0); // Port 2 bit 0
   SBIT(P2_1, 0xA0, 1); // Port 2 bit 1
   SBIT(P2_2, 0xA0, 2); // Port 2 bit 2
   SBIT(P2_3, 0xA0, 3); // Port 2 bit 3
   SBIT(P2_4, 0xA0, 4); // Port 2 bit 4
   SBIT(P2_5, 0xA0, 5); // Port 2 bit 5
   SBIT(P2_6, 0xA0, 6); // Port 2 bit 6
   SBIT(P2_7, 0xA0, 7); // Port 2 bit 7
SFR(P3, 0xB0); // Port 3
   SBIT(P3_0, 0xB0, 0); // Port 2 bit 0
   SBIT(P3_1, 0xB0, 1); // Port 2 bit 1
   SBIT(P3_2, 0xB0, 2); // Port 2 bit 2
   SBIT(P3_3, 0xB0, 3); // Port 2 bit 3
   SBIT(P3_4, 0xB0, 4); // Port 2 bit 4
   SBIT(P3_5, 0xB0, 5); // Port 2 bit 5
   SBIT(P3_6, 0xB0, 6); // Port 2 bit 6
   SBIT(P3_7, 0xB0, 7); // Port 2 bit 7
   // Alternate names
   SBIT(RXD,  0xB0, 0); // Port 2 bit 0
   SBIT(TXD,  0xB0, 1); // Port 2 bit 1
   SBIT(INT0, 0xB0, 2); // Port 2 bit 2
   SBIT(INT1, 0xB0, 3); // Port 2 bit 3
   SBIT(T0,   0xB0, 4); // Port 2 bit 4
   SBIT(T1,   0xB0, 5); // Port 2 bit 5
   SBIT(WR,   0xB0, 6); // Port 2 bit 6
   SBIT(RD,   0xB0, 7); // Port 2 bit 7
SFR(P4, 0xA5); // Port 4 - not bit addressable
   #define P4_0 0x01
   #define P4_1 0x02
   #define P4_2 0x04
   #define P4_3 0x08

// TABLE 3-10: PCA SFRs

SFR(CH, 0xF9); // PCA Timer/Counter High
SFR(CL, 0xE9); // PCA Timer/Counter Low
SFR(CCON, 0xD8); // PCA Timer/Counter Control Register  CF CR - CCF4 CCF3 CCF2 CCF1 CCF0 00x00000b
   SBIT(CF,   0xD8, 7); // PCA Counter overflow flag
   SBIT(CR,   0xD8, 6); // PCA Counter Run Control Bit
   SBIT(CCF4, 0xD8, 4); // PCA Module 4 Interrupt Flag
   SBIT(CCF3, 0xD8, 3); // PCA Module 3 Interrupt Flag
   SBIT(CCF2, 0xD8, 2); // PCA Module 2 Interrupt Flag
   SBIT(CCF1, 0xD8, 1); // PCA Module 1 Interrupt Flag
   SBIT(CCF0, 0xD8, 0); // PCA Module 0 Interrupt Flag
SFR(CMOD, 0xD9); // PCA Timer/Counter Mode Register
   #define CIDL 0x80 // CIDL=0 program the PCA counter to work during idle mode
   #define WDTE 0x40 // Watchdog Timer Enable
   #define CPS1 0x04 // PCA Count Pulse Select bit 1
   #define CPS0 0x02 // PCA Count Pulse Select bit 0
                     // 00=Internal clock, Fosc/6
                     // 01=Internal clock, Fosc/6
                     // 10=Timer 0 overflow
                     // 11=External clock at ECI/P1.2 pin (max rate=Fosc/4)
   #define ECF 0x01  // PCA Enable Counter Overflow Interrupt
SFR(CCAP0H, 0xFA); // PCA Module 0 Compare/Capture Register High
SFR(CCAP0L, 0xEA); // PCA Module 0 Compare/Capture Register Low
SFR(CCAP1H, 0xFB); // PCA Module 1 Compare/Capture Register High
SFR(CCAP1L, 0xEB); // PCA Module 1 Compare/Capture Register Low
SFR(CCAP2H, 0xFC); // PCA Module 2 Compare/Capture Register High
SFR(CCAP2L, 0xEC); // PCA Module 2 Compare/Capture Register Low
SFR(CCAP3H, 0xFD); // PCA Module 3 Compare/Capture Register High
SFR(CCAP3L, 0xED); // PCA Module 3 Compare/Capture Register Low
SFR(CCAP4H, 0xFE); // PCA Module 4 Compare/Capture Register High
SFR(CCAP4L, 0xEE); // PCA Module 4 Compare/Capture Register Low
SFR(CCAPM0, 0xDA); // PCA Compare/Capture Module 0 Mode Register
SFR(CCAPM1, 0xDB); // PCA Compare/Capture Module 1 Mode Register
SFR(CCAPM2, 0xDC); // PCA Compare/Capture Module 2 Mode Register
SFR(CCAPM3, 0xDD); // PCA Compare/Capture Module 3 Mode Register
SFR(CCAPM4, 0xDE); // PCA Compare/Capture Module 4 Mode Register
// The preceding five registers have the following bits:
   #define ECOM 0x40 // Enable Comparator
   #define CAPP 0x20 // 1=enables positive edge capture
   #define CAPN 0x10 // 1=enables negative edge capture
   #define MAT  0x08 // When counter matches sets CCFn bit causing and interrupt
   #define TOG  0x04 // Toggle output on match
   #define PWM  0x02 // Pulse width modulation mode
   #define ECCF 0x01 // Enable CCF interrupt

#endif /*REG_SST89x5xRDx_H*/
/*-------------------------------------------------------------------------
   C8051F060.h - Register Declarations for the Cygnal/SiLabs C8051F06x
   Processor Range

   Copyright (C) 2004, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef C8051F060_H
#define C8051F060_H


/*  BYTE Registers  */

/*  All Pages */
__sfr __at 0x80 P0       ;  /* PORT 0                                        */
__sfr __at 0x81 SP       ;  /* STACK POINTER                                 */
__sfr __at 0x82 DPL      ;  /* DATA POINTER - LOW BYTE                       */
__sfr __at 0x83 DPH      ;  /* DATA POINTER - HIGH BYTE                      */
__sfr __at 0x84 SFRPAGE  ;  /* SFR PAGE SELECT                               */
__sfr __at 0x85 SFRNEXT  ;  /* SFR STACK NEXT PAGE                           */
__sfr __at 0x86 SFRLAST  ;  /* SFR STACK LAST PAGE                           */
__sfr __at 0x87 PCON     ;  /* POWER CONTROL                                 */
__sfr __at 0x90 P1       ;  /* PORT 1                                        */
__sfr __at 0xA0 P2       ;  /* PORT 2                                        */
__sfr __at 0xA8 IE       ;  /* INTERRUPT ENABLE                              */
__sfr __at 0xB0 P3       ;  /* PORT 3                                        */
__sfr __at 0xB8 IP       ;  /* INTERRUPT PRIORITY                            */
__sfr __at 0xD0 PSW      ;  /* PROGRAM STATUS WORD                           */
__sfr __at 0xE0 ACC      ;  /* ACCUMULATOR                                   */
__sfr __at 0xE6 EIE1     ;  /* EXTERNAL INTERRUPT ENABLE 1                   */
__sfr __at 0xE7 EIE2     ;  /* EXTERNAL INTERRUPT ENABLE 2                   */
__sfr __at 0xF0 B        ;  /* B REGISTER                                    */
__sfr __at 0xF6 EIP1     ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 1        */
__sfr __at 0xF7 EIP2     ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 2        */
__sfr __at 0xFF WDTCN    ;  /* WATCHDOG TIMER CONTROL                        */

/*  Page 0x00 */
__sfr __at 0x88 TCON     ;  /* TIMER CONTROL                                 */
__sfr __at 0x89 TMOD     ;  /* TIMER MODE                                    */
__sfr __at 0x8A TL0      ;  /* TIMER 0 - LOW BYTE                            */
__sfr __at 0x8B TL1      ;  /* TIMER 1 - LOW BYTE                            */
__sfr __at 0x8C TH0      ;  /* TIMER 0 - HIGH BYTE                           */
__sfr __at 0x8D TH1      ;  /* TIMER 1 - HIGH BYTE                           */
__sfr __at 0x8E CKCON    ;  /* TIMER 0/1 CLOCK CONTROL                       */
__sfr __at 0x8F PSCTL    ;  /* FLASH WRITE/ERASE CONTROL                     */
__sfr __at 0x91 SSTA0    ;  /* UART 0 STATUS                                 */
__sfr __at 0x98 SCON0    ;  /* UART 0 CONTROL                                */
__sfr __at 0x98 SCON     ;  /* UART 0 CONTROL                                */
__sfr __at 0x99 SBUF0    ;  /* UART 0 BUFFER                                 */
__sfr __at 0x99 SBUF     ;  /* UART 0 BUFFER                                 */
__sfr __at 0x9A SPI0CFG  ;  /* SPI 0 CONFIGURATION                           */
__sfr __at 0x9B SPI0DAT  ;  /* SPI 0 DATA                                    */
__sfr __at 0x9D SPI0CKR  ;  /* SPI 0 CLOCK RATE CONTROL                      */
__sfr __at 0xA1 EMI0TC   ;  /* EMIF TIMING CONTROL                           */
__sfr __at 0xA2 EMI0CN   ;  /* EMIF CONTROL                                  */
__sfr __at 0xA2 _XPAGE   ;  /* XDATA/PDATA PAGE                              */
__sfr __at 0xA3 EMI0CF   ;  /* EMIF CONFIGURATION                            */
__sfr __at 0xA9 SADDR0   ;  /* UART 0 SLAVE ADDRESS                          */
__sfr __at 0xB7 FLSCL    ;  /* FLASH SCALE                                   */
__sfr __at 0xB9 SADEN0   ;  /* UART 0 SLAVE ADDRESS MASK                     */
__sfr __at 0xBB AMX0SL   ;  /* ADC 0 MUX CHANNEL SELECTION                   */
__sfr __at 0xBC ADC0CF   ;  /* ADC 0 CONFIGURATION                           */
__sfr __at 0xBE ADC0L    ;  /* ADC 0 DATA - LOW BYTE                         */
__sfr __at 0xBF ADC0H    ;  /* ADC 0 DATA - HIGH BYTE                        */
__sfr __at 0xC0 SMB0CN   ;  /* SMBUS 0 CONTROL                               */
__sfr __at 0xC1 SMB0STA  ;  /* SMBUS 0 STATUS                                */
__sfr __at 0xC2 SMB0DAT  ;  /* SMBUS 0 DATA                                  */
__sfr __at 0xC3 SMB0ADR  ;  /* SMBUS 0 SLAVE ADDRESS                         */
__sfr __at 0xC4 ADC0GTL  ;  /* ADC 0 GREATER-THAN REGISTER - LOW BYTE        */
__sfr __at 0xC5 ADC0GTH  ;  /* ADC 0 GREATER-THAN REGISTER - HIGH BYTE       */
__sfr __at 0xC6 ADC0LTL  ;  /* ADC 0 LESS-THAN REGISTER - LOW BYTE           */
__sfr __at 0xC7 ADC0LTH  ;  /* ADC 0 LESS-THAN REGISTER - HIGH BYTE          */
__sfr __at 0xC8 TMR2CN   ;  /* TIMER 2 CONTROL                               */
__sfr __at 0xC9 TMR2CF   ;  /* TIMER 2 CONFIGURATION                         */
__sfr __at 0xCA RCAP2L   ;  /* TIMER 2 CAPTURE REGISTER - LOW BYTE           */
__sfr __at 0xCB RCAP2H   ;  /* TIMER 2 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at 0xCC TMR2L    ;  /* TIMER 2 - LOW BYTE                            */
__sfr __at 0xCC TL2      ;  /* TIMER 2 - LOW BYTE                            */
__sfr __at 0xCD TMR2H    ;  /* TIMER 2 - HIGH BYTE                           */
__sfr __at 0xCD TH2      ;  /* TIMER 2 - HIGH BYTE                           */
__sfr __at 0xCF SMB0CR   ;  /* SMBUS 0 CLOCK RATE                            */
__sfr __at 0xD1 REF0CN   ;  /* VOLTAGE REFERENCE 0 CONTROL                   */
__sfr __at 0xD2 DAC0L    ;  /* DAC 0 REGISTER - LOW BYTE                     */
__sfr __at 0xD3 DAC0H    ;  /* DAC 0 REGISTER - HIGH BYTE                    */
__sfr __at 0xD4 DAC0CN   ;  /* DAC 0 CONTROL                                 */
__sfr __at 0xD8 PCA0CN   ;  /* PCA 0 COUNTER CONTROL                         */
__sfr __at 0xD9 PCA0MD   ;  /* PCA 0 COUNTER MODE                            */
__sfr __at 0xDA PCA0CPM0 ;  /* PCA 0 MODULE 0 CONTROL                        */
__sfr __at 0xDB PCA0CPM1 ;  /* PCA 0 MODULE 1 CONTROL                        */
__sfr __at 0xDC PCA0CPM2 ;  /* PCA 0 MODULE 2 CONTROL                        */
__sfr __at 0xDD PCA0CPM3 ;  /* PCA 0 MODULE 3 CONTROL                        */
__sfr __at 0xDE PCA0CPM4 ;  /* PCA 0 MODULE 4 CONTROL                        */
__sfr __at 0xDF PCA0CPM5 ;  /* PCA 0 MODULE 5 CONTROL                        */
__sfr __at 0xE1 PCA0CPL5 ;  /* PCA 0 MODULE 5 CAPTURE/COMPARE - LOW BYTE     */
__sfr __at 0xE2 PCA0CPH5 ;  /* PCA 0 MODULE 5 CAPTURE/COMPARE - HIGH BYTE    */
__sfr __at 0xE8 ADC0CN   ;  /* ADC 0 CONTROL                                 */
__sfr __at 0xE9 PCA0CPL2 ;  /* PCA 0 MODULE 2 CAPTURE/COMPARE - LOW BYTE     */
__sfr __at 0xEA PCA0CPH2 ;  /* PCA 0 MODULE 2 CAPTURE/COMPARE - HIGH BYTE    */
__sfr __at 0xEB PCA0CPL3 ;  /* PCA 0 MODULE 3 CAPTURE/COMPARE - LOW BYTE     */
__sfr __at 0xEC PCA0CPH3 ;  /* PCA 0 MODULE 3 CAPTURE/COMPARE - HIGH BYTE    */
__sfr __at 0xED PCA0CPL4 ;  /* PCA 0 MODULE 4 CAPTURE/COMPARE - LOW BYTE     */
__sfr __at 0xEE PCA0CPH4 ;  /* PCA 0 MODULE 4 CAPTURE/COMPARE - HIGH BYTE    */
__sfr __at 0xEF RSTSRC   ;  /* RESET SOURCE                                  */
__sfr __at 0xF8 SPI0CN   ;  /* SPI 0 CONTROL                                 */
__sfr __at 0xF9 PCA0L    ;  /* PCA 0 TIMER - LOW BYTE                        */
__sfr __at 0xFA PCA0H    ;  /* PCA 0 TIMER - HIGH BYTE                       */
__sfr __at 0xFB PCA0CPL0 ;  /* PCA 0 MODULE 0 CAPTURE/COMPARE - LOW BYTE     */
__sfr __at 0xFC PCA0CPH0 ;  /* PCA 0 MODULE 0 CAPTURE/COMPARE - HIGH BYTE    */
__sfr __at 0xFD PCA0CPL1 ;  /* PCA 0 MODULE 1 CAPTURE/COMPARE - LOW BYTE     */
__sfr __at 0xFE PCA0CPH1 ;  /* PCA 0 MODULE 1 CAPTURE/COMPARE - HIGH BYTE    */

/*  Page 0x01 */
__sfr __at 0x88 CPT0CN   ;  /* COMPARATOR 0 CONTROL                          */
__sfr __at 0x89 CPT0MD   ;  /* COMPARATOR 0 CONFIGURATION                    */
__sfr __at 0x98 SCON1    ;  /* UART 1 CONTROL                                */
__sfr __at 0x99 SBUF1    ;  /* UART 1 BUFFER                                 */
__sfr __at 0xBC ADC1CF   ;  /* ADC 1 CONFIGURATION                           */
__sfr __at 0xBE ADC1L    ;  /* ADC 1 DATA - LOW BYTE                         */
__sfr __at 0xBF ADC1H    ;  /* ADC 1 DATA - HIGH BYTE                        */
__sfr __at 0xC0 CAN0STA  ;  /* CAN 0 STATUS                                  */
__sfr __at 0xC8 TMR3CN   ;  /* TIMER 3 CONTROL                               */
__sfr __at 0xC9 TMR3CF   ;  /* TIMER 3 CONFIGURATION                         */
__sfr __at 0xCA RCAP3L   ;  /* TIMER 3 CAPTURE REGISTER - LOW BYTE           */
__sfr __at 0xCB RCAP3H   ;  /* TIMER 3 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at 0xCC TMR3L    ;  /* TIMER 3 - LOW BYTE                            */
__sfr __at 0xCD TMR3H    ;  /* TIMER 3 - HIGH BYTE                           */
__sfr __at 0xD1 REF1CN   ;  /* VOLTAGE REFERENCE 1 CONTROL                   */
__sfr __at 0xD2 DAC1L    ;  /* DAC 1 REGISTER - LOW BYTE                     */
__sfr __at 0xD3 DAC1H    ;  /* DAC 1 REGISTER - HIGH BYTE                    */
__sfr __at 0xD4 DAC1CN   ;  /* DAC 1 CONTROL                                 */
__sfr __at 0xD8 CAN0DATL ;  /* CAN 0 DATA REGISTER LOW                       */
__sfr __at 0xD9 CAN0DATH ;  /* CAN 0 DATA REGISTER HIGH                      */
__sfr __at 0xDA CAN0ADR  ;  /* CAN 0 ADDRESS                                 */
__sfr __at 0xDB CAN0TST  ;  /* CAN 0 TEST REGISTER                           */
__sfr __at 0xE8 ADC1CN   ;  /* ADC 1 CONTROL                                 */
__sfr __at 0xF8 CAN0CN   ;  /* CAN 0 CONTROL                                 */

/*  Page 0x02 */
__sfr __at 0x88 CPT1CN   ;  /* COMPARATOR 1 CONTROL                          */
__sfr __at 0x89 CPT1MD   ;  /* COMPARATOR 1 CONFIGURATION                    */
__sfr __at 0xBA AMX2CF   ;  /* ADC 2 MUX CONFIGURATION                       */
__sfr __at 0xBB AMX2SL   ;  /* ADC 2 MUX CHANNEL SELECTION                   */
__sfr __at 0xBC ADC2CF   ;  /* ADC 2 CONFIGURATION                           */
__sfr __at 0xBE ADC2L    ;  /* ADC 2 DATA - LOW BYTE                         */
__sfr __at 0xBF ADC2H    ;  /* ADC 2 DATA - HIGH BYTE                        */
__sfr __at 0xC4 ADC2GTL  ;  /* ADC 2 GREATER-THAN REGISTER - LOW BYTE        */
__sfr __at 0xC5 ADC2GTH  ;  /* ADC 2 GREATER-THAN REGISTER - HIGH BYTE       */
__sfr __at 0xC6 ADC2LTL  ;  /* ADC 2 LESS-THAN REGISTER - LOW BYTE           */
__sfr __at 0xC7 ADC2LTH  ;  /* ADC 2 LESS-THAN REGISTER - HIGH BYTE          */
__sfr __at 0xC8 TMR4CN   ;  /* TIMER 4 CONTROL                               */
__sfr __at 0xC9 TMR4CF   ;  /* TIMER 4 CONFIGURATION                         */
__sfr __at 0xCA RCAP4L   ;  /* TIMER 4 CAPTURE REGISTER - LOW BYTE           */
__sfr __at 0xCB RCAP4H   ;  /* TIMER 4 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at 0xCC TMR4L    ;  /* TIMER 4 - LOW BYTE                            */
__sfr __at 0xCD TMR4H    ;  /* TIMER 4 - HIGH BYTE                           */
__sfr __at 0xD1 REF2CN   ;  /* VOLTAGE REFERENCE 2 CONTROL                   */
__sfr __at 0xE8 ADC2CN   ;  /* ADC 2 CONTROL                                 */

/*  Page 0x03 */
__sfr __at 0x88 CPT2CN   ;  /* COMPARATOR 2 CONTROL                          */
__sfr __at 0x89 CPT2MD   ;  /* COMPARATOR 2 CONFIGURATION                    */
__sfr __at 0xD8 DMA0CN   ;  /* DMA0 CONTROL                                  */
__sfr __at 0xD9 DMA0DAL  ;  /* DMA0 DATA ADDRESS BEGINNING LOW BYTE          */
__sfr __at 0xDA DMA0DAH  ;  /* DMA0 DATA ADDRESS BEGINNING HIGH BYTE         */
__sfr __at 0xDB DMA0DSL  ;  /* DMA0 DATA ADDRESS POINTER LOW BYTE            */
__sfr __at 0xDC DMA0DSH  ;  /* DMA0 DATA ADDRESS POINTER HIGH BYTE           */
__sfr __at 0xDD DMA0IPT  ;  /* DMA0 INSTRUCTION WRITE ADDRESS                */
__sfr __at 0xDE DMA0IDT  ;  /* DMA0 INSTRUCTION WRITE DATA                   */
__sfr __at 0xF8 DMA0CF   ;  /* DMA0 CONFIGURATION                            */
__sfr __at 0xF9 DMA0CTL  ;  /* DMA0 REPEAT COUNTER LIMIT LOW BYTE            */
__sfr __at 0xFA DMA0CTH  ;  /* DMA0 REPEAT COUNTER LIMIT HIGH BYTE           */
__sfr __at 0xFB DMA0CSL  ;  /* DMA0 REPEAT COUNTER STATUS LOW BYTE           */
__sfr __at 0xFC DMA0CSH  ;  /* DMA0 REPEAT COUNTER STATUS HIGH BYTE          */
__sfr __at 0xFD DMA0BND  ;  /* DMA0 INSTRUCTION BOUNDARY                     */
__sfr __at 0xFE DMA0ISW  ;  /* DMA0 INSTRUCTION STATUS                       */

/*  Page 0x0F */
__sfr __at 0x8A OSCICN   ;  /* INTERNAL OSCILLATOR CONTROL                   */
__sfr __at 0x8B OSCICL   ;  /* INTERNAL OSCILLATOR CALIBRATION               */
__sfr __at 0x8C OSCXCN   ;  /* EXTERNAL OSCILLATOR CONTROL                   */
__sfr __at 0x96 SFRPGCN  ;  /* SFR PAGE CONTROL                              */
__sfr __at 0x97 CLKSEL   ;  /* SYSTEM CLOCK SELECT                           */
__sfr __at 0x9C P4MDOUT  ;  /* PORT 4 OUTPUT MODE                            */
__sfr __at 0x9D P5MDOUT  ;  /* PORT 5 OUTPUT MODE                            */
__sfr __at 0x9E P6MDOUT  ;  /* PORT 6 OUTPUT MODE                            */
__sfr __at 0x9F P7MDOUT  ;  /* PORT 7 OUTPUT MODE                            */
__sfr __at 0xA4 P0MDOUT  ;  /* PORT 0 OUTPUT MODE                            */
__sfr __at 0xA5 P1MDOUT  ;  /* PORT 1 OUTPUT MODE                            */
__sfr __at 0xA6 P2MDOUT  ;  /* PORT 2 OUTPUT MODE CONFIGURATION              */
__sfr __at 0xA7 P3MDOUT  ;  /* PORT 3 OUTPUT MODE CONFIGURATION              */
__sfr __at 0xAD P1MDIN   ;  /* PORT 1 INPUT MODE                             */
__sfr __at 0xAE P2MDIN   ;  /* PORT 2 INPUT MODE                             */
__sfr __at 0xB7 FLACL    ;  /* FLASH ACCESS LIMIT                            */
__sfr __at 0xBA ADC0CPT  ;  /* ADC0 CALIBRATION POINTER                      */
__sfr __at 0xBB ADC0CCF  ;  /* ADC0 CALIBRATION COEFFICIENT                  */
__sfr __at 0xC8 P4       ;  /* PORT 4                                        */
__sfr __at 0xD8 P5       ;  /* PORT 5                                        */
__sfr __at 0xE1 XBR0     ;  /* CROSSBAR CONFIGURATION REGISTER 0             */
__sfr __at 0xE2 XBR1     ;  /* CROSSBAR CONFIGURATION REGISTER 1             */
__sfr __at 0xE3 XBR2     ;  /* CROSSBAR CONFIGURATION REGISTER 2             */
__sfr __at 0xE4 XBR3     ;  /* CROSSBAR CONFIGURATION REGISTER 3             */
__sfr __at 0xE8 P6       ;  /* PORT 6                                        */
__sfr __at 0xF8 P7       ;  /* PORT 7                                        */


/*  BIT Registers  */

/*  P0  0x80 */
__sbit __at 0x80 P0_0    ;
__sbit __at 0x81 P0_1    ;
__sbit __at 0x82 P0_2    ;
__sbit __at 0x83 P0_3    ;
__sbit __at 0x84 P0_4    ;
__sbit __at 0x85 P0_5    ;
__sbit __at 0x86 P0_6    ;
__sbit __at 0x87 P0_7    ;

/*  TCON  0x88 */
__sbit __at 0x88 IT0     ;  /* EXT. INTERRUPT 0 TYPE                         */
__sbit __at 0x89 IE0     ;  /* EXT. INTERRUPT 0 EDGE FLAG                    */
__sbit __at 0x8A IT1     ;  /* EXT. INTERRUPT 1 TYPE                         */
__sbit __at 0x8B IE1     ;  /* EXT. INTERRUPT 1 EDGE FLAG                    */
__sbit __at 0x8C TR0     ;  /* TIMER 0 ON/OFF CONTROL                        */
__sbit __at 0x8D TF0     ;  /* TIMER 0 OVERFLOW FLAG                         */
__sbit __at 0x8E TR1     ;  /* TIMER 1 ON/OFF CONTROL                        */
__sbit __at 0x8F TF1     ;  /* TIMER 1 OVERFLOW FLAG                         */

/*  CPT0CN  0x88 */
__sbit __at 0x88 CP0HYN0 ;  /* COMPARATOR 0 NEGATIVE HYSTERESIS 0            */
__sbit __at 0x89 CP0HYN1 ;  /* COMPARATOR 0 NEGATIVE HYSTERESIS 1            */
__sbit __at 0x8A CP0HYP0 ;  /* COMPARATOR 0 POSITIVE HYSTERESIS 0            */
__sbit __at 0x8B CP0HYP1 ;  /* COMPARATOR 0 POSITIVE HYSTERESIS 1            */
__sbit __at 0x8C CP0FIF  ;  /* COMPARATOR 0 FALLING EDGE INTERRUPT           */
__sbit __at 0x8D CP0RIF  ;  /* COMPARATOR 0 RISING EDGE INTERRUPT            */
__sbit __at 0x8E CP0OUT  ;  /* COMPARATOR 0 OUTPUT                           */
__sbit __at 0x8F CP0EN   ;  /* COMPARATOR 0 ENABLE                           */

/*  CPT1CN  0x88 */
__sbit __at 0x88 CP1HYN0 ;  /* COMPARATOR 1 NEGATIVE HYSTERESIS 0            */
__sbit __at 0x89 CP1HYN1 ;  /* COMPARATOR 1 NEGATIVE HYSTERESIS 1            */
__sbit __at 0x8A CP1HYP0 ;  /* COMPARATOR 1 POSITIVE HYSTERESIS 0            */
__sbit __at 0x8B CP1HYP1 ;  /* COMPARATOR 1 POSITIVE HYSTERESIS 1            */
__sbit __at 0x8C CP1FIF  ;  /* COMPARATOR 1 FALLING EDGE INTERRUPT           */
__sbit __at 0x8D CP1RIF  ;  /* COMPARATOR 1 RISING EDGE INTERRUPT            */
__sbit __at 0x8E CP1OUT  ;  /* COMPARATOR 1 OUTPUT                           */
__sbit __at 0x8F CP1EN   ;  /* COMPARATOR 1 ENABLE                           */

/*  CPT2CN  0x88 */
__sbit __at 0x88 CP2HYN0 ;  /* COMPARATOR 2 NEGATIVE HYSTERESIS 0            */
__sbit __at 0x89 CP2HYN1 ;  /* COMPARATOR 2 NEGATIVE HYSTERESIS 1            */
__sbit __at 0x8A CP2HYP0 ;  /* COMPARATOR 2 POSITIVE HYSTERESIS 0            */
__sbit __at 0x8B CP2HYP1 ;  /* COMPARATOR 2 POSITIVE HYSTERESIS 1            */
__sbit __at 0x8C CP2FIF  ;  /* COMPARATOR 2 FALLING EDGE INTERRUPT           */
__sbit __at 0x8D CP2RIF  ;  /* COMPARATOR 2 RISING EDGE INTERRUPT            */
__sbit __at 0x8E CP2OUT  ;  /* COMPARATOR 2 OUTPUT                           */
__sbit __at 0x8F CP2EN   ;  /* COMPARATOR 2 ENABLE                           */

/*  P1  0x90 */
__sbit __at 0x90 P1_0    ;
__sbit __at 0x91 P1_1    ;
__sbit __at 0x92 P1_2    ;
__sbit __at 0x93 P1_3    ;
__sbit __at 0x94 P1_4    ;
__sbit __at 0x95 P1_5    ;
__sbit __at 0x96 P1_6    ;
__sbit __at 0x97 P1_7    ;

/*  SCON0  0x98 */
__sbit __at 0x98 RI0     ;  /* UART 0 RX INTERRUPT FLAG                      */
__sbit __at 0x98 RI      ;  /* UART 0 RX INTERRUPT FLAG                      */
__sbit __at 0x99 TI0     ;  /* UART 0 TX INTERRUPT FLAG                      */
__sbit __at 0x99 TI      ;  /* UART 0 TX INTERRUPT FLAG                      */
__sbit __at 0x9A RB80    ;  /* UART 0 RX BIT 8                               */
__sbit __at 0x9B TB80    ;  /* UART 0 TX BIT 8                               */
__sbit __at 0x9C REN0    ;  /* UART 0 RX ENABLE                              */
__sbit __at 0x9C REN     ;  /* UART 0 RX ENABLE                              */
__sbit __at 0x9D SM20    ;  /* UART 0 MULTIPROCESSOR EN                      */
__sbit __at 0x9E SM10    ;  /* UART 0 MODE 1                                 */
__sbit __at 0x9F SM00    ;  /* UART 0 MODE 0                                 */

/*  SCON1  0x98 */
__sbit __at 0x98 RI1     ;  /* UART 1 RX INTERRUPT FLAG                      */
__sbit __at 0x99 TI1     ;  /* UART 1 TX INTERRUPT FLAG                      */
__sbit __at 0x9A RB81    ;  /* UART 1 RX BIT 8                               */
__sbit __at 0x9B TB81    ;  /* UART 1 TX BIT 8                               */
__sbit __at 0x9C REN1    ;  /* UART 1 RX ENABLE                              */
__sbit __at 0x9D MCE1    ;  /* UART 1 MCE                                    */
__sbit __at 0x9F S1MODE  ;  /* UART 1 MODE                                   */

/*  P2  0xA0 */
__sbit __at 0xA0 P2_0    ;
__sbit __at 0xA1 P2_1    ;
__sbit __at 0xA2 P2_2    ;
__sbit __at 0xA3 P2_3    ;
__sbit __at 0xA4 P2_4    ;
__sbit __at 0xA5 P2_5    ;
__sbit __at 0xA6 P2_6    ;
__sbit __at 0xA7 P2_7    ;

/*  IE  0xA8 */
__sbit __at 0xA8 EX0     ;  /* EXTERNAL INTERRUPT 0 ENABLE                   */
__sbit __at 0xA9 ET0     ;  /* TIMER 0 INTERRUPT ENABLE                      */
__sbit __at 0xAA EX1     ;  /* EXTERNAL INTERRUPT 1 ENABLE                   */
__sbit __at 0xAB ET1     ;  /* TIMER 1 INTERRUPT ENABLE                      */
__sbit __at 0xAC ES0     ;  /* UART0 INTERRUPT ENABLE                        */
__sbit __at 0xAC ES      ;  /* UART0 INTERRUPT ENABLE                        */
__sbit __at 0xAD ET2     ;  /* TIMER 2 INTERRUPT ENABLE                      */
__sbit __at 0xAF EA      ;  /* GLOBAL INTERRUPT ENABLE                       */

/*  P3  0xB0 */
__sbit __at 0xB0 P3_0    ;
__sbit __at 0xB1 P3_1    ;
__sbit __at 0xB2 P3_2    ;
__sbit __at 0xB3 P3_3    ;
__sbit __at 0xB4 P3_4    ;
__sbit __at 0xB5 P3_5    ;
__sbit __at 0xB6 P3_6    ;
__sbit __at 0xB7 P3_7    ;

/*  IP  0xB8 */
__sbit __at 0xB8 PX0     ;  /* EXTERNAL INTERRUPT 0 PRIORITY                 */
__sbit __at 0xB9 PT0     ;  /* TIMER 0 PRIORITY                              */
__sbit __at 0xBA PX1     ;  /* EXTERNAL INTERRUPT 1 PRIORITY                 */
__sbit __at 0xBB PT1     ;  /* TIMER 1 PRIORITY                              */
__sbit __at 0xBC PS0     ;  /* SERIAL PORT PRIORITY                          */
__sbit __at 0xBC PS      ;  /* SERIAL PORT PRIORITY                          */
__sbit __at 0xBD PT2     ;  /* TIMER 2 PRIORITY                              */

/*  SMB0CN  0xC0 */
__sbit __at 0xC0 SMBTOE  ;  /* SMBUS 0 TIMEOUT ENABLE                        */
__sbit __at 0xC1 SMBFTE  ;  /* SMBUS 0 FREE TIMER ENABLE                     */
__sbit __at 0xC2 AA      ;  /* SMBUS 0 ASSERT/ACKNOWLEDGE FLAG               */
__sbit __at 0xC3 SI      ;  /* SMBUS 0 INTERRUPT PENDING FLAG                */
__sbit __at 0xC4 STO     ;  /* SMBUS 0 STOP FLAG                             */
__sbit __at 0xC5 STA     ;  /* SMBUS 0 START FLAG                            */
__sbit __at 0xC6 ENSMB   ;  /* SMBUS 0 ENABLE                                */
__sbit __at 0xC7 BUSY    ;  /* SMBUS 0 BUSY                                  */

/*  CAN0STA  0xC0 */
__sbit __at 0xC3 CANTXOK ;  /* CAN TRANSMITTED A MESSAGE SUCCESSFULLY        */
__sbit __at 0xC4 CANRXOK ;  /* CAN RECEIVED A MESSAGE SUCCESSFULLY           */
__sbit __at 0xC5 CANEPASS;  /* CAN ERROR PASSIVE                             */
__sbit __at 0xC6 CANEWARN;  /* CAN WARNING STATUS                            */
__sbit __at 0xC7 CANBOFF ;  /* CAN BUSOFF STATUS                             */

/*  TMR2CN  0xC8 */
__sbit __at 0xC8 CPRL2   ;  /* TIMER 2 CAPTURE SELECT                        */
__sbit __at 0xC9 CT2     ;  /* TIMER 2 COUNTER SELECT                        */
__sbit __at 0xCA TR2     ;  /* TIMER 2 ON/OFF CONTROL                        */
__sbit __at 0xCB EXEN2   ;  /* TIMER 2 EXTERNAL ENABLE FLAG                  */
__sbit __at 0xCE EXF2    ;  /* TIMER 2 EXTERNAL FLAG                         */
__sbit __at 0xCF TF2     ;  /* TIMER 2 OVERFLOW FLAG                         */

/*  TMR3CN  0xC8 */
__sbit __at 0xC8 CPRL3   ;  /* TIMER 3 CAPTURE SELECT                        */
__sbit __at 0xC9 CT3     ;  /* TIMER 3 COUNTER SELECT                        */
__sbit __at 0xCA TR3     ;  /* TIMER 3 ON/OFF CONTROL                        */
__sbit __at 0xCB EXEN3   ;  /* TIMER 3 EXTERNAL ENABLE FLAG                  */
__sbit __at 0xCE EXF3    ;  /* TIMER 3 EXTERNAL FLAG                         */
__sbit __at 0xCF TF3     ;  /* TIMER 3 OVERFLOW FLAG                         */

/*  TMR4CN  0xC8 */
__sbit __at 0xC8 CPRL4   ;  /* TIMER 4 CAPTURE SELECT                        */
__sbit __at 0xC9 CT4     ;  /* TIMER 4 COUNTER SELECT                        */
__sbit __at 0xCA TR4     ;  /* TIMER 4 ON/OFF CONTROL                        */
__sbit __at 0xCB EXEN4   ;  /* TIMER 4 EXTERNAL ENABLE FLAG                  */
__sbit __at 0xCE EXF4    ;  /* TIMER 4 EXTERNAL FLAG                         */
__sbit __at 0xCF TF4     ;  /* TIMER 4 OVERFLOW FLAG                         */

/*  P4  0xC8 */
__sbit __at 0xC8 P4_0    ;
__sbit __at 0xC9 P4_1    ;
__sbit __at 0xCA P4_2    ;
__sbit __at 0xCB P4_3    ;
__sbit __at 0xCC P4_4    ;
__sbit __at 0xCD P4_5    ;
__sbit __at 0xCE P4_6    ;
__sbit __at 0xCF P4_7    ;

/*  PSW  0xD0 */
__sbit __at 0xD0 P       ;  /* ACCUMULATOR PARITY FLAG                       */
__sbit __at 0xD1 F1      ;  /* USER FLAG 1                                   */
__sbit __at 0xD2 OV      ;  /* OVERFLOW FLAG                                 */
__sbit __at 0xD3 RS0     ;  /* REGISTER BANK SELECT 0                        */
__sbit __at 0xD4 RS1     ;  /* REGISTER BANK SELECT 1                        */
__sbit __at 0xD5 F0      ;  /* USER FLAG 0                                   */
__sbit __at 0xD6 AC      ;  /* AUXILIARY CARRY FLAG                          */
__sbit __at 0xD7 CY      ;  /* CARRY FLAG                                    */

/*  PCA0CN  0xD8 */
__sbit __at 0xD8 CCF0    ;  /* PCA 0 MODULE 0 INTERRUPT FLAG                 */
__sbit __at 0xD9 CCF1    ;  /* PCA 0 MODULE 1 INTERRUPT FLAG                 */
__sbit __at 0xDA CCF2    ;  /* PCA 0 MODULE 2 INTERRUPT FLAG                 */
__sbit __at 0xDB CCF3    ;  /* PCA 0 MODULE 3 INTERRUPT FLAG                 */
__sbit __at 0xDC CCF4    ;  /* PCA 0 MODULE 4 INTERRUPT FLAG                 */
__sbit __at 0xDD CCF5    ;  /* PCA 0 MODULE 5 INTERRUPT FLAG                 */
__sbit __at 0xDE CR      ;  /* PCA 0 COUNTER RUN CONTROL BIT                 */
__sbit __at 0xDF CF      ;  /* PCA 0 COUNTER OVERFLOW FLAG                   */

/*  DMA0CN  0xD8 */
__sbit __at 0xD8 DMA0DO0 ;  /* ADC0 Data Overflow Warning Flag               */
__sbit __at 0xD9 DMA0DO1 ;  /* ADC1 Data Overflow Warning Flag               */
__sbit __at 0xDA DMA0DOE ;  /* Data Overflow Warning Interrupt Enable        */
__sbit __at 0xDB DMA0DE0 ;  /* ADC0 Data Overflow Error Flag                 */
__sbit __at 0xDC DMA0DE1 ;  /* ADC1 Data Overflow Error Flag                 */
__sbit __at 0xDD DMA0MD  ;  /* DMA0 Mode Select                              */
__sbit __at 0xDE DMA0INT ;  /* DMA0 Operations Complete Flag                 */
__sbit __at 0xDF DMA0EN  ;  /* DMA0 Enable                                   */

/*  P5  0xD8 */
__sbit __at 0xD8 P5_0    ;
__sbit __at 0xD9 P5_1    ;
__sbit __at 0xDA P5_2    ;
__sbit __at 0xDB P5_3    ;
__sbit __at 0xDC P5_4    ;
__sbit __at 0xDD P5_5    ;
__sbit __at 0xDE P5_6    ;
__sbit __at 0xDF P5_7    ;

/*  ADC0CN  0xE8 */
__sbit __at 0xE9 AD0WINT ;  /* ADC 0 WINDOW INTERRUPT FLAG                   */
__sbit __at 0xEA AD0CM0  ;  /* ADC 0 CONVERT START MODE BIT 0                */
__sbit __at 0xEB AD0CM1  ;  /* ADC 0 CONVERT START MODE BIT 1                */
__sbit __at 0xEC AD0BUSY ;  /* ADC 0 BUSY FLAG                               */
__sbit __at 0xED AD0INT  ;  /* ADC 0 EOC INTERRUPT FLAG                      */
__sbit __at 0xEE AD0TM   ;  /* ADC 0 TRACK MODE                              */
__sbit __at 0xEF AD0EN   ;  /* ADC 0 ENABLE                                  */

/*  ADC1CN  0xE8 */
__sbit __at 0xE9 AD1CM0  ;  /* ADC 1 CONVERT START MODE BIT 0                */
__sbit __at 0xEA AD1CM1  ;  /* ADC 1 CONVERT START MODE BIT 1                */
__sbit __at 0xEB AD1CM2  ;  /* ADC 1 CONVERT START MODE BIT 1                */
__sbit __at 0xEC AD1BUSY ;  /* ADC 1 BUSY FLAG                               */
__sbit __at 0xED AD1INT  ;  /* ADC 1 EOC INTERRUPT FLAG                      */
__sbit __at 0xEE AD1TM   ;  /* ADC 1 TRACK MODE                              */
__sbit __at 0xEF AD1EN   ;  /* ADC 1 ENABLE                                  */

/*  ADC2CN  0xE8 */
__sbit __at 0xE8 AD2LJST ;  /* ADC 2 LEFT JUSTIFY SELECT                     */
__sbit __at 0xE9 AD2WINT ;  /* ADC 2 WINDOW INTERRUPT FLAG                   */
__sbit __at 0xEA AD2CM0  ;  /* ADC 2 CONVERT START MODE BIT 0                */
__sbit __at 0xEB AD2CM1  ;  /* ADC 2 CONVERT START MODE BIT 1                */
__sbit __at 0xEC AD2BUSY ;  /* ADC 2 BUSY FLAG                               */
__sbit __at 0xED AD2INT  ;  /* ADC 2 EOC INTERRUPT FLAG                      */
__sbit __at 0xEE AD2TM   ;  /* ADC 2 TRACK MODE                              */
__sbit __at 0xEF AD2EN   ;  /* ADC 2 ENABLE                                  */

/*  P6  0xE8 */
__sbit __at 0xE8 P6_0    ;
__sbit __at 0xE9 P6_1    ;
__sbit __at 0xEA P6_2    ;
__sbit __at 0xEB P6_3    ;
__sbit __at 0xEC P6_4    ;
__sbit __at 0xED P6_5    ;
__sbit __at 0xEE P6_6    ;
__sbit __at 0xEF P6_7    ;

/*  SPI0CN  0xF8 */
__sbit __at 0xF8 SPIEN   ;  /* SPI 0 SPI ENABLE                              */
__sbit __at 0xF9 TXBMT   ;  /* SPI 0 TX BUFFER EMPTY FLAG                    */
__sbit __at 0xFA NSSMD0  ;  /* SPI 0 SLAVE SELECT MODE 0                     */
__sbit __at 0xFB NSSMD1  ;  /* SPI 0 SLAVE SELECT MODE 1                     */
__sbit __at 0xFC RXOVRN  ;  /* SPI 0 RX OVERRUN FLAG                         */
__sbit __at 0xFD MODF    ;  /* SPI 0 MODE FAULT FLAG                         */
__sbit __at 0xFE WCOL    ;  /* SPI 0 WRITE COLLISION FLAG                    */
__sbit __at 0xFF SPIF    ;  /* SPI 0 INTERRUPT FLAG                          */

/*  CAN0CN  0xF8 */
__sbit __at 0xF8 CANINIT ;  /* CAN INITIALIZATION                            */
__sbit __at 0xF9 CANIE   ;  /* CAN MODULE INTERRUPT ENABLE                   */
__sbit __at 0xFA CANSIE  ;  /* CAN STATUS CHANGE INTERRUPT ENABLE            */
__sbit __at 0xFB CANEIE  ;  /* CAN ERROR INTERRUPT ENABLE                    */
__sbit __at 0xFC CANIF   ;  /* CAN INTERRUPT FLAG                            */
__sbit __at 0xFD CANDAR  ;  /* CAN DISABLE AUTOMATIC RETRANSMISSION          */
__sbit __at 0xFE CANCCE  ;  /* CAN CONFIGURATION CHANGE ENABLE               */
__sbit __at 0xFF CANTEST ;  /* CAN TEST MODE ENABLE                          */

/*  DMA0CF  0xF8 */
__sbit __at 0xF8 DMA0EO  ;  /* END-OF-OPERATION FLAG                         */
__sbit __at 0xF9 DMA0EOE ;  /* END-OF-OPERATION INTERRUPT ENABLE             */
__sbit __at 0xFA DMA0CI  ;  /* REPEAT COUNTER OVERFLOW FLAG                  */
__sbit __at 0xFB DMA0CIE ;  /* REPEAT COUNTER OVERFLOW INTERRUPT ENABLE      */
__sbit __at 0xFE DMA0XBY ;  /* OFF-CHIP XRAM BUSY FLAG                       */
__sbit __at 0xFF DMA0HLT ;  /* HALT DMA0 OFF-CHIP XRAM ACCESS                */

/*  P7  0xF8 */
__sbit __at 0xF8 P7_0    ;
__sbit __at 0xF9 P7_1    ;
__sbit __at 0xFA P7_2    ;
__sbit __at 0xFB P7_3    ;
__sbit __at 0xFC P7_4    ;
__sbit __at 0xFD P7_5    ;
__sbit __at 0xFE P7_6    ;
__sbit __at 0xFF P7_7    ;


/* Predefined SFR Bit Masks */

#define IDLE              0x01    /* PCON                                */
#define STOP              0x02    /* PCON                                */
#define ECCF              0x01    /* PCA0CPMn                            */
#define PWM               0x02    /* PCA0CPMn                            */
#define TOG               0x04    /* PCA0CPMn                            */
#define MAT               0x08    /* PCA0CPMn                            */
#define CAPN              0x10    /* PCA0CPMn                            */
#define CAPP              0x20    /* PCA0CPMn                            */
#define ECOM              0x40    /* PCA0CPMn                            */
#define PWM16             0x80    /* PCA0CPMn                            */
#define PORSF             0x02    /* RSTSRC                              */
#define SWRSF             0x10    /* RSTSRC                              */


/* SFR PAGE DEFINITIONS */

#define CONFIG_PAGE       0x0F     /* SYSTEM AND PORT CONFIGURATION PAGE */
#define LEGACY_PAGE       0x00     /* LEGACY SFR PAGE                    */
#define TIMER01_PAGE      0x00     /* TIMER 0 AND TIMER 1                */
#define CPT0_PAGE         0x01     /* COMPARATOR 0                       */
#define CPT1_PAGE         0x02     /* COMPARATOR 1                       */
#define CPT2_PAGE         0x03     /* COMPARATOR 2                       */
#define UART0_PAGE        0x00     /* UART 0                             */
#define UART1_PAGE        0x01     /* UART 1                             */
#define SPI0_PAGE         0x00     /* SPI 0                              */
#define EMI0_PAGE         0x00     /* EXTERNAL MEMORY INTERFACE          */
#define ADC0_PAGE         0x00     /* ADC 0                              */
#define ADC1_PAGE         0x01     /* ADC 1                              */
#define ADC2_PAGE         0x02     /* ADC 2                              */
#define SMB0_PAGE         0x00     /* SMBUS 0                            */
#define TMR2_PAGE         0x00     /* TIMER 2                            */
#define TMR3_PAGE         0x01     /* TIMER 3                            */
#define TMR4_PAGE         0x02     /* TIMER 4                            */
#define DAC0_PAGE         0x00     /* DAC 0                              */
#define DAC1_PAGE         0x01     /* DAC 1                              */
#define PCA0_PAGE         0x00     /* PCA 0                              */
#define DMA0_PAGE         0x03     /* DMA 0                              */
#define CAN0_PAGE         0x01     /* CAN 0                              */

#endif
/*-------------------------------------------------------------------------
   p89lpc935_6.h - This header allows to use the microcontrolers NXP
   (formerly Philips) p89lpc935, 936.

   Copyright (C) 2008, Gudjon I. Gudjonsson <gudjon AT gudjon.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------
 The registered are ordered in the same way as in the NXP data sheet:
 http://www.standardics.nxp.com/products/lpc900/datasheet/p89lpc933.p89lpc934.p89lpc935.p89lpc936.pdf
-------------------------------------------------------------------------*/

#ifndef __P89LPC935_6_H__
#define __P89LPC935_6_H__
#include <compiler.h>

/*BYTE Registers*/
SFR(ACC, 0xE0); // Accumulator
	SBIT(ACC_7, 0xE0, 7);
	SBIT(ACC_6, 0xE0, 6);
	SBIT(ACC_5, 0xE0, 5);
	SBIT(ACC_4, 0xE0, 4);
	SBIT(ACC_3, 0xE0, 3);
	SBIT(ACC_2, 0xE0, 2);
	SBIT(ACC_1, 0xE0, 1);
	SBIT(ACC_0, 0xE0, 0);
SFR(ADCON0, 0x8E); // A/D control register 0
	#define  ENBI0    0x80
	#define  ENADCI0  0x40
	#define  TMM0     0x20
	#define  EDGE0    0x10
	#define  ADCI0    0x08
	#define  ENADC0   0x04
	#define  ADCS01   0x02
	#define  ADCS00   0x01
SFR(ADCON1, 0x97); // A/D control register 1
	#define  ENBI1    0x80
	#define  ENADCI1  0x40
	#define  TMM1     0x20
	#define  EDGE1    0x10
	#define  ADCI1    0x08
	#define  ENADC1   0x04
	#define  ADCS11   0x02
	#define  ADCS10   0x01
SFR(ADINS, 0xA3); // A/D input select
	#define  ADI13    0x80
	#define  ADI12    0x40
	#define  ADI11    0x20
	#define  ADI10    0x10
	#define  ADI03    0x08
	#define  ADI02    0x04
	#define  ADI01    0x02
	#define  ADI00    0x01
SFR(ADMODA, 0xC0); // A/D mode register A
	SBIT(BNDI1,  0xC0, 7);
	SBIT(BURST1, 0xC0, 6);
	SBIT(SCC1,   0xC0, 5);
	SBIT(SCAN1,  0xC0, 4);
	SBIT(BNDI0,  0xC0, 3);
	SBIT(BURST0, 0xC0, 2);
	SBIT(SCC0,   0xC0, 1);
	SBIT(SCAN0,  0xC0, 0);
SFR(ADMODB, 0xA1); // A/D mode register B
	#define  CLK2     0x80
	#define  CLK1     0x40
	#define  CLK0     0x20
	#define  ENDAC1   0x08
	#define  ENDAC0   0x04
	#define  BSA1     0x02
	#define  BSA0     0x01
SFR(AD0BH,   0xBB); // A/D_0 boundary high register
SFR(AD0BL,   0xA6); // A/D_0 boundary low register
SFR(AD0DAT0, 0xC5); // A/D_0 data register 0
SFR(AD0DAT1, 0xC6); // A/D_0 data register 1
SFR(AD0DAT2, 0xC7); // A/D_0 data register 2
SFR(AD0DAT3, 0xF4); // A/D_0 data register 3
SFR(AD1BH,   0xC4); // A/D_1 boundary high register
SFR(AD1BL,   0xBC); // A/D_1 boundary low register
SFR(AD1DAT0, 0xD5); // A/D_1 data register 0
SFR(AD1DAT1, 0xD6); // A/D_1 data register 1
SFR(AD1DAT2, 0xD7); // A/D_1 data register 2
SFR(AD1DAT3, 0xF5); // A/D_1 data register 3
SFR(AUXR1,   0xA2); // Auxilary function register
	#define  CLKLP    0x80
	#define  EBRR     0x40
	#define  ENT1     0x20
	#define  ENT0     0x10
	#define  SRST     0x08
	#define  DPS      0x01 // Bit 2 is always 0
SFR(B, 0xF0); // B register
	SBIT(B7, 0xF0, 7);
	SBIT(B6, 0xF0, 6);
	SBIT(B5, 0xF0, 5);
	SBIT(B4, 0xF0, 4);
	SBIT(B3, 0xF0, 3);
	SBIT(B2, 0xF0, 2);
	SBIT(B1, 0xF0, 1);
	SBIT(B0, 0xF0, 0);
SFR(BRGR0,  0xBE); // Baud rate generator rate low
SFR(BRGR1,  0xBF); // Baud rate generator rate high
SFR(BRGCON, 0xBD); // Baud rate generator control
	#define  SBRGS    0x02
	#define  BRGEN    0x01
SFR(CCCRA,  0xEA); // Capture compare A control register
	#define  ICECA2   0x80
	#define  ICECA1   0x40
	#define  ICECA0   0x20
	#define  ICESA    0x10
	#define  ICNFA    0x08
	#define  FCOA     0x04
	#define  OCMA1    0x02
	#define  OCMA0    0x01
SFR(CCCRB,  0xEB); // Capture compare B control register
	#define  ICECB2   0x80
	#define  ICECB1   0x40
	#define  ICECB0   0x20
	#define  ICESB    0x10
	#define  ICNFB    0x08
	#define  FCOB     0x04
	#define  OCMB1    0x02
	#define  OCMB0    0x01
SFR(CCCRC,  0xEC); // Capture compare C control register
	#define  FCOC     0x04
	#define  OCMC1    0x02
	#define  OCMC0    0x01
SFR(CCCRD,  0xED); // Capture compare D control register
	#define  FCOD     0x04
	#define  OCMD1    0x02
	#define  OCMD0    0x01
SFR(CMP1,   0xAC); // Comparator 1 control register
	#define  CE1      0x20
	#define  CP1      0x10
	#define  CN1      0x08
	#define  OE1      0x04
	#define  CO1      0x02
	#define  CMF1     0x01
SFR(CMP2,   0xAD); // Comparator 2 control register
	#define  CE2      0x20
	#define  CP2      0x10
	#define  CN2      0x08
	#define  OE2      0x04
	#define  CO2      0x02
	#define  CMF2     0x01
SFR(DEECON, 0xF1); // Data EEPROM control register
	#define  EEIF     0x80
	#define  HVERR    0x40
	#define  ECTL1    0x20
	#define  ECTL0    0x10
	#define  EADR8    0x01
SFR(DEEDAT, 0xF2); // Data EEPROM data register
SFR(DEEADR, 0xF3); // Data EEPROM address register
SFR(DIVM,   0x95); // CPU clock divide-by-M control
SFR(DPH,    0x83); // Data Pointer High
SFR(DPL,    0x82); // Data Pointer Low
SFR(FMADRH, 0xE7); // Program flash address high
SFR(FMADRL, 0xE6); // Program flash address low
SFR(FMCON,  0xE4);
	// Program flash control (Read)
	#define  BUSY     0x80
	#define  HVA      0x08
	#define  HVE      0x04
	#define  SV       0x02
	#define  OI       0x01
	// Program flash control (Write)
	#define  FMCMD_7  0x80
	#define  FMCMD_6  0x40
	#define  FMCMD_5  0x20
	#define  FMCMD_4  0x10
	#define  FMCMD_3  0x08
	#define  FMCMD_2  0x04
	#define  FMCMD_1  0x02
	#define  FMCMD_0  0x01
SFR(FMDATA,  0xE5); // Program flash data
SFR(I2ADR,   0xDB); // I2C slave address register
	#define I2ADR_6  0x80
	#define I2ADR_5  0x40
	#define I2ADR_4  0x20
	#define I2ADR_3  0x10
	#define I2ADR_2  0x08
	#define I2ADR_1  0x04
	#define I2ADR_0  0x02
	#define GC       0x01
SFR(I2CON,  0xD8); // I2C control register
	SBIT(I2EN,  0xD8, 6);
	SBIT(STA,   0xD8, 5);
	SBIT(STO,   0xD8, 4);
	SBIT(SI,    0xD8, 3);
	SBIT(AA,    0xD8, 2);
	SBIT(CRSEL, 0xD8, 0);
SFR(I2DAT,  0xDA); // I2C data register
SFR(I2SCLH, 0xDD); // I2C serial clock generator/SCL duty cycle register high
SFR(I2SCLL, 0xDC); // I2C serial clock generator/SCL duty cycle register low
SFR(I2STAT, 0xD9); // I2C status register
	#define STA_4   0x80
	#define STA_3   0x40
	#define STA_2   0x20
	#define STA_1   0x10
	#define STA_0   0x08    // Only write 0 to the lowest three bits
SFR(ICRAH,  0xAB); // Input capture A register high
SFR(ICRAL,  0xAA); // Input capture A register low
SFR(ICRBH,  0xAF); // Input capture B register high
SFR(ICRBL,  0xAE); // Input capture B register low
SFR(IEN0,   0xA8); // Interrupt Enable 0
	SBIT(EA,     0xA8, 7);
	SBIT(EWDRT,  0xA8, 6);
	SBIT(EBO,    0xA8, 5);
	SBIT(ES_ESR, 0xA8, 4);
	SBIT(ET1,    0xA8, 3);
	SBIT(EX1,    0xA8, 2);
	SBIT(ET0,    0xA8, 1);
	SBIT(EX0,    0xA8, 0);
SFR(IEN1,  0xE8); // Interrupt Enable 1
	SBIT(EADEE,  0xE8, 7);
	SBIT(EST,    0xE8, 6);
	SBIT(ECCU,   0xE8, 4);
	SBIT(ESPI,   0xE8, 3);
	SBIT(EC,     0xE8, 2);
	SBIT(EKBI,   0xE8, 1);
	SBIT(EI2C,   0xE8, 0);
SFR(IP0, 0xB8); // Interrupt Priority 0
	SBIT(PWDRT,  0xB8, 6);
	SBIT(PBO,    0xB8, 5);
	SBIT(PS_PSR, 0xB8, 4);
	SBIT(PT1,    0xB8, 3);
	SBIT(PX1,    0xB8, 2);
	SBIT(PT0,    0xB8, 1);
	SBIT(PX0,    0xB8, 0);
SFR(IP0H, 0xB7); // Interrupt Priority 0 high
	#define PWDRTH    0x40
	#define PBOH      0x20
	#define PSH_PSRH  0x10
	#define PT1H      0x08
	#define PX1H      0x04
	#define PT0H      0x02
	#define PX0H      0x01
SFR(IP1,  0xF8); // Interrupt Priority 1
	SBIT(PADEE, 0xF8, 7);
	SBIT(PST,   0xF8, 6);
	SBIT(PCCU,  0xF8, 4);
	SBIT(PSPI,  0xF8, 3);
	SBIT(PC,    0xF8, 2);
	SBIT(PKBI,  0xF8, 1);
	SBIT(PI2C,  0xF8, 0);
SFR(IP1H, 0xF7); // Interrupt Priority 1 High
	#define PAEEH  0x80
	#define PSTH   0x40
	#define PCCUH  0x10
	#define PSPIH  0x08
	#define PCH    0x04
	#define PKBIH  0x02
	#define PI2CH  0x01
SFR(KBCON, 0x94); // Keypad control register
	#define PATN_SEL 0x02
	#define KBIF     0x01
SFR(KBMASK, 0x86); // Keypad interrupt mask register
SFR(KBPATN, 0x93); // Keypad pattern register
SFR(OCRAH,  0xEF); // Output compare A register high
SFR(OCRAL,  0xEE); // Output compare A register low
SFR(OCRBH,  0xFB); // Output compare B register high
SFR(OCRBL,  0xFA); // Output compare B register low
SFR(OCRCH,  0xFD); // Output compare C register high
SFR(OCRCL,  0xFC); // Output compare C register low
SFR(OCRDH,  0xFF); // Output compare D register high
SFR(OCRDL,  0xFE); // Output compare D register low
SFR(P0, 0x80); // Port 0
	SBIT(P0_7,   0x80, 7);
	SBIT(T1,     0x80, 7);
	SBIT(KB7,    0x80, 7);
	SBIT(P0_6,   0x80, 6);
	SBIT(CMP_1,  0x80, 6); // Renamed, not to conflict with the CMP1 register
	SBIT(KB6,    0x80, 6);
	SBIT(P0_5,   0x80, 5);
	SBIT(CMPREF, 0x80, 5);
	SBIT(KB5,    0x80, 5);
	SBIT(P0_4,   0x80, 4);
	SBIT(CIN1A,  0x80, 4);
	SBIT(KB4,    0x80, 4);
	SBIT(P0_3,   0x80, 3);
	SBIT(CIN1B,  0x80, 3);
	SBIT(KB3,    0x80, 3);
	SBIT(P0_2,   0x80, 2);
	SBIT(CIN2A,  0x80, 2);
	SBIT(KB2,    0x80, 2);
	SBIT(P0_1,   0x80, 1);
	SBIT(CIN2B,  0x80, 1);
	SBIT(KB1,    0x80, 1);
	SBIT(P0_0,   0x80, 0);
	SBIT(CMP_2,  0x80, 0); // Renamed, not to conflict with the CMP2 register
	SBIT(KB0,    0x80, 0);
SFR(P1, 0x90); // Port 1
	SBIT(P1_7,   0x90, 7);
	SBIT(OCC,    0x90, 7);
	SBIT(P1_6,   0x90, 6);
	SBIT(OCB,    0x90, 6);
	SBIT(P1_5,   0x90, 5);
	SBIT(RST,    0x90, 5);
	SBIT(P1_4,   0x90, 4);
	SBIT(INT1,   0x90, 4);
	SBIT(P1_3,   0x90, 3);
	SBIT(INT0,   0x90, 3);
	SBIT(SDA,    0x90, 3);
	SBIT(P1_2,   0x90, 2);
	SBIT(T0,     0x90, 2);
	SBIT(SCL,    0x90, 2);
	SBIT(P1_1,   0x90, 1);
	SBIT(RXD,    0x90, 1);
	SBIT(P1_0,   0x90, 0);
	SBIT(TXD,    0x90, 0);
SFR(P2, 0xA0); // Port 2
	SBIT(P2_7,   0xA0, 7);
	SBIT(ICA,    0xA0, 7);
	SBIT(P2_6,   0xA0, 6);
	SBIT(OCA,    0xA0, 6);
	SBIT(P2_5,   0xA0, 5);
	SBIT(SPICLK, 0xA0, 5);
	SBIT(P2_4,   0xA0, 4);
	SBIT(SS,     0xA0, 4);
	SBIT(P2_3,   0xA0, 3);
	SBIT(MISO,   0xA0, 3);
	SBIT(P2_2,   0xA0, 2);
	SBIT(MOSI,   0xA0, 2);
	SBIT(P2_1,   0xA0, 1);
	SBIT(OCD,    0xA0, 1);
	SBIT(P2_0,   0xA0, 0);
	SBIT(ICB,    0xA0, 0);
SFR(P3, 0xB0); // Port 3
	SBIT(P3_7, 0xB0, 7);
	SBIT(P3_6, 0xB0, 6);
	SBIT(P3_5, 0xB0, 5);
	SBIT(P3_4, 0xB0, 4);
	SBIT(P3_3, 0xB0, 3);
	SBIT(P3_2, 0xB0, 2);
	SBIT(P3_1, 0xB0, 1);
	SBIT(XTAL1,0xB0, 1);
	SBIT(P3_0, 0xB0, 0);
	SBIT(XTAL2,0xB0, 0);
SFR(P0M1, 0x84); // Port 0 output mode 1
	#define P0M1_7  0x80
	#define P0M1_6  0x40
	#define P0M1_5  0x20
	#define P0M1_4  0x10
	#define P0M1_3  0x08
	#define P0M1_2  0x04
	#define P0M1_1  0x02
	#define P0M1_0  0x01
SFR(P0M2, 0x85); // Port 0 output mode 2
	#define P0M2_7  0x80
	#define P0M2_6  0x40
	#define P0M2_5  0x20
	#define P0M2_4  0x10
	#define P0M2_3  0x08
	#define P0M2_2  0x04
	#define P0M2_1  0x02
	#define P0M2_0  0x01
SFR(P1M1, 0x91); // Port 1 output mode 1
	#define P1M1_7  0x80
	#define P1M1_6  0x40
	#define P1M1_4  0x10
	#define P1M1_3  0x08
	#define P1M1_2  0x04
	#define P1M1_1  0x02
	#define P1M1_0  0x01
SFR(P1M2, 0x92); // Port 1 output mode 2
	#define P1M2_7  0x80
	#define P1M2_6  0x40
	#define P1M2_4  0x10
	#define P1M2_3  0x08
	#define P1M2_2  0x04
	#define P1M2_1  0x02
	#define P1M2_0  0x01
SFR(P2M1, 0xA4); // Port 2 output mode 1
	#define P2M1_7  0x80
	#define P2M1_6  0x40
	#define P2M1_5  0x20
	#define P2M1_4  0x10
	#define P2M1_3  0x08
	#define P2M1_2  0x04
	#define P2M1_1  0x02
	#define P2M1_0  0x01
SFR(P2M2, 0xA5); // Port 2 output mode 2
	#define P2M2_7  0x80
	#define P2M2_6  0x40
	#define P2M2_5  0x20
	#define P2M2_4  0x10
	#define P2M2_3  0x08
	#define P2M2_2  0x04
	#define P2M2_1  0x02
	#define P2M2_0  0x01
SFR(P3M1, 0xB1); // Port 3 output mode 1
	#define P3M1_1  0x02
	#define P3M1_0  0x01
SFR(P3M2, 0xB2); // Port 3 output mode 2
	#define P3M2_1  0x02
	#define P3M2_0  0x01
SFR(PCON,  0x87); // Power control register
	#define SMOD1   0x80
	#define SMOD0   0x40
	#define BOPD    0x20
	#define BOI     0x10
	#define GF1     0x08
	#define GF0     0x04
	#define PMOD1   0x02
	#define PMOD0   0x01
SFR(PCONA, 0xB5); // Power control register A
	#define RTCPD   0x80
	#define DEEPD   0x40
	#define VCPD    0x20
	#define ADPD    0x10
	#define I2PD    0x08
	#define SPPD    0x04
	#define SPD     0x02
	#define CCUPR   0x01
SFR(PSW, 0xD0); // Program Status Word
	SBIT(CY,  0xD0, 7);
	SBIT(AC,  0xD0, 6);
	SBIT(F0,  0xD0, 5);
	SBIT(RS1, 0xD0, 4);
	SBIT(RS0, 0xD0, 3);
	SBIT(OV,  0xD0, 2);
	SBIT(F1,  0xD0, 1);
	SBIT(P,   0xD0, 0);
SFR(PT0AD, 0xF6); // Port 0 digital input disable
	#define PT0AD_5   0x20
	#define PT0AD_4   0x10
	#define PT0AD_3   0x08
	#define PT0AD_2   0x04
	#define PT0AD_1   0x02
SFR(RSTSRC, 0xDF); // Reset source register
	#define BOF    0x20
	#define POF    0x10
	#define R_BK   0x08
	#define R_WD   0x04
	#define R_SF   0x02
	#define R_EX   0x01
SFR(RTCCON, 0xD1); // Real-time clock control
	#define RTCF   0x80
	#define RTCS1  0x40
	#define RTCS0  0x20
	#define ERTC   0x02
	#define RTCEN  0x01
SFR(RTCH,  0xD2); // Real-time clock register high
SFR(RTCL,  0xD3); // Real-time clock register low
SFR(SADDR, 0xA9); // Serial port address register
SFR(SADEN, 0xB9); // Serial port address enable
SFR(SBUF,  0x99); // Serial port data buffer register
SFR(SCON,  0x98); // Serial port control
	SBIT(SM0_FE, 0x98, 7);
	SBIT(SM1,    0x98, 6);
	SBIT(SM2,    0x98, 5);
	SBIT(REN,    0x98, 4);
	SBIT(TB8,    0x98, 3);
	SBIT(RB8,    0x98, 2);
	SBIT(TI,     0x98, 1);
	SBIT(RI,     0x98, 0);
SFR(SSTAT, 0xBA); // Serial port extended status register
	#define DBMOD  0x80
	#define INTLO  0x40
	#define CIDIS  0x20
	#define DBISEL 0x10
	#define FE     0x08
	#define BR     0x04
	#define OE     0x02
	#define STINT  0x01
SFR(SP,     0x81); // Stack Pointer
SFR(SPCTL,  0xE2); // SPI control register
	#define SSIG  0x80
	#define SPEN  0x40
	#define DORD  0x20
	#define MSTR  0x10
	#define CPOL  0x08
	#define CPHA  0x04
	#define SPR1  0x02
	#define SPR0  0x01
SFR(SPSTAT, 0xE1); // SPI status register
	#define SPIF  0x80
	#define WCOL  0x40
SFR(SPDAT,  0xE3); // SPI data register
SFR(TAMOD,  0x8F); // Timer 0 and 1 auxiliary mode
	#define T1M2  0x10
	#define T0M2  0x01
SFR(TCON,   0x88); // Timer 0 and 1 control
	SBIT(TF1, 0x88, 7);
	SBIT(TR1, 0x88, 6);
	SBIT(TF0, 0x88, 5);
	SBIT(TR0, 0x88, 4);
	SBIT(IE1, 0x88, 3);
	SBIT(IT1, 0x88, 2);
	SBIT(IE0, 0x88, 1);
	SBIT(IT0, 0x88, 0);
SFR(TCR20,  0xC8); // CCU control register 0
	SBIT(PLEEN,  0xC8, 7);
	SBIT(HLTRN,  0xC8, 6);
	SBIT(HLTEN,  0xC8, 5);
	SBIT(ALTCD,  0xC8, 4);
	SBIT(ALTAB,  0xC8, 3);
	SBIT(TDIR2,  0xC8, 2);
	SBIT(TMOD21, 0xC8, 1);
	SBIT(TMOD20, 0xC8, 0);
SFR(TCR21,  0xF9); // CCU control register 1
	#define TCOU2   0x80
	#define PLLDV_3 0x08
	#define PLLDV_2 0x04
	#define PLLDV_1 0x02
	#define PLLDV_0 0x01
SFR(TH0,  0x8C); // Timer 0 high
SFR(TH1,  0x8D); // Timer 1 high
SFR(TH2,  0xCD); // CCU timer high
SFR(TICR2,0xC9); // CCU interrupt control register
	#define TOIE2    0x80
	#define TOCIE2D  0x40
	#define TOCIE2C  0x20
	#define TOCIE2B  0x10
	#define TOCIE2A  0x08
	#define TICIE2B  0x02
	#define TICIE2A  0x01
SFR(TIFR2,0xE9); // CCU interrupt flag register
	#define TOIF2    0x80
	#define TOCF2D  0x40
	#define TOCF2C  0x20
	#define TOCF2B  0x10
	#define TOCF2A  0x08
	#define TICF2B  0x02
	#define TICF2A  0x01
SFR(TISE2,0xDE); // CCU interrupt status encode register
	#define ENCINT2  0x04
	#define ENCINT1  0x02
	#define ENCINT0  0x01
SFR(TL0,   0x8A); // Timer 0 low
SFR(TL1,   0x8B); // Timer 1 low
SFR(TL2,   0xCC); // CCU timer low
SFR(TMOD, 0x89); // Timer 0 and 1 mode
	#define T1GATE  0x80
	#define T1C_T   0x40
	#define T1M1    0x20
	#define T1M0    0x10
	#define T0GATE  0x08
	#define T0C_T   0x04
	#define T0M1    0x02
	#define T0M0    0x01
SFR(TOR2H, 0xCF); // CCU reload register high
SFR(TOR2L, 0xCE); // CCU reload register low
SFR(TPCR2H,0xCB); // Prescaler control register high
	#define TPCR2H_1 0x02
	#define TPCR2H_0 0x01
SFR(TPCR2L,0xCA); // Prescaler control register low
	#define TPCR2L_7 0x80
	#define TPCR2L_6 0x40
	#define TPCR2L_5 0x20
	#define TPCR2L_4 0x10
	#define TPCR2L_3 0x08
	#define TPCR2L_2 0x04
	#define TPCR2L_1 0x02
	#define TPCR2L_0 0x01
SFR(TRIM, 0x96); // Internal oscillator trim register
	#define RCCLK   0x80
	#define ENCLK   0x40
	#define TRIM_5  0x20
	#define TRIM_4  0x10
	#define TRIM_3  0x08
	#define TRIM_2  0x04
	#define TRIM_1  0x02
	#define TRIM_0  0x01
SFR(WDCON, 0xA7); // Watchdog control register
	#define PRE2    0x80
	#define PRE1    0x40
	#define PRE0    0x20
	#define WDRUN   0x04
	#define WDTOF   0x02
	#define WDCLK   0x01
SFR(WDL,    0xC1); // Watchdog load
SFR(WFEED1, 0xC2); // Watchdog feed 1
SFR(WFEED2, 0xC3); // Watchdog feed 2
#endif // __P89LPC935_6_H__
/*-------------------------------------------------------------------------
   C8051T600.h - Register Declarations for the SiLabs C8051T60x Processor
   Range

   Copyright (C) 2008, Steven Borley, steven.borley@partnerelectronics.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef C8051T600_H
#define C8051T600_H

#include <compiler.h>


/*  BYTE Registers  */

SFR(       P0, 0x80 )  ; /* PORT 0 */
SFR(       SP, 0x81 )  ; /* STACK POINTER */
SFR(      DPL, 0x82 )  ; /* DATA POINTER - LOW BYTE */
SFR(      DPH, 0x83 )  ; /* DATA POINTER - HIGH BYTE */
SFR(     PCON, 0x87 )  ; /* POWER CONTROL */
SFR(     TCON, 0x88 )  ; /* TIMER CONTROL */
SFR(     TMOD, 0x89 )  ; /* TIMER MODE */
SFR(      TL0, 0x8A )  ; /* TIMER 0 - LOW BYTE */
SFR(      TL1, 0x8B )  ; /* TIMER 1 - LOW BYTE */
SFR(      TH0, 0x8C )  ; /* TIMER 0 - HIGH BYTE */
SFR(      TH1, 0x8D )  ; /* TIMER 1 - HIGH BYTE */
SFR(    CKCON, 0x8E )  ; /* CLOCK CONTROL */
SFR(     SCON, 0x98 )  ; /* SERIAL PORT CONTROL */
SFR(    SCON0, 0x98 )  ; /* SERIAL PORT CONTROL */
SFR(     SBUF, 0x99 )  ; /* SERIAL PORT BUFFER */
SFR(    SBUF0, 0x99 )  ; /* SERIAL PORT BUFFER */
SFR(   CPT0MD, 0x9D )  ; /* COMPARATOR 0 MODE SELECTION */
SFR(   CPT0MX, 0x9F )  ; /* COMPARATOR 0 MUX SELECTION */
SFR(    TOFFL, 0xA2 )  ; /* TEMPERATURE SENSOR OFFSET - LOW BYTE */
SFR(    TOFFH, 0xA3 )  ; /* TEMPERATURE SENSOR OFFSET - HIGH BYTE */
SFR(  P0MDOUT, 0xA4 )  ; /* PORT 0 OUTPUT MODE CONFIGURATION */
SFR(       IE, 0xA8 )  ; /* INTERRUPT ENABLE */
SFR(   OSCXCN, 0xB1 )  ; /* EXTERNAL OSCILLATOR CONTROL */
SFR(   OSCICN, 0xB2 )  ; /* INTERNAL OSCILLATOR CONTROL */
SFR(   OSCICL, 0xB3 )  ; /* INTERNAL OSCILLATOR CALIBRATION */
SFR(       IP, 0xB8 )  ; /* INTERRUPT PRIORITY */
SFR(   AMX0SL, 0xBB )  ; /* ADC 0 MUX CHANNEL SELECTION */
SFR(   ADC0CF, 0xBC )  ; /* ADC 0 CONFIGURATION */
SFR(    ADC0L, 0xBD )  ; /* ADC 0 DATA - LOW BYTE */
SFR(    ADC0H, 0xBE )  ; /* ADC 0 DATA - HIGH BYTE */
SFR(   SMB0CN, 0xC0 )  ; /* SMBUS CONTROL */
SFR(   SMB0CF, 0xC1 )  ; /* SMBUS CONFIGURATION */
SFR(  SMB0DAT, 0xC2 )  ; /* SMBUS DATA */
SFR(  ADC0GTL, 0xC3 )  ; /* ADC 0 GREATER-THAN REGISTER - LOW BYTE */
SFR(  ADC0GTH, 0xC4 )  ; /* ADC 0 GREATER-THAN REGISTER - HIGH BYTE */
SFR(  ADC0LTL, 0xC5 )  ; /* ADC 0 LESS-THAN REGISTER - LOW BYTE */
SFR(  ADC0LTH, 0xC6 )  ; /* ADC 0 LESS-THAN REGISTER - HIGH BYTE */
SFR(   REG0CN, 0xC7 )  ; /* Voltage Regulator Control */
SFR(    T2CON, 0xC8 )  ; /* TIMER 2 CONTROL */
SFR(   TMR2CN, 0xC8 )  ; /* TIMER 2 CONTROL */
SFR(   RCAP2L, 0xCA )  ; /* TIMER 2 CAPTURE REGISTER - LOW BYTE */
SFR(  TMR2RLL, 0xCA )  ; /* TIMER 2 CAPTURE REGISTER - LOW BYTE */
SFR(   RCAP2H, 0xCB )  ; /* TIMER 2 CAPTURE REGISTER - HIGH BYTE */
SFR(  TMR2RLH, 0xCB )  ; /* TIMER 2 CAPTURE REGISTER - HIGH BYTE */
SFR(      TL2, 0xCC )  ; /* TIMER 2 - LOW BYTE */
SFR(    TMR2L, 0xCC )  ; /* TIMER 2 - LOW BYTE */
SFR(      TH2, 0xCD )  ; /* TIMER 2 - HIGH BYTE */
SFR(    TMR2H, 0xCD )  ; /* TIMER 2 - HIGH BYTE */
SFR(      PSW, 0xD0 )  ; /* PROGRAM STATUS WORD */
SFR(   REF0CN, 0xD1 )  ; /* VOLTAGE REFERENCE 0 CONTROL */
SFR(   PCA0CN, 0xD8 )  ; /* PCA CONTROL */
SFR(   PCA0MD, 0xD9 )  ; /* PCA MODE */
SFR( PCA0CPM0, 0xDA )  ; /* PCA MODULE 0 MODE REGISTER */
SFR( PCA0CPM1, 0xDB )  ; /* PCA MODULE 1 MODE REGISTER */
SFR( PCA0CPM2, 0xDC )  ; /* PCA MODULE 2 MODE REGISTER */
SFR(      ACC, 0xE0 )  ; /* ACCUMULATOR */
SFR(   PRT0MX, 0xE1 )  ; /* PORT MUX CONFIGURATION REGISTER 0 */
SFR(     XBR0, 0xE1 )  ; /* PORT MUX CONFIGURATION REGISTER 0 */
SFR(   PRT1MX, 0xE2 )  ; /* PORT MUX CONFIGURATION REGISTER 1 */
SFR(     XBR1, 0xE2 )  ; /* PORT MUX CONFIGURATION REGISTER 1 */
SFR(   PRT2MX, 0xE3 )  ; /* PORT MUX CONFIGURATION REGISTER 2 */
SFR(     XBR2, 0xE3 )  ; /* PORT MUX CONFIGURATION REGISTER 2 */
SFR(   IT01CF, 0xE4 )  ; /* INT0/INT1 CONFIGURATION REGISTER */
SFR(  INT01CF, 0xE4 )  ; /* INT0/INT1 CONFIGURATION REGISTER */
SFR(     EIE1, 0xE6 )  ; /* EXTERNAL INTERRUPT ENABLE 1 */
SFR(   ADC0CN, 0xE8 )  ; /* ADC 0 CONTROL */
SFR( PCA0CPL1, 0xE9 )  ; /* PCA CAPTURE 1 LOW */
SFR( PCA0CPH1, 0xEA )  ; /* PCA CAPTURE 1 HIGH */
SFR( PCA0CPL2, 0xEB )  ; /* PCA CAPTURE 2 LOW */
SFR( PCA0CPH2, 0xEC )  ; /* PCA CAPTURE 2 HIGH */
SFR(   RSTSRC, 0xEF )  ; /* RESET SOURCE */
SFR(        B, 0xF0 )  ; /* B REGISTER */
SFR(   P0MODE, 0xF1 )  ; /* PORT 0 INPUT MODE CONFIGURATION */
SFR(   P0MDIN, 0xF1 )  ; /* PORT 0 INPUT MODE CONFIGURATION */
SFR(     EIP1, 0xF6 )  ; /* EXTERNAL INTERRUPT PRIORITY REGISTER 1 */
SFR(   CPT0CN, 0xF8 )  ; /* COMPARATOR 0 CONTROL */
SFR(    PCA0L, 0xF9 )  ; /* PCA COUNTER LOW */
SFR(    PCA0H, 0xFA )  ; /* PCA COUNTER HIGH */
SFR( PCA0CPL0, 0xFB )  ; /* PCA CAPTURE 0 LOW */
SFR( PCA0CPH0, 0xFC )  ; /* PCA CAPTURE 0 HIGH */


/*  WORD/DWORD Registers  */

SFR16E(     TMR0, 0x8C8A )  ; /* TIMER 0 COUNTER */
SFR16E(     TMR1, 0x8D8B )  ; /* TIMER 1 COUNTER */
SFR16E(     TOFF, 0xA3A2 )  ; /* TEMPERATURE SENSOR OFFSET WORD */
SFR16E(     ADC0, 0xAEAD )  ; /* ADC0 DATA WORD */
SFR16E(   ADC0GT, 0xC4C3 )  ; /* ADC 0 GREATER-THAN REGISTER WORD */
SFR16E(   ADC0LT, 0xC6C5 )  ; /* ADC 0 LESS-THAN REGISTER WORD */
SFR16E(     TMR2, 0xCDCC )  ; /* TIMER 2 COUNTER */
SFR16E(    RCAP2, 0xCBCA )  ; /* TIMER 2 CAPTURE REGISTER WORD */
SFR16E(   TMR2RL, 0xCBCA )  ; /* TIMER 2 CAPTURE REGISTER WORD */
SFR16E(     PCA0, 0xFAF9 )  ; /* PCA COUNTER */
SFR16E(  PCA0CP0, 0xFCFB )  ; /* PCA CAPTURE 0 WORD */
SFR16E(  PCA0CP1, 0xEAE9 )  ; /* PCA CAPTURE 1 WORD */
SFR16E(  PCA0CP2, 0xECEB )  ; /* PCA CAPTURE 2 WORD */


/*  BIT Registers  */

/*  P0  0x80 */
SBIT(     P0_0, 0x80, 0 )  ;
SBIT(     P0_1, 0x80, 1 )  ;
SBIT(     P0_2, 0x80, 2 )  ;
SBIT(     P0_3, 0x80, 3 )  ;
SBIT(     P0_4, 0x80, 4 )  ;
SBIT(     P0_5, 0x80, 5 )  ;
SBIT(     P0_6, 0x80, 6 )  ;
SBIT(     P0_7, 0x80, 7 )  ;

/*  TCON  0x88 */
SBIT(      IT0, 0x88, 0 )  ; /* TCON.0 - EXT. INTERRUPT 0 TYPE */
SBIT(      IE0, 0x88, 1 )  ; /* TCON.1 - EXT. INTERRUPT 0 EDGE FLAG */
SBIT(      IT1, 0x88, 2 )  ; /* TCON.2 - EXT. INTERRUPT 1 TYPE */
SBIT(      IE1, 0x88, 3 )  ; /* TCON.3 - EXT. INTERRUPT 1 EDGE FLAG */
SBIT(      TR0, 0x88, 4 )  ; /* TCON.4 - TIMER 0 ON/OFF CONTROL */
SBIT(      TF0, 0x88, 5 )  ; /* TCON.5 - TIMER 0 OVERFLOW FLAG */
SBIT(      TR1, 0x88, 6 )  ; /* TCON.6 - TIMER 1 ON/OFF CONTROL */
SBIT(      TF1, 0x88, 7 )  ; /* TCON.7 - TIMER 1 OVERFLOW FLAG */

/*  SCON  0x98 */
SBIT(       RI, 0x98, 0 )  ; /* SCON.0 - RECEIVE INTERRUPT FLAG */
SBIT(      RI0, 0x98, 0 )  ; /* SCON.0 - RECEIVE INTERRUPT FLAG */
SBIT(       TI, 0x98, 1 )  ; /* SCON.1 - TRANSMIT INTERRUPT FLAG */
SBIT(      TI0, 0x98, 1 )  ; /* SCON.1 - TRANSMIT INTERRUPT FLAG */
SBIT(      RB8, 0x98, 2 )  ; /* SCON.2 - RECEIVE BIT 8 */
SBIT(     RB80, 0x98, 2 )  ; /* SCON.2 - RECEIVE BIT 8 */
SBIT(      TB8, 0x98, 3 )  ; /* SCON.3 - TRANSMIT BIT 8 */
SBIT(     TB80, 0x98, 3 )  ; /* SCON.3 - TRANSMIT BIT 8 */
SBIT(      REN, 0x98, 4 )  ; /* SCON.4 - RECEIVE ENABLE */
SBIT(     REN0, 0x98, 4 )  ; /* SCON.4 - RECEIVE ENABLE */
SBIT(      SM2, 0x98, 5 )  ; /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE */
SBIT(     MCE0, 0x98, 5 )  ; /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE */
SBIT(      SM0, 0x98, 7 )  ; /* SCON.7 - SERIAL MODE CONTROL BIT 0 */
SBIT(   S0MODE, 0x98, 7 )  ; /* SCON.7 - SERIAL MODE CONTROL BIT 0 */

/*  IE  0xA8 */
SBIT(      EX0, 0xA8, 0 )  ; /* IE.0 - EXTERNAL INTERRUPT 0 ENABLE */
SBIT(      ET0, 0xA8, 1 )  ; /* IE.1 - TIMER 0 INTERRUPT ENABLE */
SBIT(      EX1, 0xA8, 2 )  ; /* IE.2 - EXTERNAL INTERRUPT 1 ENABLE */
SBIT(      ET1, 0xA8, 3 )  ; /* IE.3 - TIMER 1 INTERRUPT ENABLE */
SBIT(       ES, 0xA8, 4 )  ; /* IE.4 - SERIAL PORT INTERRUPT ENABLE */
SBIT(      ES0, 0xA8, 4 )  ; /* IE.4 - SERIAL PORT INTERRUPT ENABLE */
SBIT(      ET2, 0xA8, 5 )  ; /* IE.5 - TIMER 2 INTERRUPT ENABLE */
SBIT(    IEGF0, 0xA8, 6 )  ; /* IE.6 - GENERAL PURPOSE FLAG 0 */
SBIT(       EA, 0xA8, 7 )  ; /* IE.7 - GLOBAL INTERRUPT ENABLE */

/*  IP  0xB8 */
SBIT(      PX0, 0xB8, 0 )  ; /* IP.0 - EXTERNAL INTERRUPT 0 PRIORITY */
SBIT(      PT0, 0xB8, 1 )  ; /* IP.1 - TIMER 0 PRIORITY */
SBIT(      PX1, 0xB8, 2 )  ; /* IP.2 - EXTERNAL INTERRUPT 1 PRIORITY */
SBIT(      PT1, 0xB8, 3 )  ; /* IP.3 - TIMER 1 PRIORITY */
SBIT(       PS, 0xB8, 4 )  ; /* IP.4 - SERIAL PORT PRIORITY */
SBIT(      PS0, 0xB8, 4 )  ; /* IP.4 - SERIAL PORT PRIORITY */
SBIT(      PT2, 0xB8, 5 )  ; /* IP.5 - TIMER 2 PRIORITY */

/*  SMB0CN  0xC0 */
SBIT(       SI, 0xC0, 0 )  ; /* SMB0CN.0 - SMBUS 0 INTERRUPT PENDING FLAG */
SBIT(      ACK, 0xC0, 1 )  ; /* SMB0CN.1 - SMBUS 0 ACKNOWLEDGE FLAG */
SBIT(  ARBLOST, 0xC0, 2 )  ; /* SMB0CN.2 - SMBUS 0 ARBITRATION LOST INDICATOR */
SBIT(    ACKRQ, 0xC0, 3 )  ; /* SMB0CN.3 - SMBUS 0 ACKNOWLEDGE REQUEST */
SBIT(      STO, 0xC0, 4 )  ; /* SMB0CN.4 - SMBUS 0 STOP FLAG */
SBIT(      STA, 0xC0, 5 )  ; /* SMB0CN.5 - SMBUS 0 START FLAG */
SBIT(   TXMODE, 0xC0, 6 )  ; /* SMB0CN.6 - SMBUS 0 TRANSMIT MODE INDICATOR */
SBIT(   MASTER, 0xC0, 7 )  ; /* SMB0CN.7 - SMBUS 0 MASTER/SLAVE INDICATOR */

/*  TMR2CN  0xC8 */
SBIT(   T2XCLK, 0xC8, 0 )  ; /* TMR2CN.0 - TIMER 2 EXTERNAL CLOCK SELECT */
SBIT(      TR2, 0xC8, 2 )  ; /* TMR2CN.2 - TIMER 2 ON/OFF CONTROL */
SBIT(  T2SPLIT, 0xC8, 3 )  ; /* TMR2CN.3 - TIMER 2 SPLIT MODE ENABLE */
SBIT(   TF2LEN, 0xC8, 5 )  ; /* TMR2CN.5 - TIMER 2 LOW BYTE INTERRUPT ENABLE */
SBIT(     TF2L, 0xC8, 6 )  ; /* TMR2CN.6 - TIMER 2 LOW BYTE OVERFLOW FLAG */
SBIT(      TF2, 0xC8, 7 )  ; /* TMR2CN.7 - TIMER 2 OVERFLOW FLAG */
SBIT(     TF2H, 0xC8, 7 )  ; /* TMR2CN.7 - TIMER 2 HIGH BYTE OVERFLOW FLAG */

/*  PSW  0xD0 */
SBIT(   PARITY, 0xD0, 0 )  ; /* PSW.0 - ACCUMULATOR PARITY FLAG */
SBIT(       F1, 0xD0, 1 )  ; /* PSW.1 - FLAG 1 */
SBIT(       OV, 0xD0, 2 )  ; /* PSW.2 - OVERFLOW FLAG */
SBIT(      RS0, 0xD0, 3 )  ; /* PSW.3 - REGISTER BANK SELECT 0 */
SBIT(      RS1, 0xD0, 4 )  ; /* PSW.4 - REGISTER BANK SELECT 1 */
SBIT(       F0, 0xD0, 5 )  ; /* PSW.5 - FLAG 0 */
SBIT(       AC, 0xD0, 6 )  ; /* PSW.6 - AUXILIARY CARRY FLAG */
SBIT(       CY, 0xD0, 7 )  ; /* PSW.7 - CARRY FLAG */

/*  PCA0CN  0xD8 */
SBIT(     CCF0, 0xD8, 0 )  ; /* PCA0CN.0 - PCA MODULE 0 CAPTURE/COMPARE FLAG */
SBIT(     CCF1, 0xD8, 1 )  ; /* PCA0CN.1 - PCA MODULE 1 CAPTURE/COMPARE FLAG */
SBIT(     CCF2, 0xD8, 2 )  ; /* PCA0CN.2 - PCA MODULE 2 CAPTURE/COMPARE FLAG */
SBIT(       CR, 0xD8, 6 )  ; /* PCA0CN.6 - PCA COUNTER/TIMER RUN CONTROL */
SBIT(       CF, 0xD8, 7 )  ; /* PCA0CN.7 - PCA COUNTER/TIMER OVERFLOW FLAG */

/*  ADC0CN  0xE8 */
SBIT(   AD0CM0, 0xE8, 0 )  ; /* ADC0CN.0 - ADC 0 START OF CONV. MODE BIT 0 */
SBIT(   AD0CM1, 0xE8, 1 )  ; /* ADC0CN.1 - ADC 0 START OF CONV. MODE BIT 1 */
SBIT(   AD0CM2, 0xE8, 2 )  ; /* ADC0CN.2 - ADC 0 START OF CONV. MODE BIT 2 */
SBIT(  AD0WINT, 0xE8, 3 )  ; /* ADC0CN.3 - ADC 0 WINDOW COMPARE INT. FLAG */
SBIT(  AD0BUSY, 0xE8, 4 )  ; /* ADC0CN.4 - ADC 0 BUSY FLAG */
SBIT(   AD0INT, 0xE8, 5 )  ; /* ADC0CN.5 - ADC 0 CONV. COMPLETE INT. FLAG */
SBIT(    AD0TM, 0xE8, 6 )  ; /* ADC0CN.6 - ADC 0 TRACK MODE */
SBIT(    AD0EN, 0xE8, 7 )  ; /* ADC0CN.7 - ADC 0 ENABLE */

/*  CPT0CN  0xF8 */
SBIT(  CP0HYN0, 0xF8, 0 )  ; /* CPT0CN.0 - Comp.0 Neg. Hysteresis Control Bit0*/
SBIT(  CP0HYN1, 0xF8, 1 )  ; /* CPT0CN.1 - Comp.0 Neg. Hysteresis Control Bit1*/
SBIT(  CP0HYP0, 0xF8, 2 )  ; /* CPT0CN.2 - Comp.0 Pos. Hysteresis Control Bit0*/
SBIT(  CP0HYP1, 0xF8, 3 )  ; /* CPT0CN.3 - Comp.0 Pos. Hysteresis Control Bit1*/
SBIT(   CP0FIF, 0xF8, 4 )  ; /* CPT0CN.4 - Comparator0 Falling-Edge Int. Flag */
SBIT(   CP0RIF, 0xF8, 5 )  ; /* CPT0CN.5 - Comparator0 Rising-Edge Int. Flag */
SBIT(   CP0OUT, 0xF8, 6 )  ; /* CPT0CN.6 - Comparator0 Output State Flag */
SBIT(    CP0EN, 0xF8, 7 )  ; /* CPT0CN.7 - Comparator0 Enable Bit */


/* Predefined SFR Bit Masks */

#define PCON_IDLE         0x01    /* PCON                                */
#define PCON_STOP         0x02    /* PCON                                */
#define T1M               0x10    /* CKCON                               */
#define PSWE              0x01    /* PSCTL                               */
#define PSEE              0x02    /* PSCTL                               */
#define ECP0F             0x10    /* EIE1                                */
#define ECP0R             0x20    /* EIE1                                */
#define PORSF             0x02    /* RSTSRC                              */
#define SWRSF             0x10    /* RSTSRC                              */
#define ECCF              0x01    /* PCA0CPMn                            */
#define PWM               0x02    /* PCA0CPMn                            */
#define TOG               0x04    /* PCA0CPMn                            */
#define MAT               0x08    /* PCA0CPMn                            */
#define CAPN              0x10    /* PCA0CPMn                            */
#define CAPP              0x20    /* PCA0CPMn                            */
#define ECOM              0x40    /* PCA0CPMn                            */
#define PWM16             0x80    /* PCA0CPMn                            */
#define CP0E              0x10    /* XBR1                                */
#define CP0OEN            0x10    /* XBR1                                */
#define CP0AE             0x20    /* XBR1                                */
#define CP0AOEN           0x20    /* XBR1                                */

/* Interrupts */

#define INT_EXT0          0       /* External Interrupt 0 */
#define INT_TIMER0        1       /* Timer0 Overflow */
#define INT_EXT1          2       /* External Interrupt 1 */
#define INT_TIMER1        3       /* Timer1 Overflow */
#define INT_UART0         4       /* Serial Port 0 */
#define INT_TIMER2        5       /* Timer2 Overflow */
#define INT_SMBUS0        6       /* SMBus0 Interface */
#define INT_ADC0_WINDOW   7       /* ADC0 Window Comparison */
#define INT_ADC0_EOC      8       /* ADC0 End Of Conversion */
#define INT_PCA0          9       /* PCA0 Peripheral */
#define INT_CP0F          10      /* Comparator0 falling edge */
#define INT_CP0R          11      /* Comparator1 rising edge */

#endif
/*-------------------------------------------------------------------------
   P89LPC925.h - Register Declarations for NXP  P89LPC924 and P89LPC925
   (Based on datasheet Rev. 03  15 December 2004)

   Copyright (C) 2007, Jesus Calvino-Fraga / jesusc at ece.ubc.ca

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef REG_P89LPC925_H
#define REG_P89LPC925_H

#include <compiler.h>

SFR(ACC, 0xE0); // Accumulator
   SBIT(ACC_7, 0xE0, 7);
   SBIT(ACC_6, 0xE0, 6);
   SBIT(ACC_5, 0xE0, 5);
   SBIT(ACC_4, 0xE0, 4);
   SBIT(ACC_3, 0xE0, 3);
   SBIT(ACC_2, 0xE0, 2);
   SBIT(ACC_1, 0xE0, 1);
   SBIT(ACC_0, 0xE0, 0);

SFR(ADCON1, 0x97); // A/D control register 1
   #define ENBI1   0x80
   #define ENADCI1 0x40
   #define TMM1    0x20
   #define EDGE1   0x10
   #define ADCI1   0x08
   #define ENADC1  0x04
   #define ADCS11  0x02
   #define ADCS10  0x01

SFR(ADINS, 0xA3); // A/D input select
   #define ADI13 0x80
   #define ADI12 0x40
   #define ADI11 0x20
   #define ADI10 0x10

SFR(ADMODA, 0xC0); // A/D mode register A
   #define BNDI1  0x80
   #define BURST1 0x40
   #define SCC1   0x20
   #define SCAN1  0x10

SFR(ADMODB, 0xA1); // A/D mode register B
   #define CLK2   0x80
   #define CLK1   0x40
   #define CLK0   0x20
   #define ENDAC1 0x08
   #define BSA1   0x02

SFR(AD1BH, 0xC4); // A/D_1 boundary high register

SFR(AD1BL, 0xBC); // A/D_1 boundary low register

SFR(AD1DAT0, 0xD5); // A/D_1 data register 0

SFR(AD1DAT1, 0xD6); // A/D_1 data register 1

SFR(AD1DAT2, 0xD7); // A/D_1 data register 2

SFR(AD1DAT3, 0xF5); // A/D_1 data register 3

SFR(AUXR1, 0xA2); // Auxiliary function register
   #define CLKLP 0x80
   #define EBRR  0x40
   #define ENT1  0x20
   #define ENT0  0x10
   #define SRST  0x08
   #define DPS   0x01

SFR(B, 0xF0); // B register
   SBIT(B_7, 0xF0, 7);
   SBIT(B_6, 0xF0, 6);
   SBIT(B_5, 0xF0, 5);
   SBIT(B_4, 0xF0, 4);
   SBIT(B_3, 0xF0, 3);
   SBIT(B_2, 0xF0, 2);
   SBIT(B_1, 0xF0, 1);
   SBIT(B_0, 0xF0, 0);

SFR(BRGR0, 0xBE); // Baud rate generator rate LOW

SFR(BRGR1, 0xBF); // Baud rate generator rate HIGH

SFR(BRGCON, 0xBD); // Baud rate generator control
   #define SBRGS 0x02
   #define BRGEN 0x01

SFR(CMP1, 0xAC); // Comparator1 control register
   #define CE1  0x20
   #define CP1  0x10
   #define CN1  0x08
   #define OE1  0x04
   #define CO1  0x02
   #define CMF1 0x01

SFR(CMP2, 0xAD); // Comparator2 control register
   #define CE2  0x20
   #define CP2  0x10
   #define CN2  0x08
   #define OE2  0x04
   #define CO2  0x02
   #define CMF2 0x01

SFR(DIVM, 0x95); // CPU clock divide-by-M control

SFR(DPH, 0x83); // Data pointer HIGH

SFR(DPL, 0x82); // Data pointer LOW

SFR(FMADRH, 0xE7); // Program Flash address HIGH

SFR(FMADRL, 0xE6); // Program Flash address LOW

SFR(FMCON, 0xE4); // Program Flash control (Read)
   #define BUSY 0x80
   #define HVA  0x08
   #define HVE  0x04
   #define SV  0x02
   #define OI  0x01

SFR(FMCON, 0xE4); // Program Flash control (Write)
   #define FMCMD_7 0x80
   #define FMCMD_6 0x40
   #define FMCMD_5 0x20
   #define FMCMD_4 0x10
   #define FMCMD_3 0x08
   #define FMCMD_2 0x04
   #define FMCMD_1 0x02
   #define FMCMD_0 0x01

SFR(FMDATA, 0xE5); // Program Flash data

SFR(I2ADR, 0xDB); // I2C slave address register
   #define I2ADR_6 0x80
   #define I2ADR_5 0x40
   #define I2ADR_4 0x20
   #define I2ADR_3 0x10
   #define I2ADR_2 0x08
   #define I2ADR_1 0x04
   #define I2ADR_0 0x02
   #define GC      0x01

SFR(I2CON, 0xD8); // I2C control register
   SBIT(I2EN,  0xD8, 6);
   SBIT(STA,   0xD8, 5);
   SBIT(STO,   0xD8, 4);
   SBIT(SI,    0xD8, 3);
   SBIT(AA,    0xD8, 2);
   SBIT(CRSEL, 0xD8, 0);

SFR(I2DAT, 0xDA); // I2C data register

SFR(I2SCLH, 0xDD); // Serial clock generator/SCL duty cycle register HIGH

SFR(I2SCLL, 0xDC); // Serial clock generator/SCL duty cycle register LOW

SFR(I2STAT, 0xD9); // I2C status register
   #define STA_4 0x80
   #define STA_3 0x40
   #define STA_2 0x20
   #define STA_1 0x10
   #define STA_0 0x08

SFR(IEN0, 0xA8); // Interrupt enable 0
   SBIT(EA,    0xA8, 7);
   SBIT(EWDRT, 0xA8, 6);
   SBIT(EBO,   0xA8, 5);
   SBIT(ES,    0xA8, 4);
   SBIT(ESR,   0xA8, 4);
   SBIT(ET1,   0xA8, 3);
   SBIT(EX1,   0xA8, 2);
   SBIT(ET0,   0xA8, 1);
   SBIT(EX0,   0xA8, 0);

SFR(IEN1, 0xE8); // Interrupt enable 1
   SBIT(EAD,  0xE8, 7);
   SBIT(EST,  0xE8, 6);
   SBIT(EC,   0xE8, 2);
   SBIT(EKBI, 0xE8, 1);
   SBIT(EI2C, 0xE8, 0);

SFR(IP0, 0xB8); // Interrupt priority 0
   SBIT(PWDRT, 0xB8, 6);
   SBIT(PBO,   0xB8, 5);
   SBIT(PS,    0xB8, 4);
   SBIT(PSR,   0xB8, 4);
   SBIT(PT1,   0xB8, 3);
   SBIT(PX1,   0xB8, 2);
   SBIT(PT0,   0xB8, 1);
   SBIT(PX0,   0xB8, 0);

SFR(IP0H, 0xB7); // Interrupt priority 0 HIGH
   #define PWDRTH 0x40
   #define PBOH   0x20
   #define PSH    0x10
   #define PSRH   0x10
   #define PT1H   0x08
   #define PX1H   0x04
   #define PT0H   0x02
   #define PX0H   0x01

SFR(IP1, 0xF8); // Interrupt priority 1
   SBIT(PAD,  0xF8, 7);
   SBIT(PST,  0xF8, 6);
   SBIT(PC,   0xF8, 2);
   SBIT(PKBI, 0xF8, 1);
   SBIT(PI2C, 0xF8, 0);

SFR(IP1H, 0xF7); // Interrupt priority 1 HIGH
   #define PADH  0x80
   #define PSTH  0x40
   #define PCH   0x04
   #define PKBIH 0x02
   #define PI2CH 0x01

SFR(KBCON, 0x94); // Keypad control register
   #define PATN_SEL 0x02 //Pattern Matching Polarity selection
   #define KBIF     0x01 // Keypad Interrupt Flag

SFR(KBMASK, 0x86); // Keypad interrupt register mask

SFR(KBPATN, 0x93); // Keypad pattern register

SFR(P0, 0x80); // Port 0
   SBIT(P0_7, 0x80, 7);
   SBIT(P0_6, 0x80, 6);
   SBIT(P0_5, 0x80, 5);
   SBIT(P0_4, 0x80, 4);
   SBIT(P0_3, 0x80, 3);
   SBIT(P0_2, 0x80, 2);
   SBIT(P0_1, 0x80, 1);
   SBIT(P0_0, 0x80, 0);
   //P0 alternate pin functions
   SBIT(T1,     0x80, 7);
   SBIT(CMP_1,  0x80, 6); //Should be CMP1 but there is SFR with that name
   SBIT(CMPREF, 0x80, 5);
   SBIT(CIN1A,  0x80, 4);
   SBIT(CIN1B,  0x80, 3);
   SBIT(CIN2A,  0x80, 2);
   SBIT(CIN2B,  0x80, 1);
   SBIT(CMP_2,  0x80, 0); //Should be CMP2 but there is SFR with that name
   //More P0 alternate pin functions
   SBIT(KB7, 0x80, 7);
   SBIT(KB6, 0x80, 6);
   SBIT(KB5, 0x80, 5);
   SBIT(KB4, 0x80, 4);
   SBIT(KB3, 0x80, 3);
   SBIT(KB2, 0x80, 2);
   SBIT(KB1, 0x80, 1);
   SBIT(KB0, 0x80, 0);

SFR(P1, 0x90); // Port 1
   SBIT(P1_7, 0x90, 7);
   SBIT(P1_6, 0x90, 6);
   SBIT(P1_5, 0x90, 5);
   SBIT(P1_4, 0x90, 4);
   SBIT(P1_3, 0x90, 3);
   SBIT(P1_2, 0x90, 2);
   SBIT(P1_1, 0x90, 1);
   SBIT(P1_0, 0x90, 0);
   //P1 alternate pin functions
   SBIT(RST,  0x90, 5);
   SBIT(INT1, 0x90, 4);
   SBIT(INT0, 0x90, 3);
   SBIT(SDA,  0x90, 3);
   SBIT(T0,   0x90, 2);
   SBIT(SCL,  0x90, 2);
   SBIT(RXD,  0x90, 1);
   SBIT(TXD,  0x90, 0);

SFR(P3, 0xB0); // Port 3
   SBIT(P3_1, 0xB0, 1);
   SBIT(P3_0, 0xB0, 0);
   SBIT(XTAL1, 0xB0, 1);
   SBIT(XTAL2, 0xB0, 0);

SFR(P0M1, 0x84); // Port0 output mode1
   #define P0M1_7 0x80
   #define P0M1_6 0x40
   #define P0M1_5 0x20
   #define P0M1_4 0x10
   #define P0M1_3 0x08
   #define P0M1_2 0x04
   #define P0M1_1 0x02
   #define P0M1_0 0x01

SFR(P0M2, 0x85); // Port0 output mode2
   #define P0M2_7 0x80
   #define P0M2_6 0x40
   #define P0M2_5 0x20
   #define P0M2_4 0x10
   #define P0M2_3 0x08
   #define P0M2_2 0x04
   #define P0M2_1 0x02
   #define P0M2_0 0x01

SFR(P1M1, 0x91); // Port1 output mode1
   #define P1M1_7 0x80
   #define P1M1_6 0x40
   #define P1M1_4 0x10
   #define P1M1_3 0x08
   #define P1M1_2 0x04
   #define P1M1_1 0x02
   #define P1M1_0 0x01

SFR(P1M2, 0x92); // Port1 output mode2
   #define P1M2_7 0x80
   #define P1M2_6 0x40
   #define P1M2_4 0x10
   #define P1M2_3 0x08
   #define P1M2_2 0x04
   #define P1M2_1 0x02
   #define P1M2_0 0x01

SFR(P3M1, 0xB1); // Port3 output mode1
   #define P3M1_1 0x02
   #define P3M1_0 0x01

SFR(P3M2, 0xB2); // Port3 output mode2
   #define P3M2_1 0x02
   #define P3M2_0 0x01

SFR(PCON, 0x87); // Power control register
   #define SMOD1 0x80
   #define SMOD0 0x40
   #define BOPD  0x20
   #define BOI   0x10
   #define GF1   0x08
   #define GF0   0x04
   #define PMOD1 0x02
   #define PMOD0 0x01

SFR(PCONA, 0xB5); // Power control register A
   #define RTCPD 0x80
   #define VCPD  0x20
   #define ADPD  0x10
   #define I2PD  0x08
   #define SPD   0x02

SFR(PSW, 0xD0); // Program status word
   SBIT(CY,  0xD0, 7);
   SBIT(AC,  0xD0, 6);
   SBIT(F0,  0xD0, 5);
   SBIT(RS1, 0xD0, 4);
   SBIT(RS0, 0xD0, 3);
   SBIT(OV,  0xD0, 2);
   SBIT(F1,  0xD0, 1);
   SBIT(P,   0xD0, 0);

SFR(PT0AD, 0xF6); // Port0 digital input disable
   #define PT0AD_5 0x20
   #define PT0AD_4 0x10
   #define PT0AD_3 0x08
   #define PT0AD_2 0x04
   #define PT0AD_1 0x02

SFR(RSTSRC, 0xDF); // Reset source register
   #define BOF 0x20
   #define POF 0x10
   #define R_BK 0x08
   #define R_WD 0x04
   #define R_SF 0x02
   #define R_EX 0x01

SFR(RTCCON, 0xD1); // Real-time clock control
   #define RTCF  0x80
   #define RTCS1 0x40
   #define RTCS0 0x20
   #define ERTC  0x02
   #define RTCEN 0x01

SFR(RTCH, 0xD2); // Real-time clock register HIGH

SFR(RTCL, 0xD3); // Real-time clock register LOW

SFR(SADDR, 0xA9); // Serial port address register

SFR(SADEN, 0xB9); // Serial port address enable

SFR(SBUF, 0x99); // Serial Port data buffer register

SFR(SCON, 0x98); // Serial port control
   SBIT(FE,  0x98, 7);
   SBIT(SM0, 0x98, 7);
   SBIT(SM1, 0x98, 6);
   SBIT(SM2, 0x98, 5);
   SBIT(REN, 0x98, 4);
   SBIT(TB8, 0x98, 3);
   SBIT(RB8, 0x98, 2);
   SBIT(TI,  0x98, 1);
   SBIT(RI,  0x98, 0);

SFR(SSTAT, 0xBA); // Serial port extended status register
   #define DBMOD  0x80
   #define INTLO  0x40
   #define CIDIS  0x20
   #define DBISEL 0x10
   #define FE     0x08
   #define BR     0x04
   #define OE     0x02
   #define STINT  0x01

SFR(SP, 0x81); // Stack pointer

SFR(TAMOD, 0x8F); // Timer0 and 1 auxiliary mode
   #define T1M2 0x10
   #define T0M2 0x01

SFR(TCON, 0x88); // Timer0 and 1 control
   SBIT(TF1, 0x88, 7);
   SBIT(TR1, 0x88, 6);
   SBIT(TF0, 0x88, 5);
   SBIT(TR0, 0x88, 4);
   SBIT(IE1, 0x88, 3);
   SBIT(IT1, 0x88, 2);
   SBIT(IE0, 0x88, 1);
   SBIT(IT0, 0x88, 0);

SFR(TH0, 0x8C); // Timer0 HIGH

SFR(TH1, 0x8D); // Timer 1 HIGH

SFR(TL0, 0x8A); // Timer 0 LOW

SFR(TL1, 0x8B); // Timer 1 LOW

SFR(TMOD, 0x89); // Timer0 and 1 mode
   #define T1GATE 0x80
   #define T1C_T  0x40
   #define T1M1   0x20
   #define T1M0   0x10
   #define T0GATE 0x08
   #define T0C_T  0x04
   #define T0M1   0x02
   #define T0M0   0x01

SFR(TRIM, 0x96); // Internal oscillator trim register
   #define RCCLK  0x80
   #define ENCLK  0x40
   #define TRIM_5 0x20
   #define TRIM_4 0x10
   #define TRIM_3 0x08
   #define TRIM_2 0x04
   #define TRIM_1 0x02
   #define TRIM_0 0x01

SFR(WDCON, 0xA7); // Watchdog control register
   #define PRE2  0x80 //Watchdog Prescaler Tap Select bit 2
   #define PRE1  0x40 //Watchdog Prescaler Tap Select bit 1
   #define PRE0  0x20 //Watchdog Prescaler Tap Select bit 0
   #define WDRUN 0x04 //Watchdog Run Control
   #define WDTOF 0x02 //Watchdog Timer Time-Out Flag
   #define WDCLK 0x01 //Watchdog input clock select

SFR(WDL, 0xC1); // Watchdog load

SFR(WFEED1, 0xC2); // Watchdog feed 1

SFR(WFEED2, 0xC3); // Watchdog feed 2

#endif /*REG_P89LPC925_H*/
/*-------------------------------------------------------------------------
   p89lpc933_4.h - This header allows to use the microcontrolers NXP
   (formerly Philips) p89lpc933, 934.

   Copyright (C) 2008, Gudjon I. Gudjonsson <gudjon AT gudjon.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------
 The registered are ordered in the same way as in the NXP data sheet:
 http://www.standardics.nxp.com/products/lpc900/datasheet/p89lpc933.p89lpc934.p89lpc935.p89lpc936.pdf
-------------------------------------------------------------------------*/

#ifndef __P89LPC933_4_H__
#define __P89LPC933_4_H__
#include <compiler.h>

/*BYTE Registers*/
SFR(ACC, 0xE0); // Accumulator
	SBIT(ACC_7, 0xE0, 7);
	SBIT(ACC_6, 0xE0, 6);
	SBIT(ACC_5, 0xE0, 5);
	SBIT(ACC_4, 0xE0, 4);
	SBIT(ACC_3, 0xE0, 3);
	SBIT(ACC_2, 0xE0, 2);
	SBIT(ACC_1, 0xE0, 1);
	SBIT(ACC_0, 0xE0, 0);
SFR(ADCON0, 0x8E); // A/D control register 0
	#define  ENADC0   0x04
SFR(ADCON1, 0x97); // A/D control register 1
	#define  ENBI1    0x80
	#define  ENADCI1  0x40
	#define  TMM1     0x20
	#define  EDGE1    0x10
	#define  ADCI1    0x08
	#define  ENADC1   0x04
	#define  ADCS11   0x02
	#define  ADCS10   0x01
SFR(ADINS, 0xA3); // A/D input select
	#define  ADI13    0x80
	#define  ADI12    0x40
	#define  ADI11    0x20
	#define  ADI10    0x10
SFR(ADMODA, 0xC0); // A/D mode register A
	SBIT(BNDI1,  0xC0, 7);
	SBIT(BURST1, 0xC0, 6);
	SBIT(SCC1,   0xC0, 5);
	SBIT(SCAN1,  0xC0, 4);
SFR(ADMODB, 0xA1); // A/D mode register B
	#define  CLK2     0x80
	#define  CLK1     0x40
	#define  CLK0     0x20
	#define  ENDAC1   0x08
	#define  ENDAC0   0x04
	#define  BSA1     0x02
SFR(AD0DAT3, 0xF4); // A/D_0 data register 3
SFR(AD1BH,   0xC4); // A/D_1 boundary high register
SFR(AD1BL,   0xBC); // A/D_1 boundary low register
SFR(AD1DAT0, 0xD5); // A/D_1 data register 0
SFR(AD1DAT1, 0xD6); // A/D_1 data register 1
SFR(AD1DAT2, 0xD7); // A/D_1 data register 2
SFR(AD1DAT3, 0xF5); // A/D_1 data register 3
SFR(AUXR1,   0xA2); // Auxilary function register
	#define  CLKLP    0x80
	#define  EBRR     0x40
	#define  ENT1     0x20
	#define  ENT0     0x10
	#define  SRST     0x08  // Bit 2 is always 0
	#define  DPS      0x01
SFR(B, 0xF0); // B register
	SBIT(B7, 0xF0, 7);
	SBIT(B6, 0xF0, 6);
	SBIT(B5, 0xF0, 5);
	SBIT(B4, 0xF0, 4);
	SBIT(B3, 0xF0, 3);
	SBIT(B2, 0xF0, 2);
	SBIT(B1, 0xF0, 1);
	SBIT(B0, 0xF0, 0);
SFR(BRGR0,  0xBE); // Baud rate generator rate low
SFR(BRGR1,  0xBF); // Baud rate generator rate high
SFR(BRGCON, 0xBD); // Baud rate generator control
	#define  SBRGS    0x02
	#define  BRGEN    0x01
SFR(CMP1,   0xAC); // Comparator 1 control register
	#define  CE1      0x20
	#define  CP1      0x10
	#define  CN1      0x08
	#define  OE1      0x04
	#define  CO1      0x02
	#define  CMF1     0x01
SFR(CMP2,   0xAD); // Comparator 2 control register
	#define  CE2      0x20
	#define  CP2      0x10
	#define  CN2      0x08
	#define  OE2      0x04
	#define  CO2      0x02
	#define  CMF2     0x01
SFR(DIVM,   0x95); // CPU clock divide-by-M control
SFR(DPH,  0x83); // Data Pointer High
SFR(DPL,  0x82); // Data Pointer Low
SFR(FMADRH, 0xE7); // Program flash address high
SFR(FMADRL, 0xE6); // Program flash address low
SFR(FMCON,  0xE4);
	// Program flash control (Read)
	#define  BUSY     0x80
	#define  HVA      0x08
	#define  HVE      0x04
	#define  SV       0x02
	#define  OI       0x01
	// Program flash control (Write)
	#define  FMCMD_7  0x80
	#define  FMCMD_6  0x40
	#define  FMCMD_5  0x20
	#define  FMCMD_4  0x10
	#define  FMCMD_3  0x08
	#define  FMCMD_2  0x04
	#define  FMCMD_1  0x02
	#define  FMCMD_0  0x01
SFR(FMDATA,  0xE5); // Program flash data
SFR(I2ADR,   0xDB); // I2C slave address register
	#define I2ADR_6  0x80
	#define I2ADR_5  0x40
	#define I2ADR_4  0x20
	#define I2ADR_3  0x10
	#define I2ADR_2  0x08
	#define I2ADR_1  0x04
	#define I2ADR_0  0x02
	#define GC       0x01
SFR(I2CON,  0xD8); // I2C control register
	SBIT(I2EN,  0xD8, 6);
	SBIT(STA,   0xD8, 5);
	SBIT(STO,   0xD8, 4);
	SBIT(SI,    0xD8, 3);
	SBIT(AA,    0xD8, 2);
	SBIT(CRSEL, 0xD8, 0);
SFR(I2DAT,  0xDA); // I2C data register
SFR(I2SCLH, 0xDD); // I2C serial clock generator/SCL duty cycle register high
SFR(I2SCLL, 0xDC); // I2C serial clock generator/SCL duty cycle register low
SFR(I2STAT, 0xD9); // I2C status register
	#define STA_4   0x80
	#define STA_3   0x40
	#define STA_2   0x20
	#define STA_1   0x10
	#define STA_0   0x08    // Only write 0 to the lowest three bits
SFR(ICRAH,  0xAB); // Input capture A register high
SFR(ICRAL,  0xAA); // Input capture A register low
SFR(ICRBH,  0xAF); // Input capture B register high
SFR(ICRBL,  0xAE); // Input capture B register low
SFR(IEN0,   0xA8); // Interrupt Enable 0
	SBIT(EA,     0xA8, 7);
	SBIT(EWDRT,  0xA8, 6);
	SBIT(EBO,    0xA8, 5);
	SBIT(ES_ESR, 0xA8, 4);
	SBIT(ET1,    0xA8, 3);
	SBIT(EX1,    0xA8, 2);
	SBIT(ET0,    0xA8, 1);
	SBIT(EX0,    0xA8, 0);
SFR(IEN1,  0xE8); // Interrupt Enable 1
	SBIT(EAD,    0xE8, 7);
	SBIT(EST,    0xE8, 6);
	SBIT(ESPI,   0xE8, 3);
	SBIT(EC,     0xE8, 2);
	SBIT(EKBI,   0xE8, 1);
	SBIT(EI2C,   0xE8, 0);
SFR(IP0, 0xB8); // Interrupt Priority 0
	SBIT(PWDRT,  0xB8, 6);
	SBIT(PBO,    0xB8, 5);
	SBIT(PS_PSR, 0xB8, 4);
	SBIT(PT1,    0xB8, 3);
	SBIT(PX1,    0xB8, 2);
	SBIT(PT0,    0xB8, 1);
	SBIT(PX0,    0xB8, 0);
SFR(IP0H, 0xB7); // Interrupt Priority 0 high
	#define PWDRTH    0x40
	#define PBOH      0x20
	#define PSH_PSRH  0x10
	#define PT1H      0x08
	#define PX1H      0x04
	#define PT0H      0x02
	#define PX0H      0x01
SFR(IP1,  0xF8); // Interrupt Priority 1
	SBIT(PAD,   0xF8, 7);
	SBIT(PST,   0xF8, 6);
	SBIT(PSPI,  0xF8, 3);
	SBIT(PC,    0xF8, 2);
	SBIT(PKBI,  0xF8, 1);
	SBIT(PI2C,  0xF8, 0);
SFR(IP1H, 0xF7); // Interrupt Priority 1 High
	#define PADH   0x80
	#define PSTH   0x40
	#define PSPIH  0x08
	#define PCH    0x04
	#define PKBIH  0x02
	#define PI2CH  0x01
SFR(KBCON, 0x94); // Keypad control register
	#define PATN_SEL 0x02
	#define KBIF     0x01
SFR(KBMASK, 0x86); // Keypad interrupt mask register
SFR(KBPATN, 0x93); // Keypad pattern register
SFR(P0, 0x80); // Port 0
	SBIT(P0_7,  0x80, 7);
	SBIT(T1,    0x80, 7);
	SBIT(KB7,   0x80, 7);
	SBIT(P0_6,  0x80, 6);
	SBIT(CMP_1, 0x80, 6); // Renamed, not to conflict with the CMP1 register
	SBIT(KB6,   0x80, 6);
	SBIT(P0_5,  0x80, 5);
	SBIT(CMPREF,0x80, 5);
	SBIT(KB5,   0x80, 5);
	SBIT(P0_4,  0x80, 4);
	SBIT(CIN1A, 0x80, 4);
	SBIT(KB4,   0x80, 4);
	SBIT(P0_3,  0x80, 3);
	SBIT(CIN1B, 0x80, 3);
	SBIT(KB3,   0x80, 3);
	SBIT(P0_2,  0x80, 2);
	SBIT(CIN2A, 0x80, 2);
	SBIT(KB2,   0x80, 2);
	SBIT(P0_1,  0x80, 1);
	SBIT(CIN2B, 0x80, 1);
	SBIT(KB1,   0x80, 1);
	SBIT(P0_0,  0x80, 0);
	SBIT(CMP_2, 0x80, 0); // Renamed, not to conflict with the CMP2 register
	SBIT(KB0,   0x80, 0);
SFR(P1, 0x90); // Port 1
	SBIT(P1_7,    0x90, 7);
	SBIT(P1_6,    0x90, 6);
	SBIT(P1_5,    0x90, 5);
	SBIT(RST,     0x90, 5);
	SBIT(P1_4,    0x90, 4);
	SBIT(INT1,    0x90, 4);
	SBIT(P1_3,    0x90, 3);
	SBIT(INT0,    0x90, 3);
	SBIT(SDA,     0x90, 3);
	SBIT(P1_2,    0x90, 2);
	SBIT(T0,      0x90, 2);
	SBIT(SCL,     0x90, 2);
	SBIT(P1_1,    0x90, 1);
	SBIT(RXD,     0x90, 1);
	SBIT(P1_0,    0x90, 0);
	SBIT(TXD,     0x90, 0);
SFR(P2, 0xA0); // Port 2
	SBIT(P2_7,   0xA0, 7);
	SBIT(P2_6,   0xA0, 6);
	SBIT(P2_5,   0xA0, 5);
	SBIT(SPICLK, 0xA0, 5);
	SBIT(P2_4,   0xA0, 4);
	SBIT(SS,     0xA0, 4);
	SBIT(P2_3,   0xA0, 3);
	SBIT(MISO,   0xA0, 3);
	SBIT(P2_2,   0xA0, 2);
	SBIT(MOSI,   0xA0, 2);
	SBIT(P2_1,   0xA0, 1);
	SBIT(P2_0,   0xA0, 0);
SFR(P3, 0xB0); // Port 3
	SBIT(P3_7, 0xB0, 7);
	SBIT(P3_6, 0xB0, 6);
	SBIT(P3_5, 0xB0, 5);
	SBIT(P3_4, 0xB0, 4);
	SBIT(P3_3, 0xB0, 3);
	SBIT(P3_2, 0xB0, 2);
	SBIT(P3_1, 0xB0, 1);
	SBIT(XTAL1,0xB0, 1);
	SBIT(P3_0, 0xB0, 0);
	SBIT(XTAL2,0xB0, 0);
SFR(P0M1, 0x84); // Port 0 output mode 1
	#define P0M1_7  0x80
	#define P0M1_6  0x40
	#define P0M1_5  0x20
	#define P0M1_4  0x10
	#define P0M1_3  0x08
	#define P0M1_2  0x04
	#define P0M1_1  0x02
	#define P0M1_0  0x01
SFR(P0M2, 0x85); // Port 0 output mode 2
	#define P0M2_7  0x80
	#define P0M2_6  0x40
	#define P0M2_5  0x20
	#define P0M2_4  0x10
	#define P0M2_3  0x08
	#define P0M2_2  0x04
	#define P0M2_1  0x02
	#define P0M2_0  0x01
SFR(P1M1, 0x91); // Port 1 output mode 1
	#define P1M1_7  0x80
	#define P1M1_6  0x40
	#define P1M1_4  0x10
	#define P1M1_3  0x08
	#define P1M1_2  0x04
	#define P1M1_1  0x02
	#define P1M1_0  0x01
SFR(P1M2, 0x92); // Port 1 output mode 2
	#define P1M2_7  0x80
	#define P1M2_6  0x40
	#define P1M2_4  0x10
	#define P1M2_3  0x08
	#define P1M2_2  0x04
	#define P1M2_1  0x02
	#define P1M2_0  0x01
SFR(P2M1, 0xA4); // Port 2 output mode 1
	#define P2M1_7  0x80
	#define P2M1_6  0x40
	#define P2M1_5  0x20
	#define P2M1_4  0x10
	#define P2M1_3  0x08
	#define P2M1_2  0x04
	#define P2M1_1  0x02
	#define P2M1_0  0x01
SFR(P2M2, 0xA5); // Port 2 output mode 2
	#define P2M2_7  0x80
	#define P2M2_6  0x40
	#define P2M2_5  0x20
	#define P2M2_4  0x10
	#define P2M2_3  0x08
	#define P2M2_2  0x04
	#define P2M2_1  0x02
	#define P2M2_0  0x01
SFR(P3M1, 0xB1); // Port 3 output mode 1
	#define P3M1_1  0x02
	#define P3M1_0  0x01
SFR(P3M2, 0xB2); // Port 3 output mode 2
	#define P3M2_1  0x02
	#define P3M2_0  0x01
SFR(PCON,  0x87); // Power control register
	#define SMOD1   0x80
	#define SMOD0   0x40
	#define BOPD    0x20
	#define BOI     0x10
	#define GF1     0x08
	#define GF0     0x04
	#define PMOD1   0x02
	#define PMOD0   0x01
SFR(PCONA, 0xB5); // Power control register A
	#define RTCPD   0x80
	#define VCPD    0x20
	#define ADPD    0x10
	#define I2PD    0x08
	#define SPPD    0x04
	#define SPD     0x02
SFR(PSW, 0xD0); // Program Status Word
	SBIT(CY,  0xD0, 7);
	SBIT(AC,  0xD0, 6);
	SBIT(F0,  0xD0, 5);
	SBIT(RS1, 0xD0, 4);
	SBIT(RS0, 0xD0, 3);
	SBIT(OV,  0xD0, 2);
	SBIT(F1,  0xD0, 1);
	SBIT(P,   0xD0, 0);
SFR(PT0AD, 0xF6); // Port 0 digital input disable
	#define PT0AD_5   0x20
	#define PT0AD_4   0x10
	#define PT0AD_3   0x08
	#define PT0AD_2   0x04
	#define PT0AD_1   0x02
SFR(RSTSRC, 0xDF); // Reset source register
	#define BOF    0x20
	#define POF    0x10
	#define R_BK   0x08
	#define R_WD   0x04
	#define R_SF   0x02
	#define R_EX   0x01
SFR(RTCCON, 0xD1); // Real-time clock control
	#define RTCF   0x80
	#define RTCS1  0x40
	#define RTCS0  0x20
	#define ERTC   0x02
	#define RTCEN  0x01
SFR(RTCH,  0xD2); // Real-time clock register high
SFR(RTCL,  0xD3); // Real-time clock register low
SFR(SADDR, 0xA9); // Serial port address register
SFR(SADEN, 0xB9); // Serial port address enable
SFR(SBUF,  0x99); // Serial port data buffer register
SFR(SCON,  0x98); // Serial port control
	SBIT(SM0_FE, 0x98, 7);
	SBIT(SM1,    0x98, 6);
	SBIT(SM2,    0x98, 5);
	SBIT(REN,    0x98, 4);
	SBIT(TB8,    0x98, 3);
	SBIT(RB8,    0x98, 2);
	SBIT(TI,     0x98, 1);
	SBIT(RI,     0x98, 0);
SFR(SSTAT, 0xBA); // Serial port extended status register
	#define DBMOD  0x80
	#define INTLO  0x40
	#define CIDIS  0x20
	#define DBISEL 0x10
	#define FE     0x08
	#define BR     0x04
	#define OE     0x02
	#define STINT  0x01
SFR(SP,     0x81); // Stack Pointer
SFR(SPCTL,  0xE2); // SPI control register
	#define SSIG  0x80
	#define SPEN  0x40
	#define DORD  0x20
	#define MSTR  0x10
	#define CPOL  0x08
	#define CPHA  0x04
	#define SPR1  0x02
	#define SPR0  0x01
SFR(SPSTAT, 0xE1); // SPI status register
	#define SPIF  0x80
	#define WCOL  0x40
SFR(SPDAT,  0xE3); // SPI data register
SFR(TAMOD,  0x8F); // Timer 0 and 1 auxiliary mode
	#define T1M2  0x10
	#define T0M2  0x01
SFR(TCON,   0x88); // Timer 0 and 1 control
	SBIT(TF1, 0x88, 7);
	SBIT(TR1, 0x88, 6);
	SBIT(TF0, 0x88, 5);
	SBIT(TR0, 0x88, 4);
	SBIT(IE1, 0x88, 3);
	SBIT(IT1, 0x88, 2);
	SBIT(IE0, 0x88, 1);
	SBIT(IT0, 0x88, 0);
SFR(TH0,  0x8C); // Timer 0 high
SFR(TH1,  0x8D); // Timer 1 high
SFR(TL0,  0x8A); // Timer 0 low
SFR(TL1,  0x8B); // Timer 1 low
SFR(TMOD, 0x89); // Timer 0 and 1 mode
	#define T1GATE  0x80
	#define T1C_T   0x40
	#define T1M1    0x20
	#define T1M0    0x10
	#define T0GATE  0x08
	#define T0C_T   0x04
	#define T0M1    0x02
	#define T0M0    0x01
SFR(TRIM, 0x96); // Internal oscillator trim register
	#define RCCLK   0x80
	#define ENCLK   0x40
	#define TRIM_5  0x20
	#define TRIM_4  0x10
	#define TRIM_3  0x08
	#define TRIM_2  0x04
	#define TRIM_1  0x02
	#define TRIM_0  0x01
SFR(WDCON, 0xA7); // Watchdog control register
	#define PRE2    0x80
	#define PRE1    0x40
	#define PRE0    0x20
	#define WDRUN   0x04
	#define WDTOF   0x02
	#define WDCLK   0x01
SFR(WDL,    0xC1); // Watchdog load
SFR(WFEED1, 0xC2); // Watchdog feed 1
SFR(WFEED2, 0xC3); // Watchdog feed 2
#endif // __P89LPC933_4_H__
/*-------------------------------------------------------------------------
   XC866.h - register Declarations for the Infineon XC866

   Copyright (C) 2005, Llewellyn van Zyl <eduprep AT myconnection.co.za>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef XC866_H
#define XC866_H

//   SFR byte definitions
__sfr __at (0xE0) A;
__sfr __at (0xCA) ADC_CHCTR0;
__sfr __at (0xCB) ADC_CHCTR1;
__sfr __at (0xCC) ADC_CHCTR2;
__sfr __at (0xCD) ADC_CHCTR3;
__sfr __at (0xCE) ADC_CHCTR4;
__sfr __at (0xCF) ADC_CHCTR5;
__sfr __at (0xD2) ADC_CHCTR6;
__sfr __at (0xD3) ADC_CHCTR7;
__sfr __at (0xCB) ADC_CHINCR;
__sfr __at (0xCA) ADC_CHINFR;
__sfr __at (0xCD) ADC_CHINPR;
__sfr __at (0xCC) ADC_CHINSR;
__sfr __at (0xCA) ADC_CRCR1;
__sfr __at (0xCC) ADC_CRMR1;
__sfr __at (0xCB) ADC_CRPR1;
__sfr __at (0xCF) ADC_ETRCR;
__sfr __at (0xCF) ADC_EVINCR;
__sfr __at (0xCE) ADC_EVINFR;
__sfr __at (0xD3) ADC_EVINPR;
__sfr __at (0xD2) ADC_EVINSR;
__sfr __at (0xCA) ADC_GLOBCTR;
__sfr __at (0xCB) ADC_GLOBSTR;
__sfr __at (0xCE) ADC_INPCR0;
__sfr __at (0xCD) ADC_LCBR;
__sfr __at (0xD1) ADC_PAGE;
__sfr __at (0xCC) ADC_PRAR;
__sfr __at (0xCF) ADC_Q0R0;
__sfr __at (0xD2) ADC_QBUR0;
__sfr __at (0xD2) ADC_QINR0;
__sfr __at (0xCD) ADC_QMR0;
__sfr __at (0xCE) ADC_QSR0;
__sfr __at (0xCA) ADC_RCR0;
__sfr __at (0xCB) ADC_RCR1;
__sfr __at (0xCC) ADC_RCR2;
__sfr __at (0xCD) ADC_RCR3;
__sfr __at (0xCB) ADC_RESR0H;
__sfr __at (0xCA) ADC_RESR0L;
__sfr __at (0xCD) ADC_RESR1H;
__sfr __at (0xCC) ADC_RESR1L;
__sfr __at (0xCF) ADC_RESR2H;
__sfr __at (0xCE) ADC_RESR2L;
__sfr __at (0xD3) ADC_RESR3H;
__sfr __at (0xD2) ADC_RESR3L;
__sfr __at (0xCB) ADC_RESRA0H;
__sfr __at (0xCA) ADC_RESRA0L;
__sfr __at (0xCD) ADC_RESRA1H;
__sfr __at (0xCC) ADC_RESRA1L;
__sfr __at (0xCF) ADC_RESRA2H;
__sfr __at (0xCE) ADC_RESRA2L;
__sfr __at (0xD3) ADC_RESRA3H;
__sfr __at (0xD2) ADC_RESRA3L;
__sfr __at (0xCE) ADC_VFCR;
__sfr __at (0xF0) B;
__sfr __at (0xBD) BCON;
__sfr __at (0xBE) BG;
__sfr __at (0xFB) CCU6_CC60RH;
__sfr __at (0xFA) CCU6_CC60RL;
__sfr __at (0xFB) CCU6_CC60SRH;
__sfr __at (0xFA) CCU6_CC60SRL;
__sfr __at (0xFD) CCU6_CC61RH;
__sfr __at (0xFC) CCU6_CC61RL;
__sfr __at (0xFD) CCU6_CC61SRH;
__sfr __at (0xFC) CCU6_CC61SRL;
__sfr __at (0xFF) CCU6_CC62RH;
__sfr __at (0xFE) CCU6_CC62RL;
__sfr __at (0xFF) CCU6_CC62SRH;
__sfr __at (0xFE) CCU6_CC62SRL;
__sfr __at (0x9B) CCU6_CC63RH;
__sfr __at (0x9A) CCU6_CC63RL;
__sfr __at (0x9B) CCU6_CC63SRH;
__sfr __at (0x9A) CCU6_CC63SRL;
__sfr __at (0xA7) CCU6_CMPMODIFH;
__sfr __at (0xA6) CCU6_CMPMODIFL;
__sfr __at (0xFF) CCU6_CMPSTATH;
__sfr __at (0xFE) CCU6_CMPSTATL;
__sfr __at (0x9D) CCU6_IENH;
__sfr __at (0x9C) CCU6_IENL;
__sfr __at (0x9F) CCU6_INPH;
__sfr __at (0x9E) CCU6_INPL;
__sfr __at (0x9D) CCU6_ISH;
__sfr __at (0x9C) CCU6_ISL;
__sfr __at (0xA5) CCU6_ISRH;
__sfr __at (0xA4) CCU6_ISRL;
__sfr __at (0xA5) CCU6_ISSH;
__sfr __at (0xA4) CCU6_ISSL;
__sfr __at (0xA7) CCU6_MCMCTR;
__sfr __at (0x9B) CCU6_MCMOUTH;
__sfr __at (0x9A) CCU6_MCMOUTL;
__sfr __at (0x9F) CCU6_MCMOUTSH;
__sfr __at (0x9E) CCU6_MCMOUTSL;
__sfr __at (0xFD) CCU6_MODCTRH;
__sfr __at (0xFC) CCU6_MODCTRL;
__sfr __at (0xA3) CCU6_PAGE;
__sfr __at (0x9F) CCU6_PISEL0H;
__sfr __at (0x9E) CCU6_PISEL0L;
__sfr __at (0xA4) CCU6_PISEL2;
__sfr __at (0xA6) CCU6_PSLR;
__sfr __at (0xA5) CCU6_T12DTCH;
__sfr __at (0xA4) CCU6_T12DTCL;
__sfr __at (0xFB) CCU6_T12H;
__sfr __at (0xFA) CCU6_T12L;
__sfr __at (0x9B) CCU6_T12MSELH;
__sfr __at (0x9A) CCU6_T12MSELL;
__sfr __at (0x9D) CCU6_T12PRH;
__sfr __at (0x9C) CCU6_T12PRL;
__sfr __at (0xFD) CCU6_T13H;
__sfr __at (0xFC) CCU6_T13L;
__sfr __at (0x9F) CCU6_T13PRH;
__sfr __at (0x9E) CCU6_T13PRL;
__sfr __at (0xA7) CCU6_TCTR0H;
__sfr __at (0xA6) CCU6_TCTR0L;
__sfr __at (0xFB) CCU6_TCTR2H;
__sfr __at (0xFA) CCU6_TCTR2L;
__sfr __at (0x9D) CCU6_TCTR4H;
__sfr __at (0x9C) CCU6_TCTR4L;
__sfr __at (0xFF) CCU6_TRPCTRH;
__sfr __at (0xFE) CCU6_TRPCTRL;
__sfr __at (0xBA) CMCON;
__sfr __at (0x83) DPH;
__sfr __at (0x82) DPL;
__sfr __at (0xA2) EO;
__sfr __at (0xB7) EXICON0;
__sfr __at (0xBA) EXICON1;
__sfr __at (0xBD) FEAH;
__sfr __at (0xBC) FEAL;
__sfr __at (0xF7) HWBPDR;
__sfr __at (0xF6) HWBPSR;
__sfr __at (0xB3) ID;
__sfr __at (0xA8) IEN0;
__sfr __at (0xE8) IEN1;
__sfr __at (0xB8) IP;
__sfr __at (0xF8) IP1;
__sfr __at (0xB9) IPH;
__sfr __at (0xF9) IPH1;
__sfr __at (0xB4) IRCON0;
__sfr __at (0xB5) IRCON1;
__sfr __at (0xF3) MMBPCR;
__sfr __at (0xF1) MMCR;
__sfr __at (0xE9) MMCR2;
__sfr __at (0xF5) MMDR;
__sfr __at (0xF4) MMICR;
__sfr __at (0xF2) MMSR;
__sfr __at (0xB3) MODPISEL;
__sfr __at (0xBB) NMICON;
__sfr __at (0xBC) NMISR;
__sfr __at (0xB6) OSC_CON;
__sfr __at (0x80) P0_ALTSEL0;
__sfr __at (0x86) P0_ALTSEL1;
__sfr __at (0x80) P0_DATA;
__sfr __at (0x86) P0_DIR;
__sfr __at (0x80) P0_OD;
__sfr __at (0x86) P0_PUDEN;
__sfr __at (0x80) P0_PUDSEL;
__sfr __at (0x90) P1_ALTSEL0;
__sfr __at (0x91) P1_ALTSEL1;
__sfr __at (0x90) P1_DATA;
__sfr __at (0x91) P1_DIR;
__sfr __at (0x90) P1_OD;
__sfr __at (0x91) P1_PUDEN;
__sfr __at (0x90) P1_PUDSEL;
__sfr __at (0xA0) P2_DATA;
__sfr __at (0xA1) P2_PUDEN;
__sfr __at (0xA0) P2_PUDSEL;
__sfr __at (0xB0) P3_ALTSEL0;
__sfr __at (0xB1) P3_ALTSEL1;
__sfr __at (0xB0) P3_DATA;
__sfr __at (0xB1) P3_DIR;
__sfr __at (0xB0) P3_OD;
__sfr __at (0xB1) P3_PUDEN;
__sfr __at (0xB0) P3_PUDSEL;
__sfr __at (0xBB) PASSWD;
__sfr __at (0x87) PCON;
__sfr __at (0xB7) PLL_CON;
__sfr __at (0xB4) PMCON0;    
__sfr __at (0xB5) PMCON1;    
__sfr __at (0xB2) PORT_PAGE;    
__sfr __at (0xD0) PSW;    
__sfr __at (0x99) SBUF;    
__sfr __at (0x98) SCON;    
__sfr __at (0xBF) SCU_PAGE;    
__sfr __at (0x81) SP;    
__sfr __at (0xAF) SSC_BRH;    
__sfr __at (0xAE) SSC_BRL;    
__sfr __at (0xAB) SSC_CONH_O;    
__sfr __at (0xAB) SSC_CONH_P;    
__sfr __at (0xAA) SSC_CONL_O;    
__sfr __at (0xAA) SSC_CONL_P;    
__sfr __at (0xA9) SSC_PISEL;    
__sfr __at (0xAD) SSC_RBL;    
__sfr __at (0xAC) SSC_TBL;    
__sfr __at (0x8F) SYSCON0;    
__sfr __at (0xC3) T2_RC2H;    
__sfr __at (0xC2) T2_RC2L;    
__sfr __at (0xC0) T2_T2CON;    
__sfr __at (0xC5) T2_T2H;
__sfr __at (0xC4) T2_T2L;
__sfr __at (0xC1) T2_T2MOD;
__sfr __at (0x88) TCON;
__sfr __at (0x8C) TH0;
__sfr __at (0x8D) TH1;
__sfr __at (0x8A) TL0;
__sfr __at (0x8B) TL1;
__sfr __at (0x89) TMOD;
__sfr __at (0xBB) WDTCON;    // located in the mapped SFR area
__sfr __at (0xBF) WDTH;      // located in the mapped SFR area
__sfr __at (0xBE) WDTL;      // located in the mapped SFR area
__sfr __at (0xBC) WDTREL;    // located in the mapped SFR area
__sfr __at (0xBD) WDTWINB;   // located in the mapped SFR area

__sfr __at (0xB3) XADDRH;    // beware this is in an sfr page!
__sfr __at (0xB3) _XPAGE;    // this is the name SDCC expects for this sfr

//   SFR bit definitions

/*  P0  */
__sbit __at (0x80) P0_0 ;
__sbit __at (0x81) P0_1 ;
__sbit __at (0x82) P0_2 ;
__sbit __at (0x83) P0_3 ;
__sbit __at (0x84) P0_4 ;
__sbit __at (0x85) P0_5 ;

/*  P1  */
__sbit __at (0x90) P1_0 ;
__sbit __at (0x91) P1_1 ;
__sbit __at (0x92) P1_5 ;
__sbit __at (0x93) P1_6 ;
__sbit __at (0x94) P1_7 ;

/*  P2  */
__sbit __at (0xA0) P2_0 ;
__sbit __at (0xA1) P2_1 ;
__sbit __at (0xA2) P2_2 ;
__sbit __at (0xA3) P2_3 ;
__sbit __at (0xA4) P2_4 ;
__sbit __at (0xA5) P2_5 ;
__sbit __at (0xA6) P2_6 ;
__sbit __at (0xA7) P2_7 ;

/*  P3  */
__sbit __at (0xB0) P3_0 ;
__sbit __at (0xB1) P3_1 ;
__sbit __at (0xB2) P3_2 ;
__sbit __at (0xB3) P3_3 ;
__sbit __at (0xB4) P3_4 ;
__sbit __at (0xB5) P3_5 ;
__sbit __at (0xB6) P3_6 ;
__sbit __at (0xB7) P3_7 ;


//   IEN0
__sbit __at (0xAF) EA;
__sbit __at (0xAC) ES;
__sbit __at (0xA9) ET0;
__sbit __at (0xAB) ET1;
__sbit __at (0xAD) ET2;
__sbit __at (0xA8) EX0;
__sbit __at (0xAA) EX1;

//   IEN1
__sbit __at (0xE8) EADC;
__sbit __at (0xEC) ECCIP0;
__sbit __at (0xED) ECCIP1;
__sbit __at (0xEE) ECCIP2;
__sbit __at (0xEF) ECCIP3;
__sbit __at (0xE9) ESSC;
__sbit __at (0xEA) EX2;
__sbit __at (0xEB) EXM;

//   IP1
__sbit __at (0xF8) PADC;
__sbit __at (0xFC) PCCIP0;
__sbit __at (0xFD) PCCIP1;
__sbit __at (0xFE) PCCIP2;
__sbit __at (0xFF) PCCIP3;
__sbit __at (0xF9) PSSC;
__sbit __at (0xFA) PX2;
__sbit __at (0xFB) PXM;

//   IP
__sbit __at (0xBC) PS;
__sbit __at (0xB9) PT0;
__sbit __at (0xBB) PT1;
__sbit __at (0xBD) PT2;
__sbit __at (0xB8) PX0;
__sbit __at (0xBA) PX1;

//   PSW
__sbit __at (0xD6) AC;
__sbit __at (0xD7) CY;
__sbit __at (0xD5) F0;
__sbit __at (0xD1) F1;
__sbit __at (0xD2) OV;
__sbit __at (0xD0) P;
__sbit __at (0xD3) RS0;
__sbit __at (0xD4) RS1;

//   SCON
__sbit __at (0x9A) RB8;
__sbit __at (0x9C) REN;
__sbit __at (0x98) RI;
__sbit __at (0x9F) SM0;
__sbit __at (0x9E) SM1;
__sbit __at (0x9D) SM2;
__sbit __at (0x9B) TB8;
__sbit __at (0x99) TI;

//   T2_T2CON
__sbit __at (0xC0) CP_RL2;
__sbit __at (0xC3) EXEN2;
__sbit __at (0xC6) EXF2;
__sbit __at (0xC7) TF2;
__sbit __at (0xC2) TR2;

//   TCON
__sbit __at (0x89) IE0;
__sbit __at (0x8B) IE1;
__sbit __at (0x88) IT0;
__sbit __at (0x8A) IT1;
__sbit __at (0x8D) TF0;
__sbit __at (0x8F) TF1;
__sbit __at (0x8C) TR0;
__sbit __at (0x8E) TR1;

//   Definition of the PAGE SFR

//   PORT_PAGE
#define _pp0 PORT_PAGE=0 // PORT_PAGE postfix
#define _pp1 PORT_PAGE=1 // PORT_PAGE postfix
#define _pp2 PORT_PAGE=2 // PORT_PAGE postfix
#define _pp3 PORT_PAGE=3 // PORT_PAGE postfix

//   ADC_PAGE
#define _ad0 ADC_PAGE=0 // ADC_PAGE postfix
#define _ad1 ADC_PAGE=1 // ADC_PAGE postfix
#define _ad2 ADC_PAGE=2 // ADC_PAGE postfix
#define _ad3 ADC_PAGE=3 // ADC_PAGE postfix
#define _ad4 ADC_PAGE=4 // ADC_PAGE postfix
#define _ad5 ADC_PAGE=5 // ADC_PAGE postfix
#define _ad6 ADC_PAGE=6 // ADC_PAGE postfix

//   SCU_PAGE
#define _su0 SCU_PAGE=0 // SCU_PAGE postfix
#define _su1 SCU_PAGE=1 // SCU_PAGE postfix
#define _su2 SCU_PAGE=2 // SCU_PAGE postfix

//   CCU_PAGE
#define _cc0 CCU_PAGE=0 // CCU_PAGE postfix
#define _cc1 CCU_PAGE=1 // CCU_PAGE postfix
#define _cc2 CCU_PAGE=2 // CCU_PAGE postfix
#define _cc3 CCU_PAGE=3 // CCU_PAGE postfix

//   FLASH_PAGE
#define _fl0 FLASH_PAGE=0 // FLASH_PAGE postfix
#define _fl1 FLASH_PAGE=1 // FLASH_PAGE postfix
#define _fl2 FLASH_PAGE=2 // FLASH_PAGE postfix

#define SST0 0x80         // Save SFR page to ST0
#define RST0 0xC0         // Restore SFR page from ST0
#define SST1 0x90         // Save SFR page to ST1
#define RST1 0xD0         // Restore SFR page from ST1
#define SST2 0xA0         // Save SFR page to ST2
#define RST2 0xE0         // Restore SFR page from ST2
#define SST3 0xB0         // Save SFR page to ST3
#define RST3 0xF0         // Restore SFR page from ST3
#define noSST 0x00	  // Switch page without saving

#define SFR_PAGE(pg,op) pg+op

#endif
/*-------------------------------------------------------------------------
   p89v51rd2.h - Register Declarations for the Philips P89V51RD2 Processor

   Copyright (C) 2005, Jesus Calvino-Fraga / jesusc at ece.ubc.ca

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#ifndef REG_P89V51RD2_H
#define REG_P89V51RD2_H

#include <8052.h>     // Load definitions for the 8052

#ifdef REG8052_H
#undef REG8052_H
#endif

// Define P89V51RD2 specific registers only

__sfr __at (0x8E) AUXR;		//Auxiliary function register (Reset value 0x00).
	#define EXTRAM 0x02		//'0'=uses internal XRAM.
	#define AO 0x01			//'1'=Disables ALE generation.

__sfr __at (0xA2) AUXR1;	//Auxiliary function register 1 (Reset value 0x00).  
	#define GF2 0x08		//General purpose user-defined flag.
	#define DPS 0x01		//Data pointer select.

__sfr __at (0xFA) CCAP0H;	//Module 0 Capture HIGH. 
__sfr __at (0xFB) CCAP1H;	//Module 1 Capture HIGH. 
__sfr __at (0xFC) CCAP2H;	//Module 2 Capture HIGH. 
__sfr __at (0xFD) CCAP3H;	//Module 3 Capture HIGH. 
__sfr __at (0xFE) CCAP4H;	//Module 4 Capture HIGH. 
__sfr __at (0xEA) CCAP0L;	//Module 0 Capture LOW. 
__sfr __at (0xEB) CCAP1L;	//Module 1 Capture LOW. 
__sfr __at (0xEC) CCAP2L;	//Module 2 Capture LOW. 
__sfr __at (0xED) CCAP3L;	//Module 3 Capture LOW. 
__sfr __at (0xEE) CCAP4L;	//Module 4 Capture LOW. 

__sfr __at (0xDA) CCAPM0;	//Module 0 Mode.  
__sfr __at (0xDB) CCAPM1;	//Module 1 Mode.  
__sfr __at (0xDC) CCAPM2;	//Module 2 Mode.  
__sfr __at (0xDD) CCAPM3;	//Module 3 Mode.  
__sfr __at (0xDE) CCAPM4;	//Module 4 Mode.
//The preceding five registers have the following bits:  
	#define ECOM 0x40		//Enable Comparator.
	#define CAPP 0x20		//1=enables positive edge capture.
	#define CAPN 0x10		//1=enables negative edge capture.
	#define MAT  0x08		//When counter matches sets CCF_n bit causing and interrupt.
	#define TOG  0x04		//Toggle output on match.
	#define PWM  0x02		//Pulse width modulation mode.
	#define ECCF 0x01		//Enable CCF interrupt.

__sfr __at (0xD8) CCON;	//PCA Counter Control (Reset value 0x00)
	__sbit __at (0xDF) CF;	//PCA Counter overflow flag.
	__sbit __at (0xDE) CR ; //PCA Counter Run Control Bit. 1=counter on.  0=counter off.
	__sbit __at (0xDC) CCF4;//PCA Module 4 Interrupt Flag.
	__sbit __at (0xDB) CCF3;//PCA Module 3 Interrupt Flag.
	__sbit __at (0xDA) CCF2;//PCA Module 2 Interrupt Flag.
	__sbit __at (0xD9) CCF1;//PCA Module 1 Interrupt Flag.
	__sbit __at (0xD8) CCF0;//PCA Module 0 Interrupt Flag.

__sfr __at (0xF9) CH;		//PCA Counter HIGH. 
__sfr __at (0xE9) CL;		//PCA Counter LOW. 

__sfr __at (0xD9) CMOD;		//PCA Counter Mode.  
	#define CIDL 0x80		//CIDL=0 program the PCA counter to work during idle mode.
	#define WDTE 0x40		//Watchdog Timer Enable.
	#define CPS1 0x04		//PCA Count Pulse Select bit 1.
	#define CPS0 0x02		//PCA Count Pulse Select bit 0.
							//00=Internal clock, Fosc/6
							//01=Internal clock, Fosc/6
							//10=Timer 0 overflow
							//11=External clock at ECI/P1.2 pin (max rate=Fosc/4)
	#define ECF 0x01		//PCA Enable Counter Overflow Interrupt.

__sfr __at (0xB6) FST;		//Flash Status Register.  
	#define SB 0x40
	#define EDC 0x08

__sfr __at (0xB1) FCF;		//Flash program memory bank selection. 
	#define SWR  0x02
	#define BSEL 0x01

//Attention IEN0 is the same as register IE found in <8051.h> only bit EC added here.
__sfr __at (0xA8) IEN0;		//Interrupt Enable 1.
	__sbit __at (0xAE) EC;	//PCA Interrupt Enable bit.

__sfr __at (0xE8) IEN1;		//Interrupt Enable 1
	__sbit __at (0xEB) EBO; //Brown-out Interrupt Enable. (Vector is 0x00b4).

//Attention IP0 is the same as register IP found in <8051.h> only bit PPC added here.
__sfr __at (0xB8) IP0;		//Interrupt Priority 0 HIGH.  
	__sbit __at (0xBE) PPC;	//PCA Interrupt Priority low bit.

__sfr __at (0xB7) IP0H;		//Interrupt Priority 0 HIGH  
	#define PPCH 0x40		//PCA Interrupt Priority High Bit.
	#define PT2H 0x20		//Timer 2 Interrupt Interrupt Priority High Bit.
	#define PSH  0x10		//Serial Port Interrupt Priority High Bit.
	#define PT1H 0x08		//Timer 1 Interrupt Priority High Bit.
	#define PX1H 0x04		//External Interrupt 1 Priority High Bit.
	#define PT0H 0x02		//Timer 0 Interrupt Priority High Bit.
	#define PX0H 0x01		//External Interrupt 0 Priority High Bit.

__sfr __at (0xF8) IP1;		//Interrupt Priority 1.
	__sbit __at (0xFB) PBO; //Brown-out Interrupt Priority Bit.

__sfr __at (0xF7) IP1H;		//Interrupt Priority 1 HIGH.  
	#define PBOH 0x08		//Brown-out Interrupt Priority High Bit.

__sfr __at (0xA9) SADDR;	//Serial Port Address Register. 
__sfr __at (0xB9) SADEN;	//Serial Port Address Enable. 

__sfr __at (0xD5) SPCR;		//SPI Control Register (Reset value 00000000B). 
__sfr __at (0xD5) SPCTL;	//SPI Control Register (This name appears also in the datasheet).   
	#define SPIE 0x80		//If both SPIE and ES are set to one, SPI interrupts are enabled.
	#define SPEN 0x40		//SPI enable bit.  When set enables SPI.
	#define SPE  0x40		//Same as above.  This name appears also in the manual :-(
	#define DORD 0x20		//Data trans. order. 0=MSB first; 1=LSB first.
	#define MSTR 0x10		//1=master mode.  0=slave mode.
	#define CPOL 0x08		//1=SCK is high when idle (active low), 0=SCK is low when idle (active high).
	#define CPHA 0x04		//1=shift triggered on the trailing edge of SCK.  0=shift trig. on leading edge.
	#define SPR1 0x02		//SPI Clork Rate select bit 1.
	#define SPR0 0x01		//SPI Clork Rate select bit 0.
							//00 = Fosc/4
							//01 = Fosc/16
							//10 = Fosc/64
							//11 = Fosc/128

__sfr __at (0xAA) SPSR;		//SPI Configuration Register (Reset value 00000000B).  
__sfr __at (0xAA) SPCFG;	//SPI Configuration Register (This name appears also in the datasheet).  
	#define SPIF 0x80		//SPI interrupt flag.
	#define SPWCOL 0x40		//Write collision Flag.

__sfr __at (0x86) SPDR;		//SPI Data 
__sfr __at (0x86) SPDAT;	//SPI Data (This name appears also in the datasheet). 

__sfr __at (0xC0) WDTC;		//Watchdog Timer Control (Reset value 0x00). 
	__sbit __at (0xC4) WDOUT;//Watchdog output enable.
	__sbit __at (0xC3) WDRE; //Watchdog timer reset enable.
	__sbit __at (0xC2) WDTS; //Watchdog timer reset flag.
	__sbit __at (0xC1) WDT;  //Watchdog timer refresh.
	__sbit __at (0xC0) SWDT; //Start watchdog timer.

__sfr __at (0x85) WDTD;		//Watchdog Timer Data/Reload. 

__sfr __at (0xC9) T2MOD;	//Timer 2 mode control
	#define DCEN  0x01 		//Down count enable bit
	#define T2OE  0x02		//Timer 2 Output Enable bit.
	#define ENT2  0x20		//No description???

#endif /*REG_P89V51RD2_H*/
/*-------------------------------------------------------------------------
   sab80515.h - Register Declarations for SIEMENS/INFINEON SAB 80515 Processor
   based on reg51.h by Sandeep Dutta sandeep.dutta@usa.net
   KEIL C compatible definitions are included

   Copyright (C) 2005, Bela Torok / bela.torok@kssg.ch

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef SAB80515_H
#define SAB80515_H

/* BYTE addressable registers */
__sfr __at 0x80 P0          ;
__sfr __at 0x81 SP          ;
__sfr __at 0x82 DPL         ;
__sfr __at 0x83 DPH         ;
__sfr __at 0x87 PCON        ;
__sfr __at 0x88 TCON        ;
__sfr __at 0x89 TMOD        ;
__sfr __at 0x8A TL0         ;
__sfr __at 0x8B TL1         ;
__sfr __at 0x8C TH0         ;
__sfr __at 0x8D TH1         ;
__sfr __at 0x90 P1          ;
__sfr __at 0x98 SCON        ;
__sfr __at 0x99 SBUF        ;
__sfr __at 0xA0 P2          ;
__sfr __at 0xA8 IE          ;
__sfr __at 0xA8 IEN0        ; /* as called by Siemens */
__sfr __at 0xA9 IP0         ; /* interrupt priority register - SAB80515 specific */
__sfr __at 0xB0 P3          ;
__sfr __at 0xB8 IEN1        ; /* interrupt enable register - SAB80515 specific */
__sfr __at 0xB9 IP1         ; /* interrupt priority register as called by Siemens */
__sfr __at 0xC0 IRCON       ; /* interrupt control register - SAB80515 specific */
__sfr __at 0xC1 CCEN        ; /* compare/capture enable register */
__sfr __at 0xC2 CCL1        ; /* compare/capture register 1, low byte */
__sfr __at 0xC3 CCH1        ; /* compare/capture register 1, high byte */
__sfr __at 0xC4 CCL2        ; /* compare/capture register 2, low byte */
__sfr __at 0xC5 CCH2        ; /* compare/capture register 2, high byte */
__sfr __at 0xC6 CCL3        ; /* compare/capture register 3, low byte */
__sfr __at 0xC7 CCH3        ; /* compare/capture register 3, high byte */
__sfr __at 0xC8 T2CON       ;
__sfr __at 0xCA CRCL        ; /* compare/reload/capture register, low byte */
__sfr __at 0xCB CRCH        ; /* compare/reload/capture register, high byte */
__sfr __at 0xCC TL2         ;
__sfr __at 0xCD TH2         ;
__sfr __at 0xD0 PSW         ;
__sfr __at 0xD8 ADCON       ; /* A/D-converter control register */
__sfr __at 0xD9 ADDAT       ; /* A/D-converter data register */
__sfr __at 0xDA DAPR        ; /* D/A-converter program register */
__sfr __at 0xDB P6          ; /* Port 6 - SAB80515 specific */
__sfr __at 0xE0 ACC         ;
__sfr __at 0xE0 A           ;
__sfr __at 0xE8 P4          ; /* Port 4 - SAB80515 specific */
__sfr __at 0xF0 B           ;
__sfr __at 0xF8 P5          ; /* Port 5 - SAB80515 specific */


/* BIT addressable registers */
/* P0 */
__sbit __at 0x80 P0_0       ;
__sbit __at 0x81 P0_1       ;
__sbit __at 0x82 P0_2       ;
__sbit __at 0x83 P0_3       ;
__sbit __at 0x84 P0_4       ;
__sbit __at 0x85 P0_5       ;
__sbit __at 0x86 P0_6       ;
__sbit __at 0x87 P0_7       ;

/* TCON */
__sbit __at 0x88 IT0        ;
__sbit __at 0x89 IE0        ;
__sbit __at 0x8A IT1        ;
__sbit __at 0x8B IE1        ;
__sbit __at 0x8C TR0        ;
__sbit __at 0x8D TF0        ;
__sbit __at 0x8E TR1        ;
__sbit __at 0x8F TF1        ;

/* P1 */
__sbit __at 0x90 P1_0       ;
__sbit __at 0x91 P1_1       ;
__sbit __at 0x92 P1_2       ;
__sbit __at 0x93 P1_3       ;
__sbit __at 0x94 P1_4       ;
__sbit __at 0x95 P1_5       ;
__sbit __at 0x96 P1_6       ;
__sbit __at 0x97 P1_7       ;

__sbit __at 0x90 INT3_CC0   ; /* P1 alternate functions - SAB80515 specific */
__sbit __at 0x91 INT4_CC1   ;
__sbit __at 0x92 INT5_CC2   ;
__sbit __at 0x93 INT6_CC3   ;
__sbit __at 0x94 INT2       ;
__sbit __at 0x95 T2EX       ;
__sbit __at 0x96 CLKOUT     ;
__sbit __at 0x97 T2         ;

/* SCON */
__sbit __at 0x98 RI         ;
__sbit __at 0x99 TI         ;
__sbit __at 0x9A RB8        ;
__sbit __at 0x9B TB8        ;
__sbit __at 0x9C REN        ;
__sbit __at 0x9D SM2        ;
__sbit __at 0x9E SM1        ;
__sbit __at 0x9F SM0        ;

/* P2 */
__sbit __at 0xA0 P2_0       ;
__sbit __at 0xA1 P2_1       ;
__sbit __at 0xA2 P2_2       ;
__sbit __at 0xA3 P2_3       ;
__sbit __at 0xA4 P2_4       ;
__sbit __at 0xA5 P2_5       ;
__sbit __at 0xA6 P2_6       ;
__sbit __at 0xA7 P2_7       ;

/* IEN0 */
__sbit __at 0xA8 EX0        ;
__sbit __at 0xA9 ET0        ;
__sbit __at 0xAA EX1        ;
__sbit __at 0xAB ET1        ;
__sbit __at 0xAC ES         ;
__sbit __at 0xAD ET2        ;
__sbit __at 0xAE WDT        ; /* watchdog timer reset - SAB80515 specific */
__sbit __at 0xAF EA         ;

__sbit __at 0xAF EAL        ; /* EA as called by Siemens */

/* P3 */
__sbit __at 0xB0 P3_0       ;
__sbit __at 0xB1 P3_1       ;
__sbit __at 0xB2 P3_2       ;
__sbit __at 0xB3 P3_3       ;
__sbit __at 0xB4 P3_4       ;
__sbit __at 0xB5 P3_5       ;
__sbit __at 0xB6 P3_6       ;
__sbit __at 0xB7 P3_7       ;

__sbit __at 0xB0 RXD        ;
__sbit __at 0xB1 TXD        ;
__sbit __at 0xB2 INT0       ;
__sbit __at 0xB3 INT1       ;
__sbit __at 0xB4 T0         ;
__sbit __at 0xB5 T1         ;
__sbit __at 0xB6 WR         ;
__sbit __at 0xB7 RD         ;

/* IEN1 */
__sbit __at 0xB8 EADC       ; /* A/D converter interrupt enable */
__sbit __at 0xB9 EX2        ;
__sbit __at 0xBA EX3        ;
__sbit __at 0xBB EX4        ;
__sbit __at 0xBC EX5        ;
__sbit __at 0xBD EX6        ;
__sbit __at 0xBE SWDT       ; /* watchdog timer start/reset */
__sbit __at 0xBF EXEN2      ; /* timer2 external reload interrupt enable */

/* IRCON */
__sbit __at 0xC0 IADC       ; /* A/D converter irq flag */
__sbit __at 0xC1 IEX2       ; /* external interrupt edge detect flag */
__sbit __at 0xC2 IEX3       ;
__sbit __at 0xC3 IEX4       ;
__sbit __at 0xC4 IEX5       ;
__sbit __at 0xC5 IEX6       ;
__sbit __at 0xC6 TF2        ; /* timer 2 owerflow flag  */
__sbit __at 0xC7 EXF2       ; /* timer2 reload flag */

/* T2CON */
__sbit __at 0xC8 T2CON_0    ;
__sbit __at 0xC9 T2CON_1    ;
__sbit __at 0xCA T2CON_2    ;
__sbit __at 0xCB T2CON_3    ;
__sbit __at 0xCC T2CON_4    ;
__sbit __at 0xCD T2CON_5    ;
__sbit __at 0xCE T2CON_6    ;
__sbit __at 0xCF T2CON_7    ;

__sbit __at 0xC8 T2I0       ;
__sbit __at 0xC9 T2I1       ;
__sbit __at 0xCA T2CM       ;
__sbit __at 0xCB T2R0       ;
__sbit __at 0xCC T2R1       ;
__sbit __at 0xCD I2FR       ;
__sbit __at 0xCE I3FR       ;
__sbit __at 0xCF T2PS       ;


/* PSW */
__sbit __at 0xD0 P          ;
__sbit __at 0xD1 FL         ;
__sbit __at 0xD2 OV         ;
__sbit __at 0xD3 RS0        ;
__sbit __at 0xD4 RS1        ;
__sbit __at 0xD5 F0         ;
__sbit __at 0xD6 AC         ;
__sbit __at 0xD7 CY         ;

__sbit __at 0xD1 F1         ;

/* ADCON */
__sbit __at 0xD8 MX0        ;
__sbit __at 0xD9 MX1        ;
__sbit __at 0xDA MX2        ;
__sbit __at 0xDB ADM        ;
__sbit __at 0xDC BSY        ;

__sbit __at 0xDE CLK        ;
__sbit __at 0xDF BD         ;

/* A */
__sbit __at 0xA0 AREG_F0    ;
__sbit __at 0xA1 AREG_F1    ;
__sbit __at 0xA2 AREG_F2    ;
__sbit __at 0xA3 AREG_F3    ;
__sbit __at 0xA4 AREG_F4    ;
__sbit __at 0xA5 AREG_F5    ;
__sbit __at 0xA6 AREG_F6    ;
__sbit __at 0xA7 AREG_F7    ;

/* P4 */
__sbit __at 0xE8 P4_0       ;
__sbit __at 0xE9 P4_1       ;
__sbit __at 0xEA P4_2       ;
__sbit __at 0xEB P4_3       ;
__sbit __at 0xEC P4_4       ;
__sbit __at 0xED P4_5       ;
__sbit __at 0xEE P4_6       ;
__sbit __at 0xEF P4_7       ;

/* B */
__sbit __at 0xF0 BREG_F0    ;
__sbit __at 0xF1 BREG_F1    ;
__sbit __at 0xF2 BREG_F2    ;
__sbit __at 0xF3 BREG_F3    ;
__sbit __at 0xF4 BREG_F4    ;
__sbit __at 0xF5 BREG_F5    ;
__sbit __at 0xF6 BREG_F6    ;
__sbit __at 0xF7 BREG_F7    ;

/* P5 */
__sbit __at 0xF8 P5_0       ;
__sbit __at 0xF9 P5_1       ;
__sbit __at 0xFA P5_2       ;
__sbit __at 0xFB P5_3       ;
__sbit __at 0xFC P5_4       ;
__sbit __at 0xFD P5_5       ;
__sbit __at 0xFE P5_6       ;
__sbit __at 0xFF P5_7       ;

/* BIT definitions for bits that are not directly accessible */
/* PCON bits */
#define IDL             0x01
#define PD              0x02
#define GF0             0x04
#define GF1             0x08
#define SMOD            0x80

#define IDL_            0x01
#define PD_             0x02
#define GF0_            0x04
#define GF1_            0x08
#define SMOD_           0x80

/* TMOD bits */
#define M0_0            0x01
#define M1_0            0x02
#define C_T0            0x04
#define GATE0           0x08
#define M0_1            0x10
#define M1_1            0x20
#define C_T1            0x40
#define GATE1           0x80

#define M0_0_           0x01
#define M1_0_           0x02
#define C_T0_           0x04
#define GATE0_          0x08
#define M0_1_           0x10
#define M1_1_           0x20
#define C_T1_           0x40
#define GATE1_          0x80

#define T0_M0           0x01
#define T0_M1           0x02
#define T0_CT           0x04
#define T0_GATE         0x08
#define T1_M0           0x10
#define T1_M1           0x20
#define T1_CT           0x40
#define T1_GATE         0x80

#define T0_M0_          0x01
#define T0_M1_          0x02
#define T0_CT_          0x04
#define T0_GATE_        0x08
#define T1_M0_          0x10
#define T1_M1_          0x20
#define T1_CT_          0x40
#define T1_GATE_        0x80

#define T0_MASK         0x0F
#define T1_MASK         0xF0

#define T0_MASK_        0x0F
#define T1_MASK_        0xF0

/* T2MOD bits */
#define DCEN            0x01
#define T2OE            0x02

#define DCEN_           0x01
#define T2OE_           0x02

/* WMCON bits */
#define WMCON_WDTEN     0x01
#define WMCON_WDTRST    0x02
#define WMCON_DPS       0x04
#define WMCON_EEMEN     0x08
#define WMCON_EEMWE     0x10
#define WMCON_PS0       0x20
#define WMCON_PS1       0x40
#define WMCON_PS2       0x80

/* SPCR-SPI bits */
#define SPCR_SPR0       0x01
#define SPCR_SPR1       0x02
#define SPCR_CPHA       0x04
#define SPCR_CPOL       0x08
#define SPCR_MSTR       0x10
#define SPCR_DORD       0x20
#define SPCR_SPE        0x40
#define SPCR_SPIE       0x80

/* SPSR-SPI bits */
#define SPSR_WCOL       0x40
#define SPSR_SPIF       0x80

/* SPDR-SPI bits */
#define SPDR_SPD0       0x10
#define SPDR_SPD1       0x20
#define SPDR_SPD2       0x40
#define SPDR_SPD3       0x80
#define SPDR_SPD4       0x10
#define SPDR_SPD5       0x20
#define SPDR_SPD6       0x40
#define SPDR_SPD7       0x80

/* Interrupt numbers: address = (number * 8) + 3 */
#define IE0_VECTOR      0       /* 0x03 external interrupt 0 */
#define TF0_VECTOR      1       /* 0x0b timer 0 */
#define IE1_VECTOR      2       /* 0x13 external interrupt 1 */
#define TF1_VECTOR      3       /* 0x1b timer 1 */
#define SI0_VECTOR      4       /* 0x23 serial port 0 */
#define TF2_VECTOR      5       /* 0x2B timer 2 */
#define EX2_VECTOR      5       /* 0x2B external interrupt 2 */

#define IADC_VECTOR     8       /* 0x43 A/D converter interrupt */
#define IEX2_VECTOR     9       /* 0x4B external interrupt 2 */
#define IEX3_VECTOR    10       /* 0x53 external interrupt 3 */
#define IEX4_VECTOR    11       /* 0x5B external interrupt 4 */
#define IEX5_VECTOR    12       /* 0x63 external interrupt 5 */
#define IEX6_VECTOR    13       /* 0x6B external interrupt 6 */

#endif

/*-------------------------------------------------------------------------
   w7100.h - Register Declarations for WIZnet's W7100
   (Based on Internet Embedded MCU W7100 Datasheet Version 0.9 Beta)

   Copyright (C) 2009, Jesus Calvino-Fraga / jesusc at ece.ubc.ca

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef REG_W7100_H
#define REG_W7100_H

#include <compiler.h>

SFR(ACC, 0xE0);   // Accumulator
    SBIT(ACC_0, 0xE0, 0);
    SBIT(ACC_1, 0xE0, 1);
    SBIT(ACC_2, 0xE0, 2);
    SBIT(ACC_3, 0xE0, 3);
    SBIT(ACC_4, 0xE0, 4);
    SBIT(ACC_5, 0xE0, 5);
    SBIT(ACC_6, 0xE0, 6);
    SBIT(ACC_7, 0xE0, 7);

SFR(B, 0xF0);   // Register B
    SBIT(B_0, 0xF0, 0);
    SBIT(B_1, 0xF0, 1);
    SBIT(B_2, 0xF0, 2);
    SBIT(B_3, 0xF0, 3);
    SBIT(B_4, 0xF0, 4);
    SBIT(B_5, 0xF0, 5);
    SBIT(B_6, 0xF0, 6);
    SBIT(B_7, 0xF0, 7);

SFR(PCON, 0x87); // Power Configuration Register
    #define SMOD0 0x80 // Baud rate select bit
    #define SMOD1 0x40 // Not documented
    #define PWE   0x10 // Program Code Memory Write Enable Bit

SFR(WTST, 0x92); // Program Code Memory Wait States Register
    #define WTST_2 0x04 // Wait States Register bit 2
    #define WTST_1 0x02 // Wait States Register bit 1
    #define WTST_0 0x01 // Wait States Register bit 0

SFR(DPX0, 0x93); // Data Pointer Extended Register low
SFR(DPX1, 0x95); // Data Pointer Extended Register high
SFR(MXAX, 0xEA); // Data Pointer Extended Register

SFR16E(DPTR0, 0x8382); // Data Pointer Register 0
SFR(DPH,  0x83); // Data Pointer Register 0 high
SFR(DPL,  0x82); // Data Pointer Register 0 low
SFR(DPH0, 0x83); // Data Pointer Register 0 high
SFR(DPL0, 0x82); // Data Pointer Register 0 low
SFR16E(DPTR1, 0x8584); // Data Pointer Register 1
SFR(DPH1, 0x85); // Data Pointer Register 1 high
SFR(DPL1, 0x84); // Data Pointer Register 1 low
SFR(DPS, 0x86);  //Data Pointer Select Register
    #define ID1 0x80 // DPTR0, DPTR1 Operations bit 1
    #define ID0 0x40 // DPTR0, DPTR1 Operations bit 0
    #define TSL 0x20 // Toggle select enable
    #define SEL 0x01 // DPTR register select

SFR(CKCON, 0x8E); // Clock Control Register
    #define WD1 0x80 // Watchdog Interval bit 1
    #define WD0 0x40 // Watchdog Interval bit 0
    #define MD2 0x04 // Stretch bit 2
    #define MD1 0x02 // Stretch bit 1
    #define MD0 0x01 // Stretch bit 0

SFR(SP, 0x81);        // Stack Pointer
SFR(ISPID, 0xF1);     // ID Register for ISP.
SFR(ISPADDR16, 0xF2); // 16bit Address Register for ISP
SFR(ISPDATA, 0xF4);   // Data Register for ISP.
SFR(CKCBK, 0xF5);     // CKCON Backup Register.
SFR(DPX0BK, 0xF6);    // DPX0 Backup Register.
SFR(DPX1BK, 0xF7);    // DPX1 Backup Register.
SFR(DPSBK, 0xF9);     // DPX Backup Register.

// WARNING: the following six definitions are not well documented
SFR16(RAMBA16, 0xFAFB);  // RAM Base Address Register.
SFR(RAMBA16H, 0xFA);
SFR(RAMBA16L, 0xFB);
SFR16(RAMEA16, 0xFCFD);  // RAM End Address Register.
SFR(RAMEA16H, 0xFC);
SFR(RAMEA16L, 0xFD);

SFR(WCONF, 0xFF); // W7100 Configuration Register.
    #define RB    0x80 // 0 : No Reboot / 1 : Reboot after the ISP done.
    #define ISPEN 0x40 // 0 : Enable ISP in Boot built in W7100 / 1 : Disable.
    #define F64EN 0x04 // Always '0'. Read only.
    #define FB    0x02 // FLASH Busy Flag for ISP. Read only.
    #define BE    0x01 // Boot Enable (1 : Boot Running / 0 : Apps Running). Read only.

SFR(TCON, 0x88); // Timer0, 1 configuration register.
    SBIT(IT0, 0x88, 0); // INT0 level (at 0)/edge (at 1) sensitivity.
    SBIT(IE0, 0x88, 1); // INT0 interrupt flag. 
    SBIT(IT1, 0x88, 2); // INT1 level (at 0)/edge (at 1) sensitivity.
    SBIT(IE1, 0x88, 3); // INT1 interrupt flag.
    SBIT(TR0, 0x88, 4); // Timer 0 run control bit 1: Enabled, 0: Disabled.
    SBIT(TF0, 0x88, 5); // Timer 0 interrupt (overflow) flag.
    SBIT(TR1, 0x88, 6); // Timer 1 run control bit 1: Enabled, 0: Disabled.
    SBIT(TF1, 0x88, 7); // Timer 1 interrupt (overflow) flag.

SFR(TMOD, 0x89); // Timer 0 and timer 1 control mode register.
    #define T0_M0    0x01
    #define T0_M1    0x02
    #define T0_CT    0x04
    #define T0_GATE  0x08
    #define T1_M0    0x10
    #define T1_M1    0x20
    #define T1_CT    0x40
    #define T1_GATE  0x80
SFR(TH0,  0x8C); // Counter register of timer 0 high.
SFR(TL0,  0x8A); // Counter register of timer 0 low.
SFR(TH1,  0x8D); // Counter register of timer 1 high. 
SFR(TL1,  0x8B); // Counter register of timer 1 low. 

SFR(SCON, 0x98); // UART Configuration Register.
    SBIT(SM0, 0x98, 7); // UART mode bit 0.
    SBIT(SM1, 0x98, 6); // UART mode bit 1.
    SBIT(SM2, 0x98, 5); // Enable a multiprocessor communication feature.
    SBIT(REN, 0x98, 4); // Enable/Disable serial receive.
    SBIT(TB8, 0x98, 3); // The 9th transmitted data bit in Modes 2 and 3.
    SBIT(RB8, 0x98, 2); // The 9th received data bit in Modes 2 and 3.
    SBIT(TI,  0x98, 1); // UART transmitter interrupt flag.
    SBIT(RI,  0x98, 0); // UART receiver interrupt flag.

SFR(SBUF, 0x99); // UART Buffer Register. 

SFR(IE, 0xA8); // Interrupt Enable Register.
    SBIT(EX0, 0xA8, 0); // Enable INT0 interrupt.
    SBIT(ET0, 0xA8, 1); // Enable Timer0 interrupt.
    SBIT(EX1, 0xA8, 2); // Enable INT1 interrupt.
    SBIT(ET1, 0xA8, 3); // Enable Timer1 interrupt.
    SBIT(ES,  0xA8, 4); // Enable UART interrupt.
    SBIT(ET2, 0xA8, 5); // Enable Timer2 interrupt.
    SBIT(EA,  0xA8, 7); // Enable global interrupt.

SFR(IP, 0xB8); // Interrupt Priority Register.
    SBIT(PX0, 0xA8, 0); // INT0 priority level control.
    SBIT(PT0, 0xA8, 1); // Timer0 priority level control.
    SBIT(PX1, 0xA8, 2); // INT1 priority level control.
    SBIT(PT1, 0xA8, 3); // Timer1 priority level control.
    SBIT(PS,  0xA8, 4); // UART priority level control.
    SBIT(PT2, 0xA8, 5); // Timer2 priority level control.

SFR(TA, 0xC7); // Timed Access Register. 

SFR(T2CON, 0xC8); // Timer 2 Configuration Register.
    SBIT(CPRL2, 0xC8, 0); // Capture/Reload select.
    SBIT(CT2,   0xC8, 1); // Timer/Counter select.
    SBIT(TR2,   0xC8, 2); // Start/Stop Timer2.
    SBIT(EXEN2, 0xC8, 3); // Enable T2EX pin functionality.
    SBIT(TCLK,  0xC8, 4); // Transmit clock enable.
    SBIT(RCLK,  0xC8, 5); // Receive clock enable.
    SBIT(EXF2,  0xC8, 6); // Indicates a Falling edge in the T2EX pin when EXEN2=1.
    SBIT(TF2,   0xC8, 7); // Timer2 overflow flag.

SFR(RLDH, 0xCB); // Capture Registers of Timer 2 high.
SFR(RLDL, 0xCA); // Capture Registers of Timer 2 low. 

SFR(TH2, 0xCD); // Counter Register of Timer 2 high.
SFR(TL2, 0xCC); // Counter Register of Timer 2 low.

SFR(PSW, 0xD0); // Program Status Word Register.
    SBIT(P,   0xD0, 0); // Parity flag.
    SBIT(F1,  0xD0, 1); // General purpose flag 1.
    SBIT(OV,  0xD0, 2); // Overflow flag.
    SBIT(RS0, 0xD0, 3); // Register bank select bit 0.
    SBIT(RS1, 0xD0, 4); // Register bank select bit 1.
    SBIT(F0,  0xD0, 5); // General purpose flag 0.
    SBIT(AC,  0xD0, 6); // Auxiliary carry.
    SBIT(CY,  0xD0, 7); // Carry flag.

SFR(EIE, 0xE8); //Extended Interrupt Enable Register.
    SBIT(EINT2, 0xE8, 0); // Enable INT2 Interrupt.
    SBIT(EINT3, 0xE8, 1); // Enable INT3 Interrupt.
    SBIT(EINT4, 0xE8, 2); // Must be set to '0'.
    SBIT(EINT5, 0xE8, 3); // Enable TCPIPCore Interrupt.
    SBIT(EWDI,  0xE8, 4); // Enable WATCHDOG Interrupt.

SFR(EIP, 0xF8); // Extended Interrupt Priority Register.
    SBIT(PINT2, 0xF8, 0); // INT2 priority level control.
    SBIT(PINT3, 0xF8, 1); // INT3 priority level control.
    SBIT(PINT4, 0xF8, 2); // Must be set to '0'.
    SBIT(PINT5, 0xF8, 3); // TCPIPCore Interrupt priority level control.
    SBIT(PWDI,  0xF8, 4); // WATCHDOG priority level control.

SFR(EIF, 0x91); // Extended Interrupt Flag Register.
    #define INT2F 0x01 // INT2 interrupt flag. Must be cleared by software.
    #define INT3F 0x02 // INT3 interrupt flag. Must be cleared by software.
    #define INT4F 0x04 // Must be set to '0'.
    #define INT5F 0x08 // TCPIPCore Interrupt flag. Must be cleared by software.

SFR(WDCON, 0xD8); // Watchdog Control Register
    SBIT(RWT,  0xD8, 0); // Reset the Watchdog Timer.
    SBIT(EWT,  0xD8, 1); // Enable the Watchdog Timer reset.
    SBIT(WTRF, 0xD8, 2); // Watchdog Timer reset Flag.
    SBIT(WDIF, 0xD8, 3); // Watchdog Interrupt Flag.

SFR(P0, 0x80); // Port 0 Register.
    SBIT(P0_0, 0x80, 0);
    SBIT(P0_1, 0x80, 1);
    SBIT(P0_2, 0x80, 2);
    SBIT(P0_3, 0x80, 3);
    SBIT(P0_4, 0x80, 4);
    SBIT(P0_5, 0x80, 5);
    SBIT(P0_6, 0x80, 6);
    SBIT(P0_7, 0x80, 7);

SFR(P1, 0x90); // Port 1 Register.
    SBIT(P1_0, 0x90, 0);
    SBIT(P1_1, 0x90, 1);
    SBIT(P1_2, 0x90, 2);
    SBIT(P1_3, 0x90, 3);
    SBIT(P1_4, 0x90, 4);
    SBIT(P1_5, 0x90, 5);
    SBIT(P1_6, 0x90, 6);
    SBIT(P1_7, 0x90, 7);

SFR(P2, 0xA0); // Port 2 Register.
    SBIT(P2_0, 0xA0, 0);
    SBIT(P2_1, 0xA0, 1);
    SBIT(P2_2, 0xA0, 2);
    SBIT(P2_3, 0xA0, 3);
    SBIT(P2_4, 0xA0, 4);
    SBIT(P2_5, 0xA0, 5);
    SBIT(P2_6, 0xA0, 6);
    SBIT(P2_7, 0xA0, 7);

SFR(P3, 0xB0); // Port 3 Register.
    SBIT(P3_0, 0xB0, 0);
    SBIT(P3_1, 0xB0, 1);
    SBIT(P3_2, 0xB0, 2);
    SBIT(P3_3, 0xB0, 3);
    SBIT(P3_4, 0xB0, 4);
    SBIT(P3_5, 0xB0, 5);
    SBIT(P3_6, 0xB0, 6);
    SBIT(P3_7, 0xB0, 7);

#endif /*REG_W7100_H*/
/*-------------------------------------------------------------------------
   C8051F040.h - Register Declarations for the Cygnal/SiLabs C8051F04x
   Processor Range

   Copyright (C) 2004, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef C8051F040_H
#define C8051F040_H


/*  BYTE Registers  */

/*  All Pages */
__sfr __at 0x80 P0       ;  /* PORT 0                                        */
__sfr __at 0x81 SP       ;  /* STACK POINTER                                 */
__sfr __at 0x82 DPL      ;  /* DATA POINTER - LOW BYTE                       */
__sfr __at 0x83 DPH      ;  /* DATA POINTER - HIGH BYTE                      */
__sfr __at 0x84 SFRPAGE  ;  /* SFR PAGE SELECT                               */
__sfr __at 0x85 SFRNEXT  ;  /* SFR STACK NEXT PAGE                           */
__sfr __at 0x86 SFRLAST  ;  /* SFR STACK LAST PAGE                           */
__sfr __at 0x87 PCON     ;  /* POWER CONTROL                                 */
__sfr __at 0x90 P1       ;  /* PORT 1                                        */
__sfr __at 0xA0 P2       ;  /* PORT 2                                        */
__sfr __at 0xA8 IE       ;  /* INTERRUPT ENABLE                              */
__sfr __at 0xB0 P3       ;  /* PORT 3                                        */
__sfr __at 0xB8 IP       ;  /* INTERRUPT PRIORITY                            */
__sfr __at 0xD0 PSW      ;  /* PROGRAM STATUS WORD                           */
__sfr __at 0xE0 ACC      ;  /* ACCUMULATOR                                   */
__sfr __at 0xE6 EIE1     ;  /* EXTERNAL INTERRUPT ENABLE 1                   */
__sfr __at 0xE7 EIE2     ;  /* EXTERNAL INTERRUPT ENABLE 2                   */
__sfr __at 0xF0 B        ;  /* B REGISTER                                    */
__sfr __at 0xF6 EIP1     ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 1        */
__sfr __at 0xF7 EIP2     ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 2        */
__sfr __at 0xFF WDTCN    ;  /* WATCHDOG TIMER CONTROL                        */

/*  Page 0x00 */
__sfr __at 0x88 TCON     ;  /* TIMER CONTROL                                 */
__sfr __at 0x89 TMOD     ;  /* TIMER MODE                                    */
__sfr __at 0x8A TL0      ;  /* TIMER 0 - LOW BYTE                            */
__sfr __at 0x8B TL1      ;  /* TIMER 1 - LOW BYTE                            */
__sfr __at 0x8C TH0      ;  /* TIMER 0 - HIGH BYTE                           */
__sfr __at 0x8D TH1      ;  /* TIMER 1 - HIGH BYTE                           */
__sfr __at 0x8E CKCON    ;  /* TIMER 0/1 CLOCK CONTROL                       */
__sfr __at 0x8F PSCTL    ;  /* FLASH WRITE/ERASE CONTROL                     */
__sfr __at 0x91 SSTA0    ;  /* UART 0 STATUS                                 */
__sfr __at 0x98 SCON0    ;  /* UART 0 CONTROL                                */
__sfr __at 0x98 SCON     ;  /* UART 0 CONTROL                                */
__sfr __at 0x99 SBUF0    ;  /* UART 0 BUFFER                                 */
__sfr __at 0x99 SBUF     ;  /* UART 0 BUFFER                                 */
__sfr __at 0x9A SPI0CFG  ;  /* SPI 0 CONFIGURATION                           */
__sfr __at 0x9B SPI0DAT  ;  /* SPI 0 DATA                                    */
__sfr __at 0x9D SPI0CKR  ;  /* SPI 0 CLOCK RATE CONTROL                      */
__sfr __at 0xA1 EMI0TC   ;  /* EMIF TIMING CONTROL                           */
__sfr __at 0xA2 EMI0CN   ;  /* EMIF CONTROL                                  */
__sfr __at 0xA2 _XPAGE   ;  /* XDATA/PDATA PAGE                              */
__sfr __at 0xA3 EMI0CF   ;  /* EMIF CONFIGURATION                            */
__sfr __at 0xA9 SADDR0   ;  /* UART 0 SLAVE ADDRESS                          */
__sfr __at 0xB7 FLSCL    ;  /* FLASH SCALE                                   */
__sfr __at 0xB9 SADEN0   ;  /* UART 0 SLAVE ADDRESS MASK                     */
__sfr __at 0xBA AMX0CF   ;  /* ADC 0 MUX CONFIGURATION                       */
__sfr __at 0xBB AMX0SL   ;  /* ADC 0 MUX CHANNEL SELECTION                   */
__sfr __at 0xBC ADC0CF   ;  /* ADC 0 CONFIGURATION                           */
__sfr __at 0xBD AMX0PRT  ;  /* ADC 0 PORT 3 I/O PIN SELECT                   */
__sfr __at 0xBE ADC0L    ;  /* ADC 0 DATA - LOW BYTE                         */
__sfr __at 0xBF ADC0H    ;  /* ADC 0 DATA - HIGH BYTE                        */
__sfr __at 0xC0 SMB0CN   ;  /* SMBUS 0 CONTROL                               */
__sfr __at 0xC1 SMB0STA  ;  /* SMBUS 0 STATUS                                */
__sfr __at 0xC2 SMB0DAT  ;  /* SMBUS 0 DATA                                  */
__sfr __at 0xC3 SMB0ADR  ;  /* SMBUS 0 SLAVE ADDRESS                         */
__sfr __at 0xC4 ADC0GTL  ;  /* ADC 0 GREATER-THAN REGISTER - LOW BYTE        */
__sfr __at 0xC5 ADC0GTH  ;  /* ADC 0 GREATER-THAN REGISTER - HIGH BYTE       */
__sfr __at 0xC6 ADC0LTL  ;  /* ADC 0 LESS-THAN REGISTER - LOW BYTE           */
__sfr __at 0xC7 ADC0LTH  ;  /* ADC 0 LESS-THAN REGISTER - HIGH BYTE          */
__sfr __at 0xC8 TMR2CN   ;  /* TIMER 2 CONTROL                               */
__sfr __at 0xC9 TMR2CF   ;  /* TIMER 2 CONFIGURATION                         */
__sfr __at 0xCA RCAP2L   ;  /* TIMER 2 CAPTURE REGISTER - LOW BYTE           */
__sfr __at 0xCB RCAP2H   ;  /* TIMER 2 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at 0xCC TMR2L    ;  /* TIMER 2 - LOW BYTE                            */
__sfr __at 0xCC TL2      ;  /* TIMER 2 - LOW BYTE                            */
__sfr __at 0xCD TMR2H    ;  /* TIMER 2 - HIGH BYTE                           */
__sfr __at 0xCD TH2      ;  /* TIMER 2 - HIGH BYTE                           */
__sfr __at 0xCF SMB0CR   ;  /* SMBUS 0 CLOCK RATE                            */
__sfr __at 0xD1 REF0CN   ;  /* VOLTAGE REFERENCE 0 CONTROL                   */
__sfr __at 0xD2 DAC0L    ;  /* DAC 0 REGISTER - LOW BYTE                     */
__sfr __at 0xD3 DAC0H    ;  /* DAC 0 REGISTER - HIGH BYTE                    */
__sfr __at 0xD4 DAC0CN   ;  /* DAC 0 CONTROL                                 */
__sfr __at 0xD6 HVA0CN   ;  /* HIGH VOLTAGE DIFFERENTIAL AMP CONTROL         */
__sfr __at 0xD8 PCA0CN   ;  /* PCA 0 COUNTER CONTROL                         */
__sfr __at 0xD9 PCA0MD   ;  /* PCA 0 COUNTER MODE                            */
__sfr __at 0xDA PCA0CPM0 ;  /* PCA 0 MODULE 0 CONTROL                        */
__sfr __at 0xDB PCA0CPM1 ;  /* PCA 0 MODULE 1 CONTROL                        */
__sfr __at 0xDC PCA0CPM2 ;  /* PCA 0 MODULE 2 CONTROL                        */
__sfr __at 0xDD PCA0CPM3 ;  /* PCA 0 MODULE 3 CONTROL                        */
__sfr __at 0xDE PCA0CPM4 ;  /* PCA 0 MODULE 4 CONTROL                        */
__sfr __at 0xDF PCA0CPM5 ;  /* PCA 0 MODULE 5 CONTROL                        */
__sfr __at 0xE1 PCA0CPL5 ;  /* PCA 0 MODULE 5 CAPTURE/COMPARE - LOW BYTE     */
__sfr __at 0xE2 PCA0CPH5 ;  /* PCA 0 MODULE 5 CAPTURE/COMPARE - HIGH BYTE    */
__sfr __at 0xE8 ADC0CN   ;  /* ADC 0 CONTROL                                 */
__sfr __at 0xE9 PCA0CPL2 ;  /* PCA 0 MODULE 2 CAPTURE/COMPARE - LOW BYTE     */
__sfr __at 0xEA PCA0CPH2 ;  /* PCA 0 MODULE 2 CAPTURE/COMPARE - HIGH BYTE    */
__sfr __at 0xEB PCA0CPL3 ;  /* PCA 0 MODULE 3 CAPTURE/COMPARE - LOW BYTE     */
__sfr __at 0xEC PCA0CPH3 ;  /* PCA 0 MODULE 3 CAPTURE/COMPARE - HIGH BYTE    */
__sfr __at 0xED PCA0CPL4 ;  /* PCA 0 MODULE 4 CAPTURE/COMPARE - LOW BYTE     */
__sfr __at 0xEE PCA0CPH4 ;  /* PCA 0 MODULE 4 CAPTURE/COMPARE - HIGH BYTE    */
__sfr __at 0xEF RSTSRC   ;  /* RESET SOURCE                                  */
__sfr __at 0xF8 SPI0CN   ;  /* SPI 0 CONTROL                                 */
__sfr __at 0xF9 PCA0L    ;  /* PCA 0 TIMER - LOW BYTE                        */
__sfr __at 0xFA PCA0H    ;  /* PCA 0 TIMER - HIGH BYTE                       */
__sfr __at 0xFB PCA0CPL0 ;  /* PCA 0 MODULE 0 CAPTURE/COMPARE - LOW BYTE     */
__sfr __at 0xFC PCA0CPH0 ;  /* PCA 0 MODULE 0 CAPTURE/COMPARE - HIGH BYTE    */
__sfr __at 0xFD PCA0CPL1 ;  /* PCA 0 MODULE 1 CAPTURE/COMPARE - LOW BYTE     */
__sfr __at 0xFE PCA0CPH1 ;  /* PCA 0 MODULE 1 CAPTURE/COMPARE - HIGH BYTE    */

/*  Page 0x01 */
__sfr __at 0x88 CPT0CN   ;  /* COMPARATOR 0 CONTROL                          */
__sfr __at 0x89 CPT0MD   ;  /* COMPARATOR 0 CONFIGURATION                    */
__sfr __at 0x98 SCON1    ;  /* UART 1 CONTROL                                */
__sfr __at 0x99 SBUF1    ;  /* UART 1 BUFFER                                 */
__sfr __at 0xC0 CAN0STA  ;  /* CAN 0 STATUS                                  */
__sfr __at 0xC8 TMR3CN   ;  /* TIMER 3 CONTROL                               */
__sfr __at 0xC9 TMR3CF   ;  /* TIMER 3 CONFIGURATION                         */
__sfr __at 0xCA RCAP3L   ;  /* TIMER 3 CAPTURE REGISTER - LOW BYTE           */
__sfr __at 0xCB RCAP3H   ;  /* TIMER 3 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at 0xCC TMR3L    ;  /* TIMER 3 - LOW BYTE                            */
__sfr __at 0xCD TMR3H    ;  /* TIMER 3 - HIGH BYTE                           */
__sfr __at 0xD2 DAC1L    ;  /* DAC 1 REGISTER - LOW BYTE                     */
__sfr __at 0xD3 DAC1H    ;  /* DAC 1 REGISTER - HIGH BYTE                    */
__sfr __at 0xD4 DAC1CN   ;  /* DAC 1 CONTROL                                 */
__sfr __at 0xD8 CAN0DATL ;  /* CAN 0 DATA REGISTER LOW                       */
__sfr __at 0xD9 CAN0DATH ;  /* CAN 0 DATA REGISTER HIGH                      */
__sfr __at 0xDA CAN0ADR  ;  /* CAN 0 ADDRESS                                 */
__sfr __at 0xDB CAN0TST  ;  /* CAN 0 TEST REGISTER                           */
__sfr __at 0xF8 CAN0CN   ;  /* CAN 0 CONTROL                                 */

/*  Page 0x02 */
__sfr __at 0x88 CPT1CN   ;  /* COMPARATOR 1 CONTROL                          */
__sfr __at 0x89 CPT1MD   ;  /* COMPARATOR 1 CONFIGURATION                    */
__sfr __at 0xBA AMX2CF   ;  /* ADC 2 MUX CONFIGURATION                       */
__sfr __at 0xBB AMX2SL   ;  /* ADC 2 MUX CHANNEL SELECTION                   */
__sfr __at 0xBC ADC2CF   ;  /* ADC 2 CONFIGURATION                           */
__sfr __at 0xBE ADC2     ;  /* ADC 2 DATA                                    */
__sfr __at 0xC4 ADC2GT   ;  /* ADC 2 GREATER-THAN REGISTER                   */
__sfr __at 0xC6 ADC2LT   ;  /* ADC 2 LESS-THAN REGISTER                      */
__sfr __at 0xC8 TMR4CN   ;  /* TIMER 4 CONTROL                               */
__sfr __at 0xC9 TMR4CF   ;  /* TIMER 4 CONFIGURATION                         */
__sfr __at 0xCA RCAP4L   ;  /* TIMER 4 CAPTURE REGISTER - LOW BYTE           */
__sfr __at 0xCB RCAP4H   ;  /* TIMER 4 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at 0xCC TMR4L    ;  /* TIMER 4 - LOW BYTE                            */
__sfr __at 0xCD TMR4H    ;  /* TIMER 4 - HIGH BYTE                           */
__sfr __at 0xE8 ADC2CN   ;  /* ADC 2 CONTROL                                 */

/*  Page 0x03 */
__sfr __at 0x88 CPT2CN   ;  /* COMPARATOR 2 CONTROL                          */
__sfr __at 0x89 CPT2MD   ;  /* COMPARATOR 2 CONFIGURATION                    */

/*  Page 0x0F */
__sfr __at 0x8A OSCICN   ;  /* INTERNAL OSCILLATOR CONTROL                   */
__sfr __at 0x8B OSCICL   ;  /* INTERNAL OSCILLATOR CALIBRATION               */
__sfr __at 0x8C OSCXCN   ;  /* EXTERNAL OSCILLATOR CONTROL                   */
__sfr __at 0x96 SFRPGCN  ;  /* SFR PAGE CONTROL                              */
__sfr __at 0x97 CLKSEL   ;  /* SYSTEM CLOCK SELECT                           */
__sfr __at 0x9C P4MDOUT  ;  /* PORT 4 OUTPUT MODE                            */
__sfr __at 0x9D P5MDOUT  ;  /* PORT 5 OUTPUT MODE                            */
__sfr __at 0x9E P6MDOUT  ;  /* PORT 6 OUTPUT MODE                            */
__sfr __at 0x9F P7MDOUT  ;  /* PORT 7 OUTPUT MODE                            */
__sfr __at 0xA4 P0MDOUT  ;  /* PORT 0 OUTPUT MODE                            */
__sfr __at 0xA5 P1MDOUT  ;  /* PORT 1 OUTPUT MODE                            */
__sfr __at 0xA6 P2MDOUT  ;  /* PORT 2 OUTPUT MODE CONFIGURATION              */
__sfr __at 0xA7 P3MDOUT  ;  /* PORT 3 OUTPUT MODE CONFIGURATION              */
__sfr __at 0xAD P1MDIN   ;  /* PORT 1 INPUT MODE                             */
__sfr __at 0xAE P2MDIN   ;  /* PORT 2 INPUT MODE                             */
__sfr __at 0xAF P3MDIN   ;  /* PORT 3 INPUT MODE                             */
__sfr __at 0xB7 FLACL    ;  /* FLASH ACCESS LIMIT                            */
__sfr __at 0xC8 P4       ;  /* PORT 4                                        */
__sfr __at 0xD8 P5       ;  /* PORT 5                                        */
__sfr __at 0xE1 XBR0     ;  /* CROSSBAR CONFIGURATION REGISTER 0             */
__sfr __at 0xE2 XBR1     ;  /* CROSSBAR CONFIGURATION REGISTER 1             */
__sfr __at 0xE3 XBR2     ;  /* CROSSBAR CONFIGURATION REGISTER 2             */
__sfr __at 0xE4 XBR3     ;  /* CROSSBAR CONFIGURATION REGISTER 3             */
__sfr __at 0xE8 P6       ;  /* PORT 6                                        */
__sfr __at 0xF8 P7       ;  /* PORT 7                                        */

/*
Do NOT use sfr16 for CAN0DAT !
*/

/*  BIT Registers  */

/*  P0  0x80 */
__sbit __at 0x80 P0_0    ;
__sbit __at 0x81 P0_1    ;
__sbit __at 0x82 P0_2    ;
__sbit __at 0x83 P0_3    ;
__sbit __at 0x84 P0_4    ;
__sbit __at 0x85 P0_5    ;
__sbit __at 0x86 P0_6    ;
__sbit __at 0x87 P0_7    ;

/*  TCON  0x88 */
__sbit __at 0x88 IT0     ;  /* EXT. INTERRUPT 0 TYPE                         */
__sbit __at 0x89 IE0     ;  /* EXT. INTERRUPT 0 EDGE FLAG                    */
__sbit __at 0x8A IT1     ;  /* EXT. INTERRUPT 1 TYPE                         */
__sbit __at 0x8B IE1     ;  /* EXT. INTERRUPT 1 EDGE FLAG                    */
__sbit __at 0x8C TR0     ;  /* TIMER 0 ON/OFF CONTROL                        */
__sbit __at 0x8D TF0     ;  /* TIMER 0 OVERFLOW FLAG                         */
__sbit __at 0x8E TR1     ;  /* TIMER 1 ON/OFF CONTROL                        */
__sbit __at 0x8F TF1     ;  /* TIMER 1 OVERFLOW FLAG                         */

/*  CPT0CN  0x88 */
__sbit __at 0x88 CP0HYN0 ;  /* COMPARATOR 0 NEGATIVE HYSTERESIS 0            */
__sbit __at 0x89 CP0HYN1 ;  /* COMPARATOR 0 NEGATIVE HYSTERESIS 1            */
__sbit __at 0x8A CP0HYP0 ;  /* COMPARATOR 0 POSITIVE HYSTERESIS 0            */
__sbit __at 0x8B CP0HYP1 ;  /* COMPARATOR 0 POSITIVE HYSTERESIS 1            */
__sbit __at 0x8C CP0FIF  ;  /* COMPARATOR 0 FALLING EDGE INTERRUPT           */
__sbit __at 0x8D CP0RIF  ;  /* COMPARATOR 0 RISING EDGE INTERRUPT            */
__sbit __at 0x8E CP0OUT  ;  /* COMPARATOR 0 OUTPUT                           */
__sbit __at 0x8F CP0EN   ;  /* COMPARATOR 0 ENABLE                           */

/*  CPT1CN  0x88 */
__sbit __at 0x88 CP1HYN0 ;  /* COMPARATOR 1 NEGATIVE HYSTERESIS 0            */
__sbit __at 0x89 CP1HYN1 ;  /* COMPARATOR 1 NEGATIVE HYSTERESIS 1            */
__sbit __at 0x8A CP1HYP0 ;  /* COMPARATOR 1 POSITIVE HYSTERESIS 0            */
__sbit __at 0x8B CP1HYP1 ;  /* COMPARATOR 1 POSITIVE HYSTERESIS 1            */
__sbit __at 0x8C CP1FIF  ;  /* COMPARATOR 1 FALLING EDGE INTERRUPT           */
__sbit __at 0x8D CP1RIF  ;  /* COMPARATOR 1 RISING EDGE INTERRUPT            */
__sbit __at 0x8E CP1OUT  ;  /* COMPARATOR 1 OUTPUT                           */
__sbit __at 0x8F CP1EN   ;  /* COMPARATOR 1 ENABLE                           */

/*  CPT2CN  0x88 */
__sbit __at 0x88 CP2HYN0 ;  /* COMPARATOR 2 NEGATIVE HYSTERESIS 0            */
__sbit __at 0x89 CP2HYN1 ;  /* COMPARATOR 2 NEGATIVE HYSTERESIS 1            */
__sbit __at 0x8A CP2HYP0 ;  /* COMPARATOR 2 POSITIVE HYSTERESIS 0            */
__sbit __at 0x8B CP2HYP1 ;  /* COMPARATOR 2 POSITIVE HYSTERESIS 1            */
__sbit __at 0x8C CP2FIF  ;  /* COMPARATOR 2 FALLING EDGE INTERRUPT           */
__sbit __at 0x8D CP2RIF  ;  /* COMPARATOR 2 RISING EDGE INTERRUPT            */
__sbit __at 0x8E CP2OUT  ;  /* COMPARATOR 2 OUTPUT                           */
__sbit __at 0x8F CP2EN   ;  /* COMPARATOR 2 ENABLE                           */

/*  P1  0x90 */
__sbit __at 0x90 P1_0    ;
__sbit __at 0x91 P1_1    ;
__sbit __at 0x92 P1_2    ;
__sbit __at 0x93 P1_3    ;
__sbit __at 0x94 P1_4    ;
__sbit __at 0x95 P1_5    ;
__sbit __at 0x96 P1_6    ;
__sbit __at 0x97 P1_7    ;

/*  SCON0  0x98 */
__sbit __at 0x98 RI0     ;  /* UART 0 RX INTERRUPT FLAG                      */
__sbit __at 0x98 RI      ;  /* UART 0 RX INTERRUPT FLAG                      */
__sbit __at 0x99 TI0     ;  /* UART 0 TX INTERRUPT FLAG                      */
__sbit __at 0x99 TI      ;  /* UART 0 TX INTERRUPT FLAG                      */
__sbit __at 0x9A RB80    ;  /* UART 0 RX BIT 8                               */
__sbit __at 0x9B TB80    ;  /* UART 0 TX BIT 8                               */
__sbit __at 0x9C REN0    ;  /* UART 0 RX ENABLE                              */
__sbit __at 0x9C REN     ;  /* UART 0 RX ENABLE                              */
__sbit __at 0x9D SM20    ;  /* UART 0 MULTIPROCESSOR EN                      */
__sbit __at 0x9E SM10    ;  /* UART 0 MODE 1                                 */
__sbit __at 0x9F SM00    ;  /* UART 0 MODE 0                                 */

/*  SCON1  0x98 */
__sbit __at 0x98 RI1     ;  /* UART 1 RX INTERRUPT FLAG                      */
__sbit __at 0x99 TI1     ;  /* UART 1 TX INTERRUPT FLAG                      */
__sbit __at 0x9A RB81    ;  /* UART 1 RX BIT 8                               */
__sbit __at 0x9B TB81    ;  /* UART 1 TX BIT 8                               */
__sbit __at 0x9C REN1    ;  /* UART 1 RX ENABLE                              */
__sbit __at 0x9D MCE1    ;  /* UART 1 MCE                                    */
__sbit __at 0x9F S1MODE  ;  /* UART 1 MODE                                   */

/*  P2  0xA0 */
__sbit __at 0xA0 P2_0    ;
__sbit __at 0xA1 P2_1    ;
__sbit __at 0xA2 P2_2    ;
__sbit __at 0xA3 P2_3    ;
__sbit __at 0xA4 P2_4    ;
__sbit __at 0xA5 P2_5    ;
__sbit __at 0xA6 P2_6    ;
__sbit __at 0xA7 P2_7    ;

/*  IE  0xA8 */
__sbit __at 0xA8 EX0     ;  /* EXTERNAL INTERRUPT 0 ENABLE                   */
__sbit __at 0xA9 ET0     ;  /* TIMER 0 INTERRUPT ENABLE                      */
__sbit __at 0xAA EX1     ;  /* EXTERNAL INTERRUPT 1 ENABLE                   */
__sbit __at 0xAB ET1     ;  /* TIMER 1 INTERRUPT ENABLE                      */
__sbit __at 0xAC ES0     ;  /* UART0 INTERRUPT ENABLE                        */
__sbit __at 0xAC ES      ;  /* UART0 INTERRUPT ENABLE                        */
__sbit __at 0xAD ET2     ;  /* TIMER 2 INTERRUPT ENABLE                      */
__sbit __at 0xAF EA      ;  /* GLOBAL INTERRUPT ENABLE                       */

/*  P3  0xB0 */
__sbit __at 0xB0 P3_0    ;
__sbit __at 0xB1 P3_1    ;
__sbit __at 0xB2 P3_2    ;
__sbit __at 0xB3 P3_3    ;
__sbit __at 0xB4 P3_4    ;
__sbit __at 0xB5 P3_5    ;
__sbit __at 0xB6 P3_6    ;
__sbit __at 0xB7 P3_7    ;

/*  IP  0xB8 */
__sbit __at 0xB8 PX0     ;  /* EXTERNAL INTERRUPT 0 PRIORITY                 */
__sbit __at 0xB9 PT0     ;  /* TIMER 0 PRIORITY                              */
__sbit __at 0xBA PX1     ;  /* EXTERNAL INTERRUPT 1 PRIORITY                 */
__sbit __at 0xBB PT1     ;  /* TIMER 1 PRIORITY                              */
__sbit __at 0xBC PS0     ;  /* SERIAL PORT PRIORITY                          */
__sbit __at 0xBC PS      ;  /* SERIAL PORT PRIORITY                          */
__sbit __at 0xBD PT2     ;  /* TIMER 2 PRIORITY                              */

/*  SMB0CN  0xC0 */
__sbit __at 0xC0 SMBTOE  ;  /* SMBUS 0 TIMEOUT ENABLE                        */
__sbit __at 0xC1 SMBFTE  ;  /* SMBUS 0 FREE TIMER ENABLE                     */
__sbit __at 0xC2 AA      ;  /* SMBUS 0 ASSERT/ACKNOWLEDGE FLAG               */
__sbit __at 0xC3 SI      ;  /* SMBUS 0 INTERRUPT PENDING FLAG                */
__sbit __at 0xC4 STO     ;  /* SMBUS 0 STOP FLAG                             */
__sbit __at 0xC5 STA     ;  /* SMBUS 0 START FLAG                            */
__sbit __at 0xC6 ENSMB   ;  /* SMBUS 0 ENABLE                                */
__sbit __at 0xC7 BUSY    ;  /* SMBUS 0 BUSY                                  */

/*  CAN0STA  0xC0 */
__sbit __at 0xC3 CANTXOK ;  /* CAN TRANSMITTED A MESSAGE SUCCESSFULLY        */
__sbit __at 0xC4 CANRXOK ;  /* CAN RECEIVED A MESSAGE SUCCESSFULLY           */
__sbit __at 0xC5 CANEPASS;  /* CAN ERROR PASSIVE                             */
__sbit __at 0xC6 CANEWARN;  /* CAN WARNING STATUS                            */
__sbit __at 0xC7 CANBOFF ;  /* CAN BUSOFF STATUS                             */

/*  TMR2CN  0xC8 */
__sbit __at 0xC8 CPRL2   ;  /* TIMER 2 CAPTURE SELECT                        */
__sbit __at 0xC9 CT2     ;  /* TIMER 2 COUNTER SELECT                        */
__sbit __at 0xCA TR2     ;  /* TIMER 2 ON/OFF CONTROL                        */
__sbit __at 0xCB EXEN2   ;  /* TIMER 2 EXTERNAL ENABLE FLAG                  */
__sbit __at 0xCE EXF2    ;  /* TIMER 2 EXTERNAL FLAG                         */
__sbit __at 0xCF TF2     ;  /* TIMER 2 OVERFLOW FLAG                         */

/*  TMR3CN  0xC8 */
__sbit __at 0xC8 CPRL3   ;  /* TIMER 3 CAPTURE SELECT                        */
__sbit __at 0xC9 CT3     ;  /* TIMER 3 COUNTER SELECT                        */
__sbit __at 0xCA TR3     ;  /* TIMER 3 ON/OFF CONTROL                        */
__sbit __at 0xCB EXEN3   ;  /* TIMER 3 EXTERNAL ENABLE FLAG                  */
__sbit __at 0xCE EXF3    ;  /* TIMER 3 EXTERNAL FLAG                         */
__sbit __at 0xCF TF3     ;  /* TIMER 3 OVERFLOW FLAG                         */

/*  TMR4CN  0xC8 */
__sbit __at 0xC8 CPRL4   ;  /* TIMER 4 CAPTURE SELECT                        */
__sbit __at 0xC9 CT4     ;  /* TIMER 4 COUNTER SELECT                        */
__sbit __at 0xCA TR4     ;  /* TIMER 4 ON/OFF CONTROL                        */
__sbit __at 0xCB EXEN4   ;  /* TIMER 4 EXTERNAL ENABLE FLAG                  */
__sbit __at 0xCE EXF4    ;  /* TIMER 4 EXTERNAL FLAG                         */
__sbit __at 0xCF TF4     ;  /* TIMER 4 OVERFLOW FLAG                         */

/*  P4  0xC8 */
__sbit __at 0xC8 P4_0    ;
__sbit __at 0xC9 P4_1    ;
__sbit __at 0xCA P4_2    ;
__sbit __at 0xCB P4_3    ;
__sbit __at 0xCC P4_4    ;
__sbit __at 0xCD P4_5    ;
__sbit __at 0xCE P4_6    ;
__sbit __at 0xCF P4_7    ;

/*  PSW  0xD0 */
__sbit __at 0xD0 P       ;  /* ACCUMULATOR PARITY FLAG                       */
__sbit __at 0xD1 F1      ;  /* USER FLAG 1                                   */
__sbit __at 0xD2 OV      ;  /* OVERFLOW FLAG                                 */
__sbit __at 0xD3 RS0     ;  /* REGISTER BANK SELECT 0                        */
__sbit __at 0xD4 RS1     ;  /* REGISTER BANK SELECT 1                        */
__sbit __at 0xD5 F0      ;  /* USER FLAG 0                                   */
__sbit __at 0xD6 AC      ;  /* AUXILIARY CARRY FLAG                          */
__sbit __at 0xD7 CY      ;  /* CARRY FLAG                                    */

/*  PCA0CN  0xD8 */
__sbit __at 0xD8 CCF0    ;  /* PCA 0 MODULE 0 INTERRUPT FLAG                 */
__sbit __at 0xD9 CCF1    ;  /* PCA 0 MODULE 1 INTERRUPT FLAG                 */
__sbit __at 0xDA CCF2    ;  /* PCA 0 MODULE 2 INTERRUPT FLAG                 */
__sbit __at 0xDB CCF3    ;  /* PCA 0 MODULE 3 INTERRUPT FLAG                 */
__sbit __at 0xDC CCF4    ;  /* PCA 0 MODULE 4 INTERRUPT FLAG                 */
__sbit __at 0xDD CCF5    ;  /* PCA 0 MODULE 5 INTERRUPT FLAG                 */
__sbit __at 0xDE CR      ;  /* PCA 0 COUNTER RUN CONTROL BIT                 */
__sbit __at 0xDF CF      ;  /* PCA 0 COUNTER OVERFLOW FLAG                   */

/*  P5  0xD8 */
__sbit __at 0xD8 P5_0    ;
__sbit __at 0xD9 P5_1    ;
__sbit __at 0xDA P5_2    ;
__sbit __at 0xDB P5_3    ;
__sbit __at 0xDC P5_4    ;
__sbit __at 0xDD P5_5    ;
__sbit __at 0xDE P5_6    ;
__sbit __at 0xDF P5_7    ;

/*  ADC0CN  0xE8 */
__sbit __at 0xE8 AD0LJST ;  /* ADC 0 RIGHT JUSTIFY DATA BIT                  */
__sbit __at 0xE9 AD0WINT ;  /* ADC 0 WINDOW INTERRUPT FLAG                   */
__sbit __at 0xEA AD0CM0  ;  /* ADC 0 CONVERT START MODE BIT 0                */
__sbit __at 0xEB AD0CM1  ;  /* ADC 0 CONVERT START MODE BIT 1                */
__sbit __at 0xEC AD0BUSY ;  /* ADC 0 BUSY FLAG                               */
__sbit __at 0xED AD0INT  ;  /* ADC 0 EOC INTERRUPT FLAG                      */
__sbit __at 0xEE AD0TM   ;  /* ADC 0 TRACK MODE                              */
__sbit __at 0xEF AD0EN   ;  /* ADC 0 ENABLE                                  */

/*  ADC2CN  0xE8 */
__sbit __at 0xE8 AD2WINT ;  /* ADC 2 WINDOW INTERRUPT FLAG                   */
__sbit __at 0xE9 AD2CM0  ;  /* ADC 2 CONVERT START MODE BIT 0                */
__sbit __at 0xEA AD2CM1  ;  /* ADC 2 CONVERT START MODE BIT 1                */
__sbit __at 0xEB AD2CM2  ;  /* ADC 2 CONVERT START MODE BIT 2                */
__sbit __at 0xEC AD2BUSY ;  /* ADC 2 BUSY FLAG                               */
__sbit __at 0xED AD2INT  ;  /* ADC 2 EOC INTERRUPT FLAG                      */
__sbit __at 0xEE AD2TM   ;  /* ADC 2 TRACK MODE                              */
__sbit __at 0xEF AD2EN   ;  /* ADC 2 ENABLE                                  */

/*  P6  0xE8 */
__sbit __at 0xE8 P6_0    ;
__sbit __at 0xE9 P6_1    ;
__sbit __at 0xEA P6_2    ;
__sbit __at 0xEB P6_3    ;
__sbit __at 0xEC P6_4    ;
__sbit __at 0xED P6_5    ;
__sbit __at 0xEE P6_6    ;
__sbit __at 0xEF P6_7    ;

/*  SPI0CN  0xF8 */
__sbit __at 0xF8 SPIEN   ;  /* SPI 0 SPI ENABLE                              */
__sbit __at 0xF9 TXBMT   ;  /* SPI 0 TX BUFFER EMPTY FLAG                    */
__sbit __at 0xFA NSSMD0  ;  /* SPI 0 SLAVE SELECT MODE 0                     */
__sbit __at 0xFB NSSMD1  ;  /* SPI 0 SLAVE SELECT MODE 1                     */
__sbit __at 0xFC RXOVRN  ;  /* SPI 0 RX OVERRUN FLAG                         */
__sbit __at 0xFD MODF    ;  /* SPI 0 MODE FAULT FLAG                         */
__sbit __at 0xFE WCOL    ;  /* SPI 0 WRITE COLLISION FLAG                    */
__sbit __at 0xFF SPIF    ;  /* SPI 0 INTERRUPT FLAG                          */

/*  CAN0CN  0xF8 */
__sbit __at 0xF8 CANINIT ;  /* CAN INITIALIZATION                            */
__sbit __at 0xF9 CANIE   ;  /* CAN MODULE INTERRUPT ENABLE                   */
__sbit __at 0xFA CANSIE  ;  /* CAN STATUS CHANGE INTERRUPT ENABLE            */
__sbit __at 0xFB CANEIE  ;  /* CAN ERROR INTERRUPT ENABLE                    */
__sbit __at 0xFC CANIF   ;  /* CAN INTERRUPT FLAG                            */
__sbit __at 0xFD CANDAR  ;  /* CAN DISABLE AUTOMATIC RETRANSMISSION          */
__sbit __at 0xFE CANCCE  ;  /* CAN CONFIGURATION CHANGE ENABLE               */
__sbit __at 0xFF CANTEST ;  /* CAN TEST MODE ENABLE                          */

/*  P7  0xF8 */
__sbit __at 0xF8 P7_0    ;
__sbit __at 0xF9 P7_1    ;
__sbit __at 0xFA P7_2    ;
__sbit __at 0xFB P7_3    ;
__sbit __at 0xFC P7_4    ;
__sbit __at 0xFD P7_5    ;
__sbit __at 0xFE P7_6    ;
__sbit __at 0xFF P7_7    ;


/* Predefined SFR Bit Masks */

#define IDLE              0x01    /* PCON                                */
#define STOP              0x02    /* PCON                                */
#define ECCF              0x01    /* PCA0CPMn                            */
#define PWM               0x02    /* PCA0CPMn                            */
#define TOG               0x04    /* PCA0CPMn                            */
#define MAT               0x08    /* PCA0CPMn                            */
#define CAPN              0x10    /* PCA0CPMn                            */
#define CAPP              0x20    /* PCA0CPMn                            */
#define ECOM              0x40    /* PCA0CPMn                            */
#define PWM16             0x80    /* PCA0CPMn                            */
#define PORSF             0x02    /* RSTSRC                              */
#define SWRSF             0x10    /* RSTSRC                              */


/* SFR PAGE DEFINITIONS */

#define CONFIG_PAGE       0x0F     /* SYSTEM AND PORT CONFIGURATION PAGE */
#define LEGACY_PAGE       0x00     /* LEGACY SFR PAGE                    */
#define TIMER01_PAGE      0x00     /* TIMER 0 AND TIMER 1                */
#define CPT0_PAGE         0x01     /* COMPARATOR 0                       */
#define CPT1_PAGE         0x02     /* COMPARATOR 1                       */
#define CPT2_PAGE         0x03     /* COMPARATOR 2                       */
#define UART0_PAGE        0x00     /* UART 0                             */
#define UART1_PAGE        0x01     /* UART 1                             */
#define SPI0_PAGE         0x00     /* SPI 0                              */
#define EMI0_PAGE         0x00     /* EXTERNAL MEMORY INTERFACE          */
#define ADC0_PAGE         0x00     /* ADC 0                              */
#define ADC2_PAGE         0x02     /* ADC 2                              */
#define SMB0_PAGE         0x00     /* SMBUS 0                            */
#define TMR2_PAGE         0x00     /* TIMER 2                            */
#define TMR3_PAGE         0x01     /* TIMER 3                            */
#define TMR4_PAGE         0x02     /* TIMER 4                            */
#define DAC0_PAGE         0x00     /* DAC 0                              */
#define DAC1_PAGE         0x01     /* DAC 1                              */
#define PCA0_PAGE         0x00     /* PCA 0                              */
#define CAN0_PAGE         0x01     /* CAN 0                              */

#endif
/*---------------------------------------------------------------------------
   C8051F120.h - Register Declarations for the Cygnal/SiLabs C8051F12x-F13x
   Processor Range

   Copyright (C) 2003, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef C8051F120_H
#define C8051F120_H


/*  BYTE Registers  */

/*  All Pages */
__sfr __at (0x80) P0               ;  /* PORT 0                                        */
__sfr __at (0x81) SP               ;  /* STACK POINTER                                 */
__sfr __at (0x82) DPL              ;  /* DATA POINTER - LOW BYTE                       */
__sfr __at (0x83) DPH              ;  /* DATA POINTER - HIGH BYTE                      */
__sfr __at (0x84) SFRPAGE          ;  /* SFR PAGE SELECT                               */
__sfr __at (0x85) SFRNEXT          ;  /* SFR STACK NEXT PAGE                           */
__sfr __at (0x86) SFRLAST          ;  /* SFR STACK LAST PAGE                           */
__sfr __at (0x87) PCON             ;  /* POWER CONTROL                                 */
__sfr __at (0x90) P1               ;  /* PORT 1                                        */
__sfr __at (0xA0) P2               ;  /* PORT 2                                        */
__sfr __at (0xA8) IE               ;  /* INTERRUPT ENABLE                              */
__sfr __at (0xB0) P3               ;  /* PORT 3                                        */
__sfr __at (0xB1) PSBANK           ;  /* FLASH BANK SELECT                             */
__sfr __at (0xB8) IP               ;  /* INTERRUPT PRIORITY                            */
__sfr __at (0xD0) PSW              ;  /* PROGRAM STATUS WORD                           */
__sfr __at (0xE0) ACC              ;  /* ACCUMULATOR                                   */
__sfr __at (0xE6) EIE1             ;  /* EXTERNAL INTERRUPT ENABLE 1                   */
__sfr __at (0xE7) EIE2             ;  /* EXTERNAL INTERRUPT ENABLE 2                   */
__sfr __at (0xF0) B                ;  /* B REGISTER                                    */
__sfr __at (0xF6) EIP1             ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 1        */
__sfr __at (0xF7) EIP2             ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 2        */
__sfr __at (0xFF) WDTCN            ;  /* WATCHDOG TIMER CONTROL                        */

/*  Page 0x00 */
__sfr __at (0x88) TCON             ;  /* TIMER CONTROL                                 */
__sfr __at (0x89) TMOD             ;  /* TIMER MODE                                    */
__sfr __at (0x8A) TL0              ;  /* TIMER 0 - LOW BYTE                            */
__sfr __at (0x8B) TL1              ;  /* TIMER 1 - LOW BYTE                            */
__sfr __at (0x8C) TH0              ;  /* TIMER 0 - HIGH BYTE                           */
__sfr __at (0x8D) TH1              ;  /* TIMER 1 - HIGH BYTE                           */
__sfr __at (0x8E) CKCON            ;  /* TIMER 0/1 CLOCK CONTROL                       */
__sfr __at (0x8F) PSCTL            ;  /* FLASH WRITE/ERASE CONTROL                     */
__sfr __at (0x91) SSTA0            ;  /* UART 0 STATUS                                 */
__sfr __at (0x98) SCON0            ;  /* UART 0 CONTROL                                */
__sfr __at (0x98) SCON             ;  /* UART 0 CONTROL                                */
__sfr __at (0x99) SBUF0            ;  /* UART 0 BUFFER                                 */
__sfr __at (0x99) SBUF             ;  /* UART 0 BUFFER                                 */
__sfr __at (0x9A) SPI0CFG          ;  /* SPI 0 CONFIGURATION                           */
__sfr __at (0x9B) SPI0DAT          ;  /* SPI 0 DATA                                    */
__sfr __at (0x9D) SPI0CKR          ;  /* SPI 0 CLOCK RATE CONTROL                      */
__sfr __at (0xA1) EMI0TC           ;  /* EMIF TIMING CONTROL                           */
__sfr __at (0xA2) EMI0CN           ;  /* EMIF CONTROL                                  */
__sfr __at (0xA2) _XPAGE           ;  /* XDATA/PDATA PAGE                              */
__sfr __at (0xA3) EMI0CF           ;  /* EMIF CONFIGURATION                            */
__sfr __at (0xA9) SADDR0           ;  /* UART 0 SLAVE ADDRESS                          */
__sfr __at (0xB7) FLSCL            ;  /* FLASH SCALE                                   */
__sfr __at (0xB9) SADEN0           ;  /* UART 0 SLAVE ADDRESS MASK                     */
__sfr __at (0xBA) AMX0CF           ;  /* ADC 0 MUX CONFIGURATION                       */
__sfr __at (0xBB) AMX0SL           ;  /* ADC 0 MUX CHANNEL SELECTION                   */
__sfr __at (0xBC) ADC0CF           ;  /* ADC 0 CONFIGURATION                           */
__sfr __at (0xBE) ADC0L            ;  /* ADC 0 DATA - LOW BYTE                         */
__sfr __at (0xBF) ADC0H            ;  /* ADC 0 DATA - HIGH BYTE                        */
__sfr __at (0xC0) SMB0CN           ;  /* SMBUS 0 CONTROL                               */
__sfr __at (0xC1) SMB0STA          ;  /* SMBUS 0 STATUS                                */
__sfr __at (0xC2) SMB0DAT          ;  /* SMBUS 0 DATA                                  */
__sfr __at (0xC3) SMB0ADR          ;  /* SMBUS 0 SLAVE ADDRESS                         */
__sfr __at (0xC4) ADC0GTL          ;  /* ADC 0 GREATER-THAN REGISTER - LOW BYTE        */
__sfr __at (0xC5) ADC0GTH          ;  /* ADC 0 GREATER-THAN REGISTER - HIGH BYTE       */
__sfr __at (0xC6) ADC0LTL          ;  /* ADC 0 LESS-THAN REGISTER - LOW BYTE           */
__sfr __at (0xC7) ADC0LTH          ;  /* ADC 0 LESS-THAN REGISTER - HIGH BYTE          */
__sfr __at (0xC8) TMR2CN           ;  /* TIMER 2 CONTROL                               */
__sfr __at (0xC9) TMR2CF           ;  /* TIMER 2 CONFIGURATION                         */
__sfr __at (0xCA) RCAP2L           ;  /* TIMER 2 CAPTURE REGISTER - LOW BYTE           */
__sfr __at (0xCB) RCAP2H           ;  /* TIMER 2 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at (0xCC) TMR2L            ;  /* TIMER 2 - LOW BYTE                            */
__sfr __at (0xCC) TL2              ;  /* TIMER 2 - LOW BYTE                            */
__sfr __at (0xCD) TMR2H            ;  /* TIMER 2 - HIGH BYTE                           */
__sfr __at (0xCD) TH2              ;  /* TIMER 2 - HIGH BYTE                           */
__sfr __at (0xCF) SMB0CR           ;  /* SMBUS 0 CLOCK RATE                            */
__sfr __at (0xD1) REF0CN           ;  /* VOLTAGE REFERENCE 0 CONTROL                   */
__sfr __at (0xD2) DAC0L            ;  /* DAC 0 REGISTER - LOW BYTE                     */
__sfr __at (0xD3) DAC0H            ;  /* DAC 0 REGISTER - HIGH BYTE                    */
__sfr __at (0xD4) DAC0CN           ;  /* DAC 0 CONTROL                                 */
__sfr __at (0xD8) PCA0CN           ;  /* PCA 0 COUNTER CONTROL                         */
__sfr __at (0xD9) PCA0MD           ;  /* PCA 0 COUNTER MODE                            */
__sfr __at (0xDA) PCA0CPM0         ;  /* PCA 0 MODULE 0 CONTROL                        */
__sfr __at (0xDB) PCA0CPM1         ;  /* PCA 0 MODULE 1 CONTROL                        */
__sfr __at (0xDC) PCA0CPM2         ;  /* PCA 0 MODULE 2 CONTROL                        */
__sfr __at (0xDD) PCA0CPM3         ;  /* PCA 0 MODULE 3 CONTROL                        */
__sfr __at (0xDE) PCA0CPM4         ;  /* PCA 0 MODULE 4 CONTROL                        */
__sfr __at (0xDF) PCA0CPM5         ;  /* PCA 0 MODULE 5 CONTROL                        */
__sfr __at (0xE1) PCA0CPL5         ;  /* PCA 0 MODULE 5 CAPTURE/COMPARE - LOW BYTE     */
__sfr __at (0xE2) PCA0CPH5         ;  /* PCA 0 MODULE 5 CAPTURE/COMPARE - HIGH BYTE    */
__sfr __at (0xE8) ADC0CN           ;  /* ADC 0 CONTROL                                 */
__sfr __at (0xE9) PCA0CPL2         ;  /* PCA 0 MODULE 2 CAPTURE/COMPARE - LOW BYTE     */
__sfr __at (0xEA) PCA0CPH2         ;  /* PCA 0 MODULE 2 CAPTURE/COMPARE - HIGH BYTE    */
__sfr __at (0xEB) PCA0CPL3         ;  /* PCA 0 MODULE 3 CAPTURE/COMPARE - LOW BYTE     */
__sfr __at (0xEC) PCA0CPH3         ;  /* PCA 0 MODULE 3 CAPTURE/COMPARE - HIGH BYTE    */
__sfr __at (0xED) PCA0CPL4         ;  /* PCA 0 MODULE 4 CAPTURE/COMPARE - LOW BYTE     */
__sfr __at (0xEE) PCA0CPH4         ;  /* PCA 0 MODULE 4 CAPTURE/COMPARE - HIGH BYTE    */
__sfr __at (0xEF) RSTSRC           ;  /* RESET SOURCE                                  */
__sfr __at (0xF8) SPI0CN           ;  /* SPI 0 CONTROL                                 */
__sfr __at (0xF9) PCA0L            ;  /* PCA 0 TIMER - LOW BYTE                        */
__sfr __at (0xFA) PCA0H            ;  /* PCA 0 TIMER - HIGH BYTE                       */
__sfr __at (0xFB) PCA0CPL0         ;  /* PCA 0 MODULE 0 CAPTURE/COMPARE - LOW BYTE     */
__sfr __at (0xFC) PCA0CPH0         ;  /* PCA 0 MODULE 0 CAPTURE/COMPARE - HIGH BYTE    */
__sfr __at (0xFD) PCA0CPL1         ;  /* PCA 0 MODULE 1 CAPTURE/COMPARE - LOW BYTE     */
__sfr __at (0xFE) PCA0CPH1         ;  /* PCA 0 MODULE 1 CAPTURE/COMPARE - HIGH BYTE    */

/*  Page 0x01 */
__sfr __at (0x88) CPT0CN           ;  /* COMPARATOR 0 CONTROL                          */
__sfr __at (0x89) CPT0MD           ;  /* COMPARATOR 0 CONFIGURATION                    */
__sfr __at (0x98) SCON1            ;  /* UART 1 CONTROL                                */
__sfr __at (0x99) SBUF1            ;  /* UART 1 BUFFER                                 */
__sfr __at (0xC8) TMR3CN           ;  /* TIMER 3 CONTROL                               */
__sfr __at (0xC9) TMR3CF           ;  /* TIMER 3 CONFIGURATION                         */
__sfr __at (0xCA) RCAP3L           ;  /* TIMER 3 CAPTURE REGISTER - LOW BYTE           */
__sfr __at (0xCB) RCAP3H           ;  /* TIMER 3 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at (0xCC) TMR3L            ;  /* TIMER 3 - LOW BYTE                            */
__sfr __at (0xCD) TMR3H            ;  /* TIMER 3 - HIGH BYTE                           */
__sfr __at (0xD2) DAC1L            ;  /* DAC 1 REGISTER - LOW BYTE                     */
__sfr __at (0xD3) DAC1H            ;  /* DAC 1 REGISTER - HIGH BYTE                    */
__sfr __at (0xD4) DAC1CN           ;  /* DAC 1 CONTROL                                 */

/*  Page 0x02 */
__sfr __at (0x88) CPT1CN           ;  /* COMPARATOR 1 CONTROL                          */
__sfr __at (0x89) CPT1MD           ;  /* COMPARATOR 1 CONFIGURATION                    */
__sfr __at (0xBA) AMX2CF           ;  /* ADC 2 MUX CONFIGURATION                       */
__sfr __at (0xBB) AMX2SL           ;  /* ADC 2 MUX CHANNEL SELECTION                   */
__sfr __at (0xBC) ADC2CF           ;  /* ADC 2 CONFIGURATION                           */
__sfr __at (0xBE) ADC2             ;  /* ADC 2 DATA                                    */
__sfr __at (0xC4) ADC2GT           ;  /* ADC 2 GREATER-THAN REGISTER                   */
__sfr __at (0xC6) ADC2LT           ;  /* ADC 2 LESS-THAN REGISTER                      */
__sfr __at (0xC8) TMR4CN           ;  /* TIMER 4 CONTROL                               */
__sfr __at (0xC9) TMR4CF           ;  /* TIMER 4 CONFIGURATION                         */
__sfr __at (0xCA) RCAP4L           ;  /* TIMER 4 CAPTURE REGISTER - LOW BYTE           */
__sfr __at (0xCB) RCAP4H           ;  /* TIMER 4 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at (0xCC) TMR4L            ;  /* TIMER 4 - LOW BYTE                            */
__sfr __at (0xCD) TMR4H            ;  /* TIMER 4 - HIGH BYTE                           */
__sfr __at (0xE8) ADC2CN           ;  /* ADC 2 CONTROL                                 */

/*  Page 0x03 */
__sfr __at (0x91) MAC0BL           ;  /* MAC0 B Register Low Byte                      */
__sfr __at (0x92) MAC0BH           ;  /* MAC0 B Register High Byte                     */
__sfr __at (0x93) MAC0ACC0         ;  /* MAC0 Accumulator Byte 0 (LSB)                 */
__sfr __at (0x94) MAC0ACC1         ;  /* MAC0 Accumulator Byte 1                       */
__sfr __at (0x95) MAC0ACC2         ;  /* MAC0 Accumulator Byte 2                       */
__sfr __at (0x96) MAC0ACC3         ;  /* MAC0 Accumulator Byte 3 (MSB)                 */
__sfr __at (0x97) MAC0OVR          ;  /* MAC0 Accumulator Overflow                     */
__sfr __at (0xC0) MAC0STA          ;  /* MAC0 Status Register                          */
__sfr __at (0xC1) MAC0AL           ;  /* MAC0 A Register Low Byte                      */
__sfr __at (0xC2) MAC0AH           ;  /* MAC0 A Register High Byte                     */
__sfr __at (0xC3) MAC0CF           ;  /* MAC0 Configuration                            */
__sfr __at (0xCE) MAC0RNDL         ;  /* MAC0 Rounding Register Low Byte               */
__sfr __at (0xCF) MAC0RNDH         ;  /* MAC0 Rounding Register High Byte              */

/*  Page 0x0F */
__sfr __at (0x88) FLSTAT           ;  /* FLASH STATUS                                  */
__sfr __at (0x89) PLL0CN           ;  /* PLL 0 CONTROL                                 */
__sfr __at (0x8A) OSCICN           ;  /* INTERNAL OSCILLATOR CONTROL                   */
__sfr __at (0x8B) OSCICL           ;  /* INTERNAL OSCILLATOR CALIBRATION               */
__sfr __at (0x8C) OSCXCN           ;  /* EXTERNAL OSCILLATOR CONTROL                   */
__sfr __at (0x8D) PLL0DIV          ;  /* PLL 0 DIVIDER                                 */
__sfr __at (0x8E) PLL0MUL          ;  /* PLL 0 MULTIPLIER                              */
__sfr __at (0x8F) PLL0FLT          ;  /* PLL 0 FILTER                                  */
__sfr __at (0x96) SFRPGCN          ;  /* SFR PAGE CONTROL                              */
__sfr __at (0x97) CLKSEL           ;  /* SYSTEM CLOCK SELECT                           */
__sfr __at (0x9A) CCH0MA           ;  /* CACHE MISS ACCUMULATOR                        */
__sfr __at (0x9C) P4MDOUT          ;  /* PORT 4 OUTPUT MODE                            */
__sfr __at (0x9D) P5MDOUT          ;  /* PORT 5 OUTPUT MODE                            */
__sfr __at (0x9E) P6MDOUT          ;  /* PORT 6 OUTPUT MODE                            */
__sfr __at (0x9F) P7MDOUT          ;  /* PORT 7 OUTPUT MODE                            */
__sfr __at (0xA1) CCH0CN           ;  /* CACHE CONTROL                                 */
__sfr __at (0xA2) CCH0TN           ;  /* CACHE TUNING REGISTER                         */
__sfr __at (0xA3) CCH0LC           ;  /* CACHE LOCK                                    */
__sfr __at (0xA4) P0MDOUT          ;  /* PORT 0 OUTPUT MODE                            */
__sfr __at (0xA5) P1MDOUT          ;  /* PORT 1 OUTPUT MODE                            */
__sfr __at (0xA6) P2MDOUT          ;  /* PORT 2 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA7) P3MDOUT          ;  /* PORT 3 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xAD) P1MDIN           ;  /* PORT 1 INPUT MODE                             */
__sfr __at (0xB7) FLACL            ;  /* FLASH ACCESS LIMIT                            */
__sfr __at (0xC8) P4               ;  /* PORT 4                                        */
__sfr __at (0xD8) P5               ;  /* PORT 5                                        */
__sfr __at (0xE1) XBR0             ;  /* CROSSBAR CONFIGURATION REGISTER 0             */
__sfr __at (0xE2) XBR1             ;  /* CROSSBAR CONFIGURATION REGISTER 1             */
__sfr __at (0xE3) XBR2             ;  /* CROSSBAR CONFIGURATION REGISTER 2             */
__sfr __at (0xE8) P6               ;  /* PORT 6                                        */
__sfr __at (0xF8) P7               ;  /* PORT 7                                        */


/*  WORD/DWORD Registers  */

/*  Page 0x00 */
__sfr16 __at (0x8C8A) TMR0         ;  /* TIMER 0 COUNTER                               */
__sfr16 __at (0x8D8B) TMR1         ;  /* TIMER 1 COUNTER                               */
__sfr16 __at (0xCDCC) TMR2         ;  /* TIMER 2 COUNTER                               */
__sfr16 __at (0xCBCA) RCAP2        ;  /* TIMER 2 CAPTURE REGISTER WORD                 */
__sfr16 __at (0xBFBE) ADC0         ;  /* ADC 0 DATA WORD                               */
__sfr16 __at (0xC5C4) ADC0GT       ;  /* ADC 0 GREATER-THAN REGISTER WORD              */
__sfr16 __at (0xC7C6) ADC0LT       ;  /* ADC 0 LESS-THAN REGISTER WORD                 */
__sfr16 __at (0xD3D2) DAC0         ;  /* DAC 0 REGISTER WORD                           */
__sfr16 __at (0xFAF9) PCA0         ;  /* PCA 0 TIMER COUNTER                           */
__sfr16 __at (0xFCFB) PCA0CP0      ;  /* PCA 0 MODULE 0 CAPTURE/COMPARE WORD           */
__sfr16 __at (0xFEFD) PCA0CP1      ;  /* PCA 0 MODULE 1 CAPTURE/COMPARE WORD           */
__sfr16 __at (0xEAE9) PCA0CP2      ;  /* PCA 0 MODULE 2 CAPTURE/COMPARE WORD           */
__sfr16 __at (0xECEB) PCA0CP3      ;  /* PCA 0 MODULE 3 CAPTURE/COMPARE WORD           */
__sfr16 __at (0xEEED) PCA0CP4      ;  /* PCA 0 MODULE 4 CAPTURE/COMPARE WORD           */
__sfr16 __at (0xE2E1) PCA0CP5      ;  /* PCA 0 MODULE 5 CAPTURE/COMPARE WORD           */

/*  Page 0x01 */
__sfr16 __at (0xCDCC) TMR3         ;  /* TIMER 3 COUNTER                               */
__sfr16 __at (0xCBCA) RCAP3        ;  /* TIMER 3 CAPTURE REGISTER WORD                 */
__sfr16 __at (0xD3D2) DAC1         ;  /* DAC 1 REGISTER WORD                           */

/*  Page 0x02 */
__sfr16 __at (0xCDCC) TMR4         ;  /* TIMER 4 COUNTER                               */
__sfr16 __at (0xCBCA) RCAP4        ;  /* TIMER 4 CAPTURE REGISTER WORD                 */

/*  Page 0x03 */
__sfr16 __at (0xC2C1) MAC0A        ;  /* MAC0 A Register                               */
                /* No sfr16 definition for MAC0B because MAC0BL must be written last */
__sfr32 __at (0x96959493) MAC0ACC  ;  /* MAC0 Accumulator                              */
__sfr16 __at (0xCFCE) MAC0RND      ;  /* MAC0 Rounding Register                        */


/*  BIT Registers  */

/*  P0  0x80 */
__sbit __at (0x80) P0_0            ;
__sbit __at (0x81) P0_1            ;
__sbit __at (0x82) P0_2            ;
__sbit __at (0x83) P0_3            ;
__sbit __at (0x84) P0_4            ;
__sbit __at (0x85) P0_5            ;
__sbit __at (0x86) P0_6            ;
__sbit __at (0x87) P0_7            ;

/*  TCON  0x88 */
__sbit __at (0x88) IT0             ;  /* EXT. INTERRUPT 0 TYPE                         */
__sbit __at (0x89) IE0             ;  /* EXT. INTERRUPT 0 EDGE FLAG                    */
__sbit __at (0x8A) IT1             ;  /* EXT. INTERRUPT 1 TYPE                         */
__sbit __at (0x8B) IE1             ;  /* EXT. INTERRUPT 1 EDGE FLAG                    */
__sbit __at (0x8C) TR0             ;  /* TIMER 0 ON/OFF CONTROL                        */
__sbit __at (0x8D) TF0             ;  /* TIMER 0 OVERFLOW FLAG                         */
__sbit __at (0x8E) TR1             ;  /* TIMER 1 ON/OFF CONTROL                        */
__sbit __at (0x8F) TF1             ;  /* TIMER 1 OVERFLOW FLAG                         */

/*  CPT0CN  0x88 */
__sbit __at (0x88) CP0HYN0         ;  /* COMPARATOR 0 NEGATIVE HYSTERESIS 0            */
__sbit __at (0x89) CP0HYN1         ;  /* COMPARATOR 0 NEGATIVE HYSTERESIS 1            */
__sbit __at (0x8A) CP0HYP0         ;  /* COMPARATOR 0 POSITIVE HYSTERESIS 0            */
__sbit __at (0x8B) CP0HYP1         ;  /* COMPARATOR 0 POSITIVE HYSTERESIS 1            */
__sbit __at (0x8C) CP0FIF          ;  /* COMPARATOR 0 FALLING EDGE INTERRUPT           */
__sbit __at (0x8D) CP0RIF          ;  /* COMPARATOR 0 RISING EDGE INTERRUPT            */
__sbit __at (0x8E) CP0OUT          ;  /* COMPARATOR 0 OUTPUT                           */
__sbit __at (0x8F) CP0EN           ;  /* COMPARATOR 0 ENABLE                           */

/*  CPT1CN  0x88 */
__sbit __at (0x88) CP1HYN0         ;  /* COMPARATOR 1 NEGATIVE HYSTERESIS 0            */
__sbit __at (0x89) CP1HYN1         ;  /* COMPARATOR 1 NEGATIVE HYSTERESIS 1            */
__sbit __at (0x8A) CP1HYP0         ;  /* COMPARATOR 1 POSITIVE HYSTERESIS 0            */
__sbit __at (0x8B) CP1HYP1         ;  /* COMPARATOR 1 POSITIVE HYSTERESIS 1            */
__sbit __at (0x8C) CP1FIF          ;  /* COMPARATOR 1 FALLING EDGE INTERRUPT           */
__sbit __at (0x8D) CP1RIF          ;  /* COMPARATOR 1 RISING EDGE INTERRUPT            */
__sbit __at (0x8E) CP1OUT          ;  /* COMPARATOR 1 OUTPUT                           */
__sbit __at (0x8F) CP1EN           ;  /* COMPARATOR 1 ENABLE                           */

/*  FLSTAT  0x88 */
__sbit __at (0x88) FLHBUSY         ;  /* FLASH BUSY                                    */

/*  P1  0x90 */
__sbit __at (0x90) P1_0            ;
__sbit __at (0x91) P1_1            ;
__sbit __at (0x92) P1_2            ;
__sbit __at (0x93) P1_3            ;
__sbit __at (0x94) P1_4            ;
__sbit __at (0x95) P1_5            ;
__sbit __at (0x96) P1_6            ;
__sbit __at (0x97) P1_7            ;

/*  SCON0  0x98 */
__sbit __at (0x98) RI0             ;  /* UART 0 RX INTERRUPT FLAG                      */
__sbit __at (0x98) RI              ;  /* UART 0 RX INTERRUPT FLAG                      */
__sbit __at (0x99) TI0             ;  /* UART 0 TX INTERRUPT FLAG                      */
__sbit __at (0x99) TI              ;  /* UART 0 TX INTERRUPT FLAG                      */
__sbit __at (0x9A) RB80            ;  /* UART 0 RX BIT 8                               */
__sbit __at (0x9B) TB80            ;  /* UART 0 TX BIT 8                               */
__sbit __at (0x9C) REN0            ;  /* UART 0 RX ENABLE                              */
__sbit __at (0x9C) REN             ;  /* UART 0 RX ENABLE                              */
__sbit __at (0x9D) SM20            ;  /* UART 0 MULTIPROCESSOR EN                      */
__sbit __at (0x9E) SM10            ;  /* UART 0 MODE 1                                 */
__sbit __at (0x9F) SM00            ;  /* UART 0 MODE 0                                 */

/*  SCON1  0x98 */
__sbit __at (0x98) RI1             ;  /* UART 1 RX INTERRUPT FLAG                      */
__sbit __at (0x99) TI1             ;  /* UART 1 TX INTERRUPT FLAG                      */
__sbit __at (0x9A) RB81            ;  /* UART 1 RX BIT 8                               */
__sbit __at (0x9B) TB81            ;  /* UART 1 TX BIT 8                               */
__sbit __at (0x9C) REN1            ;  /* UART 1 RX ENABLE                              */
__sbit __at (0x9D) MCE1            ;  /* UART 1 MCE                                    */
__sbit __at (0x9F) S1MODE          ;  /* UART 1 MODE                                   */

/*  P2  0xA0 */
__sbit __at (0xA0) P2_0            ;
__sbit __at (0xA1) P2_1            ;
__sbit __at (0xA2) P2_2            ;
__sbit __at (0xA3) P2_3            ;
__sbit __at (0xA4) P2_4            ;
__sbit __at (0xA5) P2_5            ;
__sbit __at (0xA6) P2_6            ;
__sbit __at (0xA7) P2_7            ;

/*  IE  0xA8 */
__sbit __at (0xA8) EX0             ;  /* EXTERNAL INTERRUPT 0 ENABLE                   */
__sbit __at (0xA9) ET0             ;  /* TIMER 0 INTERRUPT ENABLE                      */
__sbit __at (0xAA) EX1             ;  /* EXTERNAL INTERRUPT 1 ENABLE                   */
__sbit __at (0xAB) ET1             ;  /* TIMER 1 INTERRUPT ENABLE                      */
__sbit __at (0xAC) ES0             ;  /* UART0 INTERRUPT ENABLE                        */
__sbit __at (0xAC) ES              ;  /* UART0 INTERRUPT ENABLE                        */
__sbit __at (0xAD) ET2             ;  /* TIMER 2 INTERRUPT ENABLE                      */
__sbit __at (0xAF) EA              ;  /* GLOBAL INTERRUPT ENABLE                       */

/*  P3  0xB0 */
__sbit __at (0xB0) P3_0            ;
__sbit __at (0xB1) P3_1            ;
__sbit __at (0xB2) P3_2            ;
__sbit __at (0xB3) P3_3            ;
__sbit __at (0xB4) P3_4            ;
__sbit __at (0xB5) P3_5            ;
__sbit __at (0xB6) P3_6            ;
__sbit __at (0xB7) P3_7            ;

/*  IP  0xB8 */
__sbit __at (0xB8) PX0             ;  /* EXTERNAL INTERRUPT 0 PRIORITY                 */
__sbit __at (0xB9) PT0             ;  /* TIMER 0 PRIORITY                              */
__sbit __at (0xBA) PX1             ;  /* EXTERNAL INTERRUPT 1 PRIORITY                 */
__sbit __at (0xBB) PT1             ;  /* TIMER 1 PRIORITY                              */
__sbit __at (0xBC) PS0             ;  /* SERIAL PORT PRIORITY                          */
__sbit __at (0xBC) PS              ;  /* SERIAL PORT PRIORITY                          */
__sbit __at (0xBD) PT2             ;  /* TIMER 2 PRIORITY                              */

/* SMB0CN 0xC0 */
__sbit __at (0xC0) SMBTOE          ;  /* SMBUS 0 TIMEOUT ENABLE                        */
__sbit __at (0xC1) SMBFTE          ;  /* SMBUS 0 FREE TIMER ENABLE                     */
__sbit __at (0xC2) AA              ;  /* SMBUS 0 ASSERT/ACKNOWLEDGE FLAG               */
__sbit __at (0xC3) SI              ;  /* SMBUS 0 INTERRUPT PENDING FLAG                */
__sbit __at (0xC4) STO             ;  /* SMBUS 0 STOP FLAG                             */
__sbit __at (0xC5) STA             ;  /* SMBUS 0 START FLAG                            */
__sbit __at (0xC6) ENSMB           ;  /* SMBUS 0 ENABLE                                */
__sbit __at (0xC7) BUSY            ;  /* SMBUS 0 BUSY                                  */

/* MAC0STA 0xC0 */
__sbit __at (0xC0) MAC0N           ;  /* MAC 0 NEGATIVE FLAG                           */
__sbit __at (0xC1) MAC0SO          ;  /* MAC 0 SOFT OVERFLOW FLAG                      */
__sbit __at (0xC2) MAC0Z           ;  /* MAC 0 ZERO FLAG                               */
__sbit __at (0xC3) MAC0HO          ;  /* MAC 0 HARD OVERFLOW FLAG                      */

/*  TMR2CN  0xC8 */
__sbit __at (0xC8) CPRL2           ;  /* TIMER 2 CAPTURE SELECT                        */
__sbit __at (0xC9) CT2             ;  /* TIMER 2 COUNTER SELECT                        */
__sbit __at (0xCA) TR2             ;  /* TIMER 2 ON/OFF CONTROL                        */
__sbit __at (0xCB) EXEN2           ;  /* TIMER 2 EXTERNAL ENABLE FLAG                  */
__sbit __at (0xCE) EXF2            ;  /* TIMER 2 EXTERNAL FLAG                         */
__sbit __at (0xCF) TF2             ;  /* TIMER 2 OVERFLOW FLAG                         */

/*  TMR3CN  0xC8 */
__sbit __at (0xC8) CPRL3           ;  /* TIMER 3 CAPTURE SELECT                        */
__sbit __at (0xC9) CT3             ;  /* TIMER 3 COUNTER SELECT                        */
__sbit __at (0xCA) TR3             ;  /* TIMER 3 ON/OFF CONTROL                        */
__sbit __at (0xCB) EXEN3           ;  /* TIMER 3 EXTERNAL ENABLE FLAG                  */
__sbit __at (0xCE) EXF3            ;  /* TIMER 3 EXTERNAL FLAG                         */
__sbit __at (0xCF) TF3             ;  /* TIMER 3 OVERFLOW FLAG                         */

/*  TMR4CN  0xC8 */
__sbit __at (0xC8) CPRL4           ;  /* TIMER 4 CAPTURE SELECT                        */
__sbit __at (0xC9) CT4             ;  /* TIMER 4 COUNTER SELECT                        */
__sbit __at (0xCA) TR4             ;  /* TIMER 4 ON/OFF CONTROL                        */
__sbit __at (0xCB) EXEN4           ;  /* TIMER 4 EXTERNAL ENABLE FLAG                  */
__sbit __at (0xCE) EXF4            ;  /* TIMER 4 EXTERNAL FLAG                         */
__sbit __at (0xCF) TF4             ;  /* TIMER 4 OVERFLOW FLAG                         */

/*  P4  0xC8 */
__sbit __at (0xC8) P4_0            ;
__sbit __at (0xC9) P4_1            ;
__sbit __at (0xCA) P4_2            ;
__sbit __at (0xCB) P4_3            ;
__sbit __at (0xCC) P4_4            ;
__sbit __at (0xCD) P4_5            ;
__sbit __at (0xCE) P4_6            ;
__sbit __at (0xCF) P4_7            ;

/*  PSW  0xD0 */
__sbit __at (0xD0) P               ;  /* ACCUMULATOR PARITY FLAG                       */
__sbit __at (0xD1) F1              ;  /* USER FLAG 1                                   */
__sbit __at (0xD2) OV              ;  /* OVERFLOW FLAG                                 */
__sbit __at (0xD3) RS0             ;  /* REGISTER BANK SELECT 0                        */
__sbit __at (0xD4) RS1             ;  /* REGISTER BANK SELECT 1                        */
__sbit __at (0xD5) F0              ;  /* USER FLAG 0                                   */
__sbit __at (0xD6) AC              ;  /* AUXILIARY CARRY FLAG                          */
__sbit __at (0xD7) CY              ;  /* CARRY FLAG                                    */

/* PCA0CN D8H */
__sbit __at (0xD8) CCF0            ;  /* PCA 0 MODULE 0 INTERRUPT FLAG                 */
__sbit __at (0xD9) CCF1            ;  /* PCA 0 MODULE 1 INTERRUPT FLAG                 */
__sbit __at (0xDA) CCF2            ;  /* PCA 0 MODULE 2 INTERRUPT FLAG                 */
__sbit __at (0xDB) CCF3            ;  /* PCA 0 MODULE 3 INTERRUPT FLAG                 */
__sbit __at (0xDC) CCF4            ;  /* PCA 0 MODULE 4 INTERRUPT FLAG                 */
__sbit __at (0xDD) CCF5            ;  /* PCA 0 MODULE 5 INTERRUPT FLAG                 */
__sbit __at (0xDE) CR              ;  /* PCA 0 COUNTER RUN CONTROL BIT                 */
__sbit __at (0xDF) CF              ;  /* PCA 0 COUNTER OVERFLOW FLAG                   */

/*  P5  0xD8 */
__sbit __at (0xD8) P5_0            ;
__sbit __at (0xD9) P5_1            ;
__sbit __at (0xDA) P5_2            ;
__sbit __at (0xDB) P5_3            ;
__sbit __at (0xDC) P5_4            ;
__sbit __at (0xDD) P5_5            ;
__sbit __at (0xDE) P5_6            ;
__sbit __at (0xDF) P5_7            ;

/* ADC0CN E8H */
__sbit __at (0xE8) AD0LJST         ;  /* ADC 0 RIGHT JUSTIFY DATA BIT                  */
__sbit __at (0xE9) AD0WINT         ;  /* ADC 0 WINDOW INTERRUPT FLAG                   */
__sbit __at (0xEA) AD0CM0          ;  /* ADC 0 CONVERT START MODE BIT 0                */
__sbit __at (0xEB) AD0CM1          ;  /* ADC 0 CONVERT START MODE BIT 1                */
__sbit __at (0xEC) AD0BUSY         ;  /* ADC 0 BUSY FLAG                               */
__sbit __at (0xED) AD0INT          ;  /* ADC 0 EOC INTERRUPT FLAG                      */
__sbit __at (0xEE) AD0TM           ;  /* ADC 0 TRACK MODE                              */
__sbit __at (0xEF) AD0EN           ;  /* ADC 0 ENABLE                                  */

/* ADC2CN E8H */
__sbit __at (0xE8) AD2WINT         ;  /* ADC 2 WINDOW INTERRUPT FLAG                   */
__sbit __at (0xE9) AD2CM0          ;  /* ADC 2 CONVERT START MODE BIT 0                */
__sbit __at (0xEA) AD2CM1          ;  /* ADC 2 CONVERT START MODE BIT 1                */
__sbit __at (0xEB) AD2CM2          ;  /* ADC 2 CONVERT START MODE BIT 2                */
__sbit __at (0xEC) AD2BUSY         ;  /* ADC 2 BUSY FLAG                               */
__sbit __at (0xED) AD2INT          ;  /* ADC 2 EOC INTERRUPT FLAG                      */
__sbit __at (0xEE) AD2TM           ;  /* ADC 2 TRACK MODE                              */
__sbit __at (0xEF) AD2EN           ;  /* ADC 2 ENABLE                                  */

/*  P6  0xE8 */
__sbit __at (0xE8) P6_0            ;
__sbit __at (0xE9) P6_1            ;
__sbit __at (0xEA) P6_2            ;
__sbit __at (0xEB) P6_3            ;
__sbit __at (0xEC) P6_4            ;
__sbit __at (0xED) P6_5            ;
__sbit __at (0xEE) P6_6            ;
__sbit __at (0xEF) P6_7            ;

/* SPI0CN F8H */
__sbit __at (0xF8) SPIEN           ;  /* SPI 0 SPI ENABLE                              */
__sbit __at (0xF9) TXBMT           ;  /* SPI 0 TX BUFFER EMPTY FLAG                    */
__sbit __at (0xFA) NSSMD0          ;  /* SPI 0 SLAVE SELECT MODE 0                     */
__sbit __at (0xFB) NSSMD1          ;  /* SPI 0 SLAVE SELECT MODE 1                     */
__sbit __at (0xFC) RXOVRN          ;  /* SPI 0 RX OVERRUN FLAG                         */
__sbit __at (0xFD) MODF            ;  /* SPI 0 MODE FAULT FLAG                         */
__sbit __at (0xFE) WCOL            ;  /* SPI 0 WRITE COLLISION FLAG                    */
__sbit __at (0xFF) SPIF            ;  /* SPI 0 INTERRUPT FLAG                          */

/*  P7  0xF8 */
__sbit __at (0xF8) P7_0            ;
__sbit __at (0xF9) P7_1            ;
__sbit __at (0xFA) P7_2            ;
__sbit __at (0xFB) P7_3            ;
__sbit __at (0xFC) P7_4            ;
__sbit __at (0xFD) P7_5            ;
__sbit __at (0xFE) P7_6            ;
__sbit __at (0xFF) P7_7            ;


/* Predefined SFR Bit Masks */

#define PCON_IDLE         0x01    /* PCON                                */
#define PCON_STOP         0x02    /* PCON                                */
#define ECCF              0x01    /* PCA0CPMn                            */
#define PWM               0x02    /* PCA0CPMn                            */
#define TOG               0x04    /* PCA0CPMn                            */
#define MAT               0x08    /* PCA0CPMn                            */
#define CAPN              0x10    /* PCA0CPMn                            */
#define CAPP              0x20    /* PCA0CPMn                            */
#define ECOM              0x40    /* PCA0CPMn                            */
#define PWM16             0x80    /* PCA0CPMn                            */
#define PINRSF            0x01    /* RSTSRC                              */
#define PORSF             0x02    /* RSTSRC                              */
#define MCDRSF            0x04    /* RSTSRC                              */
#define WDTRSF            0x08    /* RSTSRC                              */
#define SWRSF             0x10    /* RSTSRC                              */
#define C0RSEF            0x20    /* RSTSRC                              */
#define CNVRSEF           0x40    /* RSTSRC                              */


/* SFR PAGE DEFINITIONS */

#define CONFIG_PAGE       0x0F     /* SYSTEM AND PORT CONFIGURATION PAGE */
#define LEGACY_PAGE       0x00     /* LEGACY SFR PAGE                    */
#define TIMER01_PAGE      0x00     /* TIMER 0 AND TIMER 1                */
#define CPT0_PAGE         0x01     /* COMPARATOR 0                       */
#define CPT1_PAGE         0x02     /* COMPARATOR 1                       */
#define UART0_PAGE        0x00     /* UART 0                             */
#define UART1_PAGE        0x01     /* UART 1                             */
#define SPI0_PAGE         0x00     /* SPI 0                              */
#define EMI0_PAGE         0x00     /* EXTERNAL MEMORY INTERFACE          */
#define ADC0_PAGE         0x00     /* ADC 0                              */
#define ADC2_PAGE         0x02     /* ADC 2                              */
#define SMB0_PAGE         0x00     /* SMBUS 0                            */
#define TMR2_PAGE         0x00     /* TIMER 2                            */
#define TMR3_PAGE         0x01     /* TIMER 3                            */
#define TMR4_PAGE         0x02     /* TIMER 4                            */
#define DAC0_PAGE         0x00     /* DAC 0                              */
#define DAC1_PAGE         0x01     /* DAC 1                              */
#define PCA0_PAGE         0x00     /* PCA 0                              */
#define PLL0_PAGE         0x0F     /* PLL 0                              */
#define MAC0_PAGE         0x03     /* MULTIPLY / ACCUMULATE 0            */

#endif
/*-------------------------------------------------------------------------
   reg764 - register Declarations for 87C764

   Copyright (C) 2005, Robert Lacoste <robert_lacoste AT yahoo.fr>
     based upon reg51.h written by Sandeep Dutta
     Registers are taken from the Phillips Semiconductor

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef REGC764_H
#define REGC764_H

/*  Special Function Registers  */

__sfr __at 0x80 P0    ;   // Port 0
__sfr __at 0x81 SP    ;   // Stack Pointer
__sfr __at 0x82 DPL   ;   // Data Pointer Low
__sfr __at 0x83 DPH   ;   // Data Pointer High
__sfr __at 0x84 P0M1  ;   // Port 0 output mode 1
__sfr __at 0x85 P0M2  ;   // Port 0 output mode 2
__sfr __at 0x86 KBI   ;   // Keyboard interrupt
__sfr __at 0x87 PCON  ;   // Power Control
__sfr __at 0x88 TCON  ;   // Timer Control
__sfr __at 0x89 TMOD  ;   // Timer Mode
__sfr __at 0x8A TL0   ;   // Timer Low 0
__sfr __at 0x8B TL1   ;   // Timer Low 1
__sfr __at 0x8C TH0   ;   // Timer High 0
__sfr __at 0x8D TH1   ;   // Timer High 1

__sfr __at 0x90 P1    ;   // Port 1
__sfr __at 0x91 P1M1  ;   // Port 1 output mode 1
__sfr __at 0x92 P1M2  ;   // Port 1 output mode 2
__sfr __at 0x95 DIVM  ;   // CPU clock divide by N control
__sfr __at 0x98 SCON  ;   // Serial Control
__sfr __at 0x99 SBUF  ;   // Serial Data Buffer

__sfr __at 0xA0 P2    ;   // Port 2
__sfr __at 0xA2 AUXR1 ;   // Auxilliary 1 (not available on 80C51FA/87C51Fx)
__sfr __at 0xA4 P2M1  ;   // Port 2 output mode 1
__sfr __at 0xA5 P2M2  ;   // Port 2 output mode 2
__sfr __at 0xA6 WDRST ;   // Watchdog reset register
__sfr __at 0xA7 WDCON ;   // Watchdog control register
__sfr __at 0xA8 IEN0  ;   // Interrupt Enable 0
__sfr __at 0xA9 SADDR ;   // Serial slave Address
__sfr __at 0xAC CMP1  ;   // Comparator 1 control register
__sfr __at 0xAD CMP2  ;   // Comparator 2 control register

__sfr __at 0xB7 IP0H  ;   // Interrupt Priority 0 High 
__sfr __at 0xB8 IP0   ;   // Interrupt Priority 0
__sfr __at 0xB9 SADEN ;   // Serial slave Address Mask

__sfr __at 0xC8 I2CFG ;   // I2C configuration register

__sfr __at 0xD0 PSW   ;   // Program Status Word
__sfr __at 0xD8 I2CON ;   // I2C control register
__sfr __at 0xD9 I2DAT ;   // I2C data register

__sfr __at 0xE0 ACC   ;   // Accumulator
__sfr __at 0xE8 IEN1  ;   // Interrupt enable 1

__sfr __at 0xF0 B     ;   // B Register
__sfr __at 0xF6 PT0AD ;   // Port 0 digital input disable
__sfr __at 0xF7 IP1H  ;   // Interrupt Priority 1 High 
__sfr __at 0xF8 IP1   ;   // Interrupt Priority 1


/*  Bit Addressable Registers  */

/*  P0    */
__sbit __at 0x80 P0_0 ; // Also CMP2
__sbit __at 0x81 P0_1 ; // Also CIN2B
__sbit __at 0x82 P0_2 ; // Also CIN2A
__sbit __at 0x83 P0_3 ; // Also CIN1B
__sbit __at 0x84 P0_4 ; // Also CIN1A
__sbit __at 0x85 P0_5 ; // Also CMPREF
__sbit __at 0x86 P0_6 ; // Also CMP1
__sbit __at 0x87 P0_7 ; // Also T1

/*  TCON  */
__sbit __at 0x88 IT0  ; // External Interrupt 0 Type
__sbit __at 0x89 IE0  ; // External Interrupt 0 Edge Flag
__sbit __at 0x8A IT1  ; // External Interrupt 1 Type
__sbit __at 0x8B IE1  ; // External Interrupt 1 Edge Flag
__sbit __at 0x8C TR0  ; // Timer 0 Run Control
__sbit __at 0x8D TF0  ; // Timer 0 Overflow Flag
__sbit __at 0x8E TR1  ; // Timer 1 Run Control
__sbit __at 0x8F TF1  ; // Timer 1 Overflow Flag

/*  P1 */
__sbit __at 0x90 P1_0 ; // Also TxD
__sbit __at 0x91 P1_1 ; // Also RxD
__sbit __at 0x92 P1_2 ; // Also T0
__sbit __at 0x93 P1_3 ; // Also INT0
__sbit __at 0x94 P1_4 ; // Also INT1
__sbit __at 0x95 P1_5 ; // Also RST
__sbit __at 0x96 P1_6 ;
__sbit __at 0x97 P1_7 ;

/*  SCON  */
__sbit __at 0x98 RI   ; // Receive Interrupt Flag
__sbit __at 0x99 TI   ; // Transmit Interrupt Flag
__sbit __at 0x9A RB8  ; // Receive Bit 8
__sbit __at 0x9B TB8  ; // Transmit Bit 8
__sbit __at 0x9C REN  ; // Receiver Enable
__sbit __at 0x9D SM2  ; // Serial Mode Control Bit 2
__sbit __at 0x9E SM1  ; // Serial Mode Control Bit 1
__sbit __at 0x9F SM0  ; // Serial Mode Control Bit 0

/*  P2    */
__sbit __at 0xA0 P2_0 ; // Also X2
__sbit __at 0xA1 P2_1 ; // Also X1

/*  IEN0 */
__sbit __at 0xA8 EX0  ; // External Interrupt 0 Enable
__sbit __at 0xA9 ET0  ; // Timer 0 Interrupt Enable
__sbit __at 0xAA EX1  ; // External Interrupt 1 Enable
__sbit __at 0xAB ET1  ; // Timer 1 Interrupt Enable
__sbit __at 0xAC ES   ; // Serial Port Interrupt Enable
__sbit __at 0xAD EBO  ; // Brownout Interrupt Enable
__sbit __at 0xAE EWD  ; // Watchdog Interrupt Enable
__sbit __at 0xAF EA   ; // Global Interrupt Enable

/*  IP0   */ 
__sbit __at 0xB8 PX0  ; // External Interrupt 0 Priority
__sbit __at 0xB9 PT0  ; // Timer 0 Interrupt Priority
__sbit __at 0xBA PX1  ; // External Interrupt 1 Priority
__sbit __at 0xBB PT1  ; // Timer 1 Interrupt Priority
__sbit __at 0xBC PS   ; // Serial Port Interrupt Priority
__sbit __at 0xBD PBO  ; // Brownout Interrupt Priority
__sbit __at 0xBE PWD  ; // Watchdog Interrupt Priority

/*  I2CFG */
__sbit __at 0xC8 CT0   ; // Clock Time Select 0
__sbit __at 0xC9 CT1   ; // Clock Time Select 1
__sbit __at 0xCC TIRUN ; // Timer I Run Enable
__sbit __at 0xCD CLRTI ; // Clear Timer I
__sbit __at 0xCE MASTRQ; // Master Request
__sbit __at 0xCF SLAVEN; // Slave Enable

/*  PSW   */
__sbit __at 0xD0 P    ; // Accumulator Parity Flag
__sbit __at 0xD1 F1   ; // Flag 1
__sbit __at 0xD2 OV   ; // Overflow Flag
__sbit __at 0xD3 RS0  ; // Register Bank Select 0
__sbit __at 0xD4 RS1  ; // Register Bank Select 1
__sbit __at 0xD5 F0   ; // Flag 0
__sbit __at 0xD6 AC   ; // Auxiliary Carry Flag
__sbit __at 0xD7 CY   ; // Carry Flag

/*  I2CON */
__sbit __at 0xD8 XSTP ;
__sbit __at 0xD9 MASTER;// Master Status
__sbit __at 0xDA STP  ; // Stop Detect Flag
__sbit __at 0xDB STR  ; // Start Detect Flag
__sbit __at 0xDC ARL  ; // Arbitration Loss Flag
__sbit __at 0xDD DRDY ; // Data Ready Flag
__sbit __at 0xDE ATN  ; // Attention: I2C Interrupt Flag
__sbit __at 0xDF RDAT ; // I2C Read Data

/*  ACC   */
__sbit __at 0xE0 ACC_0;
__sbit __at 0xE1 ACC_1;
__sbit __at 0xE2 ACC_2;
__sbit __at 0xE3 ACC_3;
__sbit __at 0xE4 ACC_4;
__sbit __at 0xE5 ACC_5;
__sbit __at 0xE6 ACC_6;
__sbit __at 0xE7 ACC_7;

/*  IEN1  */
__sbit __at 0xE8 EI2  ; // I2C Interrupt Enable
__sbit __at 0xE9 EKB  ; // Keyboard Interrupt Enable
__sbit __at 0xEA EC2  ; // Comparator 2 Interrupt Enable
__sbit __at 0xED EC1  ; // Comparator 1 Interrupt Enable
__sbit __at 0xEF ETI  ; // Timer I Interrupt Enable

/*  B     */
__sbit __at 0xF0 B_0;
__sbit __at 0xF1 B_1;
__sbit __at 0xF2 B_2;
__sbit __at 0xF3 B_3;
__sbit __at 0xF4 B_4;
__sbit __at 0xF5 B_5;
__sbit __at 0xF6 B_6;
__sbit __at 0xF7 B_7;

/*  IP1  */ 
__sbit __at 0xF8 PI2; // I2C Interrupt Priority
__sbit __at 0xF9 PKB; // Keyboard Interrupt Priority
__sbit __at 0xFA PC2; // Comparator 2 Interrupt Priority
__sbit __at 0xFD PC1; // Comparator 1 Interrupt Priority
__sbit __at 0xFF PTI; // Timer I Interrupt Priority

/* Bitmasks for SFRs */

/* AUXR1 bits  */
#define DPS     0x01
#define SRST    0x08
#define LPEP    0x10
#define BOI     0x20
#define BOD     0x40
#define KBF     0x80

/* CMP1 bits   */
#define CMF1    0x01
#define CO1     0x02
#define OE1     0x04
#define CN1     0x08
#define CP1     0x10
#define CE1     0x20

/* CMP2 bits   */
#define CMF2    0x01
#define CO2     0x02
#define OE2     0x04
#define CN2     0x08
#define CP2     0x10
#define CE2     0x20

/* I2DAT bits  */
#define RDAT    0x80
#define XDAT    0x80

/* IP1H bits   */
#define PI2H    0x01
#define PKBH    0x02
#define PC2H    0x04
#define PC1H    0x20
#define PTIH    0x80

/* PCON bits   */
#define IDL     0x01
#define PD      0x02
#define GF0     0x04
#define GF1     0x08
#define POF     0x10
#define BOF     0x20
#define SMOD0   0x40
#define SMOD1   0x80

/* P2M1 bits   */
#define ENT0    0x04
#define ENT1    0x08
#define ENTCLK  0x10
#define P0S     0x20
#define P1S     0x40
#define P2S     0x80

/* TMOD bits */
#define M0_0    0x01
#define M1_0    0x02
#define C_T0    0x04
#define GATE0   0x08
#define M0_1    0x10
#define M1_1    0x20
#define C_T1    0x40
#define GATE1   0x80

/* WDCON bits */
#define WDS0    0x01
#define WDS1    0x02
#define WDS2    0x04
#define WDCLK   0x08
#define WDRUN   0x10
#define WDOVF   0x20


/*  Masks for I2CFG bits */
#define BTIR    0x10       // Mask for TIRUN bit.
#define BMRQ    0x40       // Mask for MASTRQ bit.
#define BSLV    0x80       // Mask for SLAVEN bit.


/* Masks for I2CON bits */
#define BCXA    0x80       // Mask for CXA bit.
#define BIDLE   0x40       // Mask for IDLE bit.
#define BCDR    0x20       // Mask for CDR bit.
#define BCARL   0x10       // Mask for CARL bit.
#define BCSTR   0x08       // Mask for CSTR bit.
#define BCSTP   0x04       // Mask for CSTP bit.
#define BXSTR   0x02       // Mask for XSTR bit.
#define BXSTP   0x01       // Mask for XSTP bit.


#endif
/*-------------------------------------------------------------------------
   Register Declarations for Chipcon CC1110

   Written By -  Pravin Angolkar (February 2008)
   (Based on CC1110 PRELIMINARY Data Sheet (rev. F) )

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

   In other words, you are welcome to use, share and improve this program.
   You are forbidden to forbid anyone else to use, share and improve
   what you give them.   Help stamp out software-hoarding!
-------------------------------------------------------------------------*/

#ifndef REG_CC1110_H
#define REG_CC1110_H

#include<compiler.h>
/* ------------------------------------------------------------------------------------------------
 *                                        Interrupt Vectors
 * ------------------------------------------------------------------------------------------------
 */
#define  RFTXRX_VECTOR  0    /*  RF TX done / RX ready                       */
#define  ADC_VECTOR     1    /*  ADC End of Conversion                       */
#define  URX0_VECTOR    2    /*  USART0 RX Complete                          */
#define  URX1_VECTOR    3    /*  USART1 RX Complete                          */
#define  ENC_VECTOR     4    /*  AES Encryption/Decryption Complete          */
#define  ST_VECTOR      5    /*  Sleep Timer Compare                         */
#define  P2INT_VECTOR   6    /*  Port 2 Inputs                               */
#define  UTX0_VECTOR    7    /*  USART0 TX Complete                          */
#define  DMA_VECTOR     8    /*  DMA Transfer Complete                       */
#define  T1_VECTOR      9    /*  Timer 1 (16-bit) Capture/Compare/Overflow   */
#define  T2_VECTOR      10   /*  Timer 2 (MAC Timer) Overflow                */
#define  T3_VECTOR      11   /*  Timer 3 (8-bit) Capture/Compare/Overflow    */
#define  T4_VECTOR      12   /*  Timer 4 (8-bit) Capture/Compare/Overflow    */
#define  P0INT_VECTOR   13   /*  Port 0 Inputs                               */
#define  UTX1_VECTOR    14   /*  USART1 TX Complete                          */
#define  P1INT_VECTOR   15   /*  Port 1 Inputs                               */
#define  RF_VECTOR      16   /*  RF General Interrupts                       */
#define  WDT_VECTOR     17   /*  Watchdog Overflow in Timer Mode             */

SFR(P0,       0x80); // Port 0
   SBIT(P0_0,     0x80, 0); // Port 0 bit 0
   SBIT(P0_1,     0x80, 1); // Port 0 bit 1
   SBIT(P0_2,     0x80, 2); // Port 0 bit 2
   SBIT(P0_3,     0x80, 3); // Port 0 bit 3
   SBIT(P0_4,     0x80, 4); // Port 0 bit 4
   SBIT(P0_5,     0x80, 5); // Port 0 bit 5
   SBIT(P0_6,     0x80, 6); // Port 0 bit 6
   SBIT(P0_7,     0x80, 7); // Port 0 bit 7

SFR(SP,       0x81); // Stack Pointer
SFR(DPL0,     0x82); // Data Pointer 0 Low Byte
SFR(DPH0,     0x83); // Data Pointer 0 High Byte
SFR(DPL1,     0x84); // Data Pointer 1 Low Byte
SFR(DPH1,     0x85); // Data Pointer 1 High Byte
SFR(U0CSR,    0x86); // USART 0 Control and Status
SFR(PCON,     0x87); // Power Mode Control

SFR(TCON,     0x88); // Interrupt Flags
   SBIT(IT0,      0x88, 0); // reserved (must always be set to 1)
   SBIT(RFTXRXIF, 0x88, 1); // RFERR  RF TX/RX FIFO interrupt flag
   SBIT(IT1,      0x88, 2); // reserved (must always be set to 1)
   SBIT(URX0IF,   0x88, 3); // USART0 RX Interrupt Flag
   SBIT(ADCIF,    0x88, 5); // ADC Interrupt Flag
   SBIT(URX1IF,   0x88, 7); // USART1 RX Interrupt Flag

SFR(P0IFG,    0x89); // Port 0 Interrupt Status Flag
SFR(P1IFG,    0x8A); // Port 1 Interrupt Status Flag
SFR(P2IFG,    0x8B); // Port 2 Interrupt Status Flag
SFR(PICTL,    0x8C); // Port Interrupt Control
SFR(P1IEN,    0x8D); // Port 1 Interrupt Mask
SFR(_SFR8E,   0x8E); // not used
SFR(P0INP,    0x8F); // Port 0 Input Mode

SFR(P1,       0x90); // Port 1
   SBIT(P1_0,     0x90, 0); // Port 1 bit 0
   SBIT(P1_1,     0x90, 1); // Port 1 bit 1
   SBIT(P1_2,     0x90, 2); // Port 1 bit 2
   SBIT(P1_3,     0x90, 3); // Port 1 bit 3
   SBIT(P1_4,     0x90, 4); // Port 1 bit 4
   SBIT(P1_5,     0x90, 5); // Port 1 bit 5
   SBIT(P1_6,     0x90, 6); // Port 1 bit 6
   SBIT(P1_7,     0x90, 7); // Port 1 bit 7

SFR(RFIM,     0x91); // RF Interrupt Mask
SFR(DPS,      0x92); // Data Pointer Select
SFR(MPAGE,    0x93); // Memory Page Select
SFR(_XPAGE,   0x93); // Memory Page Select under the name SDCC needs it
SFR(_SFR94,   0x94); // not used
SFR(_SFR95,   0x95); // not used
SFR(_SFR96,   0x96); // not used
SFR(_SFR97,   0x97); // not used

SFR(S0CON,    0x98); // Interrupt Flags 2
   SBIT(ENCIF_0,  0x98, 0); // AES Interrupt Flag 0
   SBIT(ENCIF_1,  0x98, 1); // AES Interrupt Flag 1

SFR(_SFR99,   0x99); // not used
SFR(IEN2,     0x9A); // Interrupt Enable 2
SFR(S1CON,    0x9B); // CPU Interrupt Flag 3
SFR(T2CT,     0x9C); // Timer 2 Count
SFR(T2PR,     0x9D); // Timer 2 Prescaler
SFR(T2CTL,    0x9E); // Timer 2 Control
SFR(_SFR9F,   0x9F); // not used

SFR(P2,       0xA0); // Port 2
   SBIT(P2_0,     0xA0, 0); // Port 2 bit 0
   SBIT(P2_1,     0xA0, 1); // Port 2 bit 1
   SBIT(P2_2,     0xA0, 2); // Port 2 bit 2
   SBIT(P2_3,     0xA0, 3); // Port 2 bit 3
   SBIT(P2_4,     0xA0, 4); // Port 2 bit 4
   SBIT(P2_5,     0xA0, 5); // Port 2 bit 5
   SBIT(P2_6,     0xA0, 6); // Port 2 bit 6
   SBIT(P2_7,     0xA0, 7); // Port 2 bit 7

SFR(WORIRQ,   0xA1); // Sleep Timer Interrupt Control
SFR(WORCTRL,  0xA2); // Sleep Timer Control
SFR(WOREVT0,  0xA3); // Sleep Timer Event0 Timeout Low
SFR(WOREVT1,  0xA4); // Sleep Timer Event0 Timeout High
SFR(WORTIME0, 0xA5); // Sleep Timer Low Byte
SFR(WORTIME1, 0xA6); // Sleep Timer High Byte
SFR(_SFRA7,   0xA7); // not used

SFR(IEN0,     0xA8); // Interrupt Enable 0
   SBIT(RFTXRXIE, 0xA8, 0); // RF TX/RX FIFO interrupt enable
   SBIT(ADCIE,    0xA8, 1); // ADC Interrupt Enable
   SBIT(URX0IE,   0xA8, 2); // USART0 RX Interrupt Enable
   SBIT(URX1IE,   0xA8, 3); // USART1 RX Interrupt Enable
   SBIT(ENCIE,    0xA8, 4); // AES Encryption/Decryption Interrupt Enable
   SBIT(STIE,     0xA8, 5); // Sleep Timer Interrupt Enable
   SBIT(EA,       0xA8, 7); // Global Interrupt Enable

SFR(IP0,      0xA9); // Interrupt Priority 0
SFR(_SFRAA,   0xAA); // not used
SFR(FWT,      0xAB); // Flash Write Timing
SFR(FADDRL,   0xAC); // Flash Address Low Byte
SFR(FADDRH,   0xAD); // Flash Address High Byte
SFR(FCTL,     0xAE); // Flash Control
SFR(FWDATA,   0xAF); // Flash Write Data

SFR(_SFRB0,   0xB0); // not used
SFR(ENCDI,    0xB1); // Encryption Input Data
SFR(ENCDO,    0xB2); // Encryption Output Data
SFR(ENCCS,    0xB3); // Encryption Control and Status
SFR(ADCCON1,  0xB4); // ADC Control 1
SFR(ADCCON2,  0xB5); // ADC Control 2
SFR(ADCCON3,  0xB6); // ADC Control 3
SFR(_SFRB7,   0xB7); // not used

SFR(IEN1,     0xB8); // Interrupt Enable 1
   SBIT(DMAIE,    0xB8, 0); // DMA Transfer Interrupt Enable
   SBIT(T1IE,     0xB8, 1); // Timer 1 Interrupt Enable
   SBIT(T2IE,     0xB8, 2); // Timer 2 Interrupt Enable
   SBIT(T3IE,     0xB8, 3); // Timer 3 Interrupt Enable
   SBIT(T4IE,     0xB8, 4); // Timer 4 Interrupt Enable
   SBIT(P0IE,     0xB8, 5); // Port 0 Interrupt Enable

SFR(IP1,      0xB9); // Interrupt Priority 1
SFR(ADCL,     0xBA); // ADC Data Low
SFR(ADCH,     0xBB); // ADC Data High
SFR(RNDL,     0xBC); // Random Number Generator Data Low Byte
SFR(RNDH,     0xBD); // Random Number Generator Data High Byte
SFR(SLEEP,    0xBE); // Sleep Mode Control
SFR(_SFRBF,   0xBF); // not used

SFR(IRCON,    0xC0); // Interrupt Flags 4
   SBIT(DMAIF,    0xC0, 0); // DMA Complete Interrupt Flag
   SBIT(T1IF,     0xC0, 1); // Timer 1 Interrupt Flag
   SBIT(T2IF,     0xC0, 2); // Timer 2 Interrupt Flag
   SBIT(T3IF,     0xC0, 3); // Timer 3 Interrupt Flag
   SBIT(T4IF,     0xC0, 4); // Timer 4 Interrupt Flag
   SBIT(P0IF,     0xC0, 5); // Port 0 Interrupt Flag
   SBIT(STIF,     0xC0, 7); // Sleep Timer Interrupt Flag

SFR(U0DBUF,   0xC1); // USART 0 Receive/Transmit Data Buffer
SFR(U0BAUD,   0xC2); // USART 0 Baud Rate Control
SFR(_SFRC3,   0xC3); // not in use
SFR(U0UCR,    0xC4); // USART 0 UART Control
SFR(U0GCR,    0xC5); // USART 0 Generic Control
SFR(CLKCON,   0xC6); // Clock Control
SFR(MEMCTR,   0xC7); // Memory Arbiter Control

SFR(_SFRC8,   0xC8); // not in use
SFR(WDCTL,    0xC9); // Watchdog Timer Control
SFR(T3CNT,    0xCA); // Timer 3 Counter
SFR(T3CTL,    0xCB); // Timer 3 Control
SFR(T3CCTL0,  0xCC); // Timer 3 Channel 0 Capture/Compare Control
SFR(T3CC0,    0xCD); // Timer 3 Channel 0 Capture/Compare Value
SFR(T3CCTL1,  0xCE); // Timer 3 Channel 1 Capture/Compare Control
SFR(T3CC1,    0xCF); // Timer 3 Channel 1 Capture/Compare Value

SFR(PSW,      0xD0); // Program Status Word
   SBIT(P,        0xD0, 0); // Parity Flag
   SBIT(F1,       0xD0, 1); // User-Defined Flag
   SBIT(OV,       0xD0, 2); // Overflow Flag
   SBIT(RS0,      0xD0, 3); // Register Bank Select 0
   SBIT(RS1,      0xD0, 4); // Register Bank Select 1
   SBIT(F0,       0xD0, 5); // User-Defined Flag
   SBIT(AC,       0xD0, 6); // Auxiliary Carry Flag
   SBIT(CY,       0xD0, 7); // Carry Flag

SFR(DMAIRQ,   0xD1); // DMA Interrupt Flag
SFR(DMA1CFGL, 0xD2); // DMA Channel 1-4 Configuration Address Low Byte
SFR(DMA1CFGH, 0xD3); // DMA Channel 1-4 Configuration Address High Byte
SFR(DMA0CFGL, 0xD4); // DMA Channel 0 Configuration Address Low Byte
SFR(DMA0CFGH, 0xD5); // DMA Channel 0 Configuration Address High Byte
SFR(DMAARM,   0xD6); // DMA Channel Arm
SFR(DMAREQ,   0xD7); // DMA Channel Start Request and Status

SFR(TIMIF,    0xD8); // Timers 1/3/4 Interrupt Mask/Flag
   SBIT(T3OVFIF,  0xD8, 0); // Timer 3 overflow interrupt flag 0:no pending 1:pending
   SBIT(T3CH0IF,  0xD8, 1); // Timer 3 channel 0 interrupt flag 0:no pending 1:pending
   SBIT(T3CH1IF,  0xD8, 2); // Timer 3 channel 1 interrupt flag 0:no pending 1:pending
   SBIT(T4OVFIF,  0xD8, 3); // Timer 4 overflow interrupt flag 0:no pending 1:pending
   SBIT(T4CH0IF,  0xD8, 4); // Timer 4 channel 0 interrupt flag 0:no pending 1:pending
   SBIT(T4CH1IF,  0xD8, 5); // Timer 4 channel 1 interrupt flag 0:no pending 1:pending
   SBIT(OVFIM,    0xD8, 6); // Timer 1 overflow interrupt mask

SFR(RFD,      0xD9); // RF Data
SFR(T1CC0L,   0xDA); // Timer 1 Channel 0 Capture/Compare Value Low Byte
SFR(T1CC0H,   0xDB); // Timer 1 Channel 0 Capture/Compare Value High Byte
SFR(T1CC1L,   0xDC); // Timer 1 Channel 1 Capture/Compare Value Low Byte
SFR(T1CC1H,   0xDD); // Timer 1 Channel 1 Capture/Compare Value High Byte
SFR(T1CC2L,   0xDE); // Timer 1 Channel 2 Capture/Compare Value Low Byte
SFR(T1CC2H,   0xDF); // Timer 1 Channel 2 Capture/Compare Value High Byte

SFR(ACC,      0xE0); // Accumulator
   SBIT(ACC_0,    0xE0, 0); // Accumulator bit 0
   SBIT(ACC_1,    0xE0, 1); // Accumulator bit 1
   SBIT(ACC_2,    0xE0, 2); // Accumulator bit 2
   SBIT(ACC_3,    0xE0, 3); // Accumulator bit 3
   SBIT(ACC_4,    0xE0, 4); // Accumulator bit 4
   SBIT(ACC_5,    0xE0, 5); // Accumulator bit 5
   SBIT(ACC_6,    0xE0, 6); // Accumulator bit 6
   SBIT(ACC_7,    0xE0, 7); // Accumulator bit 7

SFR(RFST,     0xE1); // RF Strobe Commands
SFR(T1CNTL,   0xE2); // Timer 1 Counter Low
SFR(T1CNTH,   0xE3); // Timer 1 Counter High
SFR(T1CTL,    0xE4); // Timer 1 Control and Status
SFR(T1CCTL0,  0xE5); // Timer 1 Channel 0 Capture/Compare Control
SFR(T1CCTL1,  0xE6); // Timer 1 Channel 1 Capture/Compare Control
SFR(T1CCTL2,  0xE7); // Timer 1 Channel 2 Capture/Compare Control

SFR(IRCON2,   0xE8); // Interrupt Flags 5
   SBIT(P2IF,     0xE8, 0); // Port 2 Interrupt Flag
   SBIT(UTX0IF,   0xE8, 1); // USART0 TX Interrupt Flag
   SBIT(UTX1IF,   0xE8, 2); // USART1 TX Interrupt Flag
   SBIT(P1IF,     0xE8, 3); // Port 1 Interrupt Flag
   SBIT(WDTIF,    0xE8, 4); // Watchdog Timer Interrupt Flag

SFR(RFIF,     0xE9); // RF Interrupt Flags
SFR(T4CNT,    0xEA); // Timer 4 Counter
SFR(T4CTL,    0xEB); // Timer 4 Control
SFR(T4CCTL0,  0xEC); // Timer 4 Channel 0 Capture/Compare Control
SFR(T4CC0,    0xED); // Timer 4 Channel 0 Capture/Compare Value
SFR(T4CCTL1,  0xEE); // Timer 4 Channel 1 Capture/Compare Control
SFR(T4CC1,    0xEF); // Timer 4 Channel 1 Capture/Compare Value

SFR(B,        0xF0); // B Register
   SBIT(B_0,      0xF0, 0); // Register B bit 0
   SBIT(B_1,      0xF0, 1); // Register B bit 1
   SBIT(B_2,      0xF0, 2); // Register B bit 2
   SBIT(B_3,      0xF0, 3); // Register B bit 3
   SBIT(B_4,      0xF0, 4); // Register B bit 4
   SBIT(B_5,      0xF0, 5); // Register B bit 5
   SBIT(B_6,      0xF0, 6); // Register B bit 6
   SBIT(B_7,      0xF0, 7); // Register B bit 7

SFR(PERCFG,   0xF1); // Peripheral Control
SFR(ADCCFG,   0xF2); // ADC Input Configuration
SFR(P0SEL,    0xF3); // Port 0 Function Select
SFR(P1SEL,    0xF4); // Port 1 Function Select
SFR(P2SEL,    0xF5); // Port 2 Function Select
SFR(P1INP,    0xF6); // Port 1 Input Mode
SFR(P2INP,    0xF7); // Port 2 Input Mode

SFR(U1CSR,    0xF8); // USART 1 Control and Status
   SBIT(ACTIVE,   0xF8, 0); // USART transmit/receive active status 0:idle 1:busy
   SBIT(TX_BYTE,  0xF8, 1); // Transmit byte status 0:Byte not transmitted 1:Last byte transmitted
   SBIT(RX_BYTE,  0xF8, 2); // Receive byte status 0:No byte received 1:Received byte ready
   SBIT(ERR,      0xF8, 3); // UART parity error status 0:No error 1:parity error
   SBIT(FE,       0xF8, 4); // UART framing error status 0:No error 1:incorrect stop bit level
   SBIT(SLAVE,    0xF8, 5); // SPI master or slave mode select 0:master 1:slave
   SBIT(RE,       0xF8, 6); // UART receiver enable 0:disabled 1:enabled
   SBIT(MODE,     0xF8, 7); // USART mode select 0:SPI 1:UART

SFR(U1DBUF,   0xF9); // USART 1 Receive/Transmit Data Buffer
SFR(U1BAUD,   0xFA); // USART 1 Baud Rate Control
SFR(U1UCR,    0xFB); // USART 1 UART Control
SFR(U1GCR,    0xFC); // USART 1 Generic Control
SFR(P0DIR,    0xFD); // Port 0 Direction
SFR(P1DIR,    0xFE); // Port 1 Direction
SFR(P2DIR,    0xFF); // Port 2 Direction

/* ------------------------------------------------------------------------------------------------
 *                            Xdata Radio Registers
 * ------------------------------------------------------------------------------------------------
 */

SFRX(MDMCTRL0H,   0xDF02);

SFRX(SYNC1,       0xDF00);  /*  Sync word, high byte                                */
SFRX(SYNC0,       0xDF01);  /*  Sync word, low byte                                 */
SFRX(PKTLEN,      0xDF02);  /*  Packet length                                       */
SFRX(PKTCTRL1,    0xDF03);  /*  Packet automation control                           */
SFRX(PKTCTRL0,    0xDF04);  /*  Packet automation control                           */
SFRX(ADDR,        0xDF05);  /*  Device address                                      */
SFRX(CHANNR,      0xDF06);  /*  Channel number                                      */
SFRX(FSCTRL1,     0xDF07);  /*  Frequency synthesizer control                       */
SFRX(FSCTRL0,     0xDF08);  /*  Frequency synthesizer control                       */
SFRX(FREQ2,       0xDF09);  /*  Frequency control word, high byte                   */
SFRX(FREQ1,       0xDF0A);  /*  Frequency control word, middle byte                 */
SFRX(FREQ0,       0xDF0B);  /*  Frequency control word, low byte                    */
SFRX(MDMCFG4,     0xDF0C);  /*  Modem configuration                                 */
SFRX(MDMCFG3,     0xDF0D);  /*  Modem configuration                                 */
SFRX(MDMCFG2,     0xDF0E);  /*  Modem configuration                                 */
SFRX(MDMCFG1,     0xDF0F);  /*  Modem configuration                                 */
SFRX(MDMCFG0,     0xDF10);  /*  Modem configuration                                 */
SFRX(DEVIATN,     0xDF11);  /*  Modem deviation setting                             */
SFRX(MCSM2,       0xDF12);  /*  Main Radio Control State Machine configuration      */
SFRX(MCSM1,       0xDF13);  /*  Main Radio Control State Machine configuration      */
SFRX(MCSM0,       0xDF14);  /*  Main Radio Control State Machine configuration      */
SFRX(FOCCFG,      0xDF15);  /*  Frequency Offset Compensation configuration         */
SFRX(BSCFG,       0xDF16);  /*  Bit Synchronization configuration                   */
SFRX(AGCCTRL2,    0xDF17);  /*  AGC control                                         */
SFRX(AGCCTRL1,    0xDF18);  /*  AGC control                                         */
SFRX(AGCCTRL0,    0xDF19);  /*  AGC control                                         */
SFRX(FREND1,      0xDF1A);  /*  Front end RX configuration                          */
SFRX(FREND0,      0xDF1B);  /*  Front end TX configuration                          */
SFRX(FSCAL3,      0xDF1C);  /*  Frequency synthesizer calibration                   */
SFRX(FSCAL2,      0xDF1D);  /*  Frequency synthesizer calibration                   */
SFRX(FSCAL1,      0xDF1E);  /*  Frequency synthesizer calibration                   */
SFRX(FSCAL0,      0xDF1F);  /*  Frequency synthesizer calibration                   */
SFRX(_XREGDF20,   0xDF20);  /*  reserved                                            */
SFRX(_XREGDF21,   0xDF21);  /*  reserved                                            */
SFRX(_XREGDF22,   0xDF22);  /*  reserved                                            */
SFRX(TEST2,       0xDF23);  /*  Various test settings                               */
SFRX(TEST1,       0xDF24);  /*  Various test settings                               */
SFRX(TEST0,       0xDF25);  /*  Various test settings                               */
SFRX(_XREGDF26,   0xDF26);  /*  reserved                                            */
SFRX(PA_TABLE7,   0xDF27);  /*  PA power setting 7                                  */
SFRX(PA_TABLE6,   0xDF28);  /*  PA power setting 6                                  */
SFRX(PA_TABLE5,   0xDF29);  /*  PA power setting 5                                  */
SFRX(PA_TABLE4,   0xDF2A);  /*  PA power setting 4                                  */
SFRX(PA_TABLE3,   0xDF2B);  /*  PA power setting 3                                  */
SFRX(PA_TABLE2,   0xDF2C);  /*  PA power setting 2                                  */
SFRX(PA_TABLE1,   0xDF2D);  /*  PA power setting 1                                  */
SFRX(PA_TABLE0,   0xDF2E);  /*  PA power setting 0                                  */
SFRX(IOCFG2,      0xDF2F);  /*  Radio Test Signal Configuration (P1_7)              */
SFRX(IOCFG1,      0xDF30);  /*  Radio Test Signal Configuration (P1_6)              */
SFRX(IOCFG0,      0xDF31);  /*  Radio Test Signal Configuration (P1_5)              */
SFRX(_XREGDF32,   0xDF32);  /*  reserved                                            */
SFRX(_XREGDF33,   0xDF33);  /*  reserved                                            */
SFRX(_XREGDF34,   0xDF34);  /*  reserved                                            */
SFRX(_XREGDF35,   0xDF35);  /*  reserved                                            */
SFRX(PARTNUM,     0xDF36);  /*  Chip ID [15:8]                                      */
SFRX(VERSION,     0xDF37);  /*  Chip ID [7:0]                                       */
SFRX(FREQEST,     0xDF38);  /*  Frequency Offset Estimate                           */
SFRX(LQI,         0xDF39);  /*  Link Quality Indicator                              */
SFRX(RSSI,        0xDF3A);  /*  Received Signal Strength Indication                 */
SFRX(MARCSTATE,   0xDF3B);  /*  Main Radio Control State                            */
SFRX(PKTSTATUS,   0xDF3C);  /*  Packet status                                       */
SFRX(VCO_VC_DAC,  0xDF3D);  /*  PLL calibration current                             */

/* ------------------------------------------------------------------------------------------------
 *                             Xdata I2S Registers
 * ------------------------------------------------------------------------------------------------
 */
SFRX(I2SCFG0,     0xDF40);  /*  I2S Configuration Register 0                        */
SFRX(I2SCFG1,     0xDF41);  /*  I2S Configuration Register 1                        */
SFRX(I2SDATL,     0xDF42);  /*  I2S Data Low Byte                                   */
SFRX(I2SDATH,     0xDF43);  /*  I2S Data High Byte                                  */
SFRX(I2SWCNT,     0xDF44);  /*  I2S Word Count Register                             */
SFRX(I2SSTAT,     0xDF45);  /*  I2S Status Register                                 */
SFRX(I2SCLKF0,    0xDF46);  /*  I2S Clock Configuration Register 0                  */
SFRX(I2SCLKF1,    0xDF47);  /*  I2S Clock Configuration Register 1                  */
SFRX(I2SCLKF2,    0xDF48);  /*  I2S Clock Configuration Register 2                  */

/* ------------------------------------------------------------------------------------------------
 *                             Xdata Mapped SFRs
 * ------------------------------------------------------------------------------------------------
 */

/*
 *   Most SFRs are also accessible through XDATA address space.  The register definitions for
 *   this type of access are listed below.  The register names are identical to the SFR names
 *   but with the prefix X_ to denote an XDATA register.
 *
 *   Some SFRs are not accessible through XDATA space.  For clarity, entries are included for these
 *   registers.  They have a prefix of _NA to denote "not available."
 *
 *   The SFRs prefixed with _X_ are not in use, but are listed for a better overview.
 *
 *   For register descriptions, refer to the actual SFR declarations elsewhere in this file.
 */

SFRX(_NA_P0,      0xDF80);
SFRX(_NA_SP,      0xDF81);
SFRX(_NA_DPL0,    0xDF82);
SFRX(_NA_DPH0,    0xDF83);
SFRX(_NA_DPL1,    0xDF84);
SFRX(_NA_DPH1,    0xDF85);
SFRX(X_U0CSR,     0xDF86);
SFRX(_NA_PCON,    0xDF87);

SFRX(_NA_TCON,    0xDF88);
SFRX(X_P0IFG,     0xDF89);
SFRX(X_P1IFG,     0xDF8A);
SFRX(X_P2IFG,     0xDF8B);
SFRX(X_PICTL,     0xDF8C);
SFRX(X_P1IEN,     0xDF8D);
SFRX(_X_SFR8E,    0xDF8E);
SFRX(X_P0INP,     0xDF8F);

SFRX(_NA_P1,      0xDF90);
SFRX(X_RFIM,      0xDF91);
SFRX(_NA_DPS,     0xDF92);
SFRX(X_MPAGE,     0xDF93);
SFRX(_X_SFR94,    0xDF94);
SFRX(_X_SFR95,    0xDF95);
SFRX(_X_SFR96,    0xDF96);
SFRX(_X_SFR97,    0xDF97);

SFRX(_NA_S0CON,   0xDF98);
SFRX(_X_SFR99,    0xDF99);
SFRX(_NA_IEN2,    0xDF9A);
SFRX(_NA_S1CON,   0xDF9B);
SFRX(X_T2CT,      0xDF9C);
SFRX(X_T2PR,      0xDF9D);
SFRX(X_T2CTL,     0xDF9E);
SFRX(_X_SFR9F,    0xDF9F);

SFRX(_NA_P2,      0xDFA0);
SFRX(X_WORIRQ,    0xDFA1);
SFRX(X_WORCTRL,   0xDFA2);
SFRX(X_WOREVT0,   0xDFA3);
SFRX(X_WOREVT1,   0xDFA4);
SFRX(X_WORTIME0,  0xDFA5);
SFRX(X_WORTIME1,  0xDFA6);
SFRX(_X_SFRA7,    0xDFA7);

SFRX(_NA_IEN0,    0xDFA8);
SFRX(_NA_IP0,     0xDFA9);
SFRX(_X_SFRAA,    0xDFAA);
SFRX(X_FWT,       0xDFAB);
SFRX(X_FADDRL,    0xDFAC);
SFRX(X_FADDRH,    0xDFAD);
SFRX(X_FCTL,      0xDFAE);
SFRX(X_FWDATA,    0xDFAF);

SFRX(_X_SFRB0,    0xDFB0);
SFRX(X_ENCDI,     0xDFB1);
SFRX(X_ENCDO,     0xDFB2);
SFRX(X_ENCCS,     0xDFB3);
SFRX(X_ADCCON1,   0xDFB4);
SFRX(X_ADCCON2,   0xDFB5);
SFRX(X_ADCCON3,   0xDFB6);
SFRX(_X_SFRB7,    0xDFB7);

SFRX(_NA_IEN1,    0xDFB8);
SFRX(_NA_IP1,     0xDFB9);
SFRX(X_ADCL,      0xDFBA);
SFRX(X_ADCH,      0xDFBB);
SFRX(X_RNDL,      0xDFBC);
SFRX(X_RNDH,      0xDFBD);
SFRX(X_SLEEP,     0xDFBE);
SFRX(_X_SFRBF,    0xDFBF);

SFRX(_NA_IRCON,   0xDFC0);
SFRX(X_U0DBUF,    0xDFC1);
SFRX(X_U0BAUD,    0xDFC2);
SFRX(_X_SFRC3,    0xDFC3);
SFRX(X_U0UCR,     0xDFC4);
SFRX(X_U0GCR,     0xDFC5);
SFRX(X_CLKCON,    0xDFC6);
SFRX(X_MEMCTR,    0xDFC7);

SFRX(_X_SFRC8,    0xDFC8);
SFRX(X_WDCTL,     0xDFC9);
SFRX(X_T3CNT,     0xDFCA);
SFRX(X_T3CTL,     0xDFCB);
SFRX(X_T3CCTL0,   0xDFCC);
SFRX(X_T3CC0,     0xDFCD);
SFRX(X_T3CCTL1,   0xDFCE);
SFRX(X_T3CC1,     0xDFCF);

SFRX(_NA_PSW,     0xDFD0);
SFRX(X_DMAIRQ,    0xDFD1);
SFRX(X_DMA1CFGL,  0xDFD2);
SFRX(X_DMA1CFGH,  0xDFD3);
SFRX(X_DMA0CFGL,  0xDFD4);
SFRX(X_DMA0CFGH,  0xDFD5);
SFRX(X_DMAARM,    0xDFD6);
SFRX(X_DMAREQ,    0xDFD7);

SFRX(X_TIMIF,     0xDFD8);
SFRX(X_RFD,       0xDFD9);
SFRX(X_T1CC0L,    0xDFDA);
SFRX(X_T1CC0H,    0xDFDB);
SFRX(X_T1CC1L,    0xDFDC);
SFRX(X_T1CC1H,    0xDFDD);
SFRX(X_T1CC2L,    0xDFDE);
SFRX(X_T1CC2H,    0xDFDF);

SFRX(_NA_ACC,     0xDFE0);
SFRX(X_RFST,      0xDFE1);
SFRX(X_T1CNTL,    0xDFE2);
SFRX(X_T1CNTH,    0xDFE3);
SFRX(X_T1CTL,     0xDFE4);
SFRX(X_T1CCTL0,   0xDFE5);
SFRX(X_T1CCTL1,   0xDFE6);
SFRX(X_T1CCTL2,   0xDFE7);

SFRX(_NA_IRCON2,  0xDFE8);
SFRX(X_RFIF,      0xDFE9);
SFRX(X_T4CNT,     0xDFEA);
SFRX(X_T4CTL,     0xDFEB);
SFRX(X_T4CCTL0,   0xDFEC);
SFRX(X_T4CC0,     0xDFED);
SFRX(X_T4CCTL1,   0xDFEE);
SFRX(X_T4CC1,     0xDFEF);

SFRX(_NA_B,       0xDFF0);
SFRX(X_PERCFG,    0xDFF1);
SFRX(X_ADCCFG,    0xDFF2);
SFRX(X_P0SEL,     0xDFF3);
SFRX(X_P1SEL,     0xDFF4);
SFRX(X_P2SEL,     0xDFF5);
SFRX(X_P1INP,     0xDFF6);
SFRX(X_P2INP,     0xDFF7);

SFRX(X_U1CSR,     0xDFF8);
SFRX(X_U1DBUF,    0xDFF9);
SFRX(X_U1BAUD,    0xDFFA);
SFRX(X_U1UCR,     0xDFFB);
SFRX(X_U1GCR,     0xDFFC);
SFRX(X_P0DIR,     0xDFFD);
SFRX(X_P1DIR,     0xDFFE);
SFRX(X_P2DIR,     0xDFFF);

/* ------------------------------------------------------------------------------------------------
 */

#endif
/*---------------------------------------------------------------------------
   regc515c.h - This file contains definitions for the builtin CAN-Bus
   Controller of the Siemens c515c controller

   Copyright (C) 2005, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef _REGC515C_H
#define _REGC515C_H

/* define CPU_CLK_10MHZ or CPU_CLK_8MHZ to select the right values for */
/* the bit timing registers */

#define CPU_CLK_10MHZ

/* address of can controller in xmem */
#define CAN_CTRL	0xf700

/* size of message buffer including 1 dummy byte at end */
#define CAN_MSG_SZ	0x10

/* register offset definitions */
#define CR	0
#define SR	1
#define IR	2

#define BT_0	4
#define BT_1	5
#define GMS_0	6
#define GMS_1	7
#define GME_0	8
#define GME_1	9
#define GME_2	0xa
#define GME_3	0xb
#define MSG15MSK_0	0xc
#define MSG15MSK_1	0xd
#define MSG15MSK_2	0xe
#define MSG15MSK_3	0xf

/* register offsets  in message buffer */
#define MCR_0	0
#define MCR_1	1
#define ARB_0	2
#define ARB_1	3
#define ARB_2	4
#define ARB_3	5
#define MCFG	6
/* beginning of message data */
#define DATA	7

/* bits in cntr_x registers */
#define MSGVAL	0x80
#define TXIE	0x20
#define RXIE	0x8
#define INTPND	0x2
#define RMTPND	0x80
#define TXRQST	0x20
#define MSGLST	0x8
#define CPUUPD	0x8
#define NEWDAT	0x2

/* macros for setting and resetting above bits, see Siemens documentation */
#define MCR_BIT_SET(p,x) ((p) = (0xff & ~((x) >> 1)))
#define MCR_BIT_RES(p,x) ((p) = (0xff & ~(x)))

/* direction = transmit in mcfg */
#define DIR_TRANSMIT	0x8

/* constants for bit timing registers */
/* 8 MHZ */
#ifdef CPU_CLK_8MHZ
#define BT_0_125K	0x3
#define BT_1_125K	0x1c
#define BT_0_250K	0x1
#define BT_1_250K	0x1c
#define BT_0_500K	0x0
#define BT_1_500K	0x1c
#define BT_0_1M		0x0
#define BT_1_1M		0x14
#endif
/* dito, 10 MHZ */
#ifdef CPU_CLK_10MHZ
#define BT_0_125K	0x3
#define BT_1_125K	0x1c
#define BT_0_250K	0x1
#define BT_1_250K	0x1c
#define BT_0_500K	0x0
#define BT_1_500K	0x2f
#define BT_0_1M		0x0
#define BT_1_1M		0x25
#endif

/* Control register bits */

#define	CINIT	0x1
#define IE	0x2
#define SIE	0x4
#define EIE	0x8

#define CCE	0x40

/* status register bits */
#define	LEC0	0x1
#define	LEC1	0x2
#define	LEC2	0x4
#define	TXOK	0x8
#define	RXOK	0x10
#define	WAKE	0x20
#define	WARN	0x40
#define	BOFF	0x80


typedef struct can_msg
{
    unsigned char mcr_0;
    unsigned char mcr_1;
    unsigned char arb_0;
    unsigned char arb_1;
    unsigned char arb_2;
    unsigned char arb_3;
    unsigned char mcfg;
    unsigned char data_bytes[8];
    unsigned char dummy;
} *can_msgp;

__xdata __at CAN_CTRL struct
{
    unsigned	char	cr;
    unsigned	char	sr;
    unsigned	char	ir;
    unsigned	char	res0;
    unsigned	char	bt_0;
    unsigned	char	bt_1;
    unsigned	char	gms_0;
    unsigned	char	gms_1;
    unsigned	char	gme_0;
    unsigned	char	gme_1;
    unsigned	char	gme_2;
    unsigned	char	gme_3;
    unsigned	char	msg15msk_0;
    unsigned	char	msg15msk_1;
    unsigned	char	msg15msk_2;
    unsigned	char	msg15msk_3;
    struct	can_msg msgbufs[15];
} can_ctrl;

/* Byte registers in numerical order */

__sfr __at 0x80 P0;
__sfr __at 0x81 SP;
__sfr __at 0x82 DPL;
__sfr __at 0x83 DPH;
__sfr __at 0x86 WDTREL;
__sfr __at 0x87 PCON;
__sfr __at 0x88 TCON;
__sfr __at 0x88 PCON1;
__sfr __at 0x89 TMOD;
__sfr __at 0x8A TL0;
__sfr __at 0x8B TL1;
__sfr __at 0x8C TH0;
__sfr __at 0x8D TH1;
__sfr __at 0x90 P1;
__sfr __at 0x91 XPAGE;
__sfr __at 0x92 DPSEL;
__sfr __at 0x93 SSCCON;
__sfr __at 0x94 STB;
__sfr __at 0x95 SRB;
__sfr __at 0x96 SSCMOD;
__sfr __at 0x98 SCON;
__sfr __at 0x99 SBUF;
__sfr __at 0x9A IEN2;
__sfr __at 0xA0 P2;
__sfr __at 0xA8 IEN0;
__sfr __at 0xA9 IP0;
__sfr __at 0xAA SRELL;
__sfr __at 0xAB SCF;
__sfr __at 0xAC SCIEN;
__sfr __at 0xB0 P3;
__sfr __at 0xB1 SYSCON;
__sfr __at 0xB8 IEN1;
__sfr __at 0xB9 IP1;
__sfr __at 0xBA SRELH;
__sfr __at 0xC0 IRCON;
__sfr __at 0xC1 CCEN;
__sfr __at 0xC2 CCL1;
__sfr __at 0xC3 CCH1;
__sfr __at 0xC4 CCL2;
__sfr __at 0xC5 CCH2;
__sfr __at 0xC6 CCL3;
__sfr __at 0xC7 CCH3;
__sfr __at 0xC8 T2CON;
__sfr __at 0xCA CRCL;
__sfr __at 0xCB CRCH;
__sfr __at 0xCC TL2;
__sfr __at 0xCD TH2;
__sfr __at 0xD0 PSW;
__sfr __at 0xD8 ADCON0;
__sfr __at 0xD9 ADDATH;
__sfr __at 0xDA ADDATL;
__sfr __at 0xDB P6;
__sfr __at 0xDC ADCON1;
__sfr __at 0xE0 ACC;
__sfr __at 0xE8 P4;
__sfr __at 0xF0 B;
__sfr __at 0xF8 P5;
__sfr __at 0xF8 DIR5;
__sfr __at 0xFA P7;


/* defining bits in SFR P0 */
__sbit __at 0x80  P0_0;
__sbit __at 0x81  P0_1;
__sbit __at 0x82  P0_2;
__sbit __at 0x83  P0_3;
__sbit __at 0x84  P0_4;
__sbit __at 0x85  P0_5;
__sbit __at 0x86  P0_6;
__sbit __at 0x87  P0_7;



/* defining bits in SFR PCON1 */
__sbit __at 0x88  IT0;
__sbit __at 0x89  IE0;
__sbit __at 0x8a  IT1;
__sbit __at 0x8b  IE1;
__sbit __at 0x8c  TR0;
__sbit __at 0x8d  TF0;
__sbit __at 0x8e  TR1;
__sbit __at 0x8f  TF1;
__sbit __at 0x8f  EWPD;



/* defining bits in SFR P1 */
__sbit __at 0x90  P1_0;
__sbit __at 0x90  INT3;
__sbit __at 0x91  P1_1;
__sbit __at 0x91  INT4;
__sbit __at 0x92  P1_2;
__sbit __at 0x92  INT5;
__sbit __at 0x93  P1_3;
__sbit __at 0x93  INT6;
__sbit __at 0x94  P1_4;
__sbit __at 0x94  INT2;
__sbit __at 0x95  P1_5;
__sbit __at 0x95  T2EX;
__sbit __at 0x96  P1_6;
__sbit __at 0x96  CLKOUT;
__sbit __at 0x97  P1_7;
__sbit __at 0x97  T2;



/* defining bits in SFR SCON */
__sbit __at 0x98  RI;
__sbit __at 0x99  TI;
__sbit __at 0x9a  RB8;
__sbit __at 0x9b  TB8;
__sbit __at 0x9c  REN;
__sbit __at 0x9d  SM2;
__sbit __at 0x9e  SM1;
__sbit __at 0x9f  SM0;



/* defining bits in SFR P2 */
__sbit __at 0xa0  P2_0;
__sbit __at 0xa1  P2_1;
__sbit __at 0xa2  P2_2;
__sbit __at 0xa3  P2_3;
__sbit __at 0xa4  P2_4;
__sbit __at 0xa5  P2_5;
__sbit __at 0xa6  P2_6;
__sbit __at 0xa7  P2_7;



/* defining bits in SFR IEN0 */
__sbit __at 0xa8  EX0;
__sbit __at 0xa9  ET0;
__sbit __at 0xaa  EX1;
__sbit __at 0xab  ET1;
__sbit __at 0xac  ES;
__sbit __at 0xad  ET2;
__sbit __at 0xae  WDT;
__sbit __at 0xaf  EA;



/* defining bits in SFR P3 */
__sbit __at 0xb0  P3_0;
__sbit __at 0xb0  RXD;
__sbit __at 0xb1  P3_1;
__sbit __at 0xb1  TXD;
__sbit __at 0xb2  P3_2;
__sbit __at 0xb2  INT0;
__sbit __at 0xb3  P3_3;
__sbit __at 0xb3  INT1;
__sbit __at 0xb4  P3_4;
__sbit __at 0xb4  T0;
__sbit __at 0xb5  P3_5;
__sbit __at 0xb5  T1;
__sbit __at 0xb6  P3_6;
__sbit __at 0xb6  WR;
__sbit __at 0xb7  P3_7;
__sbit __at 0xb7  RD;



/* defining bits in SFR IEN1 */
__sbit __at 0xb8  EADC;
__sbit __at 0xb9  EX2;
__sbit __at 0xba  EX3;
__sbit __at 0xbb  EX4;
__sbit __at 0xbc  EX5;
__sbit __at 0xbd  EX6;
__sbit __at 0xbe  SWDT;
__sbit __at 0xbf  EXEN2;



/* defining bits in SFR IRCON */
__sbit __at 0xc0  IADC;
__sbit __at 0xc1  IEX2;
__sbit __at 0xc2  IEX3;
__sbit __at 0xc3  IEX4;
__sbit __at 0xc4  IEX5;
__sbit __at 0xc5  IEX6;
__sbit __at 0xc6  TF2;
__sbit __at 0xc7  EXF2;



/* defining bits in SFR T2CON */
__sbit __at 0xc8  T2I0;
__sbit __at 0xc9  T2I1;
__sbit __at 0xca  T2CM;
__sbit __at 0xcb  T2R0;
__sbit __at 0xcc  T2R1;
__sbit __at 0xcd  I2FR;
__sbit __at 0xce  I3FR;
__sbit __at 0xcf  T2PS;



/* defining bits in SFR PSW */
__sbit __at 0xd0  P;
__sbit __at 0xd1  F1;
__sbit __at 0xd2  OV;
__sbit __at 0xd3  RS0;
__sbit __at 0xd4  RS1;
__sbit __at 0xd5  F0;
__sbit __at 0xd6  AC;
__sbit __at 0xd7  CY;



/* defining bits in SFR ADCON0 */
__sbit __at 0xd8  MX0;
__sbit __at 0xd9  MX1;
__sbit __at 0xda  MX2;
__sbit __at 0xdb  ADM;
__sbit __at 0xdc  BSY;
__sbit __at 0xdd  ADEX;
__sbit __at 0xde  CLK;
__sbit __at 0xdf  BD;



/* defining bits in SFR ACC */
__sbit __at 0xe0  ACC_0;
__sbit __at 0xe1  ACC_1;
__sbit __at 0xe2  ACC_2;
__sbit __at 0xe3  ACC_3;
__sbit __at 0xe4  ACC_4;
__sbit __at 0xe5  ACC_5;
__sbit __at 0xe6  ACC_6;
__sbit __at 0xe7  ACC_7;



/* defining bits in SFR P4 */
__sbit __at 0xe8  P4_0;
__sbit __at 0xe8  ADST;
__sbit __at 0xe9  P4_1;
__sbit __at 0xe9  SCLK;
__sbit __at 0xea  P4_2;
__sbit __at 0xea  SRI;
__sbit __at 0xeb  P4_3;
__sbit __at 0xeb  STO;
__sbit __at 0xec  P4_4;
__sbit __at 0xec  SLS;
__sbit __at 0xed  P4_5;
__sbit __at 0xed  INT8;
__sbit __at 0xee  P4_6;
__sbit __at 0xee  TXDC;
__sbit __at 0xef  P4_7;
__sbit __at 0xef  RXDC;



/* defining bits in SFR B */
__sbit __at 0xf0  B_0;
__sbit __at 0xf1  B_1;
__sbit __at 0xf2  B_2;
__sbit __at 0xf3  B_3;
__sbit __at 0xf4  B_4;
__sbit __at 0xf5  B_5;
__sbit __at 0xf6  B_6;
__sbit __at 0xf7  B_7;



/* defining bits in SFR DIR5 */
__sbit __at 0xf8  P5_0;
__sbit __at 0xf9  P5_1;
__sbit __at 0xfa  P5_2;
__sbit __at 0xfb  P5_3;
__sbit __at 0xfc  P5_4;
__sbit __at 0xfd  P5_5;
__sbit __at 0xfe  P5_6;
__sbit __at 0xff  P5_7;
__sbit __at 0xf8  DIR5_0;
__sbit __at 0xf9  DIR5_1;
__sbit __at 0xfa  DIR5_2;
__sbit __at 0xfb  DIR5_3;
__sbit __at 0xfc  DIR5_4;
__sbit __at 0xfd  DIR5_5;
__sbit __at 0xfe  DIR5_6;
__sbit __at 0xff  DIR5_7;

#endif /* _REGC515C_H */


/*-------------------------------------------------------------------------
   at89c51snd1c.h - Register Declarations for the Atmel AT89C51SND1C Processor

   Copyright (C) 2005, Weston Schmidt <weston_schmidt@alumni.purdue.edu>

   This document is based on the AT8xC51SND1C document
       4109H-8051-01/05

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#ifndef __AT89C51SND1_H__
#define __AT89C51SND1_H__


/*  BYTE Registers */
__sfr __at (0xE0) ACC     ; /* C51 Core SFRs */
__sfr __at (0xF0) B       ;
__sfr __at (0xD0) PSW     ;
__sfr __at (0x81) SP      ;
__sfr __at (0x82) DPL     ;
__sfr __at (0x83) DPH     ;
__sfr __at (0x87) PCON    ; /* System Management SFRs */
__sfr __at (0x8E) AUXR0   ;
__sfr __at (0xA2) AUXR1   ;
__sfr __at (0xFB) NVERS   ;
__sfr __at (0x8F) CKCON   ; /* PLL and System Clock SFRs */
__sfr __at (0xE9) PLLCON  ;
__sfr __at (0xEE) PLLNDIV ;
__sfr __at (0xEF) PLLRDIV ;
__sfr __at (0xA8) IEN0    ; /* Interrupt SFRs */
__sfr __at (0xB1) IEN1    ;
__sfr __at (0xB7) IPH0    ;
__sfr __at (0xB8) IPL0    ;
__sfr __at (0xB3) IPH1    ;
__sfr __at (0xB2) IPL1    ;
__sfr __at (0x80) P0      ; /* Port SFRs */
__sfr __at (0x90) P1      ;
__sfr __at (0xA0) P2      ;
__sfr __at (0xB0) P3      ;
__sfr __at (0xC0) P4      ;
__sfr __at (0xD8) P5      ;
__sfr __at (0xD1) FCON    ; /* Flash Memory SFR */
__sfr __at (0x88) TCON    ; /* Timer SFRs */
__sfr __at (0x89) TMOD    ;
__sfr __at (0x8A) TL0     ;
__sfr __at (0x8C) TH0     ;
__sfr __at (0x8B) TL1     ;
__sfr __at (0x8D) TH1     ;
__sfr __at (0xA6) WDTRST  ;
__sfr __at (0xA7) WDTPRG  ;
__sfr __at (0xAA) MP3CON  ; /* MP3 Decoder SFRs */
__sfr __at (0xC8) MP3STA  ;
__sfr __at (0xAF) MP3STA1 ;
__sfr __at (0xAC) MP3DAT  ;
__sfr __at (0xAD) MP3ANC  ;
__sfr __at (0x9E) MP3VOL  ;
__sfr __at (0x9F) MP3VOR  ;
__sfr __at (0xB4) MP3BAS  ;
__sfr __at (0xB5) MP3MED  ;
__sfr __at (0xB6) MP3TRE  ;
__sfr __at (0xEB) MP3CLK  ;
__sfr __at (0xAE) MP3DBG  ;
__sfr __at (0x9A) AUDCON0 ; /* Audio Interface SFRs */
__sfr __at (0x9B) AUDCON1 ;
__sfr __at (0x9C) AUDSTA  ;
__sfr __at (0x9D) AUDDAT  ;
__sfr __at (0xEC) AUDCLK  ;
__sfr __at (0xBC) USBCON  ; /* USB Controller SFRs */
__sfr __at (0xC6) USBADDR ;
__sfr __at (0xBD) USBINT  ;
__sfr __at (0xBE) USBIEN  ;
__sfr __at (0xC7) UEPNUM  ;
__sfr __at (0xD4) UEPCONX ;
__sfr __at (0xCE) UEPSTAX ;
__sfr __at (0xD5) UEPRST  ;
__sfr __at (0xF8) UEPINT  ;
__sfr __at (0xC2) UEPIEN  ;
__sfr __at (0xCF) UEPDATX ;
__sfr __at (0xE2) UBYCTX  ;
__sfr __at (0xBA) UFNUML  ;
__sfr __at (0xBB) UFNUMH  ;
__sfr __at (0xEA) USBCLK  ;
__sfr __at (0xE4) MMCON0  ; /* MMC Controller SFRs */
__sfr __at (0xE5) MMCON1  ;
__sfr __at (0xE6) MMCON2  ;
__sfr __at (0xDE) MMSTA   ;
__sfr __at (0xE7) MMINT   ;
__sfr __at (0xDF) MMMSK   ;
__sfr __at (0xDD) MMCMD   ;
__sfr __at (0xDC) MMDAT   ;
__sfr __at (0xED) MMCLK   ;
__sfr __at (0xF9) DAT16H  ; /* IDE Interface SFR */
__sfr __at (0x98) SCON    ; /* Serial I/O Port SFRs */
__sfr __at (0x99) SBUF    ;
__sfr __at (0xB9) SADEN   ;
__sfr __at (0xA9) SADDR   ;
__sfr __at (0x92) BDRCON  ;
__sfr __at (0x91) BRL     ;
__sfr __at (0xC3) SPCON   ; /* SPI Controller SFRs */
__sfr __at (0xC4) SPSTA   ;
__sfr __at (0xC5) SPDAT   ;
__sfr __at (0x93) SSCON   ; /* Two Wire Controller SFRs */
__sfr __at (0x94) SSSTA   ;
__sfr __at (0x95) SSDAT   ;
__sfr __at (0x96) SSADR   ;
__sfr __at (0xA3) KBCON   ; /* Keyboard Interface SFRs */
__sfr __at (0xA4) KBSTA   ;
__sfr __at (0xF3) ADCON   ; /* A/D Controller SFRs */
__sfr __at (0xF4) ADDL    ;
__sfr __at (0xF5) ADDH    ;
__sfr __at (0xF2) ADCLK   ;


/*  BIT Registers */
/*  PSW */
__sbit __at (0xD7) CY     ;
__sbit __at (0xD6) AC     ;
__sbit __at (0xD5) F0     ;
__sbit __at (0xD4) RS1    ;
__sbit __at (0xD3) RS0    ;
__sbit __at (0xD2) OV     ;
__sbit __at (0xD1) F1     ;
__sbit __at (0xD0) P      ;

/*  IEN0    */
__sbit __at (0xAF) EA     ;
__sbit __at (0xAE) EAUD   ;
__sbit __at (0xAD) EMP3   ;
__sbit __at (0xAC) ES     ;
__sbit __at (0xAB) ET1    ;
__sbit __at (0xAA) EX1    ;
__sbit __at (0xA9) ET0    ;
__sbit __at (0xA8) EX0    ;

/*  IPLO */
__sbit __at (0xBE) IPLAUD ;
__sbit __at (0xBD) IPLMP3 ;
__sbit __at (0xBC) IPLS   ;
__sbit __at (0xBB) IPLT1  ;
__sbit __at (0xBA) IPLX1  ;
__sbit __at (0xB9) IPLT0  ;
__sbit __at (0xB8) IPLX0  ;

/*  P0  */
__sbit __at (0x87) P0_7   ;
__sbit __at (0x86) P0_6   ;
__sbit __at (0x85) P0_5   ;
__sbit __at (0x84) P0_4   ;
__sbit __at (0x83) P0_3   ;
__sbit __at (0x82) P0_2   ;
__sbit __at (0x81) P0_1   ;
__sbit __at (0x80) P0_0   ;

/*  P1  */
__sbit __at (0x97) P1_7   ;
__sbit __at (0x96) P1_6   ;
__sbit __at (0x95) P1_5   ;
__sbit __at (0x94) P1_4   ;
__sbit __at (0x93) P1_3   ;
__sbit __at (0x92) P1_2   ;
__sbit __at (0x91) P1_1   ;
__sbit __at (0x90) P1_0   ;

__sbit __at (0x97) SDA    ;
__sbit __at (0x96) SCL    ;
__sbit __at (0x93) KIN3   ;
__sbit __at (0x92) KIN2   ;
__sbit __at (0x91) KIN1   ;
__sbit __at (0x90) KIN0   ;

/*  P2  */
__sbit __at (0xA7) P2_7   ;
__sbit __at (0xA6) P2_6   ;
__sbit __at (0xA5) P2_5   ;
__sbit __at (0xA4) P2_4   ;
__sbit __at (0xA3) P2_3   ;
__sbit __at (0xA2) P2_2   ;
__sbit __at (0xA1) P2_1   ;
__sbit __at (0xA0) P2_0   ;

/*  P3  */
__sbit __at (0xB7) P3_7   ;
__sbit __at (0xB6) P3_6   ;
__sbit __at (0xB5) P3_5   ;
__sbit __at (0xB4) P3_4   ;
__sbit __at (0xB3) P3_3   ;
__sbit __at (0xB2) P3_2   ;
__sbit __at (0xB1) P3_1   ;
__sbit __at (0xB0) P3_0   ;

__sbit __at (0xB7) RD     ;
__sbit __at (0xB6) WR     ;
__sbit __at (0xB5) T1     ;
__sbit __at (0xB4) T0     ;
__sbit __at (0xB3) INT1   ;
__sbit __at (0xB2) INT0   ;
__sbit __at (0xB1) TXD    ;
__sbit __at (0xB0) RXD    ;

/*  P4  */
__sbit __at (0xC7) P4_7   ;
__sbit __at (0xC6) P4_6   ;
__sbit __at (0xC5) P4_5   ;
__sbit __at (0xC4) P4_4   ;
__sbit __at (0xC3) P4_3   ;
__sbit __at (0xC2) P4_2   ;
__sbit __at (0xC1) P4_1   ;
__sbit __at (0xC0) P4_0   ;

__sbit __at (0xC3) SS_    ;
__sbit __at (0xC2) SCK    ;
__sbit __at (0xC1) MOSI   ;
__sbit __at (0xC0) MISO   ;

/*  P5  */
__sbit __at (0xDB) P5_3   ;
__sbit __at (0xDA) P5_2   ;
__sbit __at (0xD9) P5_1   ;
__sbit __at (0xD8) P5_0   ;

/*  TCON    */
__sbit __at (0x8F) TF1    ;
__sbit __at (0x8E) TR1    ;
__sbit __at (0x8D) TF0    ;
__sbit __at (0x8C) TR0    ;
__sbit __at (0x8B) IE1    ;
__sbit __at (0x8A) IT1    ;
__sbit __at (0x89) IE0    ;
__sbit __at (0x88) IT0    ;

/*  MP3STA  */
__sbit __at (0xCF) MPANC  ;
__sbit __at (0xCE) MPREQ  ;
__sbit __at (0xCD) ERRLAY ;
__sbit __at (0xCC) ERRSYN ;
__sbit __at (0xCB) ERRCRC ;
__sbit __at (0xCA) MPFS1  ;
__sbit __at (0xC9) MPFS0  ;
__sbit __at (0xC8) MPVER  ;

/*  UEPINT  */
__sbit __at (0xFA) EP2INT ;
__sbit __at (0xF9) EP1INT ;
__sbit __at (0xF8) EP0INT ;

/*  SCON  */
__sbit __at (0x9F) SM0    ;
__sbit __at (0x9F) FE     ;
__sbit __at (0x9E) SM1    ;
__sbit __at (0x9D) SM2    ;
__sbit __at (0x9C) REN    ;
__sbit __at (0x9B) TB8    ;
__sbit __at (0x9A) RB8    ;
__sbit __at (0x99) TI     ;
__sbit __at (0x98) RI     ;


/* BIT definitions for bits that are not directly accessible */
/* PCON bits */
#define MSK_SMOD1   0x80
#define MSK_SMOD0   0x40
#define MSK_GF1     0x08
#define MSK_GF0     0x04
#define MSK_PD      0x02
#define MSK_IDL     0x01

/* AUXR0 bits */
#define MSK_EXT16   0x40
#define MSK_M0      0x20
#define MSK_DPHDIS  0x10
#define MSK_XRS     0x0C
#define MSK_EXTRAM  0x02
#define MSK_AO      0x01

/* AUXR1 bits */
#define MSK_ENBOOT  0x20
#define MSK_GF3     0x08
#define MSK_DPS     0x01

/* CKCON bits */
#define MSK_X2      0x01

/* PLLCON bits */
#define MSK_PLL_R   0xC0
#define MSK_PLLRES  0x08
#define MSK_PLLEN   0x02
#define MSK_PLOCK   0x01

/* PLLNDIV bits */
#define MSK_PLL_N   0x7F

/* IEN1 bits */
#define MSK_EUSB    0x40
#define MSK_EKB     0x10
#define MSK_EADC    0x08
#define MSK_ESPI    0x04
#define MSK_EI2C    0x02
#define MSK_EMMC    0x01

/* IPHO bits */
#define MSK_IPHAUD  0x40
#define MSK_IPHMP3  0x20
#define MSK_IPHS    0x10
#define MSK_IPHT1   0x08
#define MSK_IPHX1   0x04
#define MSK_IPHT0   0x02
#define MSK_IPHX0   0x01

/* IPH1 bits */
#define MSK_IPHUSB  0x40
#define MSK_IPHKB   0x10
#define MSK_IPHADC  0x08
#define MSK_IPHSPI  0x04
#define MSK_IPHI2C  0x02
#define MSK_IPHMMC  0x01

/* IPL1 bits */
#define MSK_IPLUSB  0x40
#define MSK_IPLKB   0x10
#define MSK_IPLADC  0x08
#define MSK_IPLSPI  0x04
#define MSK_IPLI2C  0x02
#define MSK_IPLMMC  0x01

/* TMOD bits */
#define MSK_GATE1   0x80
#define MSK_C_T1    0x40
#define MSK_MO1     0x30
#define MSK_GATE0   0x08
#define MSK_C_T0    0x04
#define MSK_MO0     0x03

/* MP3CON bits */
#define MSK_MPEN    0x80
#define MSK_MPBBST  0x40
#define MSK_CRCEN   0x20
#define MSK_MSKANC  0x10
#define MSK_MSKREQ  0x08
#define MSK_MSKLAY  0x04
#define MSK_MSKSYN  0x02
#define MSK_MSKCRC  0x01

/* MP3STA1 bits */
#define MSK_MPFREQ  0x10
#define MSK_MPBREQ  0x08

/* MP3VOL bits */
#define MSK_VOL     0x1F

/* MP3VOR bits */
#define MSK_VOR     0x1F

/* MP3BAS bits */
#define MSK_BAS     0x1F

/* MP3MED bits */
#define MSK_MED     0x1F

/* MP3TRE bits */
#define MSK_TRE     0x1F

/* MP3CLK bits */
#define MSK_MPCD    0x1F

/* MP3DBG bits */
#define MSK_MPFULL  0x08

/* AUDCON0 bits */
#define MSK_JUST    0xF8
#define MSK_POL     0x04
#define MSK_DSIZ    0x02
#define MSK_HLR     0x01

/* AUDCON1 bits */
#define MSK_SRC     0x80
#define MSK_DRQEN   0x40
#define MSK_MSREQ   0x20
#define MSK_MUDRN   0x10
#define MSK_DUP     0x06
#define MSK_AUDEN   0x01

/* AUDSTA bits */
#define MSK_SREQ    0x80
#define MSK_UDRN    0x40
#define MSK_AUBUSY  0x20

/* AUDCLK bits */
#define MSK_AUCD    0x1F

/* USBCON bits */
#define MSK_USBE    0x80
#define MSK_SUSPCLK 0x40
#define MSK_SDRMWUP 0x20
#define MSK_UPRSM   0x08
#define MSK_RMWUPE  0x04
#define MSK_CONFG   0x02
#define MSK_FADDEN  0x01

/* USBADDR bits */
#define MSK_FEN     0x80
#define MSK_UADD    0x7F

/* USBINT bits */
#define MSK_WUPCPU  0x20
#define MSK_EORINT  0x10
#define MSK_SOFINT  0x08
#define MSK_SPINT   0x01

/* USBIEN bits */
#define MSK_EWUPCPU 0x20
#define MSK_EEORINT 0x10
#define MSK_ESOFINT 0x08
#define MSK_ESPINT  0x01

/* UEPNUM bits */
#define MSK_EPNUM   0x03

/* UEPCONX bits */
#define MSK_EPEN    0x80
#define MSK_NAKIEN  0x40
#define MSK_NAKOUT  0x20
#define MSK_NAKIN   0x10
#define MSK_DTGL    0x08
#define MSK_EPDIR   0x04
#define MSK_EPTYPE  0x03

/* UEPSTAX bits */
#define MSK_DIR     0x80
#define MSK_RXOUTB1 0x40
#define MSK_STALLRQ 0x20
#define MSK_TXRDY   0x10
#define MSK_STLCRC  0x08
#define MSK_RXSETUP 0x04
#define MSK_RXOUTB0 0x02
#define MSK_TXCMP   0x01

/* UEPRST bits */
#define MSK_EPRST   0x07
#define MSK_EP2RST  0x04
#define MSK_EP1RST  0x02
#define MSK_EP0RST  0x01

#define MSK_EPINT   0x07
#define MSK_EP2INT  0x04
#define MSK_EP1INT  0x02
#define MSK_EP0INT  0x01

/* UEPIEN bits */
#define MSK_EPINTE  0x07
#define MSK_EP2INTE 0x04
#define MSK_EP1INTE 0x02
#define MSK_EP0INTE 0x01

/* UBYCTX bits */
#define MSK_BYCT    0x7F

/* UFNUMH bits */
#define MSK_CRCOK   0x20
#define MSK_CRCERR  0x10
#define MSK_FNUM    0x07

/* USBCLK bits */
#define MSK_USBCD   0x03

/* MMCON0 bits */
#define MSK_DRPTR   0x80
#define MSK_DTPTR   0x40
#define MSK_CRPTR   0x20
#define MSK_CTPTR   0x10
#define MSK_MBLOCK  0x08
#define MSK_DFMT    0x04
#define MSK_RFMT    0x02
#define MSK_CRCDIS  0x01

/* MMCON1 bits */
#define MSK_BLEN    0xf0
#define MSK_DATDIR  0x08
#define MSK_DATEN   0x04
#define MSK_RESPEN  0x02
#define MSK_CMDEN   0x01

/* MMCON2 bits */
#define MSK_MMCEN   0x80
#define MSK_DCR     0x40
#define MSK_CCR     0x20
#define MSK_DATD    0x06
#define MSK_FLOWC   0x01

/* MMSTA bits */
#define MSK_CBUSY   0x20
#define MSK_CRC16S  0x10
#define MSK_DATFS   0x08
#define MSK_CRC7S   0x04
#define MSK_RESPFS  0x02
#define MSK_CFLCK   0x01

/* MMINT bits */
#define MSK_MCBI    0x80
#define MSK_EORI    0x40
#define MSK_EOCI    0x20
#define MSK_EOFI    0x10
#define MSK_F2FI    0x08
#define MSK_F1FI    0x04
#define MSK_F2EI    0x02
#define MSK_F1EI    0x01

/* MMMSK bits */
#define MSK_MCBM    0x80
#define MSK_EORM    0x40
#define MSK_EOCM    0x20
#define MSK_EOFM    0x10
#define MSK_F2FM    0x08
#define MSK_F1FM    0x04
#define MSK_F2EM    0x02
#define MSK_F1EM    0x01

/* BDRCON bits */
#define MSK_BRR     0x10
#define MSK_TBCK    0x08
#define MSK_RBCK    0x04
#define MSK_SPD     0x02
#define MSK_M0SRC   0x01

/* SPCON bits */
#define MSK_SPR     0x83
#define MSK_SPEN    0x40
#define MSK_SSDIS   0x20
#define MSK_MSTR    0x10
#define MSK_MODE    0x0C
#define MSK_CPOL    0x08
#define MSK_CPHA    0x04

/* SPSTA bits */
#define MSK_SPIF    0x80
#define MSK_WCOL    0x40
#define MSK_MODF    0x10

/* SSCON bits */
#define MSK_SSCR    0x83
#define MSK_SSPE    0x40
#define MSK_SSSTA   0x20
#define MSK_SSSTO   0x10
#define MSK_SSI     0x08
#define MSK_SSAA    0x04

/* SSSTA bits */
#define MSK_SSC     0xf8

/* SSADR bits */
#define MSK_SSA     0xfe
#define MSK_SSGC    0x01

/* KBCON bits */
#define MSK_KINL    0xf0
#define MSK_KINM    0x0f

/* BKSTA bits */
#define MSK_KPDE    0x80
#define MSK_KINF    0x0f

/* ADCON bits */
#define MSK_ADIDL   0x40
#define MSK_ADEN    0x20
#define MSK_ADEOC   0x10
#define MSK_ADSST   0x80
#define MSK_ADCS    0x01

/* ADCLK bits */
#define MSK_ADCD    0x1f

/* ADDL bits */
#define MSK_ADAT    0x03

/* Interrupt numbers: address = (number * 8) + 3 */
#define IE0_VECTOR      0   /* 0x03 External Interrupt 0 */
#define TF0_VECTOR      1   /* 0x0b Timer 0 */
#define IE1_VECTOR      2   /* 0x13 External Interrupt 1 */
#define TF1_VECTOR      3   /* 0x1b Timer 1 */
#define SIO_VECTOR      4   /* 0x23 Serial port */
#define MP3_VECTOR      5   /* 0x2b MP3 Decoder */
#define AUDIO_VECTOR    6   /* 0x33 Audio Interface */
#define MMC_VECTOR      7   /* 0x3b MMC Interface */
#define TWI_VECTOR      8   /* 0x43 Two Wire Controller */
#define SPI_VECTOR      9   /* 0x4b SPI Controller */
#define ADC_VECTOR      10  /* 0x53 A to D Contverter */
#define KBD_VECTOR      11  /* 0x5b Keyboard */
                            /* 0x63 Reserved */
#define USB_VECTOR      13  /* 0x6b USB */
                            /* 0x73 Reserved */

#endif
/*-------------------------------------------------------------------------
   mcs51reg.h - Register Declarations for the mcs51 compatible
   microcontrollers

   Copyright (C) 2000, Bela Torok / bela.torok@kssg.ch

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------
   History:
   --------
   Version 1.0 Nov 2, 2000 - B. Torok  / bela.torok@kssg.ch
   Initial release, supported microcontrollers:
   8051, 8052, Atmel AT89C1051, AT89C2051, AT89C4051,
   Infineon / Siemens SAB80515, SAB80535, SAB80515A

   Version 1.0.1 (Nov 3, 2000)
   SAB80515A definitions revised by Michael Schmitt / michael.schmitt@t-online.de

   Version 1.0.2 (Nov 6, 2000)
   T2CON bug corrected 8052 and SABX microcontrollers have different T2CONs
   Support for the Atmel AT89C52, AT80LV52, AT89C55, AT80LV55
   Support for the Dallas DS80C320 and DS80C323
   B. Torok / bela.torok@kssg.ch

   Version 1.0.3 (Nov 7, 2000)
   SAB80517 definitions added by Michael Schmitt / michael.schmitt@t-online.de
   Dallas AT89S53 definitions added by B. Torok / bela.torok@kssg.ch
   Dallas DS87C520 and DS83C520 definitions added by B. Torok / bela.torok@kssg.ch

   Version 1.0.4 (Nov 9, 2000)
   To simplify the identication of registers, a large number of definitios
   were renamed. Long register names now (hopefully) clearly define the
   function of the registers.
   Dallas DS89C420 definitions added by B. Torok / bela.torok@kssg.ch

   Version 1.0.5 (Dec 15, 2000)
   Definitions added: #ifdef MCS51REG_EXTERNAL_ROM
                      #ifdef MCS51REG_EXTERNAL_RAM
                      #ifndef MCS51REG_DISABLE_WARNINGS


   Version 1.0.6 (March 10, 2001)
   Support for the Dallas DS5000 & DS2250
   Support for the Dallas DS5001 & DS2251
   Support for the Dallas DS80C390
   microcontrollers - B. Torok / bela.torok@kssg.ch

   Version 1.0.7 (June 7, 2001)
   #ifndef MCS51REG_DISABLE_WARNINGS removed
   #ifdef MCS51REG_DISABLE_WARNINGS added - B. Torok / bela.torok@kssg.ch
   Support for the Philips P80C552 added - Bernhard Held / Bernhard.Held@otelo-online.de

   Version 1.0.8 (Feb 28, 2002)
   Dallas DS89C420 definitions corrected by B. Torok / bela.torok@kssg.ch
   Revised by lanius@ewetel.net

   Version 1.0.9 (Sept 9, 2002)
   Register declarations for the Atmel T89C51RD2 added by Johannes Hoelzl / johannes.hoelzl@gmx.de

   Version 1.0.10 (Sept 19, 2002)
   Register declarations for the Philips P89C668 added by Eric Limpens / Eric@limpens.net

   Version 1.0.11 (Sept 19, 2004)
   Dallas DS5000 MCON Register declarations corrected by Radek Zadera / a2i@swipnet.se

   Version 1.0.12 (March 2, 2005)
   Infineon SAB80C509 Register declarations added Thomas Boje / thomas@boje.name

   Adding support for additional microcontrollers:
   -----------------------------------------------

   1. Don't modify this file!!!

   2. Insert your code in a separate file e.g.: mcs51reg_update.h and include
      this after the #define HEADER_MCS51REG statement in this file

   3. The mcs51reg_update.h file should contain following definitions:

          a. An entry with the inventory of the register set of the
             microcontroller in the  "Describe microcontrollers" section.

          b. If necessary add entry(s) for registers not defined in this file

          c. Define interrupt vectors

   4. Compile a program for the microcontroller using the Preprocessor only, e.g.:,
      sdcc -E test.c > t.txt
      and check definitions for validity in the t.txt file.

   5. If everithing seems to be OK send me the mcs51reg_update.h file. --> bela.torok@kssg.ch
      I'm going to resolve conflicts & verify/merge new definitions to this file.


   Microcontroller support:

   Use one of the following options:

   1. use #include <mcs51reg.h> in your program & define MICROCONTROLLER_XXXX in your makefile.

   2. use following definitions prior the
      #include <mcs51reg.h> line in your program:
      e.g.:
      #define MICROCONTROLLER_8052       -> 8052 type microcontroller
      or
      #define MICROCONTROLLER_AT89CX051  -> Atmel AT89C1051, AT89C2051 and AT89C4051 microcontrollers


   Use only one of the following definitions!!!

   Supported Microcontrollers:

   No definition                8051
   MICROCONTROLLER_8051         8051
   MICROCONTROLLER_8052         8052
   MICROCONTROLLER_AT89CX051    Atmel AT89C1051, AT89C2051 and AT89C4051
   MICROCONTROLLER_AT89S53      Atmel AT89S53 microcontroller
   MICROCONTROLLER_AT89X52      Atmel AT89C52 and AT80LV52 microcontrollers
   MICROCONTROLLER_AT89X55      Atmel AT89C55 and AT80LV55 microcontrollers
   MICROCONTROLLER_DS5000       Dallas DS5000 & DS2250 microcontroller
   MICROCONTROLLER_DS5001       Dallas DS5001 & DS2251 microcontroller
   MICROCONTROLLER_DS80C32X     Dallas DS80C320 and DS80C323 microcontrollers
   MICROCONTROLLER_DS80C390     Dallas DS80C390 microcontroller
   MICROCONTROLLER_DS89C420     Dallas DS89C420 microcontroller
   MICROCONTROLLER_DS8XC520     Dallas DS87C520 and DS83C520 microcontrollers
   MICROCONTROLLER_P80C552      Philips P80C552
   MICROCONTROLLER_P89C668      Philips P89C668
   MICROCONTROLLER_SAB80C509    Infineon / Siemens SAB80C509
   MICROCONTROLLER_SAB80515     Infineon / Siemens SAB80515 & SAB80535
   MICROCONTROLLER_SAB80515A    Infineon / Siemens SAB80515A
   MICROCONTROLLER_SAB80517     Infineon / Siemens SAB80517
   MICROCONTROLLER_T89C51RD2    Atmel T89C51RD2

   Additional definitions (use them prior the #include mcs51reg.h statement):

   Ports P0 & P2 are not available if external ROM used.
   Use statement "#define MCS51REG_EXTERNAL_ROM" to undefine P0 & P2.

   Ports P0, P2, P3_6, WR, P3_7 & RD are not available if external RAM is used.
   Use statement "#define MCS51REG_EXTERNAL_RAM" to undefine P0, P2,
   P3_6, WR, P3_7 & RD.

   #define MCS51REG_ENABLE_WARNINGS -> enable warnings

-----------------------------------------------------------------------*/


#ifndef HEADER_MCS51REG
#define HEADER_MCS51REG

///////////////////////////////////////////////////////
///  Insert header here (for developers only)       ///
///  remove "//" from the begining of the next line ///
//#include "mcs51reg_update.h"                      ///
///////////////////////////////////////////////////////

//////////////////////////////////
///  Describe microcontrollers ///
///  (inventory of registers)  ///
//////////////////////////////////

// definitions for the 8051
#ifdef MICROCONTROLLER_8051
#ifdef MICROCONTROLLER_DEFINED
#define MCS51REG_ERROR
#endif
#ifndef MICROCONTROLLER_DEFINED
#define MICROCONTROLLER_DEFINED
#endif
#ifdef MCS51REG_ENABLE_WARNINGS
#warning Selected HW: 8051
#endif
#define P0
#define SP
#define DPL
#define DPH
#define PCON__SMOD__x__x__x__GF1__GF0__PD__IDL
#define TCON
#define TMOD
#define TL0
#define TL1
#define TH0
#define TH1
#define P1
#define SCON
#define SBUF
#define P2
#define IE__EA__x__x__ES__ET1__EX1__ET0__EX0
#define P3
#define IP__x__x__x__PS__PT1__PX1__PT0__PX0
#define PSW
#define ACC
#define B
#endif
// end of definitions for the 8051


// definitions for the 8052 microcontroller
#ifdef MICROCONTROLLER_8052
#ifdef MICROCONTROLLER_DEFINED
#define MCS51REG_ERROR
#endif
#ifndef MICROCONTROLLER_DEFINED
#define MICROCONTROLLER_DEFINED
#endif
#ifdef MCS51REG_ENABLE_WARNINGS
#warning Selected HW: 8052
#endif
// 8051 register set
#define P0
#define SP
#define DPL
#define DPH
#define PCON__SMOD__x__x__x__GF1__GF0__PD__IDL
#define TCON
#define TMOD
#define TL0
#define TL1
#define TH0
#define TH1
#define P1
#define SCON
#define SBUF
#define P2
#define IE__EA__x__ET2__ES__ET1__EX1__ET0__EX0
#define P3
#define IP__x__x__PT2__PS__PT1__PX1__PT0__PX0
#define PSW
#define ACC
#define B
// 8052 specific registers
#define T2CON__TF2__EXF2__RCLK__TCLK__EXEN2__TR2__C_T2__CP_RL2
#define RCAP2L
#define RCAP2H
#define TL2
#define TH2
#endif
// end of definitions for the 8052 microcontroller


// definitionsons for the Atmel
// AT89C1051, AT89C2051 and AT89C4051 microcontrollers
#ifdef MICROCONTROLLER_AT89CX051
#ifdef MICROCONTROLLER_DEFINED
#define MCS51REG_ERROR
#endif
#ifndef MICROCONTROLLER_DEFINED
#define MICROCONTROLLER_DEFINED
#endif
#ifdef MCS51REG_ENABLE_WARNINGS
#warning Selected HW: Atmel AT89Cx051
#endif
// 8051 register set without P0 & P2
#define SP
#define DPL
#define DPH
#define PCON__SMOD__x__x__x__GF1__GF0__PD__IDL
#define TCON
#define TMOD
#define TL0
#define TL1
#define TH0
#define TH1
#define P1
#define SCON
#define SBUF
#define IE__EA__x__x__ES__ET1__EX1__ET0__EX0
#define P3
#define IP__x__x__x__PS__PT1__PX1__PT0__PX0
#define PSW
#define ACC
#define B
#endif
// end of definitionsons for the Atmel
// AT89C1051, AT89C2051 and AT89C4051 microcontrollers


// definitions for the Atmel AT89S53
#ifdef MICROCONTROLLER_AT89S53
#ifdef MICROCONTROLLER_DEFINED
#define MCS51REG_ERROR
#endif
#ifndef MICROCONTROLLER_DEFINED
#define MICROCONTROLLER_DEFINED
#endif
#ifdef MCS51REG_ENABLE_WARNINGS
#warning Selected HW: AT89S53
#endif
// 8051 register set
#define P0
#define SP
#define DPL
#define DPH
#define PCON__SMOD__x__x__x__GF1__GF0__PD__IDL
#define TCON
#define TMOD
#define TL0
#define TL1
#define TH0
#define TH1
#define P1
#define SCON
#define SBUF
#define P2
#define IE__EA__x__ET2__ES__ET1__EX1__ET0__EX0
#define P3
#define IP__x__x__PT2__PS__PT1__PX1__PT0__PX0
#define PSW
#define ACC
#define B
// 8052 specific registers
#define T2CON__TF2__EXF2__RCLK__TCLK__EXEN2__TR2__C_T2__CP_RL2
#define RCAP2L
#define RCAP2H
#define TL2
#define TH2
// AT89S53 specific register
#define T2MOD__x__x__x__x__x__x__T2OE__DCEN
#define P1_EXT__x__x__x__x__x__x__T2EX__T2
#define SPCR
#define SPDR
#define SPSR
#define WCOM
#define DPL1
#define DPH1
#endif
// end of definitions for the Atmel AT89S53 microcontroller


// definitions for the Atmel AT89C52 and AT89LV52 microcontrollers
#ifdef MICROCONTROLLER_AT89X52
#ifdef MICROCONTROLLER_DEFINED
#define MCS51REG_ERROR
#endif
#ifndef MICROCONTROLLER_DEFINED
#define MICROCONTROLLER_DEFINED
#endif
#ifdef MCS51REG_ENABLE_WARNINGS
#warning Selected HW: AT89C52 or AT89LV52
#endif
// 8051 register set
#define P0
#define SP
#define DPL
#define DPH
#define PCON__SMOD__x__x__x__GF1__GF0__PD__IDL
#define TCON
#define TMOD
#define TL0
#define TL1
#define TH0
#define TH1
#define P1
#define SCON
#define SBUF
#define P2
#define IE__EA__x__ET2__ES__ET1__EX1__ET0__EX0
#define P3
#define IP__x__x__PT2__PS__PT1__PX1__PT0__PX0
#define PSW
#define ACC
#define B
// 8052 specific registers
#define T2CON__TF2__EXF2__RCLK__TCLK__EXEN2__TR2__C_T2__CP_RL2
#define RCAP2L
#define RCAP2H
#define TL2
#define TH2
// AT89X55 specific register
#define T2MOD__x__x__x__x__x__x__T2OE__DCEN
#define P1_EXT__x__x__x__x__x__x__T2EX__T2
#endif
// end of definitions for the Atmel AT89C52 and AT89LV52 microcontrollers


// definitions for the Atmel AT89C55 and AT89LV55 microcontrollers
#ifdef MICROCONTROLLER_AT89X55
#ifdef MICROCONTROLLER_DEFINED
#define MCS51REG_ERROR
#endif
#ifndef MICROCONTROLLER_DEFINED
#define MICROCONTROLLER_DEFINED
#endif
#ifdef MCS51REG_ENABLE_WARNINGS
#warning Selected HW: AT89C55 or AT89LV55
#endif
// 8051 register set
#define P0
#define SP
#define DPL
#define DPH
#define PCON__SMOD__x__x__x__GF1__GF0__PD__IDL
#define TCON
#define TMOD
#define TL0
#define TL1
#define TH0
#define TH1
#define P1
#define SCON
#define SBUF
#define P2
#define IE__EA__x__ET2__ES__ET1__EX1__ET0__EX0
#define P3
#define IP__x__x__PT2__PS__PT1__PX1__PT0__PX0
#define PSW
#define ACC
#define B
// 8052 specific registers
#define T2CON__TF2__EXF2__RCLK__TCLK__EXEN2__TR2__C_T2__CP_RL2
#define RCAP2L
#define RCAP2H
#define TL2
#define TH2
// AT89X55 specific register
#define T2MOD__x__x__x__x__x__x__T2OE__DCEN
#define P1_EXT__x__x__x__x__x__x__T2EX__T2
#endif
// end of definitions for the Atmel AT89C55 and AT89LV55 microcontrollers


// definitions for the Dallas DS5000
#ifdef MICROCONTROLLER_DS5000
#ifdef MICROCONTROLLER_DEFINED
#define MCS51REG_ERROR
#endif
#ifndef MICROCONTROLLER_DEFINED
#define MICROCONTROLLER_DEFINED
#endif
#ifdef MCS51REG_ENABLE_WARNINGS
#warning Selected HW: DS5000
#endif
#define P0
#define SP
#define DPL
#define DPH
#define PCON__SMOD__POR__PFW__WTR__EPFW__EWT__STOP__IDL
#define TCON
#define TMOD
#define TL0
#define TL1
#define TH0
#define TH1
#define P1
#define SCON
#define SBUF
#define P2
#define IE__EA__x__x__ES__ET1__EX1__ET0__EX0
#define P3
#define IP__RWT__x__x__PS__PT1__PX1__PT0__PX0
#define MCON__PA3__PA2__PA1__PA0__RA32_8__ECE2__PAA__SL
#define TA
#define PSW
#define ACC
#define B
#endif
// end of definitions for the Dallas DS5000


// definitions for the Dallas DS5001
#ifdef MICROCONTROLLER_DS5001
#ifdef MICROCONTROLLER_DEFINED
#define MCS51REG_ERROR
#endif
#ifndef MICROCONTROLLER_DEFINED
#define MICROCONTROLLER_DEFINED
#endif
#ifdef MCS51REG_ENABLE_WARNINGS
#warning Selected HW: DS5001
#endif
#define P0
#define SP
#define DPL
#define DPH
#define PCON__SMOD__POR__PFW__WTR__EPFW__EWT__STOP__IDL
#define TCON
#define TMOD
#define TL0
#define TL1
#define TH0
#define TH1
#define P1
#define SCON
#define SBUF
#define P2
#define IE__EA__x__x__ES__ET1__EX1__ET0__EX0
#define P3
#define IP__RWT__x__x__PS__PT1__PX1__PT0__PX0
#define CRC
#define CRCLOW
#define CRCHIGH
#define MCON__PA3__PA2__PA1__PA0__RG1__PES__PM__SL
#define TA
#define RNR
#define PSW
#define RPCTL
#define STATUS__ST7__ST6__ST5__ST4__IA0__F0__IBF__OBF
#define ACC
#define B
#endif
// end of definitions for the Dallas DS5001


// definitions for the Dallas DS80C320 and DS80C323 microcontrollers
#ifdef MICROCONTROLLER_DS80C32X
#ifdef MICROCONTROLLER_DEFINED
#define MCS51REG_ERROR
#endif
#ifndef MICROCONTROLLER_DEFINED
#define MICROCONTROLLER_DEFINED
#endif
#ifdef MCS51REG_ENABLE_WARNINGS
#warning Selected HW: Dallas DS80C320 or DS80C323
#endif
// 8051 register set
#define P0
#define SP
#define DPL
#define DPH
#define PCON__SMOD__SMOD0__x__x__GF1__GF0__STOP__IDLE
#define TCON
#define TMOD
#define TL0
#define TL1
#define TH0
#define TH1
#define P1
#define SCON
#define SCON0
#define SBUF
#define P2
#define IE__EA__ES1__ET2__ES__ET1__EX1__ET0__EX0
#define P3
#define IP__x__PS1__PT2__PS__PT1_PX1__PT0__PX0
#define PSW
#define ACC
#define B
// 8052 specific registers
#define T2CON__TF2__EXF2__RCLK__TCLK__EXEN2__TR2__C_T2__CP_RL2
#define RCAP2L
#define RCAP2H
#define TL2
#define TH2
// DS80C320 specific register
#define DPL1
#define DPH1
#define DPS__x__x__x__x__x__x__x__SEL
#define CKCON__WD1__WD0__T2M__T1M__TOM__MD2__MD1__MD0
#define EXIF__IE5__IE4__IE3__IE2__x__RGMD__RGSL__BGS
#define SADDR0
#define SADDR1
#define SADEN0
#define SADEN1
#define SCON1
#define SBUF1
#define STATUS__PIP__HIP__LIP__x__x__x__x__x
#define TA
#define T2MOD__x__x__x__x__x__x__T2OE__DCEN
#define P1_EXT__INT5__INT4__INT3__INT2__TXD1__RXD1__T2EX__T2
#define WDCON
#define EIE__x__x__x__EWDI__EX5__EX4__EX3__EX2
#define EIP__x__x__x__PWDI__PX5__PX4__PX3__PX2
#endif
// end of definitions for the Dallas DS80C320 and DS80C323 microcontrollers


// definitions for the Dallas DS80C390
#ifdef MICROCONTROLLER_DS80C390
#ifdef MICROCONTROLLER_DEFINED
#define MCS51REG_ERROR
#endif
#ifndef MICROCONTROLLER_DEFINED
#define MICROCONTROLLER_DEFINED
#endif
#ifdef MCS51REG_ENABLE_WARNINGS
#warning Selected HW: Dallas DS80C390
#endif
// 8051 register set
#define P0
#define SP
#define DPL
#define DPH
#define PCON__SMOD__SMOD0__OFDF__OFDE__GF1__GF0__STOP__IDLE
#define TCON
#define TMOD
#define TL0
#define TL1
#define TH0
#define TH1
#define P1
#define SCON
#define SCON0
#define SBUF
#define P2
#define IE__EA__ES1__ET2__ES__ET1__EX1__ET0__EX0
#define P3
#define IP__x__PS1__PT2__PS__PT1_PX1__PT0__PX0
#define PSW
#define ACC
#define B
// 8052 specific registers
#define T2CON__TF2__EXF2__RCLK__TCLK__EXEN2__TR2__C_T2__CP_RL2
#define RCAP2L
#define RCAP2H
#define TL2
#define TH2
// DS80C390 specific register
#define P4_AT_0X80
#define DPL1
#define DPH1
#define DPS__ID1__ID0__TSL__x__x__x__x__SEL
#define CKCON__WD1__WD0__T2M__T1M__TOM__MD2__MD1__MD0
#define EXIF__IE5__IE4__IE3__IE2__CKRY__RGMD__RGSL__BGS
#define P4CNT
#define DPX
#define DPX1
#define C0RMS0
#define C0RMS1
#define ESP
#define AP
#define ACON__x__x__x__x__x__SA__AM1__AM0
#define C0TMA0
#define C0TMA1
#define P5_AT_0XA1
#define P5CNT
#define C0C
#define C0S
#define C0IR
#define C0TE
#define C0RE
#define SADDR0
#define SADDR1
#define C0M1C
#define C0M2C
#define C0M3C
#define C0M4C
#define C0M5C
#define C0M6C
#define C0M7C
#define C0M8C
#define C0M9C
#define C0M10C
#define SADEN0
#define SADEN1
#define C0M11C
#define C0M12C
#define C0M13C
#define C0M14C
#define C0M15C
#define SCON1
#define SBUF1
#define PMR__CD1__CD0__SWB__CTM__4X_2X__ALEOFF__x__x
#define STATUS__PIP__HIP__LIP__x__SPTA1__SPRA1__SPTA0__SPRA0
#define MCON__IDM1__IDM0__CMA__x__PDCE3__PDCE2__PDCE1__PDCE0
#define TA
#define T2MOD__x__x__x__D13T1__D13T2__x__T2OE__DCEN
#define COR
#define MCNT0
#define MCNT1
#define MA
#define MB
#define MC
#define C1RSM0
#define C1RSM1
#define WDCON
#define C1TMA0
#define C1TMA1
#define C1C
#define C1S
#define C1IR
#define C1TE
#define C1RE
#define EIE__CANBIE__C0IE__C1IE__EWDI__EX5__EX4__EX3__EX2
#define MXMAX
#define C1M1C
#define C1M2C
#define C1M3C
#define C1M4C
#define C1M5C
#define C1M6C
#define C1M7C
#define C1M8C
#define C1M9C
#define EIP__CANBIP__C0IP__C1IP__PWDI__PX5__PX4__PX3__PX2__PX1__PX0
#define C1M10C
#define C1M11C
#define C1M12C
#define C1M13C
#define C1M14C
#define C1M15C
#define P1_EXT__INT5__INT4__INT3__INT2__TXD1__RXD1__T2EX__T2
#endif
// end of definitions for the Dallas DS80C390

// definitions for the Dallas DS89C420 microcontroller
#ifdef MICROCONTROLLER_DS89C420
#ifdef MICROCONTROLLER_DEFINED
#define MCS51REG_ERROR
#endif
#ifndef MICROCONTROLLER_DEFINED
#define MICROCONTROLLER_DEFINED
#endif
#ifdef MCS51REG_ENABLE_WARNINGS
#warning Selected HW: Dallas DS89C420
#endif
// 8051 register set
#define P0
#define SP
#define DPL
#define DPH
#define PCON__SMOD__SMOD0__OFDF__OFDE__GF1__GF0__STOP__IDLE
#define TCON
#define TMOD
#define TL0
#define TL1
#define TH0
#define TH1
#define P1
#define SCON
#define SCON0
#define SBUF
#define P2
#define IE__EA__ES1__ET2__ES__ET1__EX1__ET0__EX0
#define P3
#define IP__x__PS1__PT2__PS__PT1_PX1__PT0__PX0
#define PSW
#define ACC
#define B
// 8052 specific registers
#define T2CON__TF2__EXF2__RCLK__TCLK__EXEN2__TR2__C_T2__CP_RL2
#define RCAP2L
#define RCAP2H
#define TL2
#define TH2
// DS8XC420 specific registers
#define ACON__PAGEE__PAGES1__PAGES0__x__x__x__x__x
#define DPL1
#define DPH1
#define DPS__ID1__ID0__TSL__AID__x__x__x__SEL
#define CKCON__WD1__WD0__T2M__T1M__TOM__MD2__MD1__MD0
#define CKMOD
#define IP0__x__LPS1__LPT2__LPS0__LPT1__LPX1__LPT0__LPX0
#define IP1__x__MPS1__MPT2__MPS0__MPT1__MPX1__MPT0__MPX0
#define EXIF__IE5__IE4__IE3__IE2__CKRY__RGMD__RGSL__BGS
#define PMR__CD1__CD0__SWB__CTM__4X_2X__ALEON__DME1__DME0
#define SADDR0
#define SADDR1
#define SADEN0
#define SADEN1
#define SCON1
#define SBUF1
#define STATUS__PIS2__PIS1__PIS0__x__SPTA1__SPRA1__SPTA0__SPRA0
#define TA
#define T2MOD__x__x__x__x__x__x__T2OE__DCEN
#define P1_EXT__INT5__INT4__INT3__INT2__TXD1__RXD1__T2EX__T2
#define ROMSIZE__x__x__x__x__PRAME__RMS2__RMS1__RMS0
#define WDCON
#define EIE__x__x__x__EWDI__EX5__EX4__EX3__EX2
#define EIP0__x__x__x__LPWDI__LPX5__LPX4__LPX3__LPX2
#define EIP1__x__x__x__MPWDI__MPX5__MPX4__MPX3__MPX2
#define FCNTL__FBUSY__FERR__x__x__FC3__FC2__FC1__FC0
#endif
// end of definitions for the Dallas DS89C420 microcontroller

// definitions for the Dallas DS87C520 and DS83C520 microcontrollers
#ifdef MICROCONTROLLER_DS8XC520
#ifdef MICROCONTROLLER_DEFINED
#define MCS51REG_ERROR
#endif
#ifndef MICROCONTROLLER_DEFINED
#define MICROCONTROLLER_DEFINED
#endif
#ifdef MCS51REG_ENABLE_WARNINGS
#warning Selected HW: Dallas DS87C520 or DS85C520
#endif
// 8051 register set
#define P0
#define SP
#define DPL
#define DPH
#define PCON__SMOD__SMOD0__x__x__GF1__GF0__STOP__IDLE
#define TCON
#define TMOD
#define TL0
#define TL1
#define TH0
#define TH1
#define P1
#define SCON
#define SCON0
#define SBUF
#define P2
#define IE__EA__ES1__ET2__ES__ET1__EX1__ET0__EX0
#define P3
#define IP__x__PS1__PT2__PS__PT1_PX1__PT0__PX0
#define PSW
#define ACC
#define B
// 8052 specific registers
#define T2CON__TF2__EXF2__RCLK__TCLK__EXEN2__TR2__C_T2__CP_RL2
#define RCAP2L
#define RCAP2H
#define TL2
#define TH2
// DS8XC520 specific registers
#define DPL1
#define DPH1
#define DPS__x__x__x__x__x__x__x__SEL
#define CKCON__WD1__WD0__T2M__T1M__TOM__MD2__MD1__MD0
#define EXIF__IE5__IE4__IE3__IE2__XT_RG__RGMD__RGSL__BGS
#define PMR__CD1__CD0__SWB__x__XTOFF__ALEOFF__DME1__DME0
#define SADDR0
#define SADDR1
#define SADEN0
#define SADEN1
#define SCON1
#define SBUF1
#define STATUS__PIP__HIP__LIP__XTUP__SPTA2__SPTA1__SPTA0__SPRA0
#define TA
#define T2MOD__x__x__x__x__x__x__T2OE__DCEN
#define P1_EXT__INT5__INT4__INT3__INT2__TXD1__RXD1__T2EX__T2
#define WDCON
#define ROMSIZE__x__x__x__x__x__RMS2__RMS1__RMS0
#define BP2
#define WDCON
#define EIE__x__x__x__EWDI__EX5__EX4__EX3__EX2
#define EIP__x__x__x__PWDI__PX5__PX4__PX3__PX2
#endif
// end of definitions for the Dallas DS87C520 and DS83C520 microcontrollers


// definitions for the Philips P80C552 microcontroller
#ifdef MICROCONTROLLER_P80C552
#ifdef MICROCONTROLLER_DEFINED
#define MCS51REG_ERROR
#endif
#ifndef MICROCONTROLLER_DEFINED
#define MICROCONTROLLER_DEFINED
#endif
#ifdef MCS51REG_ENABLE_WARNINGS
#warning Selected HW: Philips P80C552
#endif
// 8051 register set
#define P0
#define SP
#define DPL
#define DPH
#define PCON__SMOD__x__x__WLE__GF1__GF0__PD__IDL
#define TCON
#define TMOD
#define TL0
#define TL1
#define TH0
#define TH1
#define P1
#define SCON
#define SBUF
#define P2
#define IE__EA__EAD__ES1__ES0__ET1__EX1__ET0__EX0
#define P3
#define IP__x__PAD__PS1__PS0__PT1__PX1__PT0__PX0
#define PSW
#define ACC
#define B
// P80C552 specific register-names
#define S0BUF           // same as SBUF, set in mcs51reg.h
#define S0CON__SM0__SM1__SM2__REN__TB8__RB8__TI__RI
// P80C552 specific registers
#define ADCH_AT_0XC6
#define ADCON__ADC_1__ADC_0__ADEX__ADCI__ADCS__AADR2__AADR1__AADR0
#define CTCON__CTN3__CTP3__CTN2__CTP2__CTN1__CTP1__CTN0__CTP0
#define CTH0_AT_0XCC
#define CTH1_AT_0XCD
#define CTH2_AT_0XCE
#define CTH3_AT_0XCF
#define CMH0_AT_0XC9
#define CMH1_AT_0XCA
#define CMH2_AT_0XCB
#define CTL0_AT_0XAC
#define CTL1_AT_0XAD
#define CTL2_AT_0XAE
#define CTL3_AT_0XAF
#define CML0_AT_0XA9
#define CML1_AT_0XAA
#define CML2_AT_0XAB
#define IEN1__ET2__ECM2__ECM1__ECM0__ECT3__ECT2__ECT1__ECT0
#define IP1__PT2__PCM2__PCM1__PCM0__PCT3__PCT2__PCT1__PCT0
#define PWM0_AT_0XFC
#define PWM1_AT_0XFD
#define PWMP_AT_0XFE
#define P1_EXT__SDA__SCL__RT2__T2__CT3I__CT2I__CT1I__CT0I
#define P4_AT_0XC0__CMT0__CMT1__CMSR5__CMSR4__CMSR3__CMSR2__CMSR1__CMSR0
#define P5_AT_0XC4
#define RTE__TP47__TP46__RP45__RP44__RP43__RP42__RP41__RP40
#define S1ADR__x__x__x__x__x__x__x__GC
#define S1DAT_AT_0XDA
#define S1STA__SC4__SC3__SC2__SC1__SC0__x__x__x
#define S1CON__CR2__ENS1__STA__ST0__SI__AA__CR1__CR0
#define STE__TG47__TG46__SP45__SP44__SP43__SP42__SP41__SP40
#define TMH2_AT_0XED
#define TML2_AT_0XEC
#define TM2CON__T2IS1__T2IS0__T2ER__T2B0__T2P1__T2P0__T2MS1__T2MS0
#define TM2IR__T20V__CMI2__CMI1__CMI0__CTI3__CTI2__CTI1__CTI0
#define T3_AT_0XFF
#endif
// end of definitions for the Philips P80C552 microcontroller


// definitions for the Philips P89C668
#ifdef MICROCONTROLLER_P89C668
#ifdef MICROCONTROLLER_DEFINED
#define MCS51REG_ERROR
#endif
#ifndef MICROCONTROLLER_DEFINED
#define MICROCONTROLLER_DEFINED
#endif
#ifdef MCS51REG_ENABLE_WARNINGS
#warning Selected HW: P89C668
#endif
#define P0
#define P0_EXT__AD7__AD6__AD5__AD4__AD3__AD2__AD1__AD0
#define P1
#define P1_EXT__SDA__SCL__CEX2__CEX1__CEX0__ECI__T2EX__T2
#define P2
#define P2_EXT__AD15__AD14__AD13__AD12__AD11__AD10__AD9__AD8
#define P3
#define P3_EXT__x__x__CEX4__CEX3__x__x__x__x
#define SP
#define DPL
#define DPH
#define TCON
#define TMOD
#define PCON__SMOD1__SMOD0__x__POF__GF1__GF0__PD__IDL
#define TL0
#define TL1
#define TH0
#define TH1
#define SCON
#define S0CON__SM0__SM1__SM2__REN__TB8__RB8__TI__RI
#define S1CON__CR2__ENS1__STA__ST0__SI__AA__CR1__CR0
#define SBUF
#define S0BUF SBUF
#define PSW
#define ACC
#define B
#define SADR_AT_0XA9
#define SADEN_AT_0XB9
#define S1IST_AT_0XDC
#define S1STA__SC4__SC3__SC2__SC1__SC0__x__x__x
#define S1DAT_AT_0XDA
#define S1ADR__x__x__x__x__x__x__x__GC
#define SBUF
#define T2CON__TF2__EXF2__RCLK__TCLK__EXEN2__TR2__C_T2__CP_RL2
#define T2MOD__x__x__x__x__x__x__T2OE__DCEN
#define RCAP2L
#define RCAP2H
#define TL2
#define TH2
#define IEN0__EA__EC__ES1__ES0__ET1__EX1__ET0__EX0
#define IEN1__x__x__x__x__x__x__x__ET2
#define IP__PT2__PPC__PS1__PS0__PT1__PX1__PT0__PX0
#define IPH__PT2H__PPCH__PS1H__PS0H__PT1H__PX1H__PT0H__PX0H
#define CCON__CF__CR__x__CCF4__CCF3__CCF2__CCF1__CCF0
#define CMOD__CIDL__WDTE__x__x__x__CPS1__CPS0__ECF
#define AUXR__x__x__x__x__x__x__EXTRAM__A0
#define AUXR1__x__x__ENBOOT__x__GF2__0__x__DPS
#define WDTRST_AT_0XA6
#define CCAPM0_AT_0XC2
#define CCAPM1_AT_0XC3
#define CCAPM2_AT_0XC4
#define CCAPM3_AT_0XC5
#define CCAPM4_AT_0XC6
#define CCAP0L_AT_0XEA
#define CCAP1L_AT_0XEB
#define CCAP2L_AT_0XEC
#define CCAP3L_AT_0XED
#define CCAP4L_AT_0XEE
#define CH_AT_0XF9
#define CL_AT_0XE9
#define CCAP0H_AT_0XFA
#define CCAP1H_AT_0XFB
#define CCAP2H_AT_0XFC
#define CCAP3H_AT_0XFD
#define CCAP4H_AT_0XFE
#endif
// end of definitions for the Philips P89C668


// definitions for the Infineon / Siemens SAB80509
#ifdef MICROCONTROLLER_SAB80509
#ifdef MICROCONTROLLER_DEFINED
#define MCS51REG_ERROR
#endif
#ifndef MICROCONTROLLER_DEFINED
#define MICROCONTROLLER_DEFINED
#endif
#ifdef MCS51REG_ENABLE_WARNINGS
#warning Selected HW: Infineon / Siemens SAB80509
#endif
// 8051 register set without IP
#define P0
#define SP
#define DPL
#define DPH
#define PCON__SMOD__PDS__IDLS__x__x__x__PD__IDL
#define TCON
#define TMOD
#define TL0
#define TL1
#define TH0
#define TH1
#define WDTREL
#define P1
#define XPAGE
#define S0CON__SM0__SM1__SM20__REN0__TB80__RB80__TI0__RI0
#define IEN2__SAB80517

#define P2
#define IE__EA_WDT_ET2_ES_ET1_EX1_ET0_EX0
#define IP0__x__WDTS__IP0_5__IP0_4__IP0_3__IP0_2__IP0_1__IP0_0

#define P3
#define SYSCON
#define IEN1__EXEN2__SWDT__EX6__EX5__EX4__EX3__EX2__EADC
#define IP1__x__x__IP1_5__IP1_4__IP1_3__IP1_2__IP1_1__IP1_0

#define IRCON
#define CCEN
#define CCL1
#define CCH1
#define CCL2
#define CCH2
#define CCL3
#define CCH3
#define CCL4
#define CCH4
#define CC4EN
#define S0RELH
#define S0RELL
#define S1BUF
#define S1CON_AT_0X9B
#define S1RELH
#define S1RELL
#define T2CON__T2PS__I3FR__I2FR__T2R1__T2R0__T2CM__T2I1__T2I0

#define PSW
#define CMEN
#define CMH0
#define CML0
#define CMH1
#define CML1
#define CMH2
#define CML2
#define CMH3
#define CML3
#define CMH4
#define CML4
#define CMH5
#define CML5
#define CMH6
#define CML6
#define CMH7
#define CML7
#define CMSEL
#define CRCL
#define CRCH
#define CTCOM_AT_0XE1
#define CTRELH
#define CTRELL
#define TL2
#define TH2
#define ADCON0
#define ADCON1
#define ADDATH
#define ADDATL

#define P4_AT_0XE8
#define DPSEL
#define ARCON
#define MD0
#define MD1
#define MD2
#define MD3
#define MD4
#define MD5
#define S0BUF

#define ACC

#define B

#define P5_AT_0XF8
#define P6_AT_0XFA
#define P7
#define P8

#define COMSETL
#define COMSETH
#define COMCLRL
#define COMCLRH
#define SETMSK
#define CLRMSK
#define SYSCON1
#define FMODE
#define PRSC
#define CT1COM
#define IEN3
#define IRCON2
#define EICC1
#define CC1
#define CC2
#define CC3
#define CC4
#define CCR
#define T2
#define P9_AT_0XF9
#endif
// end of definitions for the Infineon / Siemens SAB80509


// definitions for the Infineon / Siemens SAB80515 & SAB80535
#ifdef MICROCONTROLLER_SAB80515
#ifdef MICROCONTROLLER_DEFINED
#define MCS51REG_ERROR
#endif
#ifndef MICROCONTROLLER_DEFINED
#define MICROCONTROLLER_DEFINED
#endif
#ifdef MCS51REG_ENABLE_WARNINGS
#warning Selected HW: Infineon / Siemens SAB80515 & SAB80535
#endif
// 8051 register set without IP
#define P0
#define SP
#define DPL
#define DPH
#define PCON__SMOD__x__x__x__x__x__x__x
#define TCON
#define TMOD
#define TL0
#define TL1
#define TH0
#define TH1
#define P1
#define SCON
#define SBUF
#define P2
#define IE__EA_WDT_ET2_ES_ET1_EX1_ET0_EX0
#define P3
#define PSW
#define ACC
#define B
// SAB80515 specific registers
#define P1_EXT__T2__CLKOUT__T2EX__INT2__INT6_CC3__INT5_CC2__INT4_CC1__INT3_CC0
#define IP0__x__WDTS__IP0_5__IP0_4__IP0_3__IP0_2__IP0_1__IP0_0
#define IEN1__EXEN2__SWDT__EX6__EX5__EX4__EX3__EX2__EADC
#define IRCON
#define CCEN
#define CCL1
#define CCH1
#define CCL2
#define CCH2
#define CCL3
#define CCH3
#define T2CON__T2PS__I3FR__I2FR__T2R1__T2R0__T2CM__T2I1__T2I0
#define CRCL
#define CRCH
#define TL2
#define TH2
#define ADCON
#define ADDAT
#define DAPR__SAB80515
#define P4_AT_0XE8
#define P5_AT_0XF8
#define P6_AT_0XDB
#endif
// end of definitions for the Infineon / Siemens SAB80515


// definitions for the Infineon / Siemens SAB80515A
#ifdef MICROCONTROLLER_SAB80515A
#ifdef MICROCONTROLLER_DEFINED
#define MCS51REG_ERROR
#endif
#ifndef MICROCONTROLLER_DEFINED
#define MICROCONTROLLER_DEFINED
#endif
#ifdef MCS51REG_ENABLE_WARNINGS
#warning Selected HW: Infineon / Siemens SAB80515A
#endif
// 8051 register set without IP
#define P0
#define SP
#define DPL
#define DPH
#define PCON__SMOD__PDS__IDLS__x__x__x__PD__IDL
#define TCON
#define TMOD
#define TL0
#define TL1
#define TH0
#define TH1
#define P1
#define SCON
#define SBUF
#define P2
#define IE__EA_WDT_ET2_ES_ET1_EX1_ET0_EX0
#define P3
#define PSW
#define ACC
#define B
// SAB80515A specific registers
#define P1_EXT__T2__CLKOUT__T2EX__INT2__INT6_CC3__INT5_CC2__INT4_CC1__INT3_CC0
#define IP0__x__WDTS__IP0_5__IP0_4__IP0_3__IP0_2__IP0_1__IP0_0
#define IP1__x__x__IP1_5__IP1_4__IP1_3__IP1_2__IP1_1__IP1_0
#define IEN1__EXEN2__SWDT__EX6__EX5__EX4__EX3__EX2__EADC
#define IRCON
#define CCEN
#define CCL1
#define CCH1
#define CCL2
#define CCH2
#define CCL3
#define CCH3
#define T2CON__T2PS__I3FR__I2FR__T2R1__T2R0__T2CM__T2I1__T2I0
#define CRCL
#define CRCH
#define TL2
#define TH2
#define ADCON0
#define ADDATH
#define ADDATL
#define ADCON1
#define SRELL
#define SYSCON
#define SRELH
#define P4_AT_0XE8
#define P5_AT_0XF8
#define P6_AT_0XDB
#define XPAGE
#endif
// end of definitions for the Infineon / Siemens SAB80515A


// definitions for the Infineon / Siemens SAB80517
#ifdef MICROCONTROLLER_SAB80517
#ifdef MICROCONTROLLER_DEFINED
#define MCS51REG_ERROR
#endif
#ifndef MICROCONTROLLER_DEFINED
#define MICROCONTROLLER_DEFINED
#endif
#ifdef MCS51REG_ENABLE_WARNINGS
#warning Selected HW: Infineon / Siemens SAB80517
#endif
// 8051 register set without IP, SCON & SBUF
#define P0
#define SP
#define DPL
#define DPH
#define PCON__SMOD__PDS__IDLS__x__x__x__PD__IDL
#define TCON
#define TMOD
#define TL0
#define TL1
#define TH0
#define TH1
#define P1
// #define SCON
// #define SBUF
#define P2
#define IE__EA_WDT_ET2_ES_ET1_EX1_ET0_EX0
#define P3
#define PSW
#define ACC
#define B
// SAB80517 specific registers
#define P1_EXT__T2__CLKOUT__T2EX__INT2__INT6_CC3__INT5_CC2__INT4_CC1__INT3_CC0
#define IP0__x__WDTS__IP0_5__IP0_4__IP0_3__IP0_2__IP0_1__IP0_0
#define IP1__x__x__IP1_5__IP1_4__IP1_3__IP1_2__IP1_1__IP1_0
#define IEN1__EXEN2__SWDT__EX6__EX5__EX4__EX3__EX2__EADC
#define IEN2__SAB80517
#define IRCON
#define CCEN
#define CCL1
#define CCH1
#define CCL2
#define CCH2
#define CCL3
#define CCH3
#define CCL4
#define CCH4
#define CC4EN
#define CMEN
#define CMH0
#define CML0
#define CMH1
#define CML1
#define CMH2
#define CML2
#define CMH3
#define CML3
#define CMH4
#define CML4
#define CMH5
#define CML5
#define CMH6
#define CML6
#define CMH7
#define CML7
#define CMSEL
#define T2CON__T2PS__I3FR__I2FR__T2R1__T2R0__T2CM__T2I1__T2I0
#define CRCL
#define CRCH
#define CTCOM_AT_0XE1
#define CTRELH
#define CTRELL
#define TL2
#define TH2
#define ADCON0
#define ADCON1
#define ADDAT
#define DAPR__SAB80517
#define P4_AT_0XE8
#define P5_AT_0XF8
#define P6_AT_0XFA
#define P7_AT_0XDB
#define P8_AT_0XDD
#define DPSEL
#define ARCON
#define MD0
#define MD1
#define MD2
#define MD3
#define MD4
#define MD5
#define S0BUF
#define S0CON__SM0__SM1__SM20__REN0__TB80__RB80__TI0__RI0
#define S0RELH
#define S0RELL
#define S1BUF
#define S1CON_AT_0X9B
#define S1RELH
#define S1RELL
#define WDTH
#define WDTL
#define WDTREL
#endif
// end of definitions for the Infineon / Siemens SAB80517


// definitions for the Atmel T89C51RD2
#ifdef MICROCONTROLLER_T89C51RD2
#ifdef MICROCONTROLLER_DEFINED
#define MCS51REG_ERROR
#endif
#ifndef MICROCONTROLLER_DEFINED
#define MICROCONTROLLER_DEFINED
#endif
#ifdef MCS51REG_ENABLE_WARNINGS
#warning Selected HW: T89C51RD2
#endif

// 8051 register set
#define P0
#define SP
#define DPL
#define DPH
#define PCON__SMOD1__SMOD0__x__POF__GF1__GF0__PD__IDL
#define TCON
#define TMOD
#define TL0
#define TL1
#define TH0
#define TH1
#define P1
#define SCON
#define SBUF
#define P2
#define IE__EA__EC__ET2__ES__ET1__EX1__ET0__EX0
#define SADDR
#define P3
#define IP__x__PPC__PT2__PS__PT1__PX1__PT0__PX0
#define PSW
#define ACC
#define B

// 8052 register set
#define T2CON__TF2__EXF2__RCLK__TCLK__EXEN2__TR2__C_T2__CP_RL2
#define RCAP2L
#define RCAP2H
#define TL2
#define TH2

// T89C51RD2 register set
#define P4_AT_0XC0__P4_7__P4_6__P4_5__P4_3__P4_2__P4_1__P4_0
#define P5_AT_0XE8
#define SADEN0

#define AUXR1__x__x__x__x__GF3__x__x__DPS
#define WDTRST_AT_0XA6
#define WDTPRG_AT_0XA7
#define AUXR__x__x__M0__x__XRS1__XRS0__EXTRAM__A0
#define IPH__x__PPCH__PT2H__PSH__PT1H__PX1H__PT0H__PX0H
#define FCON
#define EECON
#define EETIM
#define CKCON__X2__T0X2__T1X2__T2X2__SiX2__PcaX2__WdX2__x
#define CCON__0xD8__CF__CR__x__CCF4__CCF3__CCF2__CCF1__CCF0
#define CMOD__0xD9__CIDL__WDTE__x__x__x__CPS1__CPS0__ECF
#define CCAPM0_AT_0XDA
#define CCAPM1_AT_0XDB
#define CCAPM2_AT_0XDC
#define CCAPM3_AT_0XDD
#define CCAPM4_AT_0XDE
#define CL_AT_0XE9
#define CCAP0L_AT_0XEA
#define CCAP1L_AT_0XEB
#define CCAP2L_AT_0XEC
#define CCAP3L_AT_0XED
#define CCAP4L_AT_0XEE
#define CH_AT_0XF9
#define CCAP0H_AT_0XFA
#define CCAP1H_AT_0XFB
#define CCAP2H_AT_0XFC
#define CCAP3H_AT_0XFD
#define CCAP4H_AT_0XFE
#endif /* MICROCONTROLLER_T89C51RD2 */
/* end of definition for the Atmel T89C51RD2 */


/////////////////////////////////////////////////////////
///  don't specify microcontrollers below this line!  ///
/////////////////////////////////////////////////////////


// default microcontroller -> 8051
// use default if no microcontroller specified
#ifndef MICROCONTROLLER_DEFINED
#define MICROCONTROLLER_DEFINED
#ifdef MCS51REG_ENABLE_WARNINGS
#warning No microcontroller defined!
#warning Code generated for the 8051
#endif
// 8051 register set
#define P0
#define SP
#define DPL
#define DPH
#define PCON__SMOD__x__x__x__GF1__GF0__PD__IDL
#define TCON
#define TMOD
#define TL0
#define TL1
#define TH0
#define TH1
#define P1
#define SCON
#define SBUF
#define P2
#define IE__EA__x__x__ES__ET1__EX1__ET0__EX0
#define P3
#define IP__x__x__x__PS__PT1__PX1__PT0__PX0
#define PSW
#define ACC
#define B
#endif
// end of definitions for the default microcontroller


#ifdef MCS51REG_ERROR
#error Two or more microcontrollers defined!
#endif

#ifdef MCS51REG_EXTERNAL_ROM
#ifndef MCS51REG_UNDEFINE_P0
#define MCS51REG_UNDEFINE_P0
#endif
#ifndef MCS51REG_UNDEFINE_P2
#define MCS51REG_UNDEFINE_P2
#endif
#endif

#ifdef MCS51REG_EXTERNAL_RAM
#ifndef MCS51REG_UNDEFINE_P0
#define MCS51REG_UNDEFINE_P0
#endif
#ifndef MCS51REG_UNDEFINE_P2
#define MCS51REG_UNDEFINE_P2
#endif
#endif

#ifdef MCS51REG_UNDEFINE_P0
#undef P0
#endif

#ifdef MCS51REG_UNDEFINE_P2
#undef P2
#endif

////////////////////////////////
///  Register definitions    ///
///  (In alphabetical order) ///
////////////////////////////////

#ifdef ACC
#undef ACC
__sfr __at 0xE0 ACC         ;
#endif

#ifdef ACON__PAGEE__PAGES1__PAGES0__x__x__x__x__x
#undef ACON__PAGEE__PAGES1__PAGES0__x__x__x__x__x
__sfr __at 0x9D ACON        ; // DS89C420 specific
// Not directly accessible bits
#define PAGES0      0x20
#define PAGES1      0x40
#define PAGEE       0x80
#endif

#ifdef ACON__x__x__x__x__x__SA__AM1__AM0
#undef ACON__x__x__x__x__x__SA__AM1__AM0
__sfr __at 0x9D ACON        ; // DS89C390 specific
// Not directly accessible bits
#define AM0         0x01
#define AM1         0x02
#define SA          0x04
#endif

#ifdef ADCH_AT_0XC6
#undef ADCH_AT_0XC6
__sfr __at 0xC6 ADCH        ; // A/D converter high
#endif

#ifdef ADCON
#undef ADCON
__sfr __at 0xD8 ADCON       ; // A/D-converter control register SAB80515 specific
// Bit registers
__sbit __at 0xD8 MX0        ;
__sbit __at 0xD9 MX1        ;
__sbit __at 0xDA MX2        ;
__sbit __at 0xDB ADM        ;
__sbit __at 0xDC BSY        ;
__sbit __at 0xDE CLK        ;
__sbit __at 0xDF BD         ;
#endif

// ADCON0 ... Infineon / Siemens also called this register ADCON in the User Manual
#ifdef ADCON0
#undef ADCON0
__sfr __at 0xD8 ADCON0      ; // A/D-converter control register 0 SAB80515A &
// Bit registers          // SAB80517 specific
__sbit __at 0xD8 MX0        ;
__sbit __at 0xD9 MX1        ;
__sbit __at 0xDA MX2        ;
__sbit __at 0xDB ADM        ;
__sbit __at 0xDC BSY        ;
__sbit __at 0xDD ADEX       ;
__sbit __at 0xDE CLK        ;
__sbit __at 0xDF BD         ;
// Not directly accessible ADCON0
#define ADCON0_MX0  0x01
#define ADCON0_MX1  0x02
#define ADCON0_MX2  0x04
#define ADCON0_ADM  0x08
#define ADCON0_BSY  0x10
#define ADCON0_ADEX 0x20
#define ADCON0_CLK  0x40
#define ADCON0_BD   0x80
#endif

#ifdef ADCON1
#undef ADCON1
__sfr __at 0xDC ADCON1      ; // A/D-converter control register 1 SAB80515A & SAB80517 specific
// Not directly accessible ADCON1
#define ADCON1_MX0  0x01
#define ADCON1_MX1  0x02
#define ADCON1_MX2  0x04
#define ADCON1_ADCL 0x80
#endif

#ifdef ADCON__ADC_1__ADC_0__ADEX__ADCI__ADCS__AADR2__AADR1__AADR0
#undef ADCON__ADC_1__ADC_0__ADEX__ADCI__ADCS__AADR2__AADR1__AADR0
__sfr __at 0xC5 ADCON       ; // A/D control, P80C552 specific
// Not directly accessible Bits.
#define AADR0       0x01
#define AADR1       0x02
#define AADR2       0x04
#define ADCS        0x08
#define ADCI        0x10
#define ADEX        0x20
#define ADC_0       0x40    // different name as ADC0 in P5
#define ADC_1       0x80    // different name as ADC1 in P5
#endif

#ifdef ADDAT
#undef ADDAT
__sfr __at 0xD9 ADDAT       ; // A/D-converter data register SAB80515 specific
#endif

#ifdef ADDATH
#undef ADDATH
__sfr __at 0xD9 ADDATH      ; // A/D data high byte SAB80515A specific
#endif

#ifdef ADDATL
#undef ADDATL
__sfr __at 0xDA ADDATL      ; // A/D data low byte SAB80515A specific
#endif

#ifdef ARCON
#undef ARCON
__sfr __at 0xEF ARCON       ; // arithmetic control register SAB80517
#endif

#ifdef AP
#undef AP
__sfr __at 0x9C AP          ; // DS80C390
#endif

#ifdef AUXR__x__x__x__x__x__x__EXTRAM__A0
#undef AUXR__x__x__x__x__x__x__EXTRAM__A0
// P89C668 specific, Auxilary
__sfr __at 0x8E AUXR        ;
// not bit addressable:
#define EXTRAM      0x02
#define A0          0x01
#endif

#ifdef AUXR__x__x__M0__x__XRS1__XRS0__EXTRAM__A0
#undef AUXR__x__x__M0__x__XRS1__XRS0__EXTRAM__A0
__sfr __at 0x8E AUXR        ;
#define AO          0x01
#define EXTRAM      0x02
#define XRS0        0x04
#define XRS1        0x08
#define M0          0x20
#endif
#ifdef B
#undef B
__sfr __at 0xF0 B           ;
// Bit registers
__sbit __at 0xF0 BREG_F0    ;
__sbit __at 0xF1 BREG_F1    ;
__sbit __at 0xF2 BREG_F2    ;
__sbit __at 0xF3 BREG_F3    ;
__sbit __at 0xF4 BREG_F4    ;
__sbit __at 0xF5 BREG_F5    ;
__sbit __at 0xF6 BREG_F6    ;
__sbit __at 0xF7 BREG_F7    ;
#endif

#ifdef AUXR1__x__x__x__x__GF3__x__x__DPS
#undef AUXR1__x__x__x__x__GF3__x__x__DPS
__sfr __at 0xA2 AUXR1       ;
#define DPS         0x01
#define GF3         0x08
#endif

#ifdef AUXR1__x__x__ENBOOT__x__GF2__0__x__DPS
#undef AUXR1__x__x__ENBOOT__x__GF2__0__x__DPS
// P89C668 specific, Auxilary 1
__sfr __at 0xA2 AUXR1       ;
#define ENBOOT      0x20
#define GF2         0x08
#define ALWAYS_ZERO 0x04
#define DPS         0x01
#endif

#ifdef BP2
#undef BP2
__sfr __at 0xC3 BP2         ;
// Not directly accessible bits
#define MS0         0x01
#define MS1         0x02
#define MS2         0x04
#define LB1         0x08
#define LB2         0x10
#define LB3         0x20
#endif

#ifdef C0C
#undef C0C
__sfr __at 0xA3 C0C         ; // DS80C390 specific
// Not directly accessible bits
#define SWINT       0x01
#define ERCS        0x02
#define AUTOB       0x04
#define CRST        0x08
#define SIESTA      0x10
#define PDE         0x20
#define STIE        0x40
#define ERIE        0x80
#endif

#ifdef C0IR
#undef C0IR
__sfr __at 0xA5 C0IR        ; // DS80C390 specific
// Not directly accessible bits
#define INTIN0      0x01
#define INTIN1      0x02
#define INTIN2      0x04
#define INTIN3      0x08
#define INTIN4      0x10
#define INTIN5      0x20
#define INTIN6      0x40
#define INTIN7      0x80
#endif

#ifdef C0M1C
#undef C0M1C
__sfr __at 0xAB C0M1C       ; // DS80C390 specific
// Not directly accessible bits
#define DTUP        0x01
#define ROW_TIH     0x02
#define MTRQ        0x04
#define EXTRQ       0x08
#define INTRQ       0x10
#define ERI         0x20
#define ETI         0x40
#define MSRDY       0x80
#endif

#ifdef C0M2C
#undef C0M2C
__sfr __at 0xAC C0M2C       ; // DS80C390 specific
#endif

#ifdef C0M3C
#undef C0M3C
__sfr __at 0xAD C0M3C       ; // DS80C390 specific
#endif

#ifdef C0M4C
#undef C0M4C
__sfr __at 0xAE C0M4C       ; // DS80C390 specific
#endif

#ifdef C0M5C
#undef C0M5C
__sfr __at 0xAF C0M5C       ; // DS80C390 specific
#endif

#ifdef C0M6C
#undef C0M6C
__sfr __at 0xB3 C0M6C       ; // DS80C390 specific
#endif

#ifdef C0M7C
#undef C0M7C
__sfr __at 0xB4 C0M7C       ; // DS80C390 specific
#endif

#ifdef C0M8C
#undef C0M8C
__sfr __at 0xB5 C0M8C       ; // DS80C390 specific
#endif

#ifdef C0M9C
#undef C0M9C
__sfr __at 0xB6 C0M9C       ; // DS80C390 specific
#endif

#ifdef C0M10C
#undef C0M10C
__sfr __at 0xB7 C0M10C      ; // DS80C390 specific
#endif

#ifdef C0M11C
#undef C0M11C
__sfr __at 0xBB C0M11C      ; // DS80C390 specific
#endif

#ifdef C0M12C
#undef C0M12C
__sfr __at 0xBC C0M12C      ; // DS80C390 specific
#endif

#ifdef C0M13C
#undef C0M13C
__sfr __at 0xBD C0M13C      ; // DS80C390 specific
#endif

#ifdef C0M14C
#undef C0M14C
__sfr __at 0xBE C0M14C      ; // DS80C390 specific
#endif

#ifdef C0M15C
#undef C0M15C
__sfr __at 0xBF C0M15C      ; // DS80C390 specific
#endif

#ifdef C0RE
#undef C0RE
__sfr __at 0xA7 C0RE        ; // DS80C390 specific
#endif

#ifdef C0RMS0
#undef C0RMS0
__sfr __at 0x96 C0RMS0      ; // DS80C390 specific
#endif

#ifdef C0RMS1
#undef C0RMS1
__sfr __at 0x97 C0RMS1      ; // DS80C390 specific
#endif

#ifdef C0S
#undef C0S
__sfr __at 0xA4 C0S         ; // DS80C390 specific
// Not directly accessible bits
#define ER0         0x01
#define ER1         0x02
#define ER2         0x04
#define TXS         0x08
#define RXS         0x10
#define WKS         0x20
#define EC96_128    0x40
#define BSS         0x80
#endif

#ifdef C0TE
#undef C0TE
__sfr __at 0xA6 C0TE        ; // DS80C390 specific
#endif

#ifdef C0TMA0
#undef C0TMA0
__sfr __at 0x9E C0TMA0      ; // DS80C390 specific
#endif

#ifdef C0TMA1
#undef C0TMA1
__sfr __at 0x9F C0TMA1      ; // DS80C390 specific
#endif

#ifdef C1C
#undef C1C
__sfr __at 0xE3 C1C         ; // DS80C390 specific
// Not directly accessible bits
#define SWINT       0x01
#define ERCS        0x02
#define AUTOB       0x04
#define CRST        0x08
#define SIESTA      0x10
#define PDE         0x20
#define STIE        0x40
#define ERIE        0x80
#endif

#ifdef C1IR
#undef C1IR
__sfr __at 0xE5 C1IR        ; // DS80C390 specific
// Not directly accessible bits
#define INTIN0      0x01
#define INTIN1      0x02
#define INTIN2      0x04
#define INTIN3      0x08
#define INTIN4      0x10
#define INTIN5      0x20
#define INTIN6      0x40
#define INTIN7      0x80
#endif

#ifdef C1IRE
#undef C1IRE
__sfr __at 0xE7 C1RE        ; // DS80C390 specific
#endif

#ifdef C1M1C
#undef C1M1C
__sfr __at 0xEB C1M1C       ; // DS80C390 specific
#endif

#ifdef C1M2C
#undef C1M2C
__sfr __at 0xEC C1M2C       ; // DS80C390 specific
#endif

#ifdef C1M3C
#undef C1M3C
__sfr __at 0xED C1M3C       ; // DS80C390 specific
#endif

#ifdef C1M4C
#undef C1M4C
__sfr __at 0xEE C1M4C       ; // DS80C390 specific
#endif

#ifdef C1M5C
#undef C1M5C
__sfr __at 0xEF C1M5C       ; // DS80C390 specific
#endif

#ifdef C1M6C
#undef C1M6C
__sfr __at 0xF3 C1M6C       ; // DS80C390 specific
#endif

#ifdef C1M7C
#undef C1M7C
__sfr __at 0xF4 C1M7C       ; // DS80C390 specific
#endif

#ifdef C1M8C
#undef C1M8C
__sfr __at 0xF5 C1M8C       ; // DS80C390 specific
#endif

#ifdef C1M9C
#undef C1M9C
__sfr __at 0xF6 C1M9C       ; // DS80C390 specific
#endif

#ifdef C1M10C
#undef C1M10C
__sfr __at 0xF7 C1M10C      ; // DS80C390 specific
#endif

#ifdef C1M11C
#undef C1M11C
__sfr __at 0xFB C1M11C      ; // DS80C390 specific
#endif

#ifdef C1M12C
#undef C1M12C
__sfr __at 0xFC C1M12C      ; // DS80C390 specific
#endif

#ifdef C1M13C
#undef C1M13C
__sfr __at 0xFD C1M13C      ; // DS80C390 specific
#endif

#ifdef C1M14C
#undef C1M14C
__sfr __at 0xFE C1M14C      ; // DS80C390 specific
#endif

#ifdef C1M15C
#undef C1M15C
__sfr __at 0xFF C1M15C      ; // DS80C390 specific
#endif

#ifdef C1S
#undef C1S
__sfr __at 0xE4 C1S         ; // DS80C390 specific
// Not directly accessible bits
#define ER0         0x01
#define ER1         0x02
#define ER2         0x04
#define TXS         0x08
#define RXS         0x10
#define WKS         0x20
#define CECE        0x40
#define BSS         0x80
#endif

#ifdef C1ITE
#undef C1ITE
__sfr __at 0xE6 C1TE        ; // DS80C390 specific
#endif

#ifdef C1RSM0
#undef C1RSM0
__sfr __at 0xD6 C1RSM0      ; // DS80C390 specific
#endif

#ifdef C1RSM1
#undef C1RSM1
__sfr __at 0xD7 C1RSM1      ; // DS80C390 specific
#endif

#ifdef C1TMA0
#undef C1TMA0
__sfr __at 0xDE C1TMA0      ; // DS80C390 specific
#endif

#ifdef C1TMA1
#undef C1TMA1
__sfr __at 0xDF C1TMA1      ; // DS80C390 specific
#endif

#ifdef CC1
#undef CC1
__sfr __at 0xC2 CC1;
#endif

#ifdef CC2
#undef CC2
__sfr __at 0xC4 CC2;
#endif

#ifdef CC3
#undef CC3
__sfr __at 0xC6 CC3;
#endif

#ifdef CC4
#undef CC4
__sfr __at 0xCE CC4;
#endif

#ifdef CC4EN
#undef CC4EN
__sfr __at 0xC9 CC4EN       ; // compare/capture 4 enable register SAB80517 specific
#endif

#ifdef CCAP0H_AT_0XFA
#undef CCAP0H_AT_0XFA
__sfr __at 0xFA CCAP0H      ;
#endif

#ifdef CCAP1H_AT_0XFB
#undef CCAP1H_AT_0XFB
__sfr __at 0xFB CCAP1H      ;
#endif

#ifdef CCAP2H_AT_0XFC
#undef CCAP2H_AT_0XFC
__sfr __at 0xFC CCAP2H      ;
#endif

#ifdef CCAP3H_AT_0XFD
#undef CCAP3H_AT_0XFD
__sfr __at 0xFD CCAP3H      ;
#endif

#ifdef CCAP4H_AT_0XFE
#undef CCAP4H_AT_0XFE
__sfr __at 0xFE CCAP4H      ;
#endif

#ifdef CCAP0L_AT_0XEA
#undef CCAP0L_AT_0XEA
__sfr __at 0xEA CCAP0L      ;
#endif

#ifdef CCAP1L_AT_0XEB
#undef CCAP1L_AT_0XEB
__sfr __at 0xEB CCAP1L      ;
#endif

#ifdef CCAP2L_AT_0XEC
#undef CCAP2L_AT_0XEC
__sfr __at 0xEC CCAP2L      ;
#endif

#ifdef CCAP3L_AT_0XED
#undef CCAP3L_AT_0XED
__sfr __at 0xED CCAP3L      ;
#endif

#ifdef CCAP4L_AT_0XEE
#undef CCAP4L_AT_0XEE
__sfr __at 0xEE CCAP4L      ;
#endif

#ifdef CCAPM0_AT_0XC2
#undef CCAPM0_AT_0XC2
// P89C668 specific, Capture module:
__sfr __at 0xC2 CCAPM0      ;
#endif

#ifdef CCAPM0_AT_0XDA
#undef CCAPM0_AT_0XDA
__sfr __at 0xDA CCAPM0      ;
#define ECCF        0x01
#define PWM         0x02
#define TOG         0x04
#define MAT         0x08
#define CAPN        0x10
#define CAPP        0x20
#define ECOM        0x40
#endif

#ifdef CCAPM1_AT_0XC3
#undef CCAPM1_AT_0XC3
__sfr __at 0xC3 CCAPM1      ;
#endif

#ifdef CCAPM1_AT_0XDB
#undef CCAPM1_AT_0XDB
__sfr __at 0xDB CCAPM1      ;
#endif

#ifdef CCAPM2_AT_0XC4
#undef CCAPM2_AT_0XC4
__sfr __at 0xC4 CCAPM2      ;
#endif

#ifdef CCAPM2_AT_0XDC
#undef CCAPM2_AT_0XDC
__sfr __at 0x0DC CCAPM2     ;
#endif

#ifdef CCAPM3_AT_0XC5
#undef CCAPM3_AT_0XC5
__sfr __at 0xC5 CCAPM3      ;
#endif

#ifdef CCAPM3_AT_0XDD
#undef CCAPM3_AT_0XDD
__sfr __at 0x0DD CCAPM3     ;
#endif

#ifdef CCAPM4_AT_0XDE
#undef CCAPM4_AT_0XDE
__sfr __at 0x0DE CCAPM4     ;
#endif

#ifdef CCAPM4_AT_0XC6
#undef CCAPM4_AT_0XC6
__sfr __at 0xC6 CCAPM4      ;
#endif

#ifdef CCEN
#undef CCEN
__sfr __at 0xC1 CCEN        ; // compare/capture enable register SAB80515 specific
#endif

#ifdef CCH1
#undef CCH1
__sfr __at 0xC3 CCH1        ; // compare/capture register 1, high byte SAB80515 specific
#endif

#ifdef CCH2
#undef CCH2
__sfr __at 0xC5 CCH2        ; // compare/capture register 2, high byte SAB80515 specific
#endif

#ifdef CCH3
#undef CCH3
__sfr __at 0xC7 CCH3        ; // compare/capture register 3, high byte SAB80515 specific
#endif

#ifdef CCH4
#undef CCH4
__sfr __at 0xCF CCH4        ; // compare/capture register 4, high byte SAB80515 specific
#endif

#ifdef CCL1
#undef CCL1
__sfr __at 0xC2 CCL1        ; // compare/capture register 1, low byte SAB80515 specific
#endif

#ifdef CCL2
#undef CCL2
__sfr __at 0xC4 CCL2        ; // compare/capture register 2, low byte SAB80515 specific
#endif

#ifdef CCL3
#undef CCL3
__sfr __at 0xC6 CCL3        ; // compare/capture register 3, low byte SAB80515 specific
#endif

#ifdef CCL4
#undef CCL4
__sfr __at 0xCE CCL4        ; // compare/capture register 4, low byte SAB80515 specific
#endif

#ifdef CCON__0xD8__CF__CR__x__CCF4__CCF3__CCF2__CCF1__CCF0
#undef CCON__0xD8__CF__CR__x__CCF4__CCF3__CCF2__CCF1__CCF0
__sfr __at 0xD8 CCON        ; // T89C51RD2 specific register
// Bit registers
__sbit __at 0xD8 CCF0       ;
__sbit __at 0xD9 CCF1       ;
__sbit __at 0xDA CCF2       ;
__sbit __at 0xDB CCF3       ;
__sbit __at 0xDC CCF4       ;
__sbit __at 0xDE CR         ;
__sbit __at 0xDF CF         ;
#endif

#ifdef CCON__CF__CR__x__CCF4__CCF3__CCF2__CCF1__CCF0
#undef CCON__CF__CR__x__CCF4__CCF3__CCF2__CCF1__CCF0
// P89C668 specific, PCA Counter control:
__sfr __at 0xC0 CCON        ;
// Bit registers
__sbit __at 0xC0 CCF0       ;
__sbit __at 0xC1 CCF1       ;
__sbit __at 0xC2 CCF2       ;
__sbit __at 0xC3 CCF3       ;
__sbit __at 0xC4 CCF4       ;
//__sbit __at 0xC5 -
__sbit __at 0xC6 CR         ;
__sbit __at 0xC7 CF         ;
#endif

#ifdef CCR
#undef CCR
__sfr __at 0xCA CCR;
#endif

#ifdef CH_AT_0XF9
#undef CH_AT_0XF9
__sfr __at 0xF9 CH          ;
#endif

#ifdef CMOD__CIDL__WDTE__x__x__x__CPS1__CPS0__ECF
#undef CMOD__CIDL__WDTE__x__x__x__CPS1__CPS0__ECF
// P89C668 specific, PCA Counter mode:
__sfr __at 0xC1 CMOD        ;
// not bit addressable:
#define CIDL        0x80
#define WDTE        0x40
#define CPS1        0x04
#define CPS0        0x02
#define ECF         0x01
#endif

#ifdef CKCON__WD1__WD0__T2M__T1M__TOM__MD2__MD1__MD0
#undef CKCON__WD1__WD0__T2M__T1M__TOM__MD2__MD1__MD0
__sfr __at 0x8E CKCON       ; // DS80C320 & DS80C390 specific
// Not directly accessible Bits.
#define MD0         0x01
#define MD1         0x02
#define MD2         0x04
#define T0M         0x08
#define T1M         0x10
#define T2M         0x20
#define WD0         0x40
#define WD1         0x80
#endif

#ifdef CKCON__X2__T0X2__T1X2__T2X2__SiX2__PcaX2__WdX2__x
#undef CKCON__X2__T0X2__T1X2__T2X2__SiX2__PcaX2__WdX2__x
__sfr __at 0x8F CKCON       ;
#define X2          0x01
#define T0X2        0x02
#define T1X2        0x04
#define T2X2        0x08
#define SiX2        0x10
#define PcaX2       0x20
#define WdX2        0x40
#endif

#ifdef CKMOD
#undef CKMOD
__sfr __at 0x96 CKMOD       ; // DS89C420 specific
// Not directly accessible Bits.
#define T0MH        0x08
#define T1MH        0x10
#define T2MH        0x20
#endif

#ifdef CL_AT_0XE9
#undef CL_AT_0XE9
__sfr __at 0xE9 CL          ;
#endif

#ifdef CLRMSK
#undef CLRMSK
__sfr __at 0xA6 CLRMSK;
#endif

#ifdef CMEN
#undef CMEN
__sfr __at 0xF6 CMEN        ; // compare enable register SAB80517 specific
#endif

#ifdef CMH0
#undef CMH0
__sfr __at 0xD3 CMH0        ; // compare register 0 high byte SAB80517 specific
#endif

#ifdef CMH1
#undef CMH1
__sfr __at 0xD5 CMH1        ; // compare register 1 high byte SAB80517 specific
#endif

#ifdef CMH2
#undef CMH2
__sfr __at 0xD7 CMH2        ; // compare register 2 high byte SAB80517 specific
#endif

#ifdef CMH3
#undef CMH3
__sfr __at 0xE3 CMH3        ; // compare register 3 high byte SAB80517 specific
#endif

#ifdef CMH4
#undef CMH4
__sfr __at 0xE5 CMH4        ; // compare register 4 high byte SAB80517 specific
#endif

#ifdef CMH5
#undef CMH5
__sfr __at 0xE7 CMH5        ; // compare register 5 high byte SAB80517 specific
#endif

#ifdef CMH6
#undef CMH6
__sfr __at 0xF3 CMH6        ; // compare register 6 high byte SAB80517 specific
#endif

#ifdef CMH7
#undef CMH7
__sfr __at 0xF5 CMH7        ; // compare register 7 high byte SAB80517 specific
#endif

#ifdef CMH0_AT_0XC9
#undef CMH0_AT_0XC9
__sfr __at 0xC9 CMH0        ; // Compare high 0, P80C552 specific
#endif

#ifdef CMH1_AT_0XCA
#undef CMH1_AT_0XCA
__sfr __at 0xCA CMH1        ; // Compare high 1, P80C552 specific
#endif

#ifdef CMH2_AT_0XCB
#undef CMH2_AT_0XCB
__sfr __at 0xCB CMH2        ; // Compare high 2, P80C552 specific
#endif

#ifdef CML0
#undef CML0
__sfr __at 0xD2 CML0        ; // compare register 0 low byte SAB80517 specific
#endif

#ifdef CML1
#undef CML1
__sfr __at 0xD4 CML1        ; // compare register 1 low byte SAB80517 specific
#endif

#ifdef CML2
#undef CML2
__sfr __at 0xD6 CML2        ; // compare register 2 low byte SAB80517 specific
#endif

#ifdef CML3
#undef CML3
__sfr __at 0xE2 CML3        ; // compare register 3 low byte SAB80517 specific
#endif

#ifdef CML4
#undef CML4
__sfr __at 0xE4 CML4        ; // compare register 4 low byte SAB80517 specific
#endif

#ifdef CML5
#undef CML5
__sfr __at 0xE6 CML5        ; // compare register 5 low byte SAB80517 specific
#endif

#ifdef CML6
#undef CML6
__sfr __at 0xF2 CML6        ; // compare register 6 low byte SAB80517 specific
#endif

#ifdef CML7
#undef CML7
__sfr __at 0xF4 CML7        ; // compare register 7 low byte SAB80517 specific
#endif

#ifdef CML0_AT_0XA9
#undef CML0_AT_0XA9
__sfr __at 0xA9 CML0        ; // Compare low 0, P80C552 specific
#endif

#ifdef CML1_AT_0XAA
#undef CML1_AT_0XAA
__sfr __at 0xAA CML1        ; // Compare low 1, P80C552 specific
#endif

#ifdef CML2_AT_0XAB
#undef CML2_AT_0XAB
__sfr __at 0xAB CML2        ; // Compare low 2, P80C552 specific
#endif

#ifdef CMOD__0xD9__CIDL__WDTE__x__x__x__CPS1__CPS0__ECF
#undef CMOD__0xD9__CIDL__WDTE__x__x__x__CPS1__CPS0__ECF
__sfr __at 0xD9 CMOD        ;
#define ECF         0x01
#define CPS0        0x02
#define CPS1        0x04
#define WDTE        0x40
#define CIDL        0x80
#endif

#ifdef CMSEL
#undef CMSEL
__sfr __at 0xF7 CMSEL       ; // compare input select SAB80517
#endif

#ifdef COMCLRH
#undef COMCLRH
__sfr __at 0xA4 COMCLRH;
#endif

#ifdef COMCLRL
#undef COMCLRL
__sfr __at 0xA3 COMCLRL;
#endif

#ifdef COMSETH
#undef COMSETH
__sfr __at 0xA2 COMSETH;
#endif

#ifdef COMSETL
#undef COMSETL
__sfr __at 0xA1 COMSETL;
#endif

#ifdef COR
#undef COR
__sfr __at 0xCE COR         ; // Dallas DS80C390 specific
#define CLKOE       0x01
#define COD0        0x02
#define COD1        0x04
#define C0BPR6      0x08
#define C0BPR7      0x10
#define C1BPR6      0x20
#define C1BPR7      0x40
#define IRDACK      0x80
#endif

#ifdef CRC
#undef CRC
__sfr __at 0xC1 CRC         ; // Dallas DS5001 specific
#define CRC_        0x01
#define MDM         0x02
#define RNGE0       0x10
#define RNGE1       0x20
#define RNGE2       0x40
#define RNGE3       0x80
#endif

#ifdef CRCH
#undef CRCH
__sfr __at 0xCB CRCH        ; // compare/reload/capture register, high byte SAB80515 specific
#endif

#ifdef CRCHIGH
#undef CRCHIGH
__sfr __at 0xC3 CRCHIGH     ; // DS5001 specific
#endif

#ifdef CRCL
#undef CRCL
__sfr __at 0xCA CRCL        ; // compare/reload/capture register, low byte SAB80515 specific
#endif

#ifdef CRCLOW
#undef CRCLOW
__sfr __at 0xC2 CRCLOW      ; // DS5001 specific
#endif

#ifdef CT1COM
#undef CT1COM
__sfr __at 0xBC CT1COM;
#endif

#ifdef CTCOM_AT_0XE1
#undef CTCOM_AT_0XE1
__sfr __at 0xE1 CTCON       ; // com.timer control register SAB80517
#endif

#ifdef CTCON__CTN3__CTP3__CTN2__CTP2__CTN1__CTP1__CTN0__CTP0
#undef CTCON__CTN3__CTP3__CTN2__CTP2__CTN1__CTP1__CTN0__CTP0
__sfr __at 0xEB CTCON       ; // Capture control, P80C552 specific
// Not directly accessible Bits.
#define CTP0        0x01
#define CTN0        0x02
#define CTP1        0x04
#define CTN1        0x08
#define CTP2        0x10
#define CTN2        0x20
#define CTP3        0x40
#define CTN3        0x80
#endif

#ifdef CTH0_AT_0XCC
#undef CTH0_AT_0XCC
__sfr __at 0xCC CTH0        ; // Capture high 0, P80C552 specific
#endif

#ifdef CTH1_AT_0XCD
#undef CTH1_AT_0XCD
__sfr __at 0xCD CTH1        ; // Capture high 1, P80C552 specific
#endif

#ifdef CTH2_AT_0XCE
#undef CTH2_AT_0XCE
__sfr __at 0xCE CTH2        ; // Capture high 2, P80C552 specific
#endif

#ifdef CTH3_AT_0XCF
#undef CTH3_AT_0XCF
__sfr __at 0xCF CTH3        ; // Capture high 3, P80C552 specific
#endif

#ifdef CTL0_AT_0XAC
#undef CTL0_AT_0XAC
__sfr __at 0xAC CTL0        ; // Capture low 0, P80C552 specific
#endif

#ifdef CTL1_AT_0XAD
#undef CTL1_AT_0XAD
__sfr __at 0xAD CTL1        ; // Capture low 1, P80C552 specific
#endif

#ifdef CTL2_AT_0XAE
#undef CTL2_AT_0XAE
__sfr __at 0xAE CTL2        ; // Capture low 2, P80C552 specific
#endif

#ifdef CTL3_AT_0XAF
#undef CTL3_AT_0XAF
__sfr __at 0xAF CTL3        ; // Capture low 3, P80C552 specific
#endif

#ifdef CTRELH
#undef CTRELH
__sfr __at 0xDF CTRELH      ; // com.timer rel register high byte SAB80517
#endif

#ifdef CTRELL
#undef CTRELL
__sfr __at 0xDE CTRELL      ; // com.timer rel register low byte SAB80517
#endif

#ifdef DAPR__SAB80515
#undef DAPR__SAB80515
__sfr __at 0xDA DAPR        ; // D/A-converter program register SAB80515 specific
#endif

#ifdef DAPR__SAB80517
#undef DAPR__SAB80517
__sfr __at 0xDA DAPR        ; // D/A-converter program register SAB80517 specific
#endif

#ifdef DPH
#undef DPH
__sfr __at 0x83 DPH         ;
__sfr __at 0x83 DP0H        ;  // Alternate name for AT89S53
#endif

#ifdef DPH1
#undef DPH1
__sfr __at 0x85 DPH1        ; // DS80C320 specific
__sfr __at 0x85 DP1H        ; // Alternate name for AT89S53
#endif

#ifdef DPL
#undef DPL
__sfr __at 0x82 DPL         ;  // Alternate name for AT89S53
__sfr __at 0x82 DP0L        ;
#endif

#ifdef DPL1
#undef DPL1
__sfr __at 0x84 DPL1        ; // DS80C320 specific
__sfr __at 0x84 DP1L        ; // Alternate name for AT89S53
#endif

#ifdef DPS__x__x__x__x__x__x__x__SEL
#undef DPS__x__x__x__x__x__x__x__SEL
__sfr __at 0x86 DPS         ;
// Not directly accessible DPS Bit. DS80C320 & DPS8XC520 specific
#define SEL         0x01
#endif

#ifdef DPS__ID1__ID0__TSL__x__x__x__x__SEL
#undef DPS__ID1__ID0__TSL__x__x__x__x__SEL
__sfr __at 0x86 DPS         ;
// Not directly accessible DPS Bit. DS89C390 specific
#define SEL         0x01
#define TSL         0x20
#define ID0         0x40
#define ID1         0x80
#endif

#ifdef DPS__ID1__ID0__TSL__AID__x__x__x__SEL
#undef DPS__ID1__ID0__TSL__AID__x__x__x__SEL
__sfr __at 0x86 DPS         ;
// Not directly accessible DPS Bit. DS89C420 specific
#define SEL         0x01
#define AID         0x10
#define TSL         0x20
#define ID0         0x40
#define ID1         0x80
#endif

#ifdef DPSEL
#undef DPSEL
__sfr __at 0x92 DPSEL       ; // data pointer select register SAB80517
#endif

#ifdef DPX
#undef DPX
__sfr __at 0x93 DPX1        ; // DS80C390 specific
#endif

#ifdef DPX1
#undef DPX1
__sfr __at 0x95 DPX1        ; // DS80C390 specific
#endif

#ifdef EECON
#undef EECON
__sfr __at 0xD2 EECON       ;
#define EEBUSY      0x01
#define EEE         0x02
#define EEPL0       0x10
#define EEPL1       0x20
#define EEPL2       0x40
#define EEPL3       0x80
#define EEPL        0xF0
#endif

#ifdef EETIM
#undef EETIM
__sfr __at 0xD3 EETIM       ;
#endif

#ifdef EICC1
#undef EICC1
__sfr __at 0xBF EICC1;
#endif

#ifdef EIE__x__x__x__EWDI__EX5__EX4__EX3__EX2
#undef EIE__x__x__x__EWDI__EX5__EX4__EX3__EX2
__sfr __at 0xE8 EIE         ;
// Bit registers DS80C320 specific
__sbit __at 0xE8 EX2        ;
__sbit __at 0xE9 EX3        ;
__sbit __at 0xEA EX4        ;
__sbit __at 0xEB EX5        ;
__sbit __at 0xEC EWDI       ;
#endif

#ifdef EIE__CANBIE__C0IE__C1IE__EWDI__EX5__EX4__EX3__EX2
#undef EIE__CANBIE__C0IE__C1IE__EWDI__EX5__EX4__EX3__EX2
__sfr __at 0xE8 EIE         ;
// Bit registers DS80C390 specific
__sbit __at 0xE8 EX2        ;
__sbit __at 0xE9 EX3        ;
__sbit __at 0xEA EX4        ;
__sbit __at 0xEB EX5        ;
__sbit __at 0xEC EWDI       ;
__sbit __at 0xED C1IE       ;
__sbit __at 0xEE C0IE       ;
__sbit __at 0xEF CANBIE     ;
#endif

#ifdef EIP__x__x__x__PWDI__PX5__PX4__PX3__PX2
#undef EIP__x__x__x__PWDI__PX5__PX4__PX3__PX2
__sfr __at 0xF8 EIP         ;
// Bit registers DS80C320 specific
__sbit __at 0xF8 PX2        ;
__sbit __at 0xF9 PX3        ;
__sbit __at 0xFA PX4        ;
__sbit __at 0xFB PX5        ;
__sbit __at 0xFC PWDI       ;
#endif

#ifdef EIP__CANBIP__C0IP__C1IP__PWDI__PX5__PX4__PX3__PX2__PX1__PX0
#undef EIP__CANBIP__C0IP__C1IP__PWDI__PX5__PX4__PX3__PX2__PX1__PX0
__sfr __at 0xF8 EIP         ;
// Bit registers DS80C320 specific
__sbit __at 0xF8 PX2        ;
__sbit __at 0xF9 PX3        ;
__sbit __at 0xFA PX4        ;
__sbit __at 0xFB PX5        ;
__sbit __at 0xFC PWDI       ;
__sbit __at 0xFD C1IP       ;
__sbit __at 0xFE C0IP       ;
__sbit __at 0xFF CANBIP     ;
#endif

#ifdef EIP0__x__x__x__LPWDI__LPX5__LPX4__LPX3__LPX2
#undef EIP0__x__x__x__LPWDI__LPX5__LPX4__LPX3__LPX2
__sfr __at 0xF8 EIP0        ;
// Bit registers DS89C420 specific
__sbit __at 0xF8 LPX2       ;
__sbit __at 0xF9 LPX3       ;
__sbit __at 0xFA LPX4       ;
__sbit __at 0xFB LPX5       ;
__sbit __at 0xFC LPWDI      ;
#endif

#ifdef EIP1__x__x__x__MPWDI__MPX5__MPX4__MPX3__MPX2
#undef EIP1__x__x__x__MPWDI__MPX5__MPX4__MPX3__MPX2
__sfr __at 0xF1 EIP1        ;
// Not directly accessible Bits DS89C420 specific
#define MPX2        0x01
#define MPX3        0x02
#define MPX4        0x04
#define MPX5        0x08
#define MPWDI       0x10
#endif

#ifdef ESP
#undef ESP
__sfr __at 0x9B ESP         ;
// Not directly accessible Bits DS80C390 specific
#define ESP_0       0x01
#define ESP_1       0x02
#endif

#ifdef EXIF__IE5__IE4__IE3__IE2__x__RGMD__RGSL__BGS
#undef EXIF__IE5__IE4__IE3__IE2__x__RGMD__RGSL__BGS
__sfr __at 0x91 EXIF        ;
// Not directly accessible EXIF Bits DS80C320 specific
#define BGS         0x01
#define RGSL        0x02
#define RGMD        0x04
#define IE2         0x10
#define IE3         0x20
#define IE4         0x40
#define IE5         0x80
#endif

#ifdef EXIF__IE5__IE4__IE3__IE2__XT_RG__RGMD__RGSL__BGS
#undef EXIF__IE5__IE4__IE3__IE2__XT_RG__RGMD__RGSL__BGS
__sfr __at 0x91 EXIF        ;
// Not directly accessible EXIF Bits DS87C520 specific
#define BGS         0x01
#define RGSL        0x02
#define RGMD        0x04
#define XT_RG       0x08
#define IE2         0x10
#define IE3         0x20
#define IE4         0x40
#define IE5         0x80
#endif

#ifdef EXIF__IE5__IE4__IE3__IE2__CKRY__RGMD__RGSL__BGS
#undef EXIF__IE5__IE4__IE3__IE2__CKRY__RGMD__RGSL__BGS
__sfr __at 0x91 EXIF        ;
// Not directly accessible EXIF Bits DS80C390 & DS89C420 specific
#define BGS         0x01
#define RGSL        0x02
#define RGMD        0x04
#define CKRY        0x08
#define IE2         0x10
#define IE3         0x20
#define IE4         0x40
#define IE5         0x80
#endif

#ifdef FCNTL__FBUSY__FERR__x__x__FC3__FC2__FC1__FC0
#undef FCNTL__FBUSY__FERR__x__x__FC3__FC2__FC1__FC0
__sfr __at 0xD5 FCNTL       ;
// Not directly accessible DS89C420 specific
#define FC0         0x01
#define FC1         0x02
#define FC2         0x04
#define FC3         0x08
#define FERR        0x40
#define FBUSY       0x80
#endif

#ifdef FCON
#undef FCON
__sfr __at 0xD1 FCON        ;
#define FBUSY       0x01
#define FMOD0       0x02
#define FMOD1       0x04
#define FPS         0x08
#define FPL0        0x10
#define FPL1        0x20
#define FPL2        0x40
#define FPL3        0x80
#define FPL         0xF0
#endif

#ifdef FDATA
#undef FDATA
__sfr __at 0xD6 FDATA       ;
#endif

#ifdef FMODE
#undef FMODE
__sfr __at 0xB3 FMODE;
#endif

#ifdef IE__EA__x__x__ES__ET1__EX1__ET0__EX0
#undef IE__EA__x__x__ES__ET1__EX1__ET0__EX0
__sfr __at 0xA8 IE          ;
// Bit registers
__sbit __at 0xA8 EX0        ;
__sbit __at 0xA9 ET0        ;
__sbit __at 0xAA EX1        ;
__sbit __at 0xAB ET1        ;
__sbit __at 0xAC ES         ;
__sbit __at 0xAF EA         ;
#endif

#ifdef IE__EA__x__ET2__ES__ET1__EX1__ET0__EX0
#undef IE__EA__x__ET2__ES__ET1__EX1__ET0__EX0
__sfr __at 0xA8 IE          ;
// Bit registers
__sbit __at 0xA8 EX0        ;
__sbit __at 0xA9 ET0        ;
__sbit __at 0xAA EX1        ;
__sbit __at 0xAB ET1        ;
__sbit __at 0xAC ES         ;
__sbit __at 0xAD ET2        ; // Enable timer2 interrupt
__sbit __at 0xAF EA         ;
#endif // IE

#ifdef IE__EA__EAD__ES1__ES0__ET1__EX1__ET0__EX0
#undef IE__EA__EAD__ES1__ES0__ET1__EX1__ET0__EX0
__sfr __at 0xA8 IE          ; // same as IEN0 - Interrupt enable 0, P80C552 specific
__sfr __at 0xA8 IEN0        ; // alternate name
// Bit registers
__sbit __at 0xA8 EX0        ;
__sbit __at 0xA9 ET0        ;
__sbit __at 0xAA EX1        ;
__sbit __at 0xAB ET1        ;
__sbit __at 0xAC ES0        ;
__sbit __at 0xAD ES1        ;
__sbit __at 0xAE EAD        ;
__sbit __at 0xAF EEA        ;
#endif

#ifdef IE__EA__EC__ET2__ES__ET1__EX1__ET0__EX0
#undef IE__EA__EC__ET2__ES__ET1__EX1__ET0__EX0
__sfr __at 0xA8 IE          ;
__sbit __at 0xA8 EX0        ;
__sbit __at 0xA9 ET0        ;
__sbit __at 0xAA EX1        ;
__sbit __at 0xAB ET1        ;
__sbit __at 0xAC ES         ;
__sbit __at 0xAD ET2        ;
__sbit __at 0xAE EC         ;
__sbit __at 0xAF EA         ;
#endif

#ifdef IE__EA__ES1__ET2__ES__ET1__EX1__ET0__EX0
#undef IE__EA__ES1__ET2__ES__ET1__EX1__ET0__EX0
__sfr __at 0xA8 IE          ;
// Bit registers
__sbit __at 0xA8 EX0        ;
__sbit __at 0xA9 ET0        ;
__sbit __at 0xAA EX1        ;
__sbit __at 0xAB ET1        ;
__sbit __at 0xAC ES         ;
__sbit __at 0xAC ES0        ; // Alternate name
__sbit __at 0xAD ET2        ; // Enable timer2 interrupt
__sbit __at 0xAE ES1        ;
__sbit __at 0xAF EA         ;
#endif // IE

#ifdef IE__EA_WDT_ET2_ES_ET1_EX1_ET0_EX0
#undef IE__EA_WDT_ET2_ES_ET1_EX1_ET0_EX0
__sfr __at 0xA8 IE          ;
__sfr __at 0xA8 IEN0        ; // Alternate name
// Bit registers for the SAB80515 and compatible IE
__sbit __at 0xA8 EX0        ;
__sbit __at 0xA9 ET0        ;
__sbit __at 0xAA EX1        ;
__sbit __at 0xAB ET1        ;
__sbit __at 0xAC ES         ;
__sbit __at 0xAC ES0        ;
__sbit __at 0xAD ET2        ; // Enable timer 2 overflow SAB80515 specific
__sbit __at 0xAE WDT        ; // watchdog timer reset - SAB80515 specific
__sbit __at 0xAF EA         ;
__sbit __at 0xAF EAL        ; // EA as called by Infineon / Siemens
#endif

#ifdef IEN0__EA__EC__ES1__ES0__ET1__EX1__ET0__EX0
#undef IEN0__EA__EC__ES1__ES0__ET1__EX1__ET0__EX0
// P89C668 specific
__sfr __at 0xA8 IEN0        ;
// Bit registers
__sbit __at 0xA8 EX0        ;
__sbit __at 0xA9 ET0        ;
__sbit __at 0xAA EX1        ;
__sbit __at 0xAB ET1        ;
__sbit __at 0xAC ES0        ;
__sbit __at 0xAD ES1        ;
__sbit __at 0xAE EC         ;
__sbit __at 0xAF EA         ;
#endif

#ifdef IEN1__x__x__x__x__x__x__x__ET2
#undef IEN1__x__x__x__x__x__x__x__ET2
// P89C668 specific bit registers
__sfr __at 0xE8 IEN1        ;
// Bit registers
__sbit __at 0xE8 ET2        ;
#endif

#ifdef IEN1__ET2__ECM2__ECM1__ECM0__ECT3__ECT2__ECT1__ECT0
#undef IEN1__ET2__ECM2__ECM1__ECM0__ECT3__ECT2__ECT1__ECT0
__sfr __at 0xE8 IEN1        ; // Interrupt enable 1, P80C552 specific
// Bit registers
__sbit __at 0xE8 ECT0       ;
__sbit __at 0xE9 ECT1       ;
__sbit __at 0xEA ECT2       ;
__sbit __at 0xEB ECT3       ;
__sbit __at 0xEC ECM0       ;
__sbit __at 0xED ECM1       ;
__sbit __at 0xEE ECM2       ;
__sbit __at 0xEF ET2        ;
#endif

#ifdef IEN1__EXEN2__SWDT__EX6__EX5__EX4__EX3__EX2__EADC
#undef IEN1__EXEN2__SWDT__EX6__EX5__EX4__EX3__EX2__EADC
__sfr __at 0xB8 IEN1        ; // interrupt enable register - SAB80515 specific
// Bit registers
__sbit __at 0xB8 EADC       ; // A/D converter interrupt enable
__sbit __at 0xB9 EX2        ;
__sbit __at 0xBA EX3        ;
__sbit __at 0xBB EX4        ;
__sbit __at 0xBC EX5        ;
__sbit __at 0xBD EX6        ;
__sbit __at 0xBE SWDT       ; // watchdog timer start/reset
__sbit __at 0xBF EXEN2      ; // timer2 external reload interrupt enable
#endif

#ifdef IEN2__SAB80517
#undef IEN2__SAB80517
__sfr __at 0x9A IEN2        ; // interrupt enable register 2 SAB80517
#endif

#ifdef IEN3
#undef IEN3
__sfr __at 0xBE IEN3;
#endif

#ifdef IP__x__x__x__PS__PT1__PX1__PT0__PX0
#undef IP__x__x__x__PS__PT1__PX1__PT0__PX0
__sfr __at 0xB8 IP          ;
// Bit registers
__sbit __at 0xB8 PX0        ;
__sbit __at 0xB9 PT0        ;
__sbit __at 0xBA PX1        ;
__sbit __at 0xBB PT1        ;
__sbit __at 0xBC PS         ;
#endif

#ifdef IP__x__x__PT2__PS__PT1__PX1__PT0__PX0
#undef IP__x__x__PT2__PS__PT1__PX1__PT0__PX0
__sfr __at 0xB8 IP          ;
// Bit registers
__sbit __at 0xB8 PX0        ;
__sbit __at 0xB9 PT0        ;
__sbit __at 0xBA PX1        ;
__sbit __at 0xBB PT1        ;
__sbit __at 0xBC PS         ;
__sbit __at 0xBC PS0        ;  // alternate name
__sbit __at 0xBD PT2        ;
#endif

#ifdef IP__x__PAD__PS1__PS0__PT1__PX1__PT0__PX0
#undef IP__x__PAD__PS1__PS0__PT1__PX1__PT0__PX0
__sfr __at 0xB8 IP          ; // Interrupt priority 0, P80C552 specific
__sfr __at 0xB8 IP0         ; // alternate name
// Bit registers
__sbit __at 0xB8 PX0        ;
__sbit __at 0xB9 PT0        ;
__sbit __at 0xBA PX1        ;
__sbit __at 0xBB PT1        ;
__sbit __at 0xBC PS0        ;
__sbit __at 0xBD PS1        ;
__sbit __at 0xBE PAD        ;
#endif

#ifdef IP__x__PPC__PT2__PS__PT1__PX1__PT0__PX0
#undef IP__x__PPC__PT2__PS__PT1__PX1__PT0__PX0
__sfr __at 0xB8 IP          ;
// Bit registers
__sbit __at 0xB8 PX0        ;
__sbit __at 0xB9 PT0        ;
__sbit __at 0xBA PX1        ;
__sbit __at 0xBB PT1        ;
__sbit __at 0xBC PS         ;
__sbit __at 0xBD PT2        ;
__sbit __at 0xBE PPC        ;
#endif

#ifdef IP__x__PS1__PT2__PS__PT1_PX1__PT0__PX0
#undef IP__x__PS1__PT2__PS__PT1_PX1__PT0__PX0
__sfr __at 0xB8 IP          ;
// Bit registers
__sbit __at 0xB8 PX0        ;
__sbit __at 0xB9 PT0        ;
__sbit __at 0xBA PX1        ;
__sbit __at 0xBB PT1        ;
__sbit __at 0xBC PS         ;
__sbit __at 0xBD PT2        ;
__sbit __at 0xBE PS1        ;
#endif

#ifdef IP__PT2__PPC__PS1__PS0__PT1__PX1__PT0__PX0
#undef IP__PT2__PPC__PS1__PS0__PT1__PX1__PT0__PX0
// P89C668 specific:
__sfr __at 0xB8 IP          ;
// Bit registers
__sbit __at 0xB8 PX0        ;
__sbit __at 0xB9 PT0        ;
__sbit __at 0xBA PX1        ;
__sbit __at 0xBB PT1        ;
__sbit __at 0xBC PS0        ;
__sbit __at 0xBD PS1        ;
__sbit __at 0xBE PPC        ;
__sbit __at 0xBF PT2        ;
#endif

#ifdef IP__RWT__x__x__PS__PT1__PX1__PT0__PX0
#undef IP__RWT__x__x__PS__PT1__PX1__PT0__PX0
__sfr __at 0xB8 IP          ;
// Bit registers
__sbit __at 0xB8 PX0        ;
__sbit __at 0xB9 PT0        ;
__sbit __at 0xBA PX1        ;
__sbit __at 0xBB PT1        ;
__sbit __at 0xBC PS         ;
__sbit __at 0xBF RWT        ;
#endif

#ifdef IP0__x__WDTS__IP0_5__IP0_4__IP0_3__IP0_2__IP0_1__IP0_0
#undef IP0__x__WDTS__IP0_5__IP0_4__IP0_3__IP0_2__IP0_1__IP0_0
__sfr __at 0xA9 IP0         ; // interrupt priority register SAB80515 specific
// Not directly accessible IP0 bits
#define IP0_0       0x01
#define IP0_1       0x02
#define IP0_2       0x04
#define IP0_3       0x08
#define IP0_4       0x10
#define IP0_5       0x20
#define WDTS        0x40
#endif

#ifdef IP0__x__LPS1__LPT2__LPS0__LPT1__LPX1__LPT0__LPX0
#undef IP0__x__LPS1__LPT2__LPS0__LPT1__LPX1__LPT0__LPX0
__sfr __at 0xB8 IP0         ; // interrupt priority register DS89C420 specific
// Bit registers
__sbit __at 0xB8 LPX0       ;
__sbit __at 0xB9 LPT0       ;
__sbit __at 0xBA LPX1       ;
__sbit __at 0xBB LPT1       ;
__sbit __at 0xBC LPS0       ;
__sbit __at 0xBD LPT2       ;
__sbit __at 0xBE LPS1       ;
#endif

#ifdef IP1__x__x__IP1_5__IP1_4__IP1_3__IP1_2__IP1_1__IP1_0
#undef IP1__x__x__IP1_5__IP1_4__IP1_3__IP1_2__IP1_1__IP1_0
__sfr __at 0xB9 IP1         ; // interrupt priority register SAB80515 specific
// Not directly accessible IP1 bits
#define IP1_0       0x01
#define IP1_1       0x02
#define IP1_2       0x04
#define IP1_3       0x08
#define IP1_4       0x10
#define IP1_5       0x20
#endif

#ifdef IP1__x__MPS1__MPT2__MPS0__MPT1__MPX1__MPT0__MPX0
#undef IP1__x__MPS1__MPT2__MPS0__MPT1__MPX1__MPT0__MPX0
__sfr __at 0xB1 IP1         ; // interrupt priority register DS89C420 specific
// Not directly accessible IP1 bits
#define MPX0        0x01
#define MPT0        0x02
#define MPX1        0x04
#define MPT1        0x08
#define MPS0        0x10
#define MPT2        0x20
#define MPS1        0x40
#endif

#ifdef IP1__PT2__PCM2__PCM1__PCM0__PCT3__PCT2__PCT1__PCT0
#undef IP1__PT2__PCM2__PCM1__PCM0__PCT3__PCT2__PCT1__PCT0
__sfr __at 0xF8 IP1         ; // Interrupt priority 1, P80C552 specific
// Bit registers
__sbit __at 0xF8 PCT0       ;
__sbit __at 0xF9 PCT1       ;
__sbit __at 0xFA PCT2       ;
__sbit __at 0xFB PCT3       ;
__sbit __at 0xFC PCM0       ;
__sbit __at 0xFD PCM1       ;
__sbit __at 0xFE PCM2       ;
__sbit __at 0xFF PT2        ;
#endif

#ifdef IPH__x__PPCH__PT2H__PSH__PT1H__PX1H__PT0H__PX0H
#undef IPH__x__PPCH__PT2H__PSH__PT1H__PX1H__PT0H__PX0H
__sfr __at 0xB7 IPH         ;
#define PX0H        0x01
#define PT0H        0x02
#define PX1H        0x04
#define PT1H        0x08
#define PSH         0x10
#define PT2H        0x20
#define PPCH        0x40
#endif

#ifdef IPH__PT2H__PPCH__PS1H__PS0H__PT1H__PX1H__PT0H__PX0H
#undef IPH__PT2H__PPCH__PS1H__PS0H__PT1H__PX1H__PT0H__PX0H
// P89C668 specific:
__sfr __at 0xB7 IPH         ;
// not bit addressable:
#define PX0H        0x01
#define PT0H        0x02
#define PX1H        0x04
#define PT1H        0x08
#define PS0H        0x10
#define PS1H        0x20
#define PPCH        0x40
#define PT2H        0x80
#endif

#ifdef IRCON
#undef IRCON
__sfr __at 0xC0 IRCON       ; // interrupt control register - SAB80515 specific
// Bit registers
__sbit __at 0xC0 IADC       ; // A/D converter irq flag
__sbit __at 0xC1 IEX2       ; // external interrupt edge detect flag
__sbit __at 0xC2 IEX3       ;
__sbit __at 0xC3 IEX4       ;
__sbit __at 0xC4 IEX5       ;
__sbit __at 0xC5 IEX6       ;
__sbit __at 0xC6 TF2        ; // timer 2 owerflow flag
__sbit __at 0xC7 EXF2       ; // timer2 reload flag
#endif

#ifdef IRCON0
#undef IRCON0
__sfr __at 0xC0 IRCON0      ; // interrupt control register - SAB80515 specific
// Bit registers
__sbit __at 0xC0 IADC       ; // A/D converter irq flag
__sbit __at 0xC1 IEX2       ; // external interrupt edge detect flag
__sbit __at 0xC2 IEX3       ;
__sbit __at 0xC3 IEX4       ;
__sbit __at 0xC4 IEX5       ;
__sbit __at 0xC5 IEX6       ;
__sbit __at 0xC6 TF2        ; // timer 2 owerflow flag
__sbit __at 0xC7 EXF2       ; // timer2 reload flag
#endif

#ifdef IRCON1
#undef IRCON1
__sfr __at 0xD1 IRCON1      ; // interrupt control register - SAB80515 specific
#endif

#ifdef IRCON2
#undef IRCON2
__sfr __at 0xBF IRCON2;
#endif

#ifdef MA
#undef MA
__sfr __at 0xD3 MA          ; // DS80C390
#endif

#ifdef MB
#undef MB
__sfr __at 0xD4 MB          ; // DS80C390
#endif

#ifdef MC
#undef MC
__sfr __at 0xD5 MC          ; // DS80C390
#endif

#ifdef MCNT0
#undef MCNT0
__sfr __at 0xD1 MCNT0       ; // DS80C390
#define MAS0        0x01
#define MAS1        0x02
#define MAS2        0x04
#define MAS3        0x08
#define MAS4        0x10
#define SCB         0x20
#define CSE         0x40
#define LSHIFT      0x80
#endif

#ifdef MCNT1
#undef MCNT1
__sfr __at 0xD2 MCNT1       ; // DS80C390
#define CLM         0x10
#define MOF         0x40
#define MST         0x80
#endif

#ifdef MCON__IDM1__IDM0__CMA__x__PDCE3__PDCE2__PDCE1__PDCE0
#undef MCON__IDM1__IDM0__CMA__x__PDCE3__PDCE2__PDCE1__PDCE0
__sfr __at 0xC6 MCON        ; // DS80C390
#define PDCE0       0x01
#define PDCE1       0x02
#define PDCE2       0x04
#define PDCE3       0x08
#define CMA         0x20
#define IDM0        0x40
#define IDM1        0x80
#endif

#ifdef MCON__PA3__PA2__PA1__PA0__RA32_8__ECE2__PAA__SL
#undef MCON__PA3__PA2__PA1__PA0__RA32_8__ECE2__PAA__SL
__sfr __at 0xC6 MCON        ; // DS5000
#define SL          0x01
#define PAA         0x02
#define ECE2        0x04
#define RA32_8      0x08
#define PA0         0x10
#define PA1         0x20
#define PA2         0x40
#define PA3         0x80
#endif

#ifdef MCON__PA3__PA2__PA1__PA0__RG1__PES__PM__SL
#undef MCON__PA3__PA2__PA1__PA0__RG1__PES__PM__SL
__sfr __at 0xC6 MCON        ; // DS5001
#define SL          0x01
#define PM          0x02
#define PES         0x04
#define RG1         0x08
#define PA0         0x10
#define PA1         0x20
#define PA2         0x40
#define PA3         0x80
#endif

#ifdef MD0
#undef MD0
__sfr __at 0xE9 MD0         ; // MUL / DIV register 0 SAB80517
#endif

#ifdef MD1
#undef MD1
__sfr __at 0xEA MD1         ; // MUL / DIV register 1 SAB80517
#endif

#ifdef MD2
#undef MD2
__sfr __at 0xEB MD2         ; // MUL / DIV register 2 SAB80517
#endif

#ifdef MD3
#undef MD3
__sfr __at 0xEC MD3         ; // MUL / DIV register 3 SAB80517
#endif

#ifdef MD4
#undef MD4
__sfr __at 0xED MD4         ; // MUL / DIV register 4 SAB80517
#endif

#ifdef MD5
#undef MD5
__sfr __at 0xEE MD5         ; // MUL / DIV register 5 SAB80517
#endif

#ifdef MXAX
#undef MXAX
__sfr __at 0xEA MXAX        ; // Dallas DS80C390
#endif

#ifdef P0
#undef P0
__sfr __at 0x80 P0          ;
//  Bit Registers
__sbit __at 0x80 P0_0       ;
__sbit __at 0x81 P0_1       ;
__sbit __at 0x82 P0_2       ;
__sbit __at 0x83 P0_3       ;
__sbit __at 0x84 P0_4       ;
__sbit __at 0x85 P0_5       ;
__sbit __at 0x86 P0_6       ;
__sbit __at 0x87 P0_7       ;
#endif

#ifdef P0_EXT__AD7__AD6__AD5__AD4__AD3__AD2__AD1__AD0
#undef P0_EXT__AD7__AD6__AD5__AD4__AD3__AD2__AD1__AD0
// P89C668 alternate names for bits in P0
__sbit __at 0x80 AD0        ;
__sbit __at 0x81 AD1        ;
__sbit __at 0x82 AD2        ;
__sbit __at 0x83 AD3        ;
__sbit __at 0x84 AD4        ;
__sbit __at 0x85 AD5        ;
__sbit __at 0x86 AD6        ;
__sbit __at 0x87 AD7        ;
#endif

#ifdef P1
#undef P1
__sfr __at 0x90 P1          ;
// Bit registers
__sbit __at 0x90 P1_0       ;
__sbit __at 0x91 P1_1       ;
__sbit __at 0x92 P1_2       ;
__sbit __at 0x93 P1_3       ;
__sbit __at 0x94 P1_4       ;
__sbit __at 0x95 P1_5       ;
__sbit __at 0x96 P1_6       ;
__sbit __at 0x97 P1_7       ;
#endif

#ifdef P1_EXT__INT5__INT4__INT3__INT2__TXD1__RXD1__T2EX__T2
#undef P1_EXT__INT5__INT4__INT3__INT2__TXD1__RXD1__T2EX__T2
// P1 alternate functions
__sbit __at 0x90 T2         ;
__sbit __at 0x91 T2EX       ;
__sbit __at 0x92 RXD1       ;
__sbit __at 0x93 TXD1       ;
__sbit __at 0x94 INT2       ;
__sbit __at 0x95 INT3       ;
__sbit __at 0x96 INT4       ;
__sbit __at 0x97 INT5       ;
#endif

#ifdef P1_EXT__SDA__SCL__CEX2__CEX1__CEX0__ECI__T2EX__T2
#undef P1_EXT__SDA__SCL__CEX2__CEX1__CEX0__ECI__T2EX__T2
// P89C669 alternate names for bits __at P1
// P1_EXT__SDA__SCL__CEX2__CEX1__CEX0__ECI__T2EX__T2
__sbit __at 0x90 T2         ;
__sbit __at 0x91 T2EX       ;
__sbit __at 0x92 ECI        ;
__sbit __at 0x93 CEX0       ;
__sbit __at 0x94 CEX1       ;
__sbit __at 0x95 CEX2       ;
__sbit __at 0x96 SCL        ;
__sbit __at 0x97 SDA        ;
#endif

#ifdef P1_EXT__T2__CLKOUT__T2EX__INT2__INT6_CC3__INT5_CC2__INT4_CC1__INT3_CC0
__sbit __at 0x90 INT3_CC0   ; // P1 alternate functions - SAB80515 specific
__sbit __at 0x91 INT4_CC1   ;
__sbit __at 0x92 INT5_CC2   ;
__sbit __at 0x93 INT6_CC3   ;
__sbit __at 0x94 INT2       ;
__sbit __at 0x95 T2EX       ;
__sbit __at 0x96 CLKOUT     ;
__sbit __at 0x97 T2         ;
#endif

#ifdef P1_EXT__CT0I__CT1I__CT2I__CT3I__T2__RT2__SCL__SDA
#undef P1_EXT__CT0I__CT1I__CT2I__CT3I__T2__RT2__SCL__SDA
// Bit registers
__sbit __at 0x90 CT0I       ; // Port 1 alternate functions, P80C552 specific
__sbit __at 0x91 CT1I       ;
__sbit __at 0x92 CT2I       ;
__sbit __at 0x93 CT3I       ;
__sbit __at 0x94 T2         ;
__sbit __at 0x95 RT2        ;
__sbit __at 0x96 SCL        ;
__sbit __at 0x97 SDA        ;
#endif

#ifdef P1_EXT__x__x__x__x__x__x__T2EX__T2
#undef P1_EXT__x__x__x__x__x__x__T2EX__T2
// P1 alternate functions
__sbit __at 0x90 T2         ;
__sbit __at 0x91 T2EX       ;
#endif

#ifdef P2
#undef P2
__sfr __at 0xA0 P2          ;
// Bit registers
__sbit __at 0xA0 P2_0       ;
__sbit __at 0xA1 P2_1       ;
__sbit __at 0xA2 P2_2       ;
__sbit __at 0xA3 P2_3       ;
__sbit __at 0xA4 P2_4       ;
__sbit __at 0xA5 P2_5       ;
__sbit __at 0xA6 P2_6       ;
__sbit __at 0xA7 P2_7       ;
#endif

#ifdef P2_EXT__AD15__AD14__AD13__AD12__AD11__AD10__AD9__AD8
#undef P2_EXT__AD15__AD14__AD13__AD12__AD11__AD10__AD9__AD8
// P89C668 specific bit registers __at P2:
__sbit __at 0xA0 AD8        ;
__sbit __at 0xA1 AD9        ;
__sbit __at 0xA2 AD10       ;
__sbit __at 0xA3 AD11       ;
__sbit __at 0xA4 AD12       ;
__sbit __at 0xA5 AD13       ;
__sbit __at 0xA6 AD14       ;
__sbit __at 0xA7 AD15       ;
#endif

#ifdef P3
#undef P3
__sfr __at 0xB0 P3          ;
// Bit registers
__sbit __at 0xB0 P3_0       ;
__sbit __at 0xB1 P3_1       ;
__sbit __at 0xB2 P3_2       ;
__sbit __at 0xB3 P3_3       ;
__sbit __at 0xB4 P3_4       ;
__sbit __at 0xB5 P3_5       ;
#ifndef MCS51REG_EXTERNAL_RAM
__sbit __at 0xB6 P3_6       ;
__sbit __at 0xB7 P3_7       ;
#endif
// alternate names
__sbit __at 0xB0 RXD        ;
__sbit __at 0xB0 RXD0       ;
__sbit __at 0xB1 TXD        ;
__sbit __at 0xB1 TXD0       ;
__sbit __at 0xB2 INT0       ;
__sbit __at 0xB3 INT1       ;
__sbit __at 0xB4 T0         ;
__sbit __at 0xB5 T1         ;
#ifndef MCS51REG_EXTERNAL_RAM
__sbit __at 0xB6 WR         ;
__sbit __at 0xB7 RD         ;
#endif
#endif

#ifdef P3_EXT__x__x__CEX4__CEX3__x__x__x__x
#undef P3_EXT__x__x__CEX4__CEX3__x__x__x__x
// P89C668 specific bit registers __at P3 (alternate names)
__sbit __at 0xB5 CEX4       ;
__sbit __at 0xB4 CEX3       ;
#endif

#ifdef P4_AT_0X80
#undef P4_AT_0X80
__sfr __at 0x80 P4          ; // Port 4 - DS80C390
// Bit registers
__sbit __at 0x80 P4_0       ;
__sbit __at 0x81 P4_1       ;
__sbit __at 0x82 P4_2       ;
__sbit __at 0x83 P4_3       ;
__sbit __at 0x84 P4_4       ;
__sbit __at 0x85 P4_5       ;
__sbit __at 0x86 P4_6       ;
__sbit __at 0x87 P4_7       ;
#endif

#ifdef P4_AT_0XC0__CMT0__CMT1__CMSR5__CMSR4__CMSR3__CMSR2__CMSR1__CMSR0
#undef P4_AT_0XC0__CMT0__CMT1__CMSR5__CMSR4__CMSR3__CMSR2__CMSR1__CMSR0
__sfr __at 0xC0 P4          ; // Port 4, P80C552 specific
// Bit registers
__sbit __at 0xC0 CMSR0      ;
__sbit __at 0xC1 CMSR1      ;
__sbit __at 0xC2 CMSR2      ;
__sbit __at 0xC3 CMSR3      ;
__sbit __at 0xC4 CMSR4      ;
__sbit __at 0xC5 CMSR5      ;
__sbit __at 0xC6 CMT0       ;
__sbit __at 0xC7 CMT1       ;
#endif

#ifdef P4_AT_0XC0__P4_7__P4_6__P4_5__P4_3__P4_2__P4_1__P4_0
#undef P4_AT_0XC0__P4_7__P4_6__P4_5__P4_3__P4_2__P4_1__P4_0
__sfr __at 0xC0 P4          ; // Port 4, T89C51 specific
// Bit registers
__sbit __at 0xC0 P4_0       ;
__sbit __at 0xC1 P4_1       ;
__sbit __at 0xC2 P4_2       ;
__sbit __at 0xC3 P4_3       ;
__sbit __at 0xC4 P4_4       ;
__sbit __at 0xC5 P4_5       ;
__sbit __at 0xC6 P4_6       ;
__sbit __at 0xC7 P4_7       ;
#endif

#ifdef P4_AT_0XE8
#undef P4_AT_0XE8
__sfr __at 0xE8 P4          ; // Port 4 - SAB80515 & compatible microcontrollers
// Bit registers
__sbit __at 0xE8 P4_0       ;
__sbit __at 0xE9 P4_1       ;
__sbit __at 0xEA P4_2       ;
__sbit __at 0xEB P4_3       ;
__sbit __at 0xEC P4_4       ;
__sbit __at 0xED P4_5       ;
__sbit __at 0xEE P4_6       ;
__sbit __at 0xEF P4_7       ;
#endif

#ifdef P4CNT
#undef P4CNT
__sfr __at 0x92 P4CNT       ; // DS80C390
// Not directly accessible bits
#define P4CNT_0     0x01
#define P4CNT_1     0x02
#define P4CNT_2     0x04
#define P4CNT_3     0x08
#define P4CNT_4     0x10
#define P4CNT_5     0x20
#define SBCAN       0x40
#endif

#ifdef P5_AT_0XA1
#undef P5_AT_0XA1
__sfr __at 0xA1 P5          ; // Port 5 - DS80C390
#endif

#ifdef P5_AT_0XE8
#undef P5_AT_0XE8
__sfr __at 0xE8 P5          ; // Port 5 - T89C51RD2
// Bit registers
__sbit __at 0xE8 P5_0       ;
__sbit __at 0xE9 P5_1       ;
__sbit __at 0xEA P5_2       ;
__sbit __at 0xEB P5_3       ;
__sbit __at 0xEC P5_4       ;
__sbit __at 0xED P5_5       ;
__sbit __at 0xEE P5_6       ;
__sbit __at 0xEF P5_7       ;
#endif

#ifdef P5CNT
#undef P5CNT
__sfr __at 0xA2 P5CNT       ; // DS80C390
// Not directly accessible bits
#define P5CNT_0     0x01
#define P5CNT_1     0x02
#define P5CNT_2     0x04
#define C0_I_O      0x08
#define C1_I_O      0x10
#define SP1EC       0x20
#define SBCAN0BA    0x40
#define SBCAN1BA    0x80
#endif

#ifdef P5_AT_0XC4
#undef P5_AT_0XC4
__sfr __at 0xC4 P5          ; // Port 5, P80C552 specific
// Not directly accessible Bits.
#define ADC0        0x01
#define ADC1        0x02
#define ADC2        0x04
#define ADC3        0x08
#define ADC4        0x10
#define ADC5        0x20
#define ADC6        0x40
#define ADC7        0x80
#endif

#ifdef P5_AT_0XF8
#undef P5_AT_0XF8
__sfr __at 0xF8 P5          ; // Port 5 - SAB80515 & compatible microcontrollers
// Bit registers
__sbit __at 0xF8 P5_0       ;
__sbit __at 0xF9 P5_1       ;
__sbit __at 0xFA P5_2       ;
__sbit __at 0xFB P5_3       ;
__sbit __at 0xFC P5_4       ;
__sbit __at 0xFD P5_5       ;
__sbit __at 0xFE P5_6       ;
__sbit __at 0xFF P5_7       ;
#endif

#ifdef P6_AT_0XDB
#undef P6_AT_0XDB
__sfr __at 0xDB P6          ; // Port 6 - SAB80515 & compatible microcontrollers
#endif

#ifdef P6_AT_0XFA
#undef P6_AT_0XFA
__sfr __at 0xFA P6          ; // Port 6 - SAB80517 specific
#endif

#ifdef P7_AT_0XDB
#undef P7_AT_0XDB
__sfr __at 0xDB P7          ; // Port 7 - SAB80517 specific
#endif

#ifdef P8_AT_0XDD
#undef P8_AT_0XDD
__sfr __at 0xDD P8          ; // Port 6 - SAB80517 specific
#endif

#ifdef P9_AT_0XF9
#undef P9_AT_0XF9
__sfr __at 0xF9 P9;
#endif

#ifdef PCON__SMOD__x__x__x__x__x__x__x
#undef PCON__SMOD__x__x__x__x__x__x__x
__sfr __at 0x87 PCON        ;
// Not directly accessible PCON bits
#define SMOD        0x80
#endif

#ifdef PCON__SMOD__x__x__x__GF1__GF0__PD__IDL
#undef PCON__SMOD__x__x__x__GF1__GF0__PD__IDL
__sfr __at 0x87 PCON        ;
// Not directly accessible PCON bits
#define IDL         0x01
#define PD          0x02
#define GF0         0x04
#define GF1         0x08
#define SMOD        0x80
#endif

#ifdef PCON__SMOD__x__x__WLE__GF1__GF0__PD__IDL
#undef PCON__SMOD__x__x__WLE__GF1__GF0__PD__IDL
__sfr __at 0x87 PCON        ; // PCON, P80C552 specific
// Not directly accessible Bits.
#define IDL         0x01
#define IDLE        0x01 /* same as IDL */
#define PD          0x02
#define GF0         0x04
#define GF1         0x08
#define WLE         0x10
#define SMOD        0x80
#endif

#ifdef PCON__SMOD__PDS__IDLS__x__x__x__PD__IDL
#undef PCON__SMOD__PDS__IDLS__x__x__x__PD__IDL
__sfr __at 0x87 PCON        ;
// Not directly accessible PCON bits
#define IDL         0x01
#define IDLE        0x01 /* same as IDL */
#define PD          0x02
#define PDE         0x02 /* same as PD */
#define IDLS        0x20
#define PDS         0x40
#define SMOD        0x80
// alternate names
#define PCON_IDLE   0x01
#define PCON_PDE    0x02
#define PCON_GF0    0x04
#define PCON_GF1    0x08
#define PCON_IDLS   0x20
#define PCON_PDS    0x40
#define PCON_SMOD   0x80
#endif

#ifdef PCON__SMOD__POR__PFW__WTR__EPFW__EWT__STOP__IDL
#undef PCON__SMOD__POR__PFW__WTR__EPFW__EWT__STOP__IDL
__sfr __at 0x87 PCON        ;
// Not directly accessible PCON bits
#define IDL         0x01
#define IDLE        0x01 /* same as IDL */
#define STOP        0x02
#define EWT         0x04
#define EPFW        0x08
#define WTR         0x10
#define PFW         0x20
#define POR         0x40
#define SMOD        0x80
#endif

#ifdef PCON__SMOD__SMOD0__x__x__GF1__GF0__STOP__IDLE
#undef PCON__SMOD__SMOD0__x__x__GF1__GF0__STOP__IDLE
__sfr __at 0x87 PCON        ;
// Not directly accessible PCON bits
#define IDL         0x01
#define IDLE        0x01  /* same as IDL */
#define STOP        0x02
#define GF0         0x04
#define GF1         0x08
#define SMOD0       0x40
#define SMOD        0x80
#endif

#ifdef PCON__SMOD__SMOD0__OFDF__OFDE__GF1__GF0__STOP__IDLE
#undef PCON__SMOD__SMOD0__OFDF__OFDE__GF1__GF0__STOP__IDLE
__sfr __at 0x87 PCON        ;
// Not directly accessible PCON bits
#define IDL         0x01
#define IDLE        0x01 /* same as IDL */
#define STOP        0x02
#define GF0         0x04
#define GF1         0x08
#define OFDE        0x10
#define OFDF        0x20
#define SMOD0       0x40
#define SMOD        0x80
#define SMOD_0      0x80 /* same as SMOD */
#endif

#ifdef PCON__SMOD1__SMOD0__x__POF__GF1__GF0__PD__IDL
#undef PCON__SMOD1__SMOD0__x__POF__GF1__GF0__PD__IDL
__sfr __at 0x87 PCON        ;
#define IDL         0x01
#define PD          0x02
#define GF0         0x04
#define GF1         0x08
#define POF         0x10
#define SMOD0       0x40
#define SMOD1       0x80
#endif

#ifdef PMR__CD1__CD0__SWB__x__XTOFF__ALEOFF__DME1__DME0
#undef PMR__CD1__CD0__SWB__x__XTOFF__ALEOFF__DME1__DME0
__sfr __at 0xC4 PMR         ; // DS87C520, DS83C520
// Not directly accessible bits
#define DME0        0x01
#define DME1        0x02
#define ALEOFF      0x04
#define XTOFF       0x08
#define SWB         0x20
#define CD0         0x40
#define CD1         0x80
#endif

#ifdef PMR__CD1__CD0__SWB__CTM__4X_2X__ALEOFF__x__x
#undef PMR__CD1__CD0__SWB__CTM__4X_2X__ALEOFF__x__x
__sfr __at 0xC4 PMR         ; // DS80C390
// Not directly accessible bits
#define ALEOFF      0x04
#define XTOFF       0x08
#define _4X_2X      0x10
#define SWB         0x20
#define CD0         0x40
#define CD1         0x80
#endif

#ifdef PMR__CD1__CD0__SWB__CTM__4X_2X__ALEON__DME1__DME0
#undef PMR__CD1__CD0__SWB__CTM__4X_2X__ALEON__DME1__DME0
__sfr __at 0xC4 PMR         ; // DS89C420
// Not directly accessible bits
#define DME0        0x01
#define DME1        0x02
#define ALEON       0x04
#define _4X_2X      0x08
#define CTM         0x10
#define SWB         0x20
#define CD0         0x40
#define CD1         0x80
#endif

#ifdef PRSC
#undef PRSC
__sfr __at 0xB4 PRSC;
#endif

#ifdef PSW
#undef PSW
__sfr __at 0xD0 PSW         ;
// Bit registers
__sbit __at 0xD0 P          ;
__sbit __at 0xD1 F1         ;
__sbit __at 0xD2 OV         ;
__sbit __at 0xD3 RS0        ;
__sbit __at 0xD4 RS1        ;
__sbit __at 0xD5 F0         ;
__sbit __at 0xD6 AC         ;
__sbit __at 0xD7 CY         ;
#endif

#ifdef PWM0_AT_0XFC
#undef PWM0_AT_0XFC
__sfr __at 0xFC PWM0        ; // PWM register 0, P80C552 specific
#endif

#ifdef PWM1_AT_0XFD
#undef PWM1_AT_0XFD
__sfr __at 0xFD PWM1        ; // PWM register 1, P80C552 specific
#endif

#ifdef PWMP_AT_0XFE
#undef PWMP_AT_0XFE
__sfr __at 0xFE PWMP        ; // PWM prescaler, P80C552 specific
#endif

#ifdef RCAP2H
#undef RCAP2H
__sfr __at 0xCB RCAP2H      ;
#endif

#ifdef RCAP2L
#undef RCAP2L
__sfr __at 0xCA RCAP2L      ;
#endif

#ifdef RNR
#undef RNR
__sfr __at 0xCF RNR         ;
#endif

#ifdef ROMSIZE__x__x__x__x__x__RMS2__RMS1__RMS0
#undef ROMSIZE__x__x__x__x__x__RMS2__RMS1__RMS0
__sfr __at 0xC2 ROMSIZE     ; // DS87C520, DS83C520
// Not directly accessible bits
#define RSM0        0x01
#define RSM1        0x02
#define RSM2        0x04
#endif

#ifdef ROMSIZE__x__x__x__x__PRAME__RMS2__RMS1__RMS0
#undef ROMSIZE__x__x__x__x__PRAME__RMS2__RMS1__RMS0
__sfr __at 0xC2 ROMSIZE     ; // DS89C420
// Not directly accessible bits
#define RSM0        0x01
#define RSM1        0x02
#define RSM2        0x04
#define PRAME       0x08
#endif

#ifdef ROMSIZE__HBPF__BPF__TE__MOVCX__PRAME__RMS2__RMS1__RMS0
#undef ROMSIZE__HBPF__BPF__TE__MOVCX__PRAME__RMS2__RMS1__RMS0
__sfr __at 0xC2 ROMSIZE     ; // DS87C520, DS83C520
// Not directly accessible bits
#define RSM0        0x01
#define RSM1        0x02
#define RSM2        0x04
#define PRAME       0x08
#define MOVCX       0x10
#define TE          0x20
#define BPF         0x40
#define HBPF        0x80
#endif

#ifdef RPCTL
#undef RPCTL
__sfr __at 0xD8 RPCTL       ;  // Dallas DS5001 specific
__sbit __at 0xD8 RG0        ;
__sbit __at 0xD9 RPCON      ;
__sbit __at 0xDA DMA        ;
__sbit __at 0xDB IBI        ;
__sbit __at 0xDC AE         ;
__sbit __at 0xDD EXBS       ;
__sbit __at 0xDF RNR_FLAG   ;
#endif

#ifdef RTE__TP47__TP46__RP45__RP44__RP43__RP42__RP41__RP40
#undef RTE__TP47__TP46__RP45__RP44__RP43__RP42__RP41__RP40
__sfr __at 0xEF RTE         ; // Reset/toggle enable, P80C552 specific
// Not directly accessible Bits.
#define RP40        0x01
#define RP41        0x02
#define RP42        0x04
#define RP43        0x08
#define RP44        0x10
#define RP45        0x20
#define TP46        0x40
#define TP47        0x80
#endif

#ifdef S0BUF
#undef S0BUF
__sfr __at 0x99 S0BUF       ; // serial channel 0 buffer register SAB80517 specific
#endif

#ifdef S0CON__SM0__SM1__SM2__REN__TB8__RB8__TI__RI
#undef S0CON__SM0__SM1__SM2__REN__TB8__RB8__TI__RI
__sfr __at 0x98 S0CON       ; // serial channel 0 control register P80C552 specific
// Bit registers
// Already defined in SCON
//__sbit __at 0x98 RI0  ;
//__sbit __at 0x99 TI0  ;
//__sbit __at 0x9A RB8  ;
//__sbit __at 0x9B TB8  ;
//__sbit __at 0x9C REN  ;
//__sbit __at 0x9D SM2  ;
//__sbit __at 0x9E SM1  ;
//__sbit __at 0x9F SM0  ;
#endif

#ifdef S0CON__SM0__SM1__SM20__REN0__TB80__RB80__TI0__RI0
#undef S0CON__SM0__SM1__SM20__REN0__TB80__RB80__TI0__RI0
// serial channel 0 buffer register SAB80517 specific(same as stock SCON)
__sfr __at 0x98 S0CON       ;
__sbit __at 0x98 RI0        ;
__sbit __at 0x99 TI0        ;
__sbit __at 0x9A RB80       ;
__sbit __at 0x9B TB80       ;
__sbit __at 0x9C REN0       ;
__sbit __at 0x9D SM20       ;
__sbit __at 0x9E SM1        ;
__sbit __at 0x9F SM0        ;
#endif

#ifdef S0RELL
#undef S0RELL
__sfr __at 0xAA S0RELL      ; // serial channel 0 reload register low byte SAB80517 specific
#endif

#ifdef S0RELH
#undef S0RELH
__sfr __at 0xBA S0RELH      ; // serial channel 0 reload register high byte SAB80517 specific
#endif

#ifdef S1ADR__x__x__x__x__x__x__x__GC
#undef S1ADR__x__x__x__x__x__x__x__GC
__sfr __at 0xDB S1ADR       ; // Serial 1 address, P80C552 specific
// Not directly accessible Bits.
#define GC      0x01
#endif

#ifdef S1BUF
#undef S1BUF
__sfr __at 0x9C S1BUF       ; // serial channel 1 buffer register SAB80517 specific
#endif

#ifdef S1CON_AT_0X9B
#undef S1CON_AT_0X9B
__sfr __at 0x9B S1CON       ; // serial channel 1 control register SAB80517 specific
#endif

#ifdef S1CON__CR2__ENS1__STA__ST0__SI__AA__CR1__CR0
#undef S1CON__CR2__ENS1__STA__ST0__SI__AA__CR1__CR0
__sfr __at 0xD8 S1CON       ; // Serial 1 control, P80C552 specific
__sfr __at 0xD8 SICON       ; // sometimes called SICON
// Bit register
__sbit __at 0xD8 CR0        ;
__sbit __at 0xD9 CR1        ;
__sbit __at 0xDA AA         ;
__sbit __at 0xDB SI         ;
__sbit __at 0xDC ST0        ;
__sbit __at 0xDD STA        ;
__sbit __at 0xDE ENS1       ;
__sbit __at 0xDF CR2        ;
#endif

#ifdef S1DAT_AT_0XDA
#undef S1DAT_AT_0XDA
__sfr __at 0xDA S1DAT       ; // Serial 1 data, P80C552 specific
__sfr __at 0xDA SIDAT       ; // sometimes called SIDAT
#endif

#ifdef S1IST_AT_0XDC
#undef S1IST_AT_0XDC
// P89C668 specific
__sfr __at 0xDC S1IST       ;
#endif

#ifdef S1RELL
#undef S1RELL
__sfr __at 0x9D S1RELL      ; // serial channel 1 reload register low byte SAB80517 specific
#endif

#ifdef S1RELH
#undef S1RELH
__sfr __at 0xBB S1RELH      ; // serial channel 1 reload register high byte SAB80517 specific
#endif

#ifdef S1STA__SC4__SC3__SC2__SC1__SC0__x__x__x
#undef S1STA__SC4__SC3__SC2__SC1__SC0__x__x__x
__sfr __at 0xD9 S1STA       ; // Serial 1 status, P80C552 specific
// Not directly accessible Bits.
#define SC0         0x08
#define SC1         0x10
#define SC2         0x20
#define SC3         0x40
#define SC4         0x80
#endif

#ifdef SADR_AT_0XA9
#undef SADR_AT_0XA9
__sfr __at 0xA9 SADDR       ;
#endif

#ifdef SADDR0
#undef SADDR0
// DS80C320 specific
__sfr __at 0xA9 SADDR0      ;
#endif

#ifdef SADDR1
#undef SADDR1
// DS80C320 specific
__sfr __at 0xAA SADDR1      ;
#endif

#ifdef SADEN_AT_0XB9
#undef SADEN_AT_0XB9
__sfr __at 0xB9 SADEN       ;
#endif

#ifdef SADEN0
#undef SADEN0
// DS80C320 & DS80C390 specific
__sfr __at 0xB9 SADEN0      ;
#endif

#ifdef SADEN1
#undef SADEN1
// DS80C320 & DS80C390 specific
__sfr __at 0xBA SADEN1      ;
#endif

#ifdef SBUF
#undef SBUF
__sfr __at 0x99 SBUF        ;
__sfr __at 0x99 SBUF0       ;
#endif

#ifdef SBUF1
#undef SBUF1
// DS80C320 & DS80C390 specific
__sfr __at 0xC1 SBUF1       ;
#endif

#ifdef SCON
#undef SCON
__sfr __at 0x98 SCON        ;
// Bit registers
__sbit __at 0x98 RI         ;
__sbit __at 0x99 TI         ;
__sbit __at 0x9A RB8        ;
__sbit __at 0x9B TB8        ;
__sbit __at 0x9C REN        ;
__sbit __at 0x9D SM2        ;
__sbit __at 0x9E SM1        ;
__sbit __at 0x9F SM0        ;
#endif

#ifdef SCON0
#undef SCON0
__sfr __at 0x98 SCON0       ;
// Bit registers
__sbit __at 0x98 RI_0       ;
__sbit __at 0x99 TI_0       ;
__sbit __at 0x9A RB8_0      ;
__sbit __at 0x9B TB8_0      ;
__sbit __at 0x9C REN_0      ;
__sbit __at 0x9D SM2_0      ;
__sbit __at 0x9E SM1_0      ;
__sbit __at 0x9F SM0_0      ;
__sbit __at 0x9F FE_0       ;
__sbit __at 0x9F SM0_FE_0   ;
#endif

#ifdef SCON1
#undef SCON1
// DS80C320 - 80C390 specific
__sfr __at 0xC0 SCON1       ;
// Bit registers
__sbit __at 0xC0 RI_1       ;
__sbit __at 0xC1 TI_1       ;
__sbit __at 0xC2 RB8_1      ;
__sbit __at 0xC3 TB8_1      ;
__sbit __at 0xC4 REN_1      ;
__sbit __at 0xC5 SM2_1      ;
__sbit __at 0xC6 SM1_1      ;
__sbit __at 0xC7 SM0_1      ;
__sbit __at 0xC7 FE_1       ;
__sbit __at 0xC7 SM0_FE_1   ;
#endif

#ifdef SETMSK
#undef SETMSK
__sfr __at 0xA5 SETMSK;
#endif

#ifdef SP
#undef SP
__sfr __at 0x81 SP          ;
#endif

#ifdef SPCR
#undef SPCR
__sfr __at 0xD5 SPCR        ; // AT89S53 specific
// Not directly accesible bits
#define SPR0        0x01
#define SPR1        0x02
#define CPHA        0x04
#define CPOL        0x08
#define MSTR        0x10
#define DORD        0x20
#define SPE         0x40
#define SPIE        0x80
#endif

#ifdef SPDR
#undef SPDR
__sfr __at 0x86 SPDR        ; // AT89S53 specific
// Not directly accesible bits
#define SPD_0       0x01
#define SPD_1       0x02
#define SPD_2       0x04
#define SPD_3       0x08
#define SPD_4       0x10
#define SPD_5       0x20
#define SPD_6       0x40
#define SPD_7       0x80
#endif

#ifdef SPSR
#undef SPSR
__sfr __at 0xAA SPSR        ; // AT89S53 specific
// Not directly accesible bits
#define SPIF        0x40
#define WCOL        0x80
#endif

#ifdef SRELH
#undef SRELH
__sfr __at 0xBA SRELH       ; // Baudrate generator reload high
#endif

#ifdef SRELL
#undef SRELL
__sfr __at 0xAA SRELL       ; // Baudrate generator reload low
#endif

#ifdef STATUS__PIP__HIP__LIP__x__x__x__x__x
#undef STATUS__PIP__HIP__LIP__x__x__x__x__x
// DS80C320 specific
__sfr __at 0xC5 STATUS      ;
// Not directly accessible Bits. DS80C320 specific
#define LIP         0x20
#define HIP         0x40
#define PIP         0x80
#endif

#ifdef STATUS__PIP__HIP__LIP__x__SPTA1__SPRA1__SPTA0__SPRA0
#undef STATUS__PIP__HIP__LIP__x__SPTA1__SPRA1__SPTA0__SPRA0
__sfr __at 0xC5 STATUS      ; // DS80C390 specific
// Not directly accessible Bits.
#define SPRA0       0x01
#define SPTA0       0x02
#define SPRA1       0x04
#define SPTA1       0x08
#define LIP         0x20
#define HIP         0x40
#define PIP         0x80
#endif

#ifdef STATUS__PIS2__PIS1__PIS0__x__SPTA1__SPRA1__SPTA0__SPRA0
#undef STATUS__PIS2__PIS1__PIS0__x__SPTA1__SPRA1__SPTA0__SPRA0
__sfr __at 0xC5 STATUS      ; // DS89C420 specific
// Not directly accessible Bits.
#define SPRA0       0x01
#define SPTA0       0x02
#define SPRA1       0x04
#define SPTA1       0x08
#define PIS0        0x20
#define PIS1        0x40
#define PIS2        0x80
#endif

#ifdef STATUS__PIP__HIP__LIP__x__SPTA1__SPRA1__SPTA0__SPRA0
#undef STATUS__PIP__HIP__LIP__x__SPTA1__SPRA1__SPTA0__SPRA0
__sfr __at 0xC5 STATUS      ; // DS80C390 specific
// Not directly accessible Bits.
#define SPRA0       0x01
#define SPTA0       0x02
#define SPRA1       0x04
#define SPTA1       0x08
#define LIP         0x20
#define HIP         0x40
#define PIP         0x80
#endif

#ifdef STATUS__PIP__HIP__LIP__XTUP__SPTA2__SPTA1__SPTA0__SPRA0
#undef STATUS__PIP__HIP__LIP__XTUP__SPTA2__SPTA1__SPTA0__SPRA0
__sfr __at 0xC5 STATUS      ; // DS87C520 & DS83520specific
// Not directly accessible Bits.
#define SPRA0       0x01
#define SPTA0       0x02
#define SPTA1       0x04
#define SPTA2       0x08
#define XTUP        0x10
#define LIP         0x20
#define HIP         0x40
#define PIP         0x80
#endif

#ifdef STATUS__ST7__ST6__ST5__ST4__IA0__F0__IBF__OBF
#undef STATUS__ST7__ST6__ST5__ST4__IA0__F0__IBF__OBF
__sfr __at 0xDA STATUS      ; // DS5001specific
// Not directly accessible Bits.
#define OBF         0x01
#define IBF         0x02
#define F0          0x04
#define IA0         0x08
#define ST4         0x10
#define ST5         0x20
#define ST6         0x40
#define ST7         0x80
#endif

#ifdef STE__TG47__TG46__SP45__SP44__SP43__SP42__SP41__SP40
#undef STE__TG47__TG46__SP45__SP44__SP43__SP42__SP41__SP40
__sfr __at 0xEE STE         ; // Set enable, P80C552 specific
// Not directly accessible Bits.
#define SP40        0x01
#define SP41        0x02
#define SP42        0x04
#define SP43        0x08
#define SP44        0x10
#define SP45        0x20
#define TG46        0x40
#define TG47        0x80
#endif

#ifdef SYSCON
#undef SYSCON
__sfr __at 0xB1 SYSCON      ; // XRAM Controller Access Control
// SYSCON bits
#define SYSCON_XMAP0 0x01
#define SYSCON_XMAP1 0x02
#define SYSCON_RMAP  0x10
#define SYSCON_EALE  0x20
#endif

#ifdef SYSCON1
#undef SYSCON1
__sfr __at 0xB2 SYSCON1;
#endif

#ifdef T2
#undef T2
__sfr __at 0xCC T2;
#endif

#ifdef T2CON__TF2__EXF2__RCLK__TCLK__EXEN2__TR2__C_T2__CP_RL2
#undef T2CON__TF2__EXF2__RCLK__TCLK__EXEN2__TR2__C_T2__CP_RL2
__sfr __at 0xC8 T2CON       ;
// Definitions for the 8052 compatible microcontrollers.
// Bit registers
__sbit __at 0xC8 CP_RL2     ;
__sbit __at 0xC9 C_T2       ;
__sbit __at 0xCA TR2        ;
__sbit __at 0xCB EXEN2      ;
__sbit __at 0xCC TCLK       ;
__sbit __at 0xCD RCLK       ;
__sbit __at 0xCE EXF2       ;
__sbit __at 0xCF TF2        ;
// alternate names
__sbit __at 0xC8 T2CON_0    ;
__sbit __at 0xC9 T2CON_1    ;
__sbit __at 0xCA T2CON_2    ;
__sbit __at 0xCB T2CON_3    ;
__sbit __at 0xCC T2CON_4    ;
__sbit __at 0xCD T2CON_5    ;
__sbit __at 0xCE T2CON_6    ;
__sbit __at 0xCF T2CON_7    ;
#endif

#ifdef T2CON__T2PS__I3FR__I2FR__T2R1__T2R0__T2CM__T2I1__T2I0
#undef T2CON__T2PS__I3FR__I2FR__T2R1__T2R0__T2CM__T2I1__T2I0
__sfr __at 0xC8 T2CON       ;
// Definitions for the Infineon / Siemens SAB80515, SAB80515A, SAB80517
// Bit registers
__sbit __at 0xC8 T2I0       ;
__sbit __at 0xC9 T2I1       ;
__sbit __at 0xCA T2CM       ;
__sbit __at 0xCB T2R0       ;
__sbit __at 0xCC T2R1       ;
__sbit __at 0xCD I2FR       ;
__sbit __at 0xCE I3FR       ;
__sbit __at 0xCF T2PS       ;
// alternate names
__sbit __at 0xC8 T2CON_0    ;
__sbit __at 0xC9 T2CON_1    ;
__sbit __at 0xCA T2CON_2    ;
__sbit __at 0xCB T2CON_3    ;
__sbit __at 0xCC T2CON_4    ;
__sbit __at 0xCD T2CON_5    ;
__sbit __at 0xCE T2CON_6    ;
__sbit __at 0xCF T2CON_7    ;
#endif

#ifdef T2MOD__x__x__x__D13T1__D13T2__x__T2OE__DCEN
#undef T2MOD__x__x__x__D13T1__D13T2__x__T2OE__DCEN
// Definitions for the timer/counter 2 of the Atmel & Dallas microcontrollers
__sfr __at 0xC9 T2MOD       ;
// Not not directly accessible T2MOD bits
#define DCEN        0x01
#define T2OE        0x02
#define D13T2       0x08
#define D13T1       0x10
#endif

#ifdef T2MOD__x__x__x__x__x__x__T2OE__DCEN
#undef T2MOD__x__x__x__x__x__x__T2OE__DCEN
// Definitions for the timer/counter 2 of the Atmel 89x52 microcontroller
__sfr __at 0xC9 T2MOD       ;
// Not not directly accessible T2MOD bits
#define DCEN        0x01
#define T2OE        0x02
// Alternate names
#define DCEN_       0x01
#define T2OE_       0x02
#endif

#ifdef T3_AT_0XFF
#undef T3_AT_0XFF
__sfr __at 0xFF T3          ; // Timer 3, P80C552 specific
#endif

#ifdef TA
#undef TA
// DS500x, DS80C320 & DS80C390 specific
__sfr __at 0xC7 TA          ;
#endif

#ifdef TCON
#undef TCON
__sfr __at 0x88 TCON        ;
//  Bit registers
__sbit __at 0x88 IT0        ;
__sbit __at 0x89 IE0        ;
__sbit __at 0x8A IT1        ;
__sbit __at 0x8B IE1        ;
__sbit __at 0x8C TR0        ;
__sbit __at 0x8D TF0        ;
__sbit __at 0x8E TR1        ;
__sbit __at 0x8F TF1        ;
#endif

#ifdef TH0
#undef TH0
__sfr __at 0x8C TH0         ;
#endif

#ifdef TH1
#undef TH1
__sfr __at 0x8D TH1         ;
#endif

#ifdef TH2
#undef TH2
__sfr __at 0xCD TH2         ;
#endif

#ifdef TL0
#undef TL0
__sfr __at 0x8A TL0         ;
#endif

#ifdef TL1
#undef TL1
__sfr __at 0x8B TL1         ;
#endif

#ifdef TL2
#undef TL2
__sfr __at 0xCC TL2         ;
#endif

#ifdef TMOD
#undef TMOD
__sfr __at 0x89 TMOD        ;
// Not directly accessible TMOD bits
#define T0_M0       0x01
#define T0_M1       0x02
#define T0_CT       0x04
#define T0_GATE     0x08
#define T1_M0       0x10
#define T1_M1       0x20
#define T1_CT       0x40
#define T1_GATE     0x80

#define T0_MASK     0x0F
#define T1_MASK     0xF0
#endif

#ifdef TM2CON__T2IS1__T2IS0__T2ER__T2B0__T2P1__T2P0__T2MS1__T2MS0
#undef TM2CON__T2IS1__T2IS0__T2ER__T2B0__T2P1__T2P0__T2MS1__T2MS0
__sfr __at 0xEA TM2CON      ; // Timer 2 control, P80C552 specific
// Not directly accessible Bits.
#define T2MS0       0x01
#define T2MS1       0x02
#define T2P0        0x04
#define T2P1        0x08
#define T2B0        0x10
#define T2ER        0x20
#define T2IS0       0x40
#define T2IS1       0x80
#endif

#ifdef TM2IR__T20V__CMI2__CMI1__CMI0__CTI3__CTI2__CTI1__CTI0
#undef TM2IR__T20V__CMI2__CMI1__CMI0__CTI3__CTI2__CTI1__CTI0
__sfr __at 0xC8 TM2IR       ; // Timer 2 int flag reg, P80C552 specific
// Bit register
__sbit __at 0xC8 CTI0       ;
__sbit __at 0xC9 CTI1       ;
__sbit __at 0xCA CTI2       ;
__sbit __at 0xCB CTI3       ;
__sbit __at 0xCC CMI0       ;
__sbit __at 0xCD CMI1       ;
__sbit __at 0xCE CMI2       ;
__sbit __at 0xCF T20V       ;
#endif

#ifdef TMH2_AT_0XED
#undef TMH2_AT_0XED
__sfr __at 0xED TMH2        ; // Timer high 2, P80C552 specific
#endif

#ifdef TML2_AT_0XEC
#undef TML2_AT_0XEC
__sfr __at 0xEC TML2        ; // Timer low 2, P80C552 specific
#endif

#ifdef WCON
#undef WCON
__sfr __at 0x96 WCON        ;   // AT89S53 specific
// Not directly accesible bits
#define WDTEN       0x01
#define WDTRST      0x02
#define DPS         0x04
#define PS0         0x20
#define PS1         0x40
#define PS2         0x80
#endif

#ifdef WDCON
#undef WDCON
// DS80C320 - 390, DS89C420, etc. specific
__sfr __at 0xD8 WDCON       ;
//  Bit registers
__sbit __at 0xD8 RWT        ;
__sbit __at 0xD9 EWT        ;
__sbit __at 0xDA WTRF       ;
__sbit __at 0xDB WDIF       ;
__sbit __at 0xDC PFI        ;
__sbit __at 0xDD EPFI       ;
__sbit __at 0xDE POR        ;
__sbit __at 0xDF SMOD_1     ;
#endif

#ifdef WDTPRG_AT_0XA7
#undef WDTPRG_AT_0XA7
__sfr __at 0xA7 WDTPRG      ;
#define WDTRPRG_S0  0x01
#define WDTRPRG_S1  0x02
#define WDTRPRG_S2  0x04
#endif

#ifdef WDTREL
#undef WDTREL
__sfr __at 0x86 WDTREL      ; // Watchdof Timer reload register
#endif

#ifdef WDTRST_AT_0XA6
#undef WDTRST_AT_0XA6
__sfr __at 0xA6 WDTRST      ;
#endif

#ifdef XPAGE
#undef XPAGE
__sfr __at 0x91 XPAGE       ; // Page Address Register for Extended On-Chip Ram - Infineon / Siemens SAB80515A specific
#endif

/////////////////////////
/// Interrupt vectors ///
/////////////////////////

// Interrupt numbers: address = (number * 8) + 3
#define IE0_VECTOR      0       // 0x03 external interrupt 0
#define TF0_VECTOR      1       // 0x0b timer 0
#define IE1_VECTOR      2       // 0x13 external interrupt 1
#define TF1_VECTOR      3       // 0x1b timer 1
#define SI0_VECTOR      4       // 0x23 serial port 0

#ifdef MICROCONTROLLER_AT89S53
#define TF2_VECTOR      5       /* 0x2B timer 2 */
#define EX2_VECTOR      5       /* 0x2B external interrupt 2 */
#endif

#ifdef MICROCONTROLLER_AT89X52
#define TF2_VECTOR      5       /* 0x2B timer 2 */
#define EX2_VECTOR      5       /* 0x2B external interrupt 2 */
#endif

#ifdef MICROCONTROLLER_AT89X55
#define TF2_VECTOR      5       /* 0x2B timer 2 */
#define EX2_VECTOR      5       /* 0x2B external interrupt 2 */
#endif

#ifdef MICROCONTROLLER_DS5000
#define PFW_VECTOR      5       /* 0x2B */
#endif

#ifdef MICROCONTROLLER_DS5001
#define PFW_VECTOR      5       /* 0x2B */
#endif

#ifdef MICROCONTROLLER_DS80C32X
#define TF2_VECTOR      5       /* 0x2B */
#define PFI_VECTOR      6       /* 0x33 */
#define SIO1_VECTOR     7       /* 0x3B */
#define IE2_VECTOR      8       /* 0x43 */
#define IE3_VECTOR      9       /* 0x4B */
#define IE4_VECTOR     10       /* 0x53 */
#define IE5_VECTOR     11       /* 0x5B */
#define WDI_VECTOR     12       /* 0x63 */
#endif

#ifdef MICROCONTROLLER_DS89C420
#define TF2_VECTOR      5       /* 0x2B */
#define PFI_VECTOR      6       /* 0x33 */
#define SIO1_VECTOR     7       /* 0x3B */
#define IE2_VECTOR      8       /* 0x43 */
#define IE3_VECTOR      9       /* 0x4B */
#define IE4_VECTOR     10       /* 0x53 */
#define IE5_VECTOR     11       /* 0x5B */
#define WDI_VECTOR     12       /* 0x63 */
#endif

#ifdef MICROCONTROLLER_DS8XC520
#define TF2_VECTOR      5       /* 0x2B */
#define PFI_VECTOR      6       /* 0x33 */
#define SIO1_VECTOR     7       /* 0x3B */
#define IE2_VECTOR      8       /* 0x43 */
#define IE3_VECTOR      9       /* 0x4B */
#define IE4_VECTOR     10       /* 0x53 */
#define IE5_VECTOR     11       /* 0x5B */
#define WDI_VECTOR     12       /* 0x63 */
#endif

#ifdef MICROCONTROLLER_P80C552
#define SIO1_VECTOR     5       // 0x2B SIO1 (I2C)
#define CT0_VECTOR      6       // 0x33 T2 capture 0
#define CT1_VECTOR      7       // 0x3B T2 capture 1
#define CT2_VECTOR      8       // 0x43 T2 capture 2
#define CT3_VECTOR      9       // 0x4B T2 capture 3
#define ADC_VECTOR     10       // 0x53 ADC completion
#define CM0_VECTOR     11       // 0x5B T2 compare 0
#define CM1_VECTOR     12       // 0x63 T2 compare 1
#define CM2_VECTOR     13       // 0x6B T2 compare 2
#define TF2_VECTOR     14       // 0x73 T2 overflow
#endif

#ifdef MICROCONTROLLER_P89C668
#define SIO1_VECTOR     5       // 0x2b SIO1 (i2c)
#define PCA_VECTOR      6       // 0x33 (Programmable Counter Array)
#define TF2_VECTOR      7       // 0x3B (Timer 2)
#endif

#ifdef MICROCONTROLLER_SAB80509
#define RI0_VECTOR      4       // 0x23 serial port 0
#define TI0_VECTOR      4       // 0x23 serial port 0
#define TF2_VECTOR      5       // 0x2B timer 2
#define EX2_VECTOR      5       // 0x2B external interrupt 2
                                // 0x33
                                // 0x3B
#define IADC_VECTOR     8       // 0x43 A/D converter interrupt
#define IEX2_VECTOR     9       // 0x4B external interrupt 2
#define IEX3_VECTOR    10       // 0x53 external interrupt 3
#define IEX4_VECTOR    11       // 0x5B external interrupt 4
#define IEX5_VECTOR    12       // 0x63 external interrupt 5
#define IEX6_VECTOR    13       // 0x6B external interrupt 6
                                // 0x73 not used
                                // 0x7B not used
#define SI1_VECTOR     16       // 0x83 serial port 1
#define RI1_VECTOR     16       // 0x83 serial port 1
#define TI1_VECTOR     16       // 0x83 serial port 1
                                // 0x8B not used
#define ICM_VECTOR     18       // 0x93 compare registers CM0-CM7
#define CTF_VECTOR     19       // 0x9B compare time overflow
#define ICS_VECTOR     20       // 0xA3 compare register COMSET
#define ICR_VECTOR     21       // 0xAB compare register COMCLR
#define ICC_VECTOR     26       // 0xD3 compare event interrupt ICC10-ICC17
#define CT1_VECTOR     27       // 0xDB compare timer 1 oveflow
#endif

#ifdef MICROCONTROLLER_SAB80515
#define TF2_VECTOR      5       // 0x2B timer 2
#define EX2_VECTOR      5       // 0x2B external interrupt 2
#define IADC_VECTOR     8       // 0x43 A/D converter interrupt
#define IEX2_VECTOR     9       // 0x4B external interrupt 2
#define IEX3_VECTOR    10       // 0x53 external interrupt 3
#define IEX4_VECTOR    11       // 0x5B external interrupt 4
#define IEX5_VECTOR    12       // 0x63 external interrupt 5
#define IEX6_VECTOR    13       // 0x6B external interrupt 6
#endif

#ifdef MICROCONTROLLER_SAB80515A
#define TF2_VECTOR      5       // 0x2B timer 2
#define EX2_VECTOR      5       // 0x2B external interrupt 2
#define IADC_VECTOR     8       // 0x43 A/D converter interrupt
#define IEX2_VECTOR     9       // 0x4B external interrupt 2
#define IEX3_VECTOR    10       // 0x53 external interrupt 3
#define IEX4_VECTOR    11       // 0x5B external interrupt 4
#define IEX5_VECTOR    12       // 0x63 external interrupt 5
#define IEX6_VECTOR    13       // 0x6B external interrupt 6
#endif

#ifdef MICROCONTROLLER_SAB80517
#define TF2_VECTOR      5       // 0x2B timer 2
#define EX2_VECTOR      5       // 0x2B external interrupt 2
#define IADC_VECTOR     8       // 0x43 A/D converter interrupt
#define IEX2_VECTOR     9       // 0x4B external interrupt 2
#define IEX3_VECTOR    10       // 0x53 external interrupt 3
#define IEX4_VECTOR    11       // 0x5B external interrupt 4
#define IEX5_VECTOR    12       // 0x63 external interrupt 5
#define IEX6_VECTOR    13       // 0x6B external interrupt 6
                                // 0x73 not used
                                // 0x7B not used
#define SI1_VECTOR     16       // 0x83 serial port 1
                                // 0x8B not used
                                // 0x93 not used
#define COMPARE_VECTOR 19       // 0x9B compare
#endif

#ifdef MICROCONTORLLER_T89C51RD2
#define TF2_VECTOR      5       /* 0x2B timer 2 */
#define PCA_VECTOR      6       /* 0x33 Programmable Counter Array interrupt */
#endif /* MICROCONTORLLER_T89C51RD2 */

#endif  // End of the header -> #ifndef MCS51REG_H
/*-------------------------------------------------------------------------
   8052.h: Register Declarations for the Intel 8052 Processor

   Copyright (C) 2000, Bela Torok / bela.torok@kssg.ch

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef REG8052_H
#define REG8052_H

#include <8051.h>     /* load definitions for the 8051 core */

#ifdef REG8051_H
#undef REG8051_H
#endif

/* define 8052 specific registers only */

/* T2CON */
__sfr __at (0xC8) T2CON ;

/* RCAP2 L & H */
__sfr __at (0xCA) RCAP2L  ;
__sfr __at (0xCB) RCAP2H  ;
__sfr __at (0xCC) TL2     ;
__sfr __at (0xCD) TH2     ;

/*  IE  */
__sbit __at (0xAD) ET2    ; /* Enable timer2 interrupt */

/*  IP  */
__sbit __at (0xBD) PT2    ; /* T2 interrupt priority bit */

/* T2CON bits */
__sbit __at (0xC8) T2CON_0 ;
__sbit __at (0xC9) T2CON_1 ;
__sbit __at (0xCA) T2CON_2 ;
__sbit __at (0xCB) T2CON_3 ;
__sbit __at (0xCC) T2CON_4 ;
__sbit __at (0xCD) T2CON_5 ;
__sbit __at (0xCE) T2CON_6 ;
__sbit __at (0xCF) T2CON_7 ;

__sbit __at (0xC8) CP_RL2  ;
__sbit __at (0xC9) C_T2    ;
__sbit __at (0xCA) TR2     ;
__sbit __at (0xCB) EXEN2   ;
__sbit __at (0xCC) TCLK    ;
__sbit __at (0xCD) RCLK    ;
__sbit __at (0xCE) EXF2    ;
__sbit __at (0xCF) TF2     ;

#endif
/*-------------------------------------------------------------------------
   p89lpc938.h - This header defines register addresses for the Philips
   P89LPC938 microcontroller for use with the SDCC compiler.

   Copyright (C) 2007, Kyle Guinn <elyk03@gmail.com>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef P89LPC938_H
#define P89LPC938_H

/* SFR byte addresses */
__sfr __at (0x80) P0;      /* Port 0                               */
__sfr __at (0x81) SP;      /* Stack pointer                        */
__sfr __at (0x82) DPL;     /* Data pointer low                     */
__sfr __at (0x83) DPH;     /* Data pointer high                    */
__sfr __at (0x84) P0M1;    /* Port 0 output mode 1                 */
__sfr __at (0x85) P0M2;    /* Port 0 output mode 2                 */
__sfr __at (0x86) KBMASK;  /* Keypad interrupt mask register       */
__sfr __at (0x87) PCON;    /* Power control register               */
__sfr __at (0x88) TCON;    /* Timer 0 and 1 control                */
__sfr __at (0x89) TMOD;    /* Timer 0 and 1 mode                   */
__sfr __at (0x8A) TL0;     /* Timer 0 low                          */
__sfr __at (0x8B) TL1;     /* Timer 1 low                          */
__sfr __at (0x8C) TH0;     /* Timer 0 high                         */
__sfr __at (0x8D) TH1;     /* Timer 1 high                         */
__sfr __at (0x8F) TAMOD;   /* Timer 0 and 1 auxiliary mode         */
__sfr __at (0x90) P1;      /* Port 1                               */
__sfr __at (0x91) P1M1;    /* Port 1 output mode 1                 */
__sfr __at (0x92) P1M2;    /* Port 1 output mode 2                 */
__sfr __at (0x93) KBPATN;  /* Keypad pattern register              */
__sfr __at (0x94) KBCON;   /* Keypad control register              */
__sfr __at (0x95) DIVM;    /* CPU clock divide-by-M control        */
__sfr __at (0x96) TRIM;    /* Internal oscillator trim register    */
__sfr __at (0x97) AD0CON;  /* ADC0 control register                */
__sfr __at (0x98) SCON;    /* Serial port control                  */
__sfr __at (0x99) SBUF;    /* Serial port data buffer register     */
__sfr __at (0xA0) P2;      /* Port 2                               */
__sfr __at (0xA1) AD0MODB; /* ADC0 mode register B                 */
__sfr __at (0xA2) AUXR1;   /* Auxiliary function register          */
__sfr __at (0xA3) AD0INS;  /* ADC0 input select                    */
__sfr __at (0xA4) P2M1;    /* Port 2 output mode 1                 */
__sfr __at (0xA5) P2M2;    /* Port 2 output mode 2                 */
__sfr __at (0xA7) WDCON;   /* Watchdog control register            */
__sfr __at (0xA8) IEN0;    /* Interrupt enable 0                   */
__sfr __at (0xA9) SADDR;   /* Serial port address register         */
__sfr __at (0xAA) ICRAL;   /* Input capture A register low         */
__sfr __at (0xAB) ICRAH;   /* Input capture A register high        */
__sfr __at (0xAC) CMP1;    /* Comparator 1 control register        */
__sfr __at (0xAD) CMP2;    /* Comparator 2 control register        */
__sfr __at (0xAE) ICRBL;   /* Input capture B register low         */
__sfr __at (0xAF) ICRBH;   /* Input capture B register high        */
__sfr __at (0xB0) P3;      /* Port 3                               */
__sfr __at (0xB1) P3M1;    /* Port 3 output mode 1                 */
__sfr __at (0xB2) P3M2;    /* Port 3 output mode 2                 */
__sfr __at (0xB5) PCONA;   /* Power control register A             */
__sfr __at (0xB7) IP0H;    /* Interrupt priority 0 high            */
__sfr __at (0xB8) IP0;     /* Interrupt priority 0                 */
__sfr __at (0xB9) SADEN;   /* Serial port address enable           */
__sfr __at (0xBA) SSTAT;   /* Serial port extended status register */
__sfr __at (0xBD) BRGCON;  /* Baud rate generator control          */
__sfr __at (0xBE) BRGR0;   /* Baud rate generator rate low         */
__sfr __at (0xBF) BRGR1;   /* Baud rate generator rate high        */
__sfr __at (0xC0) AD0MODA; /* ADC0 mode register A                 */
__sfr __at (0xC1) WDL;     /* Watchdog load                        */
__sfr __at (0xC2) WFEED1;  /* Watchdog feed 1                      */
__sfr __at (0xC3) WFEED2;  /* Watchdog feed 2                      */
__sfr __at (0xC8) TCR20;   /* CCU control register 0               */
__sfr __at (0xC9) TICR2;   /* CCU interrupt control register       */
__sfr __at (0xCA) TPCR2L;  /* Prescaler control register low       */
__sfr __at (0xCB) TPCR2H;  /* Prescaler control register high      */
__sfr __at (0xCC) TL2;     /* CCU timer low                        */
__sfr __at (0xCD) TH2;     /* CCU timer high                       */
__sfr __at (0xCE) TOR2L;   /* CCU reload register low              */
__sfr __at (0xCF) TOR2H;   /* CCU reload register high             */
__sfr __at (0xD0) PSW;     /* Program status word                  */
__sfr __at (0xD1) RTCCON;  /* RTC control                          */
__sfr __at (0xD2) RTCH;    /* RTC register high                    */
__sfr __at (0xD3) RTCL;    /* RTC register low                     */
__sfr __at (0xD5) IEN2;    /* Interrupt enable 2                   */
__sfr __at (0xD6) IP2;     /* Interrupt priority 2                 */
__sfr __at (0xD7) IP2H;    /* Interrupt priority 2 high            */
__sfr __at (0xD8) I2CON;   /* IÂ²C control register                 */
__sfr __at (0xD9) I2STAT;  /* IÂ²C status register                  */
__sfr __at (0xDA) I2DAT;   /* IÂ²C data register                    */
__sfr __at (0xDB) I2ADR;   /* IÂ²C slave address register           */
__sfr __at (0xDC) I2SCLL;  /* Serial clock generator low/
                            * SCL duty cycle register low          */
__sfr __at (0xDD) I2SCLH;  /* Serial clock generator high/
                            * SCL duty cycle register high         */
__sfr __at (0xDE) TISE2;   /* CCU interrupt status encode register */
__sfr __at (0xDF) RSTSRC;  /* Reset source register                */
__sfr __at (0xE0) ACC;     /* Accumulator                          */
__sfr __at (0xE1) SPSTAT;  /* SPI status register                  */
__sfr __at (0xE2) SPCTL;   /* SPI control register                 */
__sfr __at (0xE3) SPDAT;   /* SPI data register                    */
__sfr __at (0xE4) FMCON;   /* Program Flash control (Read)/
                            * Program Flash control (Write)        */
__sfr __at (0xE5) FMDATA;  /* Program Flash data                   */
__sfr __at (0xE6) FMADRL;  /* Program Flash address low            */
__sfr __at (0xE7) FMADRH;  /* Program Flash address high           */
__sfr __at (0xE8) IEN1;    /* Interrupt enable 1                   */
__sfr __at (0xE9) TIFR2;   /* CCU interrupt flag register          */
__sfr __at (0xEA) CCCRA;   /* Capture compare A control register   */
__sfr __at (0xEB) CCCRB;   /* Capture compare B control register   */
__sfr __at (0xEC) CCCRC;   /* Capture compare C control register   */
__sfr __at (0xED) CCCRD;   /* Capture compare D control register   */
__sfr __at (0xEE) OCRAL;   /* Output compare A register low        */
__sfr __at (0xEF) OCRAH;   /* Output compare A register high       */
__sfr __at (0xF0) B;       /* B register                           */
__sfr __at (0xF1) DEECON;  /* Data EEPROM control register         */
__sfr __at (0xF2) DEEDAT;  /* Data EEPROM data register            */
__sfr __at (0xF3) DEEADR;  /* Data EEPROM address register         */
__sfr __at (0xF6) PT0AD;   /* Port 0 digital input disable         */
__sfr __at (0xF7) IP1H;    /* Interrupt priority 1 high            */
__sfr __at (0xF8) IP1;     /* Interrupt priority 1                 */
__sfr __at (0xF9) TCR21;   /* CCU control register 1               */
__sfr __at (0xFA) OCRBL;   /* Output compare B register low        */
__sfr __at (0xFB) OCRBH;   /* Output compare B register high       */
__sfr __at (0xFC) OCRCL;   /* Output compare C register low        */
__sfr __at (0xFD) OCRCH;   /* Output compare C register high       */
__sfr __at (0xFE) OCRDL;   /* Output compare D register low        */
__sfr __at (0xFF) OCRDH;   /* Output compare D register high       */

/* 16-bit SFRs (duplicates of above) */
__sfr16 __at (0x8382) DPTR;  /* Data pointer               */
__sfr16 __at (0x8C8A) TMR0;  /* Timer 0 count              */
__sfr16 __at (0x8D8B) TMR1;  /* Timer 1 count              */
__sfr16 __at (0xABAA) ICRA;  /* Input capture A register   */
__sfr16 __at (0xAFAE) ICRB;  /* Input capture B register   */
__sfr16 __at (0xBFBE) BRGR;  /* Baud rate generator        */
__sfr16 __at (0xCBCA) TPCR2; /* Prescaler control register */
__sfr16 __at (0xCDCC) TMR2;  /* Timer 2 count              */
__sfr16 __at (0xCFCE) TOR2;  /* CCU reload register        */
__sfr16 __at (0xD2D3) RTC;   /* RTC register               */
__sfr16 __at (0xDDDC) I2SCL; /* Serial clock generator/
                              * SCL duty cycle register    */
__sfr16 __at (0xE7E6) FMADR; /* Program Flash address      */
__sfr16 __at (0xEFEE) OCRA;  /* Output compare A register  */
__sfr16 __at (0xFBFA) OCRB;  /* Output compare B register  */
__sfr16 __at (0xFDFC) OCRC;  /* Output compare C register  */
__sfr16 __at (0xFFFE) OCRD;  /* Output compare D register  */

/* "Extended SFRs" (logically in __xdata memory space) */
#define BNDSTA0  (*(__xdata volatile unsigned char*)0xFFED) /* ADC0 boundary status register           */
#define ADC0LBND (*(__xdata volatile unsigned char*)0xFFEE) /* ADC0 low_boundary register (MSB)        */
#define ADC0HBND (*(__xdata volatile unsigned char*)0xFFEF) /* ADC0 high_boundary register, left (MSB) */
#define AD0DAT7R (*(__xdata volatile unsigned char*)0xFFF0) /* ADC0 data register 7, right (LSB)       */
#define AD0DAT7L (*(__xdata volatile unsigned char*)0xFFF1) /* ADC0 data register 7, left (MSB)        */
#define AD0DAT6R (*(__xdata volatile unsigned char*)0xFFF2) /* ADC0 data register 6, right (LSB)       */
#define AD0DAT6L (*(__xdata volatile unsigned char*)0xFFF3) /* ADC0 data register 6, left (MSB)        */
#define AD0DAT5R (*(__xdata volatile unsigned char*)0xFFF4) /* ADC0 data register 5, right (LSB)       */
#define AD0DAT5L (*(__xdata volatile unsigned char*)0xFFF5) /* ADC0 data register 5, left (MSB)        */
#define AD0DAT4R (*(__xdata volatile unsigned char*)0xFFF6) /* ADC0 data register 4, right (LSB)       */
#define AD0DAT4L (*(__xdata volatile unsigned char*)0xFFF7) /* ADC0 data register 4, left (MSB)        */
#define AD0DAT3R (*(__xdata volatile unsigned char*)0xFFF8) /* ADC0 data register 3, right (LSB)       */
#define AD0DAT3L (*(__xdata volatile unsigned char*)0xFFF9) /* ADC0 data register 3, left (MSB)        */
#define AD0DAT2R (*(__xdata volatile unsigned char*)0xFFFA) /* ADC0 data register 2, right (LSB)       */
#define AD0DAT2L (*(__xdata volatile unsigned char*)0xFFFB) /* ADC0 data register 2, left (MSB)        */
#define AD0DAT1R (*(__xdata volatile unsigned char*)0xFFFC) /* ADC0 data register 1, right (LSB)       */
#define AD0DAT1L (*(__xdata volatile unsigned char*)0xFFFD) /* ADC0 data register 1, left (MSB)        */
#define AD0DAT0R (*(__xdata volatile unsigned char*)0xFFFE) /* ADC0 data register 0, right (LSB)       */
#define AD0DAT0L (*(__xdata volatile unsigned char*)0xFFFF) /* ADC0 data register 0, left (MSB)        */

/* Special Function Bits */
/* P0 (0x80) */
__sbit __at (0x80) P0_0;
__sbit __at (0x81) P0_1;
__sbit __at (0x82) P0_2;
__sbit __at (0x83) P0_3;
__sbit __at (0x84) P0_4;
__sbit __at (0x85) P0_5;
__sbit __at (0x86) P0_6;
__sbit __at (0x87) P0_7;
#define CMP_2  P0_0 /* Renamed:  Name conflicts with SFR 0xAD */
#define KB0    P0_0
#define CIN2B  P0_1
#define KB1    P0_1
#define CIN2A  P0_2
#define KB2    P0_2
#define CIN1B  P0_3
#define KB3    P0_3
#define CIN1A  P0_4
#define KB4    P0_4
#define CMPREF P0_5
#define KB5    P0_5
#define CMP_1  P0_6 /* Renamed:  Name conflicts with SFR 0xAC */
#define KB6    P0_6
#define T1     P0_7
#define KB7    P0_7

/* TCON (0x88) */
__sbit __at (0x88) TCON_0;
__sbit __at (0x89) TCON_1;
__sbit __at (0x8A) TCON_2;
__sbit __at (0x8B) TCON_3;
__sbit __at (0x8C) TCON_4;
__sbit __at (0x8D) TCON_5;
__sbit __at (0x8E) TCON_6;
__sbit __at (0x8F) TCON_7;
#define IT0 TCON_0
#define IE0 TCON_1
#define IT1 TCON_2
#define IE1 TCON_3
#define TR0 TCON_4
#define TF0 TCON_5
#define TR1 TCON_6
#define TF1 TCON_7

/* P1 (0x90) */
__sbit __at (0x90) P1_0;
__sbit __at (0x91) P1_1;
__sbit __at (0x92) P1_2;
__sbit __at (0x93) P1_3;
__sbit __at (0x94) P1_4;
__sbit __at (0x95) P1_5;
__sbit __at (0x96) P1_6;
__sbit __at (0x97) P1_7;
#define TXD  P1_0
#define RXD  P1_1
#define T0   P1_2
#define SCL  P1_2
#define INT0 P1_3
#define SDA  P1_3
#define INT1 P1_4
#define RST  P1_5
#define OCB  P1_6
#define OCC  P1_7

/* SCON (0x98) */
__sbit __at (0x98) SCON_0;
__sbit __at (0x99) SCON_1;
__sbit __at (0x9A) SCON_2;
__sbit __at (0x9B) SCON_3;
__sbit __at (0x9C) SCON_4;
__sbit __at (0x9D) SCON_5;
__sbit __at (0x9E) SCON_6;
__sbit __at (0x9F) SCON_7;
#define RI  SCON_0
#define TI  SCON_1
#define RB8 SCON_2
#define TB8 SCON_3
#define REN SCON_4
#define SM2 SCON_5
#define SM1 SCON_6
#define SM0 SCON_7
#define FE  SCON_7

/* P2 (0xA0) */
__sbit __at (0xA0) P2_0;
__sbit __at (0xA1) P2_1;
__sbit __at (0xA2) P2_2;
__sbit __at (0xA3) P2_3;
__sbit __at (0xA4) P2_4;
__sbit __at (0xA5) P2_5;
__sbit __at (0xA6) P2_6;
__sbit __at (0xA7) P2_7;
#define ICB    P2_0
#define OCD    P2_1
#define MOSI   P2_2
#define MISO   P2_3
#define SS     P2_4
#define SPICLK P2_5
#define OCA    P2_6
#define ICA    P2_7

/* IEN0 (0xA8) */
__sbit __at (0xA8) IEN0_0;
__sbit __at (0xA9) IEN0_1;
__sbit __at (0xAA) IEN0_2;
__sbit __at (0xAB) IEN0_3;
__sbit __at (0xAC) IEN0_4;
__sbit __at (0xAD) IEN0_5;
__sbit __at (0xAE) IEN0_6;
__sbit __at (0xAF) IEN0_7;
#define EX0   IEN0_0
#define ET0   IEN0_1
#define EX1   IEN0_2
#define ET1   IEN0_3
#define ES    IEN0_4
#define ESR   IEN0_4
#define EBO   IEN0_5
#define EWDRT IEN0_6
#define EA    IEN0_7

/* P3 (0xB0) */
__sbit __at (0xB0) P3_0;
__sbit __at (0xB1) P3_1;
__sbit __at (0xB2) P3_2;
__sbit __at (0xB3) P3_3;
__sbit __at (0xB4) P3_4;
__sbit __at (0xB5) P3_5;
__sbit __at (0xB6) P3_6;
__sbit __at (0xB7) P3_7;
#define XTAL2 P3_0
#define XTAL1 P3_1

/* IP0 (0xB8) */
__sbit __at (0xB8) IP0_0;
__sbit __at (0xB9) IP0_1;
__sbit __at (0xBA) IP0_2;
__sbit __at (0xBB) IP0_3;
__sbit __at (0xBC) IP0_4;
__sbit __at (0xBD) IP0_5;
__sbit __at (0xBE) IP0_6;
__sbit __at (0xBF) IP0_7;
#define PX0   IP0_0
#define PT0   IP0_1
#define PX1   IP0_2
#define PT1   IP0_3
#define PS    IP0_4
#define PSR   IP0_4
#define PBO   IP0_5
#define PWDRT IP0_6

/* AD0MODA (0xC0) */
__sbit __at (0xC0) AD0MODA_0;
__sbit __at (0xC1) AD0MODA_1;
__sbit __at (0xC2) AD0MODA_2;
__sbit __at (0xC3) AD0MODA_3;
__sbit __at (0xC4) AD0MODA_4;
__sbit __at (0xC5) AD0MODA_5;
__sbit __at (0xC6) AD0MODA_6;
__sbit __at (0xC7) AD0MODA_7;
#define SCAN0  AD0MODA_4
#define SCC0   AD0MODA_5
#define BURST0 AD0MODA_6
#define BNDI0  AD0MODA_7

/* TCR20 (0xC8) */
__sbit __at (0xC8) TCR20_0;
__sbit __at (0xC9) TCR20_1;
__sbit __at (0xCA) TCR20_2;
__sbit __at (0xCB) TCR20_3;
__sbit __at (0xCC) TCR20_4;
__sbit __at (0xCD) TCR20_5;
__sbit __at (0xCE) TCR20_6;
__sbit __at (0xCF) TCR20_7;
#define TMOD20 TCR20_0
#define TMOD21 TCR20_1
#define TDIR2  TCR20_2
#define ALTAB  TCR20_3
#define ALTCD  TCR20_4
#define HLTEN  TCR20_5
#define HLTRN  TCR20_6
#define PLEEN  TCR20_7

/* PSW (0xD0) */
__sbit __at (0xD0) PSW_0;
__sbit __at (0xD1) PSW_1;
__sbit __at (0xD2) PSW_2;
__sbit __at (0xD3) PSW_3;
__sbit __at (0xD4) PSW_4;
__sbit __at (0xD5) PSW_5;
__sbit __at (0xD6) PSW_6;
__sbit __at (0xD7) PSW_7;
#define P   PSW_0
#define F1  PSW_1
#define OV  PSW_2
#define RS0 PSW_3
#define RS1 PSW_4
#define F0  PSW_5
#define AC  PSW_6
#define CY  PSW_7

/* I2CON (0xD8) */
__sbit __at (0xD8) I2CON_0;
__sbit __at (0xD9) I2CON_1;
__sbit __at (0xDA) I2CON_2;
__sbit __at (0xDB) I2CON_3;
__sbit __at (0xDC) I2CON_4;
__sbit __at (0xDD) I2CON_5;
__sbit __at (0xDE) I2CON_6;
__sbit __at (0xDF) I2CON_7;
#define CRSEL I2CON_0
#define AA    I2CON_2
#define SI    I2CON_3
#define STO   I2CON_4
#define STA   I2CON_5
#define I2EN  I2CON_6

/* ACC (0xE0) */
__sbit __at (0xE0) ACC_0;
__sbit __at (0xE1) ACC_1;
__sbit __at (0xE2) ACC_2;
__sbit __at (0xE3) ACC_3;
__sbit __at (0xE4) ACC_4;
__sbit __at (0xE5) ACC_5;
__sbit __at (0xE6) ACC_6;
__sbit __at (0xE7) ACC_7;

/* IEN1 (0xE8) */
__sbit __at (0xE8) IEN1_0;
__sbit __at (0xE9) IEN1_1;
__sbit __at (0xEA) IEN1_2;
__sbit __at (0xEB) IEN1_3;
__sbit __at (0xEC) IEN1_4;
__sbit __at (0xED) IEN1_5;
__sbit __at (0xEE) IEN1_6;
__sbit __at (0xEF) IEN1_7;
#define EI2C IEN1_0
#define EKBI IEN1_1
#define EC   IEN1_2
#define ESPI IEN1_3
#define ECCU IEN1_4
#define EST  IEN1_6
#define EIEE IEN1_7

/* B (0xF0) */
__sbit __at (0xF0) B_0;
__sbit __at (0xF1) B_1;
__sbit __at (0xF2) B_2;
__sbit __at (0xF3) B_3;
__sbit __at (0xF4) B_4;
__sbit __at (0xF5) B_5;
__sbit __at (0xF6) B_6;
__sbit __at (0xF7) B_7;

/* IP1 (0xF8) */
__sbit __at (0xF8) IP1_0;
__sbit __at (0xF9) IP1_1;
__sbit __at (0xFA) IP1_2;
__sbit __at (0xFB) IP1_3;
__sbit __at (0xFC) IP1_4;
__sbit __at (0xFD) IP1_5;
__sbit __at (0xFE) IP1_6;
__sbit __at (0xFF) IP1_7;
#define PI2C  IP1_0
#define PKBI  IP1_1
#define PC    IP1_2
#define PSPI  IP1_3
#define PCCU  IP1_4
#define PST   IP1_6
#define PADEE IP1_7

#endif /* P89LPC938_H */
/*-------------------------------------------------------------------------
   C8051F336.h - Register Declarations for the SiLabs C8051F336/7/8/9
   Processor Range
 
   Copyright (C) 2008, Steven Borley, steven.borley@partnerelectronics.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef C8051F336_H
#define C8051F336_H

#include <compiler.h>

/*  BYTE Registers  */

SFR(       P0, 0x80 )  ; /* PORT 0 */
SFR(       SP, 0x81 )  ; /* STACK POINTER */
SFR(      DPL, 0x82 )  ; /* DATA POINTER - LOW BYTE */
SFR(      DPH, 0x83 )  ; /* DATA POINTER - HIGH BYTE */
SFR(     PCON, 0x87 )  ; /* POWER CONTROL */
SFR(     TCON, 0x88 )  ; /* TIMER CONTROL */
SFR(     TMOD, 0x89 )  ; /* TIMER MODE */
SFR(      TL0, 0x8A )  ; /* TIMER 0 - LOW BYTE */
SFR(      TL1, 0x8B )  ; /* TIMER 1 - LOW BYTE */
SFR(      TH0, 0x8C )  ; /* TIMER 0 - HIGH BYTE */
SFR(      TH1, 0x8D )  ; /* TIMER 1 - HIGH BYTE */
SFR(    CKCON, 0x8E )  ; /* CLOCK CONTROL */
SFR(    PSCTL, 0x8F )  ; /* PROGRAM STORE R/W CONTROL */
SFR(       P1, 0x90 )  ; /* PORT 1 */
SFR(   TMR3CN, 0x91 )  ; /* TIMER 3 CONTROL */
SFR(  TMR3RLL, 0x92 )  ; /* TIMER 3 CAPTURE REGISTER - LOW BYTE */
SFR(  TMR3RLH, 0x93 )  ; /* TIMER 3 CAPTURE REGISTER - HIGH BYTE */
SFR(    TMR3L, 0x94 )  ; /* TIMER 3 - LOW BYTE */
SFR(    TMR3H, 0x95 )  ; /* TIMER 3 - HIGH BYTE */
SFR(    IDA0L, 0x96 )  ; /* CURRENT MODE DAC 0 - LOW BYTE */
SFR(    IDA0H, 0x97 )  ; /* CURRENT MODE DAC 0 - HIGH BYTE */
SFR(     SCON, 0x98 )  ; /* SERIAL PORT CONTROL */
SFR(    SCON0, 0x98 )  ; /* SERIAL PORT CONTROL */
SFR(     SBUF, 0x99 )  ; /* SERIAL PORT BUFFER */
SFR(    SBUF0, 0x99 )  ; /* SERIAL PORT BUFFER */
SFR(   CPT0CN, 0x9B )  ; /* COMPARATOR 0 CONTROL */
SFR(   CPT0MD, 0x9D )  ; /* COMPARATOR 0 MODE SELECTION */
SFR(   CPT0MX, 0x9F )  ; /* COMPARATOR 0 MUX SELECTION */
SFR(       P2, 0xA0 )  ; /* PORT 2 */
SFR(  SPI0CFG, 0xA1 )  ; /* SPI0 CONFIGURATION */
SFR(  SPI0CKR, 0xA2 )  ; /* SPI0 CLOCK RATE CONTROL */
SFR(  SPI0DAT, 0xA3 )  ; /* SPI0 DATA */
SFR(  P0MDOUT, 0xA4 )  ; /* PORT 0 OUTPUT MODE CONFIGURATION */
SFR(  P1MDOUT, 0xA5 )  ; /* PORT 1 OUTPUT MODE CONFIGURATION */
SFR(  P2MDOUT, 0xA6 )  ; /* PORT 2 OUTPUT MODE CONFIGURATION */
SFR(       IE, 0xA8 )  ; /* INTERRUPT ENABLE */
SFR(   CLKSEL, 0xA9 )  ; /* SYSTEM CLOCK SELECT */
SFR(   EMI0CN, 0xAA )  ; /* EXTERNAL MEMORY INTERFACE CONTROL */
SFR(   _XPAGE, 0xAA )  ; /* XDATA/PDATA PAGE */
SFR(   OSCXCN, 0xB1 )  ; /* EXTERNAL OSCILLATOR CONTROL */
SFR(   OSCICN, 0xB2 )  ; /* INTERNAL OSCILLATOR CONTROL */
SFR(   OSCICL, 0xB3 )  ; /* INTERNAL OSCILLATOR CALIBRATION */
SFR(    FLSCL, 0xB6 )  ; /* FLASH MEMORY TIMING PRESCALER */
SFR(    FLKEY, 0xB7 )  ; /* FLASH ACESS LIMIT */
SFR(       IP, 0xB8 )  ; /* INTERRUPT PRIORITY */
SFR(   IDA0CN, 0xB9 )  ; /* CURRENT MODE DAC 0 - CONTROL */
SFR(    AMX0N, 0xBA )  ; /* ADC 0 MUX NEGATIVE CHANNEL SELECTION */
SFR(    AMX0P, 0xBB )  ; /* ADC 0 MUX POSITIVE CHANNEL SELECTION */
SFR(   ADC0CF, 0xBC )  ; /* ADC 0 CONFIGURATION */
SFR(    ADC0L, 0xBD )  ; /* ADC 0 DATA WORD LSB */
SFR(    ADC0H, 0xBE )  ; /* ADC 0 DATA WORD MSB */
SFR(   SMB0CN, 0xC0 )  ; /* SMBUS CONTROL */
SFR(   SMB0CF, 0xC1 )  ; /* SMBUS CONFIGURATION */
SFR(  SMB0DAT, 0xC2 )  ; /* SMBUS DATA */
SFR(  ADC0GTL, 0xC3 )  ; /* ADC 0 GREATER-THAN LOW BYTE */
SFR(  ADC0GTH, 0xC4 )  ; /* ADC 0 GREATER-THAN HIGH BYTE */
SFR(  ADC0LTL, 0xC5 )  ; /* ADC 0 LESS-THAN LOW BYTE */
SFR(  ADC0LTH, 0xC6 )  ; /* ADC 0 LESS-THAN HIGH BYTE */
SFR(    T2CON, 0xC8 )  ; /* TIMER 2 CONTROL */
SFR(   TMR2CN, 0xC8 )  ; /* TIMER 2 CONTROL */
SFR(   RCAP2L, 0xCA )  ; /* TIMER 2 CAPTURE REGISTER - LOW BYTE */
SFR(  TMR2RLL, 0xCA )  ; /* TIMER 2 CAPTURE REGISTER - LOW BYTE */
SFR(   RCAP2H, 0xCB )  ; /* TIMER 2 CAPTURE REGISTER - HIGH BYTE */
SFR(  TMR2RLH, 0xCB )  ; /* TIMER 2 CAPTURE REGISTER - HIGH BYTE */
SFR(      TL2, 0xCC )  ; /* TIMER 2 - LOW BYTE */
SFR(    TMR2L, 0xCC )  ; /* TIMER 2 - LOW BYTE */
SFR(      TH2, 0xCD )  ; /* TIMER 2 - HIGH BYTE */
SFR(    TMR2H, 0xCD )  ; /* TIMER 2 - HIGH BYTE */
SFR(      PSW, 0xD0 )  ; /* PROGRAM STATUS WORD */
SFR(   REF0CN, 0xD1 )  ; /* VOLTAGE REFERENCE 0 CONTROL */
SFR(   P0SKIP, 0xD4 )  ; /* PORT 0 SKIP */
SFR(   P1SKIP, 0xD5 )  ; /* PORT 1 SKIP */
SFR(   P2SKIP, 0xD6 )  ; /* PORT 2 SKIP */
SFR(  SMB0ADR, 0xD7 )  ; /* SMBUS SLAVE ADDRESS */
SFR(   PCA0CN, 0xD8 )  ; /* PCA CONTROL */
SFR(   PCA0MD, 0xD9 )  ; /* PCA MODE */
SFR( PCA0CPM0, 0xDA )  ; /* PCA MODULE 0 MODE REGISTER */
SFR( PCA0CPM1, 0xDB )  ; /* PCA MODULE 1 MODE REGISTER */
SFR( PCA0CPM2, 0xDC )  ; /* PCA MODULE 2 MODE REGISTER */
SFR(      ACC, 0xE0 )  ; /* ACCUMULATOR */
SFR(     XBR0, 0xE1 )  ; /* PORT MUX CONFIGURATION REGISTER 0 */
SFR(     XBR1, 0xE2 )  ; /* PORT MUX CONFIGURATION REGISTER 1 */
SFR(   OSCLCN, 0xE3 )  ; /* LOW-FREQUENCY OSCILLATOR CONTROL */
SFR(   IT01CF, 0xE4 )  ; /* INT0/INT1 CONFIGURATION REGISTER */
SFR(  INT01CF, 0xE4 )  ; /* INT0/INT1 CONFIGURATION REGISTER */
SFR(     EIE1, 0xE6 )  ; /* EXTERNAL INTERRUPT ENABLE 1 */
SFR(  SMB0ADM, 0xE7 )  ; /* SMBUS SLAVE ADDRESS MASK */
SFR(   ADC0CN, 0xE8 )  ; /* ADC 0 CONTROL */
SFR( PCA0CPL1, 0xE9 )  ; /* PCA CAPTURE 1 LOW */
SFR( PCA0CPH1, 0xEA )  ; /* PCA CAPTURE 1 HIGH */
SFR( PCA0CPL2, 0xEB )  ; /* PCA CAPTURE 2 LOW */
SFR( PCA0CPH2, 0xEC )  ; /* PCA CAPTURE 2 HIGH */
SFR(    P1MAT, 0xED )  ; /* PORT 1 MATCH REGISTER */
SFR(   P1MASK, 0xEE )  ; /* PORT 1 MASK REGISTER */
SFR(   RSTSRC, 0xEF )  ; /* RESET SOURCE */
SFR(        B, 0xF0 )  ; /* B REGISTER */
SFR(   P0MODE, 0xF1 )  ; /* PORT 0 INPUT MODE CONFIGURATION */
SFR(   P0MDIN, 0xF1 )  ; /* PORT 0 INPUT MODE CONFIGURATION */
SFR(   P1MODE, 0xF2 )  ; /* PORT 1 INPUT MODE CONFIGURATION */
SFR(   P1MDIN, 0xF2 )  ; /* PORT 1 INPUT MODE CONFIGURATION */
SFR(   P2MDIN, 0xF3 )  ; /* PORT 2 INPUT MODE */
SFR(     EIP1, 0xF6 )  ; /* EXTERNAL INTERRUPT PRIORITY REGISTER 1 */
SFR(  PCA0PWM, 0xF7 )  ; /* PCA PWM CONFIGURATION */
SFR(   SPI0CN, 0xF8 )  ; /* SPI0 CONTROL */
SFR(    PCA0L, 0xF9 )  ; /* PCA COUNTER LOW */
SFR(    PCA0H, 0xFA )  ; /* PCA COUNTER HIGH */
SFR( PCA0CPL0, 0xFB )  ; /* PCA CAPTURE 0 LOW */
SFR( PCA0CPH0, 0xFC )  ; /* PCA CAPTURE 0 HIGH */
SFR(    P0MAT, 0xFD )  ; /* PORT 0 MATCH REGISTER */
SFR(   P0MASK, 0xFE )  ; /* PORT 0 MASK REGISTER */
SFR(   VDM0CN, 0xFF )  ; /* VDD MONITOR CONTROL */


/*  WORD/DWORD Registers  */

SFR16E(     TMR0, 0x8C8A )  ; /* TIMER 0 COUNTER */
SFR16E(     TMR1, 0x8D8B )  ; /* TIMER 1 COUNTER */
SFR16E(     TMR2, 0xCDCC )  ; /* TIMER 2 COUNTER */
SFR16E(    RCAP2, 0xCBCA )  ; /* TIMER 2 CAPTURE REGISTER WORD */
SFR16E(   TMR2RL, 0xCBCA )  ; /* TIMER 2 CAPTURE REGISTER WORD */
SFR16E(     TMR3, 0x9594 )  ; /* TIMER 3 COUNTER */
SFR16E(   TMR3RL, 0x9392 )  ; /* TIMER 3 CAPTURE REGISTER WORD */
SFR16E(     IDA0, 0x9796 )  ; /* CURRENT MODE DAC 0 DATA WORD */
SFR16E(     ADC0, 0xBEBD )  ; /* ADC 0 DATA WORD */
SFR16E(   ADC0GT, 0xC4C3 )  ; /* ADC 0 GREATER-THAN REGISTER WORD */
SFR16E(   ADC0LT, 0xC6C5 )  ; /* ADC 0 LESS-THAN REGISTER WORD */
SFR16E(     PCA0, 0xFAF9 )  ; /* PCA COUNTER */
SFR16E(  PCA0CP0, 0xFCFB )  ; /* PCA CAPTURE 0 WORD */
SFR16E(  PCA0CP1, 0xEAE9 )  ; /* PCA CAPTURE 1 WORD */
SFR16E(  PCA0CP2, 0xECEB )  ; /* PCA CAPTURE 2 WORD */


/*  BIT Registers  */

/*  P0  0x80 */
SBIT(     P0_0, 0x80, 0 )  ;
SBIT(     P0_1, 0x80, 1 )  ;
SBIT(     P0_2, 0x80, 2 )  ;
SBIT(     P0_3, 0x80, 3 )  ;
SBIT(     P0_4, 0x80, 4 )  ;
SBIT(     P0_5, 0x80, 5 )  ;
SBIT(     P0_6, 0x80, 6 )  ;
SBIT(     P0_7, 0x80, 7 )  ;

/*  TCON  0x88 */
SBIT(      IT0, 0x88, 0 )  ; /* TCON.0 - EXT. INTERRUPT 0 TYPE */
SBIT(      IE0, 0x88, 1 )  ; /* TCON.1 - EXT. INTERRUPT 0 EDGE FLAG */
SBIT(      IT1, 0x88, 2 )  ; /* TCON.2 - EXT. INTERRUPT 1 TYPE */
SBIT(      IE1, 0x88, 3 )  ; /* TCON.3 - EXT. INTERRUPT 1 EDGE FLAG */
SBIT(      TR0, 0x88, 4 )  ; /* TCON.4 - TIMER 0 ON/OFF CONTROL */
SBIT(      TF0, 0x88, 5 )  ; /* TCON.5 - TIMER 0 OVERFLOW FLAG */
SBIT(      TR1, 0x88, 6 )  ; /* TCON.6 - TIMER 1 ON/OFF CONTROL */
SBIT(      TF1, 0x88, 7 )  ; /* TCON.7 - TIMER 1 OVERFLOW FLAG */

/*  P1  0x90 */
SBIT(     P1_0, 0x90, 0 )  ;
SBIT(     P1_1, 0x90, 1 )  ;
SBIT(     P1_2, 0x90, 2 )  ;
SBIT(     P1_3, 0x90, 3 )  ;
SBIT(     P1_4, 0x90, 4 )  ;
SBIT(     P1_5, 0x90, 5 )  ;
SBIT(     P1_6, 0x90, 6 )  ;
SBIT(     P1_7, 0x90, 7 )  ;

/*  SCON  0x98 */
SBIT(       RI, 0x98, 0 )  ; /* SCON.0 - RECEIVE INTERRUPT FLAG */
SBIT(      RI0, 0x98, 0 )  ; /* SCON.0 - RECEIVE INTERRUPT FLAG */
SBIT(       TI, 0x98, 1 )  ; /* SCON.1 - TRANSMIT INTERRUPT FLAG */
SBIT(      TI0, 0x98, 1 )  ; /* SCON.1 - TRANSMIT INTERRUPT FLAG */
SBIT(      RB8, 0x98, 2 )  ; /* SCON.2 - RECEIVE BIT 8 */
SBIT(     RB80, 0x98, 2 )  ; /* SCON.2 - RECEIVE BIT 8 */
SBIT(      TB8, 0x98, 3 )  ; /* SCON.3 - TRANSMIT BIT 8 */
SBIT(     TB80, 0x98, 3 )  ; /* SCON.3 - TRANSMIT BIT 8 */
SBIT(      REN, 0x98, 4 )  ; /* SCON.4 - RECEIVE ENABLE */
SBIT(     REN0, 0x98, 4 )  ; /* SCON.4 - RECEIVE ENABLE */
SBIT(      SM2, 0x98, 5 )  ; /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE */
SBIT(     MCE0, 0x98, 5 )  ; /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE */
SBIT(      SM0, 0x98, 7 )  ; /* SCON.7 - SERIAL MODE CONTROL BIT 0 */
SBIT(   S0MODE, 0x98, 7 )  ; /* SCON.7 - SERIAL MODE CONTROL BIT 0 */

/*  P2  0xA0 */
SBIT(     P2_0, 0xA0, 0 )  ;
SBIT(     P2_1, 0xA0, 1 )  ;
SBIT(     P2_2, 0xA0, 2 )  ;
SBIT(     P2_3, 0xA0, 3 )  ;
SBIT(     P2_4, 0xA0, 4 )  ;
SBIT(     P2_5, 0xA0, 5 )  ;
SBIT(     P2_6, 0xA0, 6 )  ;
SBIT(     P2_7, 0xA0, 7 )  ;

/*  IE  0xA8 */
SBIT(      EX0, 0xA8, 0 )  ; /* IE.0 - EXTERNAL INTERRUPT 0 ENABLE */
SBIT(      ET0, 0xA8, 1 )  ; /* IE.1 - TIMER 0 INTERRUPT ENABLE */
SBIT(      EX1, 0xA8, 2 )  ; /* IE.2 - EXTERNAL INTERRUPT 1 ENABLE */
SBIT(      ET1, 0xA8, 3 )  ; /* IE.3 - TIMER 1 INTERRUPT ENABLE */
SBIT(       ES, 0xA8, 4 )  ; /* IE.4 - SERIAL PORT INTERRUPT ENABLE */
SBIT(      ES0, 0xA8, 4 )  ; /* IE.4 - SERIAL PORT INTERRUPT ENABLE */
SBIT(      ET2, 0xA8, 5 )  ; /* IE.5 - TIMER 2 INTERRUPT ENABLE */
SBIT(    ESPI0, 0xA8, 6 )  ; /* IE.6 - SPI0 INTERRUPT ENABLE */
SBIT(       EA, 0xA8, 7 )  ; /* IE.7 - GLOBAL INTERRUPT ENABLE */

/*  IP  0xB8 */
SBIT(      PX0, 0xB8, 0 )  ; /* IP.0 - EXTERNAL INTERRUPT 0 PRIORITY */
SBIT(      PT0, 0xB8, 1 )  ; /* IP.1 - TIMER 0 PRIORITY */
SBIT(      PX1, 0xB8, 2 )  ; /* IP.2 - EXTERNAL INTERRUPT 1 PRIORITY */
SBIT(      PT1, 0xB8, 3 )  ; /* IP.3 - TIMER 1 PRIORITY */
SBIT(       PS, 0xB8, 4 )  ; /* IP.4 - SERIAL PORT PRIORITY */
SBIT(      PS0, 0xB8, 4 )  ; /* IP.4 - SERIAL PORT PRIORITY */
SBIT(      PT2, 0xB8, 5 )  ; /* IP.5 - TIMER 2 PRIORITY */
SBIT(    PSPI0, 0xB8, 6 )  ; /* IP.6 - SPI0 PRIORITY */

/*  SMB0CN  0xC0 */
SBIT(       SI, 0xC0, 0 )  ; /* SMB0CN.0 - SMBUS 0 INTERRUPT PENDING FLAG */
SBIT(      ACK, 0xC0, 1 )  ; /* SMB0CN.1 - SMBUS 0 ACKNOWLEDGE FLAG */
SBIT(  ARBLOST, 0xC0, 2 )  ; /* SMB0CN.2 - SMBUS 0 ARBITRATION LOST INDICATOR */
SBIT(    ACKRQ, 0xC0, 3 )  ; /* SMB0CN.3 - SMBUS 0 ACKNOWLEDGE REQUEST */
SBIT(      STO, 0xC0, 4 )  ; /* SMB0CN.4 - SMBUS 0 STOP FLAG */
SBIT(      STA, 0xC0, 5 )  ; /* SMB0CN.5 - SMBUS 0 START FLAG */
SBIT(   TXMODE, 0xC0, 6 )  ; /* SMB0CN.6 - SMBUS 0 TRANSMIT MODE INDICATOR */
SBIT(   MASTER, 0xC0, 7 )  ; /* SMB0CN.7 - SMBUS 0 MASTER/SLAVE INDICATOR */

/*  TMR2CN  0xC8 */
SBIT(   T2XCLK, 0xC8, 0 )  ; /* TMR2CN.0 - TIMER 2 EXTERNAL CLOCK SELECT */
SBIT(      TR2, 0xC8, 2 )  ; /* TMR2CN.2 - TIMER 2 ON/OFF CONTROL */
SBIT(  T2SPLIT, 0xC8, 3 )  ; /* TMR2CN.3 - TIMER 2 SPLIT MODE ENABLE */
SBIT(   TF2CEN, 0xC8, 4 )  ; /* TMR2CN.4 - TIMER 2 LOW-FREQ OSC CAPTURE ENABLE*/
SBIT(   TF2LEN, 0xC8, 5 )  ; /* TMR2CN.5 - TIMER 2 LOW BYTE INTERRUPT ENABLE */
SBIT(     TF2L, 0xC8, 6 )  ; /* TMR2CN.6 - TIMER 2 LOW BYTE OVERFLOW FLAG */
SBIT(      TF2, 0xC8, 7 )  ; /* TMR2CN.7 - TIMER 2 OVERFLOW FLAG */
SBIT(     TF2H, 0xC8, 7 )  ; /* TMR2CN.7 - TIMER 2 HIGH BYTE OVERFLOW FLAG */

/*  PSW  0xD0 */
SBIT(   PARITY, 0xD0, 0 )  ; /* PSW.0 - ACCUMULATOR PARITY FLAG */
SBIT(       F1, 0xD0, 1 )  ; /* PSW.1 - FLAG 1 */
SBIT(       OV, 0xD0, 2 )  ; /* PSW.2 - OVERFLOW FLAG */
SBIT(      RS0, 0xD0, 3 )  ; /* PSW.3 - REGISTER BANK SELECT 0 */
SBIT(      RS1, 0xD0, 4 )  ; /* PSW.4 - REGISTER BANK SELECT 1 */
SBIT(       F0, 0xD0, 5 )  ; /* PSW.5 - FLAG 0 */
SBIT(       AC, 0xD0, 6 )  ; /* PSW.6 - AUXILIARY CARRY FLAG */
SBIT(       CY, 0xD0, 7 )  ; /* PSW.7 - CARRY FLAG */

/*  PCA0CN  0xD8 */
SBIT(     CCF0, 0xD8, 0 )  ; /* PCA0CN.0 - PCA MODULE 0 CAPTURE/COMPARE FLAG */
SBIT(     CCF1, 0xD8, 1 )  ; /* PCA0CN.1 - PCA MODULE 1 CAPTURE/COMPARE FLAG */
SBIT(     CCF2, 0xD8, 2 )  ; /* PCA0CN.2 - PCA MODULE 2 CAPTURE/COMPARE FLAG */
SBIT(       CR, 0xD8, 6 )  ; /* PCA0CN.6 - PCA COUNTER/TIMER RUN CONTROL */
SBIT(       CF, 0xD8, 7 )  ; /* PCA0CN.7 - PCA COUNTER/TIMER OVERFLOW FLAG */

/*  ADC0CN  0xE8 */
SBIT(   AD0CM0, 0xE8, 0 )  ; /* ADC0CN.0 - ADC 0 START OF CONV. MODE BIT 0 */
SBIT(   AD0CM1, 0xE8, 1 )  ; /* ADC0CN.1 - ADC 0 START OF CONV. MODE BIT 1 */
SBIT(   AD0CM2, 0xE8, 2 )  ; /* ADC0CN.2 - ADC 0 START OF CONV. MODE BIT 2 */
SBIT(  AD0WINT, 0xE8, 3 )  ; /* ADC0CN.3 - ADC 0 WINDOW COMPARE INT. FLAG */
SBIT(  AD0BUSY, 0xE8, 4 )  ; /* ADC0CN.4 - ADC 0 BUSY FLAG */
SBIT(   AD0INT, 0xE8, 5 )  ; /* ADC0CN.5 - ADC 0 CONV. COMPLETE INT. FLAG */
SBIT(    AD0TM, 0xE8, 6 )  ; /* ADC0CN.6 - ADC 0 TRACK MODE */
SBIT(    AD0EN, 0xE8, 7 )  ; /* ADC0CN.7 - ADC 0 ENABLE */

/*  SPI0CN  0xF8 */
SBIT(    SPIEN, 0xF8, 0 )  ; /* SPI0CN.0 - SPI0 ENABLE */
SBIT(    TXBMT, 0xF8, 1 )  ; /* SPI0CN.1 - TRANSMIT BUFFER EMPTY */
SBIT(   NSSMD0, 0xF8, 2 )  ; /* SPI0CN.2 - SLAVE SELECT MODE BIT 0 */
SBIT(   NSSMD1, 0xF8, 3 )  ; /* SPI0CN.3 - SLAVE SELECT MODE BIT 1 */
SBIT(   RXOVRN, 0xF8, 4 )  ; /* SPI0CN.4 - RECEIVE OVERRUN FLAG */
SBIT(     MODF, 0xF8, 5 )  ; /* SPI0CN.5 - MODE FAULT FLAG */
SBIT(     WCOL, 0xF8, 6 )  ; /* SPI0CN.6 - WRITE COLLISION FLAG */
SBIT(     SPIF, 0xF8, 7 )  ; /* SPI0CN.7 - SPI0 INTERRUPT FLAG */


/* Predefined SFR Bit Masks */

#define PCON_IDLE         0x01    /* PCON                                */
#define PCON_STOP         0x02    /* PCON                                */
#define T1M               0x08    /* CKCON                               */
#define PSWE              0x01    /* PSCTL                               */
#define PSEE              0x02    /* PSCTL                               */
#define ECP0              0x20    /* EIE1                                */
#define PORSF             0x02    /* RSTSRC                              */
#define SWRSF             0x10    /* RSTSRC                              */
#define ECCF              0x01    /* PCA0CPMn                            */
#define PWM               0x02    /* PCA0CPMn                            */
#define TOG               0x04    /* PCA0CPMn                            */
#define MAT               0x08    /* PCA0CPMn                            */
#define CAPN              0x10    /* PCA0CPMn                            */
#define CAPP              0x20    /* PCA0CPMn                            */
#define ECOM              0x40    /* PCA0CPMn                            */
#define PWM16             0x80    /* PCA0CPMn                            */
#define CP0E              0x10    /* XBR0                                */
#define CP0OEN            0x10    /* XBR0                                */
#define CP0AE             0x20    /* XBR0                                */
#define CP0AOEN           0x20    /* XBR0                                */

/* Interrupts */

#define INT_EXT0          0       /* External Interrupt 0 */
#define INT_TIMER0        1       /* Timer0 Overflow */
#define INT_EXT1          2       /* External Interrupt 1 */
#define INT_TIMER1        3       /* Timer1 Overflow */
#define INT_UART0         4       /* Serial Port 0 */
#define INT_TIMER2        5       /* Timer2 Overflow */
#define INT_SPI0          6       /* Serial Peripheral Interface 0 */
#define INT_SMBUS0        7       /* SMBus0 Interface */
#define INT_PMAT          8       /* Port match */
#define INT_ADC0_WINDOW   9       /* ADC0 Window Comparison */
#define INT_ADC0_EOC      10      /* ADC0 End Of Conversion */
#define INT_PCA0          11      /* PCA0 Peripheral */
#define INT_COMPARATOR0   12      /* Comparator0 */
/*                        13         Reserved */
#define INT_TIMER3        14      /* Timer3 Overflow */

#endif
/*-------------------------------------------------------------------------
   C8051F310.h - Register Declarations for the Cygnal/SiLabs C8051F31x
   Processor Range

   Copyright (C) 2004, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef C8051F310_H
#define C8051F310_H


/*  BYTE Registers  */

__sfr __at (0x80) P0           ;  /* PORT 0                                        */
__sfr __at (0x81) SP           ;  /* STACK POINTER                                 */
__sfr __at (0x82) DPL          ;  /* DATA POINTER - LOW BYTE                       */
__sfr __at (0x83) DPH          ;  /* DATA POINTER - HIGH BYTE                      */
__sfr __at (0x87) PCON         ;  /* POWER CONTROL                                 */
__sfr __at (0x88) TCON         ;  /* TIMER CONTROL                                 */
__sfr __at (0x89) TMOD         ;  /* TIMER MODE                                    */
__sfr __at (0x8A) TL0          ;  /* TIMER 0 - LOW BYTE                            */
__sfr __at (0x8B) TL1          ;  /* TIMER 1 - LOW BYTE                            */
__sfr __at (0x8C) TH0          ;  /* TIMER 0 - HIGH BYTE                           */
__sfr __at (0x8D) TH1          ;  /* TIMER 1 - HIGH BYTE                           */
__sfr __at (0x8E) CKCON        ;  /* CLOCK CONTROL                                 */
__sfr __at (0x8F) PSCTL        ;  /* PROGRAM STORE R/W CONTROL                     */
__sfr __at (0x90) P1           ;  /* PORT 1                                        */
__sfr __at (0x91) TMR3CN       ;  /* TIMER 3 CONTROL                               */
__sfr __at (0x92) TMR3RLL      ;  /* TIMER 3 CAPTURE REGISTER - LOW BYTE           */
__sfr __at (0x93) TMR3RLH      ;  /* TIMER 3 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at (0x94) TMR3L        ;  /* TIMER 3 - LOW BYTE                            */
__sfr __at (0x95) TMR3H        ;  /* TIMER 3 - HIGH BYTE                           */
__sfr __at (0x98) SCON         ;  /* SERIAL PORT CONTROL                           */
__sfr __at (0x98) SCON0        ;  /* SERIAL PORT CONTROL                           */
__sfr __at (0x99) SBUF         ;  /* SERIAL PORT BUFFER                            */
__sfr __at (0x99) SBUF0        ;  /* SERIAL PORT BUFFER                            */
__sfr __at (0x9A) CPT1CN       ;  /* COMPARATOR 1 CONTROL                          */
__sfr __at (0x9B) CPT0CN       ;  /* COMPARATOR 0 CONTROL                          */
__sfr __at (0x9C) CPT1MD       ;  /* COMPARATOR 1 MODE SELECTION                   */
__sfr __at (0x9D) CPT0MD       ;  /* COMPARATOR 0 MODE SELECTION                   */
__sfr __at (0x9E) CPT1MX       ;  /* COMPARATOR 1 MUX SELECTION                    */
__sfr __at (0x9F) CPT0MX       ;  /* COMPARATOR 0 MUX SELECTION                    */
__sfr __at (0xA0) P2           ;  /* PORT 2                                        */
__sfr __at (0xA1) SPI0CFG      ;  /* SPI0 CONFIGURATION                            */
__sfr __at (0xA2) SPI0CKR      ;  /* SPI0 CLOCK RATE CONTROL                       */
__sfr __at (0xA3) SPI0DAT      ;  /* SPI0 DATA                                     */
__sfr __at (0xA4) P0MDOUT      ;  /* PORT 0 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA5) P1MDOUT      ;  /* PORT 1 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA6) P2MDOUT      ;  /* PORT 2 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA7) P3MDOUT      ;  /* PORT 3 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA8) IE           ;  /* INTERRUPT ENABLE                              */
__sfr __at (0xA9) CLKSEL       ;  /* SYSTEM CLOCK SELECT                           */
__sfr __at (0xAA) EMI0CN       ;  /* EXTERNAL MEMORY INTERFACE CONTROL             */
__sfr __at (0xAA) _XPAGE       ;  /* XDATA/PDATA PAGE                              */
__sfr __at (0xB0) P3           ;  /* PORT 3                                        */
__sfr __at (0xB1) OSCXCN       ;  /* EXTERNAL OSCILLATOR CONTROL                   */
__sfr __at (0xB2) OSCICN       ;  /* INTERNAL OSCILLATOR CONTROL                   */
__sfr __at (0xB3) OSCICL       ;  /* INTERNAL OSCILLATOR CALIBRATION               */
__sfr __at (0xB6) FLSCL        ;  /* FLASH MEMORY TIMING PRESCALER                 */
__sfr __at (0xB7) FLKEY        ;  /* FLASH ACESS LIMIT                             */
__sfr __at (0xB8) IP           ;  /* INTERRUPT PRIORITY                            */
__sfr __at (0xBA) AMX0N        ;  /* ADC 0 MUX NEGATIVE CHANNEL SELECTION          */
__sfr __at (0xBB) AMX0P        ;  /* ADC 0 MUX POSITIVE CHANNEL SELECTION          */
__sfr __at (0xBC) ADC0CF       ;  /* ADC 0 CONFIGURATION                           */
__sfr __at (0xBD) ADC0L        ;  /* ADC 0 DATA WORD LSB                           */
__sfr __at (0xBE) ADC0H        ;  /* ADC 0 DATA WORD MSB                           */
__sfr __at (0xC0) SMB0CN       ;  /* SMBUS CONTROL                                 */
__sfr __at (0xC1) SMB0CF       ;  /* SMBUS CONFIGURATION                           */
__sfr __at (0xC2) SMB0DAT      ;  /* SMBUS DATA                                    */
__sfr __at (0xC3) ADC0GTL      ;  /* ADC 0 GREATER-THAN LOW BYTE                   */
__sfr __at (0xC4) ADC0GTH      ;  /* ADC 0 GREATER-THAN HIGH BYTE                  */
__sfr __at (0xC5) ADC0LTL      ;  /* ADC 0 LESS-THAN LOW BYTE                      */
__sfr __at (0xC6) ADC0LTH      ;  /* ADC 0 LESS-THAN HIGH BYTE                     */
__sfr __at (0xC8) T2CON        ;  /* TIMER 2 CONTROL                               */
__sfr __at (0xC8) TMR2CN       ;  /* TIMER 2 CONTROL                               */
__sfr __at (0xCA) RCAP2L       ;  /* TIMER 2 CAPTURE REGISTER - LOW BYTE           */
__sfr __at (0xCA) TMR2RLL      ;  /* TIMER 2 CAPTURE REGISTER - LOW BYTE           */
__sfr __at (0xCB) RCAP2H       ;  /* TIMER 2 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at (0xCB) TMR2RLH      ;  /* TIMER 2 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at (0xCC) TL2          ;  /* TIMER 2 - LOW BYTE                            */
__sfr __at (0xCC) TMR2L        ;  /* TIMER 2 - LOW BYTE                            */
__sfr __at (0xCD) TH2          ;  /* TIMER 2 - HIGH BYTE                           */
__sfr __at (0xCD) TMR2H        ;  /* TIMER 2 - HIGH BYTE                           */
__sfr __at (0xD0) PSW          ;  /* PROGRAM STATUS WORD                           */
__sfr __at (0xD1) REF0CN       ;  /* VOLTAGE REFERENCE 0 CONTROL                   */
__sfr __at (0xD4) P0SKIP       ;  /* PORT 0 SKIP                                   */
__sfr __at (0xD5) P1SKIP       ;  /* PORT 1 SKIP                                   */
__sfr __at (0xD6) P2SKIP       ;  /* PORT 2 SKIP                                   */
__sfr __at (0xD8) PCA0CN       ;  /* PCA CONTROL                                   */
__sfr __at (0xD9) PCA0MD       ;  /* PCA MODE                                      */
__sfr __at (0xDA) PCA0CPM0     ;  /* PCA MODULE 0 MODE REGISTER                    */
__sfr __at (0xDB) PCA0CPM1     ;  /* PCA MODULE 1 MODE REGISTER                    */
__sfr __at (0xDC) PCA0CPM2     ;  /* PCA MODULE 2 MODE REGISTER                    */
__sfr __at (0xDD) PCA0CPM3     ;  /* PCA MODULE 3 MODE REGISTER                    */
__sfr __at (0xDE) PCA0CPM4     ;  /* PCA MODULE 4 MODE REGISTER                    */
__sfr __at (0xE0) ACC          ;  /* ACCUMULATOR                                   */
__sfr __at (0xE1) XBR0         ;  /* PORT MUX CONFIGURATION REGISTER 0             */
__sfr __at (0xE2) XBR1         ;  /* PORT MUX CONFIGURATION REGISTER 1             */
__sfr __at (0xE4) IT01CF       ;  /* INT0/INT1 CONFIGURATION REGISTER              */
__sfr __at (0xE4) INT01CF      ;  /* INT0/INT1 CONFIGURATION REGISTER              */
__sfr __at (0xE6) EIE1         ;  /* EXTERNAL INTERRUPT ENABLE 1                   */
__sfr __at (0xE8) ADC0CN       ;  /* ADC 0 CONTROL                                 */
__sfr __at (0xE9) PCA0CPL1     ;  /* PCA CAPTURE 1 LOW                             */
__sfr __at (0xEA) PCA0CPH1     ;  /* PCA CAPTURE 1 HIGH                            */
__sfr __at (0xEB) PCA0CPL2     ;  /* PCA CAPTURE 2 LOW                             */
__sfr __at (0xEC) PCA0CPH2     ;  /* PCA CAPTURE 2 HIGH                            */
__sfr __at (0xED) PCA0CPL3     ;  /* PCA CAPTURE 3 LOW                             */
__sfr __at (0xEE) PCA0CPH3     ;  /* PCA CAPTURE 3 HIGH                            */
__sfr __at (0xEF) RSTSRC       ;  /* RESET SOURCE                                  */
__sfr __at (0xF0) B            ;  /* B REGISTER                                    */
__sfr __at (0xF1) P0MODE       ;  /* PORT 0 INPUT MODE CONFIGURATION               */
__sfr __at (0xF1) P0MDIN       ;  /* PORT 0 INPUT MODE CONFIGURATION               */
__sfr __at (0xF2) P1MODE       ;  /* PORT 1 INPUT MODE CONFIGURATION               */
__sfr __at (0xF2) P1MDIN       ;  /* PORT 1 INPUT MODE CONFIGURATION               */
__sfr __at (0xF3) P2MODE       ;  /* PORT 2 INPUT MODE CONFIGURATION               */
__sfr __at (0xF3) P2MDIN       ;  /* PORT 2 INPUT MODE CONFIGURATION               */
__sfr __at (0xF4) P3MODE       ;  /* PORT 3 INPUT MODE CONFIGURATION               */
__sfr __at (0xF4) P3MDIN       ;  /* PORT 3 INPUT MODE CONFIGURATION               */
__sfr __at (0xF6) EIP1         ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 1        */
__sfr __at (0xF8) SPI0CN       ;  /* SPI0 CONTROL                                  */
__sfr __at (0xF9) PCA0L        ;  /* PCA COUNTER LOW                               */
__sfr __at (0xFA) PCA0H        ;  /* PCA COUNTER HIGH                              */
__sfr __at (0xFB) PCA0CPL0     ;  /* PCA CAPTURE 0 LOW                             */
__sfr __at (0xFC) PCA0CPH0     ;  /* PCA CAPTURE 0 HIGH                            */
__sfr __at (0xFD) PCA0CPL4     ;  /* PCA CAPTURE 4 LOW                             */
__sfr __at (0xFE) PCA0CPH4     ;  /* PCA CAPTURE 4 HIGH                            */
__sfr __at (0xFF) VDM0CN       ;  /* VDD MONITOR CONTROL                           */


/*  WORD/DWORD Registers  */

__sfr16 __at (0x8C8A) TMR0     ;  /* TIMER 0 COUNTER                               */
__sfr16 __at (0x8D8B) TMR1     ;  /* TIMER 1 COUNTER                               */
__sfr16 __at (0xCDCC) TMR2     ;  /* TIMER 2 COUNTER                               */
__sfr16 __at (0xCBCA) RCAP2    ;  /* TIMER 2 CAPTURE REGISTER WORD                 */
__sfr16 __at (0xCBCA) TMR2RL   ;  /* TIMER 2 CAPTURE REGISTER WORD                 */
__sfr16 __at (0x9594) TMR3     ;  /* TIMER 3 COUNTER                               */
__sfr16 __at (0x9392) TMR3RL   ;  /* TIMER 3 CAPTURE REGISTER WORD                 */
__sfr16 __at (0xBEBD) ADC0     ;  /* ADC 0 DATA WORD                               */
__sfr16 __at (0xC4C3) ADC0GT   ;  /* ADC 0 GREATER-THAN REGISTER WORD              */
__sfr16 __at (0xC6C5) ADC0LT   ;  /* ADC 0 LESS-THAN REGISTER WORD                 */
__sfr16 __at (0xFAF9) PCA0     ;  /* PCA COUNTER                                   */
__sfr16 __at (0xFCFB) PCA0CP0  ;  /* PCA CAPTURE 0 WORD                            */
__sfr16 __at (0xEAE9) PCA0CP1  ;  /* PCA CAPTURE 1 WORD                            */
__sfr16 __at (0xECEB) PCA0CP2  ;  /* PCA CAPTURE 2 WORD                            */
__sfr16 __at (0xEEED) PCA0CP3  ;  /* PCA CAPTURE 3 WORD                            */
__sfr16 __at (0xFEFD) PCA0CP4  ;  /* PCA CAPTURE 4 WORD                            */


/*  BIT Registers  */

/*  P0  0x80 */
__sbit __at (0x80) P0_0        ;
__sbit __at (0x81) P0_1        ;
__sbit __at (0x82) P0_2        ;
__sbit __at (0x83) P0_3        ;
__sbit __at (0x84) P0_4        ;
__sbit __at (0x85) P0_5        ;
__sbit __at (0x86) P0_6        ;
__sbit __at (0x87) P0_7        ;

/*  TCON  0x88 */
__sbit __at (0x88) IT0         ;  /* TCON.0 - EXT. INTERRUPT 0 TYPE                */
__sbit __at (0x89) IE0         ;  /* TCON.1 - EXT. INTERRUPT 0 EDGE FLAG           */
__sbit __at (0x8A) IT1         ;  /* TCON.2 - EXT. INTERRUPT 1 TYPE                */
__sbit __at (0x8B) IE1         ;  /* TCON.3 - EXT. INTERRUPT 1 EDGE FLAG           */
__sbit __at (0x8C) TR0         ;  /* TCON.4 - TIMER 0 ON/OFF CONTROL               */
__sbit __at (0x8D) TF0         ;  /* TCON.5 - TIMER 0 OVERFLOW FLAG                */
__sbit __at (0x8E) TR1         ;  /* TCON.6 - TIMER 1 ON/OFF CONTROL               */
__sbit __at (0x8F) TF1         ;  /* TCON.7 - TIMER 1 OVERFLOW FLAG                */

/*  P1  0x90 */
__sbit __at (0x90) P1_0        ;
__sbit __at (0x91) P1_1        ;
__sbit __at (0x92) P1_2        ;
__sbit __at (0x93) P1_3        ;
__sbit __at (0x94) P1_4        ;
__sbit __at (0x95) P1_5        ;
__sbit __at (0x96) P1_6        ;
__sbit __at (0x97) P1_7        ;

/*  SCON  0x98 */
__sbit __at (0x98) RI          ;  /* SCON.0 - RECEIVE INTERRUPT FLAG               */
__sbit __at (0x98) RI0         ;  /* SCON.0 - RECEIVE INTERRUPT FLAG               */
__sbit __at (0x99) TI          ;  /* SCON.1 - TRANSMIT INTERRUPT FLAG              */
__sbit __at (0x99) TI0         ;  /* SCON.1 - TRANSMIT INTERRUPT FLAG              */
__sbit __at (0x9A) RB8         ;  /* SCON.2 - RECEIVE BIT 8                        */
__sbit __at (0x9A) RB80        ;  /* SCON.2 - RECEIVE BIT 8                        */
__sbit __at (0x9B) TB8         ;  /* SCON.3 - TRANSMIT BIT 8                       */
__sbit __at (0x9B) TB80        ;  /* SCON.3 - TRANSMIT BIT 8                       */
__sbit __at (0x9C) REN         ;  /* SCON.4 - RECEIVE ENABLE                       */
__sbit __at (0x9C) REN0        ;  /* SCON.4 - RECEIVE ENABLE                       */
__sbit __at (0x9D) SM2         ;  /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE  */
__sbit __at (0x9D) MCE0        ;  /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE  */
__sbit __at (0x9F) SM0         ;  /* SCON.7 - SERIAL MODE CONTROL BIT 0            */
__sbit __at (0x9F) S0MODE      ;  /* SCON.7 - SERIAL MODE CONTROL BIT 0            */

/*  P2  0xA0 */
__sbit __at (0xA0) P2_0        ;
__sbit __at (0xA1) P2_1        ;
__sbit __at (0xA2) P2_2        ;
__sbit __at (0xA3) P2_3        ;
__sbit __at (0xA4) P2_4        ;
__sbit __at (0xA5) P2_5        ;
__sbit __at (0xA6) P2_6        ;
__sbit __at (0xA7) P2_7        ;

/*  IE  0xA8 */
__sbit __at (0xA8) EX0         ;  /* IE.0 - EXTERNAL INTERRUPT 0 ENABLE            */
__sbit __at (0xA9) ET0         ;  /* IE.1 - TIMER 0 INTERRUPT ENABLE               */
__sbit __at (0xAA) EX1         ;  /* IE.2 - EXTERNAL INTERRUPT 1 ENABLE            */
__sbit __at (0xAB) ET1         ;  /* IE.3 - TIMER 1 INTERRUPT ENABLE               */
__sbit __at (0xAC) ES          ;  /* IE.4 - SERIAL PORT INTERRUPT ENABLE           */
__sbit __at (0xAC) ES0         ;  /* IE.4 - SERIAL PORT INTERRUPT ENABLE           */
__sbit __at (0xAD) ET2         ;  /* IE.5 - TIMER 2 INTERRUPT ENABLE               */
__sbit __at (0xAE) ESPI0       ;  /* IE.6 - SPI0 INTERRUPT ENABLE                  */
__sbit __at (0xAF) EA          ;  /* IE.7 - GLOBAL INTERRUPT ENABLE                */

/*  P3  0xB0 */
__sbit __at (0xB0) P3_0        ;
__sbit __at (0xB1) P3_1        ;
__sbit __at (0xB2) P3_2        ;
__sbit __at (0xB3) P3_3        ;
__sbit __at (0xB4) P3_4        ;
__sbit __at (0xB5) P3_5        ;
__sbit __at (0xB6) P3_6        ;
__sbit __at (0xB7) P3_7        ;

/*  IP  0xB8 */
__sbit __at (0xB8) PX0         ;  /* IP.0 - EXTERNAL INTERRUPT 0 PRIORITY          */
__sbit __at (0xB9) PT0         ;  /* IP.1 - TIMER 0 PRIORITY                       */
__sbit __at (0xBA) PX1         ;  /* IP.2 - EXTERNAL INTERRUPT 1 PRIORITY          */
__sbit __at (0xBB) PT1         ;  /* IP.3 - TIMER 1 PRIORITY                       */
__sbit __at (0xBC) PS          ;  /* IP.4 - SERIAL PORT PRIORITY                   */
__sbit __at (0xBC) PS0         ;  /* IP.4 - SERIAL PORT PRIORITY                   */
__sbit __at (0xBD) PT2         ;  /* IP.5 - TIMER 2 PRIORITY                       */
__sbit __at (0xBE) PSPI0       ;  /* IP.6 - SPI0 PRIORITY                          */

/*  SMB0CN  0xC0 */
__sbit __at (0xC0) SI          ;  /* SMB0CN.0 - SMBUS 0 INTERRUPT PENDING FLAG     */
__sbit __at (0xC1) ACK         ;  /* SMB0CN.1 - SMBUS 0 ACKNOWLEDGE FLAG           */
__sbit __at (0xC2) ARBLOST     ;  /* SMB0CN.2 - SMBUS 0 ARBITRATION LOST INDICATOR */
__sbit __at (0xC3) ACKRQ       ;  /* SMB0CN.3 - SMBUS 0 ACKNOWLEDGE REQUEST        */
__sbit __at (0xC4) STO         ;  /* SMB0CN.4 - SMBUS 0 STOP FLAG                  */
__sbit __at (0xC5) STA         ;  /* SMB0CN.5 - SMBUS 0 START FLAG                 */
__sbit __at (0xC6) TXMODE      ;  /* SMB0CN.6 - SMBUS 0 TRANSMIT MODE INDICATOR    */
__sbit __at (0xC7) MASTER      ;  /* SMB0CN.7 - SMBUS 0 MASTER/SLAVE INDICATOR     */

/*  TMR2CN  0xC8 */
__sbit __at (0xC8) T2XCLK      ;  /* TMR2CN.0 - TIMER 2 EXTERNAL CLOCK SELECT      */
__sbit __at (0xCA) TR2         ;  /* TMR2CN.2 - TIMER 2 ON/OFF CONTROL             */
__sbit __at (0xCB) T2SPLIT     ;  /* TMR2CN.3 - TIMER 2 SPLIT MODE ENABLE          */
__sbit __at (0xCD) TF2LEN      ;  /* TMR2CN.5 - TIMER 2 LOW BYTE INTERRUPT ENABLE  */
__sbit __at (0xCE) TF2L        ;  /* TMR2CN.6 - TIMER 2 LOW BYTE OVERFLOW FLAG     */
__sbit __at (0xCF) TF2         ;  /* TMR2CN.7 - TIMER 2 OVERFLOW FLAG              */
__sbit __at (0xCF) TF2H        ;  /* TMR2CN.7 - TIMER 2 HIGH BYTE OVERFLOW FLAG    */

/*  PSW  0xD0 */
__sbit __at (0xD0) PARITY      ;  /* PSW.0 - ACCUMULATOR PARITY FLAG               */
__sbit __at (0xD1) F1          ;  /* PSW.1 - FLAG 1                                */
__sbit __at (0xD2) OV          ;  /* PSW.2 - OVERFLOW FLAG                         */
__sbit __at (0xD3) RS0         ;  /* PSW.3 - REGISTER BANK SELECT 0                */
__sbit __at (0xD4) RS1         ;  /* PSW.4 - REGISTER BANK SELECT 1                */
__sbit __at (0xD5) F0          ;  /* PSW.5 - FLAG 0                                */
__sbit __at (0xD6) AC          ;  /* PSW.6 - AUXILIARY CARRY FLAG                  */
__sbit __at (0xD7) CY          ;  /* PSW.7 - CARRY FLAG                            */

/*  PCA0CN  0xD8 */
__sbit __at (0xD8) CCF0        ;  /* PCA0CN.0 - PCA MODULE 0 CAPTURE/COMPARE FLAG  */
__sbit __at (0xD9) CCF1        ;  /* PCA0CN.1 - PCA MODULE 1 CAPTURE/COMPARE FLAG  */
__sbit __at (0xDA) CCF2        ;  /* PCA0CN.2 - PCA MODULE 2 CAPTURE/COMPARE FLAG  */
__sbit __at (0xDB) CCF3        ;  /* PCA0CN.3 - PCA MODULE 3 CAPTURE/COMPARE FLAG  */
__sbit __at (0xDC) CCF4        ;  /* PCA0CN.4 - PCA MODULE 4 CAPTURE/COMPARE FLAG  */
__sbit __at (0xDE) CR          ;  /* PCA0CN.6 - PCA COUNTER/TIMER RUN CONTROL      */
__sbit __at (0xDF) CF          ;  /* PCA0CN.7 - PCA COUNTER/TIMER OVERFLOW FLAG    */

/*  ADC0CN  0xE8 */
__sbit __at (0xE8) AD0CM0      ;  /* ADC0CN.0 - ADC 0 START OF CONV. MODE BIT 0    */
__sbit __at (0xE9) AD0CM1      ;  /* ADC0CN.1 - ADC 0 START OF CONV. MODE BIT 1    */
__sbit __at (0xEA) AD0CM2      ;  /* ADC0CN.2 - ADC 0 START OF CONV. MODE BIT 2    */
__sbit __at (0xEB) AD0WINT     ;  /* ADC0CN.3 - ADC 0 WINDOW COMPARE INT. FLAG     */
__sbit __at (0xEC) AD0BUSY     ;  /* ADC0CN.4 - ADC 0 BUSY FLAG                    */
__sbit __at (0xED) AD0INT      ;  /* ADC0CN.5 - ADC 0 CONV. COMPLETE INT. FLAG     */
__sbit __at (0xEE) AD0TM       ;  /* ADC0CN.6 - ADC 0 TRACK MODE                   */
__sbit __at (0xEF) AD0EN       ;  /* ADC0CN.7 - ADC 0 ENABLE                       */
                             
/*  SPI0CN  0xF8 */          
__sbit __at (0xF8) SPIEN       ;  /* SPI0CN.0 - SPI0 ENABLE                        */
__sbit __at (0xF9) TXBMT       ;  /* SPI0CN.1 - TRANSMIT BUFFER EMPTY              */
__sbit __at (0xFA) NSSMD0      ;  /* SPI0CN.2 - SLAVE SELECT MODE BIT 0            */
__sbit __at (0xFB) NSSMD1      ;  /* SPI0CN.3 - SLAVE SELECT MODE BIT 1            */
__sbit __at (0xFC) RXOVRN      ;  /* SPI0CN.4 - RECEIVE OVERRUN FLAG               */
__sbit __at (0xFD) MODF        ;  /* SPI0CN.5 - MODE FAULT FLAG                    */
__sbit __at (0xFE) WCOL        ;  /* SPI0CN.6 - WRITE COLLISION FLAG               */
__sbit __at (0xFF) SPIF        ;  /* SPI0CN.7 - SPI0 INTERRUPT FLAG                */


/* Predefined SFR Bit Masks */

#define PCON_IDLE         0x01    /* PCON                                */
#define PCON_STOP         0x02    /* PCON                                */
#define T1M               0x08    /* CKCON                               */
#define PSWE              0x01    /* PSCTL                               */
#define PSEE              0x02    /* PSCTL                               */
#define ECP0              0x20    /* EIE1                                */
#define ECP1              0x40    /* EIE1                                */
#define PORSF             0x02    /* RSTSRC                              */
#define SWRSF             0x10    /* RSTSRC                              */
#define ECCF              0x01    /* PCA0CPMn                            */
#define PWM               0x02    /* PCA0CPMn                            */
#define TOG               0x04    /* PCA0CPMn                            */
#define MAT               0x08    /* PCA0CPMn                            */
#define CAPN              0x10    /* PCA0CPMn                            */
#define CAPP              0x20    /* PCA0CPMn                            */
#define ECOM              0x40    /* PCA0CPMn                            */
#define PWM16             0x80    /* PCA0CPMn                            */
#define CP0E              0x10    /* XBR0                                */
#define CP0OEN            0x10    /* XBR0                                */
#define CP0AE             0x20    /* XBR0                                */
#define CP0AOEN           0x20    /* XBR0                                */
#define CP1E              0x40    /* XBR0                                */
#define CP1AE             0x80    /* XBR0                                */

#endif
/*-------------------------------------------------------------------------
   C8051F410.h - Register Declarations for the SiLabs C8051F41x
   Processor Range

   Copyright (C) 2006, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef C8051F410_H
#define C8051F410_H


/*  BYTE Registers  */

__sfr __at (0x80) P0           ;  /* PORT 0                                        */
__sfr __at (0x81) SP           ;  /* STACK POINTER                                 */
__sfr __at (0x82) DPL          ;  /* DATA POINTER - LOW BYTE                       */
__sfr __at (0x83) DPH          ;  /* DATA POINTER - HIGH BYTE                      */
__sfr __at (0x84) CRC0CN       ;  /* CRC 0 CONTROL                                 */
__sfr __at (0x85) CRC0IN       ;  /* CRC 0 DATA INPUT                              */
__sfr __at (0x86) CRC0DAT      ;  /* CRC 0 DATA OUTPUT                             */
__sfr __at (0x87) PCON         ;  /* POWER CONTROL                                 */
__sfr __at (0x88) TCON         ;  /* TIMER CONTROL                                 */
__sfr __at (0x89) TMOD         ;  /* TIMER MODE                                    */
__sfr __at (0x8A) TL0          ;  /* TIMER 0 - LOW BYTE                            */
__sfr __at (0x8B) TL1          ;  /* TIMER 1 - LOW BYTE                            */
__sfr __at (0x8C) TH0          ;  /* TIMER 0 - HIGH BYTE                           */
__sfr __at (0x8D) TH1          ;  /* TIMER 1 - HIGH BYTE                           */
__sfr __at (0x8E) CKCON        ;  /* CLOCK CONTROL                                 */
__sfr __at (0x8F) PSCTL        ;  /* PROGRAM STORE R/W CONTROL                     */
__sfr __at (0x90) P1           ;  /* PORT 1                                        */
__sfr __at (0x91) TMR3CN       ;  /* TIMER 3 CONTROL                               */
__sfr __at (0x92) TMR3RLL      ;  /* TIMER 3 CAPTURE REGISTER - LOW BYTE           */
__sfr __at (0x93) TMR3RLH      ;  /* TIMER 3 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at (0x94) TMR3L        ;  /* TIMER 3 - LOW BYTE                            */
__sfr __at (0x95) TMR3H        ;  /* TIMER 3 - HIGH BYTE                           */
__sfr __at (0x96) IDA0L        ;  /* CURRENT MODE DAC 0 - LOW BYTE                 */
__sfr __at (0x97) IDA0H        ;  /* CURRENT MODE DAC 0 - HIGH BYTE                */
__sfr __at (0x98) SCON         ;  /* SERIAL PORT CONTROL                           */
__sfr __at (0x98) SCON0        ;  /* SERIAL PORT CONTROL                           */
__sfr __at (0x99) SBUF         ;  /* SERIAL PORT BUFFER                            */
__sfr __at (0x99) SBUF0        ;  /* SERIAL PORT BUFFER                            */
__sfr __at (0x9A) CPT1CN       ;  /* COMPARATOR 1 CONTROL                          */
__sfr __at (0x9B) CPT0CN       ;  /* COMPARATOR 0 CONTROL                          */
__sfr __at (0x9C) CPT1MD       ;  /* COMPARATOR 1 MODE SELECTION                   */
__sfr __at (0x9D) CPT0MD       ;  /* COMPARATOR 0 MODE SELECTION                   */
__sfr __at (0x9E) CPT1MX       ;  /* COMPARATOR 1 MUX SELECTION                    */
__sfr __at (0x9F) CPT0MX       ;  /* COMPARATOR 0 MUX SELECTION                    */
__sfr __at (0xA0) P2           ;  /* PORT 2                                        */
__sfr __at (0xA1) SPI0CFG      ;  /* SPI0 CONFIGURATION                            */
__sfr __at (0xA2) SPI0CKR      ;  /* SPI0 CLOCK RATE CONTROL                       */
__sfr __at (0xA3) SPI0DAT      ;  /* SPI0 DATA                                     */
__sfr __at (0xA4) P0MDOUT      ;  /* PORT 0 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA5) P1MDOUT      ;  /* PORT 1 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA6) P2MDOUT      ;  /* PORT 2 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA8) IE           ;  /* INTERRUPT ENABLE                              */
__sfr __at (0xA9) CLKSEL       ;  /* SYSTEM CLOCK SELECT                           */
__sfr __at (0xAA) EMI0CN       ;  /* EXTERNAL MEMORY INTERFACE CONTROL             */
__sfr __at (0xAA) _XPAGE       ;  /* XDATA/PDATA PAGE                              */
__sfr __at (0xAB) CLKMUL       ;  /* CLOCK MULTIPLIER                              */
__sfr __at (0xAC) RTC0ADR      ;  /* SMARTCLOCK ADDRESS                            */
__sfr __at (0xAD) RTC0DAT      ;  /* SMARTCLOCK DATA                               */
__sfr __at (0xAE) RTC0KEY      ;  /* SMARTCLOCK LOCK AND KEY                       */
__sfr __at (0xAF) ONESHOT      ;  /* FLASH ONESHOT PERIOD                          */
__sfr __at (0xB0) P0ODEN       ;  /* PORT 0 OVERDRIVE                              */
__sfr __at (0xB1) OSCXCN       ;  /* EXTERNAL OSCILLATOR CONTROL                   */
__sfr __at (0xB2) OSCICN       ;  /* INTERNAL OSCILLATOR CONTROL                   */
__sfr __at (0xB3) OSCICL       ;  /* INTERNAL OSCILLATOR CALIBRATION               */
__sfr __at (0xB5) IDA1CN       ;  /* CURRENT MODE DAC 1 - CONTROL                  */
__sfr __at (0xB6) FLSCL        ;  /* FLASH MEMORY TIMING PRESCALER                 */
__sfr __at (0xB7) FLKEY        ;  /* FLASH ACESS LIMIT                             */
__sfr __at (0xB8) IP           ;  /* INTERRUPT PRIORITY                            */
__sfr __at (0xB9) IDA0CN       ;  /* CURRENT MODE DAC 0 - CONTROL                  */
__sfr __at (0xBA) ADC0TK       ;  /* ADC 0 TRACKING MODE SELECT                    */
__sfr __at (0xBB) ADC0MX       ;  /* ADC 0 CHANNEL SELECT                          */
__sfr __at (0xBC) ADC0CF       ;  /* ADC 0 CONFIGURATION                           */
__sfr __at (0xBD) ADC0L        ;  /* ADC 0 DATA WORD LSB                           */
__sfr __at (0xBE) ADC0H        ;  /* ADC 0 DATA WORD MSB                           */
__sfr __at (0xBF) P1MASK       ;  /* PORT 1 MASK                                   */
__sfr __at (0xC0) SMB0CN       ;  /* SMBUS CONTROL                                 */
__sfr __at (0xC1) SMB0CF       ;  /* SMBUS CONFIGURATION                           */
__sfr __at (0xC2) SMB0DAT      ;  /* SMBUS DATA                                    */
__sfr __at (0xC3) ADC0GTL      ;  /* ADC 0 GREATER-THAN LOW BYTE                   */
__sfr __at (0xC4) ADC0GTH      ;  /* ADC 0 GREATER-THAN HIGH BYTE                  */
__sfr __at (0xC5) ADC0LTL      ;  /* ADC 0 LESS-THAN LOW BYTE                      */
__sfr __at (0xC6) ADC0LTH      ;  /* ADC 0 LESS-THAN HIGH BYTE                     */
__sfr __at (0xC7) P0MASK       ;  /* PORT 0 MASK                                   */
__sfr __at (0xC8) T2CON        ;  /* TIMER 2 CONTROL                               */
__sfr __at (0xC8) TMR2CN       ;  /* TIMER 2 CONTROL                               */
__sfr __at (0xC9) REG0CN       ;  /* VOLTAGE REGULATOR CONTROL                     */
__sfr __at (0xCA) RCAP2L       ;  /* TIMER 2 CAPTURE REGISTER - LOW BYTE           */
__sfr __at (0xCA) TMR2RLL      ;  /* TIMER 2 CAPTURE REGISTER - LOW BYTE           */
__sfr __at (0xCB) RCAP2H       ;  /* TIMER 2 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at (0xCB) TMR2RLH      ;  /* TIMER 2 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at (0xCC) TL2          ;  /* TIMER 2 - LOW BYTE                            */
__sfr __at (0xCC) TMR2L        ;  /* TIMER 2 - LOW BYTE                            */
__sfr __at (0xCD) TH2          ;  /* TIMER 2 - HIGH BYTE                           */
__sfr __at (0xCD) TMR2H        ;  /* TIMER 2 - HIGH BYTE                           */
__sfr __at (0xCE) PCA0CPM5     ;  /* PCA MODULE 5 MODE REGISTER                    */
__sfr __at (0xCF) P1MAT        ;  /* PORT 1 MATCH                                  */
__sfr __at (0xD0) PSW          ;  /* PROGRAM STATUS WORD                           */
__sfr __at (0xD1) REF0CN       ;  /* VOLTAGE REFERENCE 0 CONTROL                   */
__sfr __at (0xD2) PCA0CPL5     ;  /* PCA CAPTURE 5 LOW                             */
__sfr __at (0xD3) PCA0CPH5     ;  /* PCA CAPTURE 5 HIGH                            */
__sfr __at (0xD4) P0SKIP       ;  /* PORT 0 SKIP                                   */
__sfr __at (0xD5) P1SKIP       ;  /* PORT 1 SKIP                                   */
__sfr __at (0xD6) P2SKIP       ;  /* PORT 2 SKIP                                   */
__sfr __at (0xD7) P0MAT        ;  /* PORT 0 MATCH                                  */
__sfr __at (0xD8) PCA0CN       ;  /* PCA CONTROL                                   */
__sfr __at (0xD9) PCA0MD       ;  /* PCA MODE                                      */
__sfr __at (0xDA) PCA0CPM0     ;  /* PCA MODULE 0 MODE REGISTER                    */
__sfr __at (0xDB) PCA0CPM1     ;  /* PCA MODULE 1 MODE REGISTER                    */
__sfr __at (0xDC) PCA0CPM2     ;  /* PCA MODULE 2 MODE REGISTER                    */
__sfr __at (0xDD) PCA0CPM3     ;  /* PCA MODULE 3 MODE REGISTER                    */
__sfr __at (0xDE) PCA0CPM4     ;  /* PCA MODULE 4 MODE REGISTER                    */
__sfr __at (0xDF) CRC0FLIP     ;  /* CRC 0 BIT FLIP                                */
__sfr __at (0xE0) ACC          ;  /* ACCUMULATOR                                   */
__sfr __at (0xE1) XBR0         ;  /* PORT MUX CONFIGURATION REGISTER 0             */
__sfr __at (0xE2) XBR1         ;  /* PORT MUX CONFIGURATION REGISTER 1             */
__sfr __at (0xE3) PFE0CN       ;  /* PREFETCH ENGINE CONTROL                       */
__sfr __at (0xE4) IT01CF       ;  /* INT0/INT1 CONFIGURATION REGISTER              */
__sfr __at (0xE4) INT01CF      ;  /* INT0/INT1 CONFIGURATION REGISTER              */
__sfr __at (0xE6) EIE1         ;  /* EXTERNAL INTERRUPT ENABLE 1                   */
__sfr __at (0xE7) EIE2         ;  /* EXTERNAL INTERRUPT ENABLE 2                   */
__sfr __at (0xE8) ADC0CN       ;  /* ADC 0 CONTROL                                 */
__sfr __at (0xE9) PCA0CPL1     ;  /* PCA CAPTURE 1 LOW                             */
__sfr __at (0xEA) PCA0CPH1     ;  /* PCA CAPTURE 1 HIGH                            */
__sfr __at (0xEB) PCA0CPL2     ;  /* PCA CAPTURE 2 LOW                             */
__sfr __at (0xEC) PCA0CPH2     ;  /* PCA CAPTURE 2 HIGH                            */
__sfr __at (0xED) PCA0CPL3     ;  /* PCA CAPTURE 3 LOW                             */
__sfr __at (0xEE) PCA0CPH3     ;  /* PCA CAPTURE 3 HIGH                            */
__sfr __at (0xEF) RSTSRC       ;  /* RESET SOURCE                                  */
__sfr __at (0xF0) B            ;  /* B REGISTER                                    */
__sfr __at (0xF1) P0MODE       ;  /* PORT 0 INPUT MODE CONFIGURATION               */
__sfr __at (0xF1) P0MDIN       ;  /* PORT 0 INPUT MODE CONFIGURATION               */
__sfr __at (0xF2) P1MODE       ;  /* PORT 1 INPUT MODE CONFIGURATION               */
__sfr __at (0xF2) P1MDIN       ;  /* PORT 1 INPUT MODE CONFIGURATION               */
__sfr __at (0xF3) P2MODE       ;  /* PORT 2 INPUT MODE CONFIGURATION               */
__sfr __at (0xF3) P2MDIN       ;  /* PORT 2 INPUT MODE CONFIGURATION               */
__sfr __at (0xF4) IDA1L        ;  /* CURRENT MODE DAC 1 - LOW BYTE                 */
__sfr __at (0xF5) IDA1H        ;  /* CURRENT MODE DAC 1 - HIGH BYTE                */
__sfr __at (0xF6) EIP1         ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 1        */
__sfr __at (0xF7) EIP2         ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 2        */
__sfr __at (0xF8) SPI0CN       ;  /* SPI0 CONTROL                                  */
__sfr __at (0xF9) PCA0L        ;  /* PCA COUNTER LOW                               */
__sfr __at (0xFA) PCA0H        ;  /* PCA COUNTER HIGH                              */
__sfr __at (0xFB) PCA0CPL0     ;  /* PCA CAPTURE 0 LOW                             */
__sfr __at (0xFC) PCA0CPH0     ;  /* PCA CAPTURE 0 HIGH                            */
__sfr __at (0xFD) PCA0CPL4     ;  /* PCA CAPTURE 4 LOW                             */
__sfr __at (0xFE) PCA0CPH4     ;  /* PCA CAPTURE 4 HIGH                            */
__sfr __at (0xFF) VDM0CN       ;  /* VDD MONITOR CONTROL                           */


/*  WORD/DWORD Registers  */

__sfr16 __at (0x8C8A) TMR0     ;  /* TIMER 0 COUNTER                               */
__sfr16 __at (0x8D8B) TMR1     ;  /* TIMER 1 COUNTER                               */
__sfr16 __at (0xCDCC) TMR2     ;  /* TIMER 2 COUNTER                               */
__sfr16 __at (0xCBCA) RCAP2    ;  /* TIMER 2 CAPTURE REGISTER WORD                 */
__sfr16 __at (0xCBCA) TMR2RL   ;  /* TIMER 2 CAPTURE REGISTER WORD                 */
__sfr16 __at (0x9594) TMR3     ;  /* TIMER 3 COUNTER                               */
__sfr16 __at (0x9392) TMR3RL   ;  /* TIMER 3 CAPTURE REGISTER WORD                 */
__sfr16 __at (0x9796) IDA0     ;  /* CURRENT MODE DAC 0 DATA WORD                  */
__sfr16 __at (0xF5F4) IDA1     ;  /* CURRENT MODE DAC 1 DATA WORD                  */
__sfr16 __at (0xBEBD) ADC0     ;  /* ADC 0 DATA WORD                               */
__sfr16 __at (0xC4C3) ADC0GT   ;  /* ADC 0 GREATER-THAN REGISTER WORD              */
__sfr16 __at (0xC6C5) ADC0LT   ;  /* ADC 0 LESS-THAN REGISTER WORD                 */
__sfr16 __at (0xFAF9) PCA0     ;  /* PCA COUNTER                                   */
__sfr16 __at (0xFCFB) PCA0CP0  ;  /* PCA CAPTURE 0 WORD                            */
__sfr16 __at (0xEAE9) PCA0CP1  ;  /* PCA CAPTURE 1 WORD                            */
__sfr16 __at (0xECEB) PCA0CP2  ;  /* PCA CAPTURE 2 WORD                            */
__sfr16 __at (0xEEED) PCA0CP3  ;  /* PCA CAPTURE 3 WORD                            */
__sfr16 __at (0xFEFD) PCA0CP4  ;  /* PCA CAPTURE 4 WORD                            */
__sfr16 __at (0xD3D2) PCA0CP5  ;  /* PCA CAPTURE 5 WORD                            */


/*  BIT Registers  */

/*  P0  0x80 */
__sbit __at (0x80) P0_0        ;
__sbit __at (0x81) P0_1        ;
__sbit __at (0x82) P0_2        ;
__sbit __at (0x83) P0_3        ;
__sbit __at (0x84) P0_4        ;
__sbit __at (0x85) P0_5        ;
__sbit __at (0x86) P0_6        ;
__sbit __at (0x87) P0_7        ;

/*  TCON  0x88 */
__sbit __at (0x88) IT0         ;  /* TCON.0 - EXT. INTERRUPT 0 TYPE                */
__sbit __at (0x89) IE0         ;  /* TCON.1 - EXT. INTERRUPT 0 EDGE FLAG           */
__sbit __at (0x8A) IT1         ;  /* TCON.2 - EXT. INTERRUPT 1 TYPE                */
__sbit __at (0x8B) IE1         ;  /* TCON.3 - EXT. INTERRUPT 1 EDGE FLAG           */
__sbit __at (0x8C) TR0         ;  /* TCON.4 - TIMER 0 ON/OFF CONTROL               */
__sbit __at (0x8D) TF0         ;  /* TCON.5 - TIMER 0 OVERFLOW FLAG                */
__sbit __at (0x8E) TR1         ;  /* TCON.6 - TIMER 1 ON/OFF CONTROL               */
__sbit __at (0x8F) TF1         ;  /* TCON.7 - TIMER 1 OVERFLOW FLAG                */

/*  P1  0x90 */
__sbit __at (0x90) P1_0        ;
__sbit __at (0x91) P1_1        ;
__sbit __at (0x92) P1_2        ;
__sbit __at (0x93) P1_3        ;
__sbit __at (0x94) P1_4        ;
__sbit __at (0x95) P1_5        ;
__sbit __at (0x96) P1_6        ;
__sbit __at (0x97) P1_7        ;

/*  SCON  0x98 */
__sbit __at (0x98) RI          ;  /* SCON.0 - RECEIVE INTERRUPT FLAG               */
__sbit __at (0x98) RI0         ;  /* SCON.0 - RECEIVE INTERRUPT FLAG               */
__sbit __at (0x99) TI          ;  /* SCON.1 - TRANSMIT INTERRUPT FLAG              */
__sbit __at (0x99) TI0         ;  /* SCON.1 - TRANSMIT INTERRUPT FLAG              */
__sbit __at (0x9A) RB8         ;  /* SCON.2 - RECEIVE BIT 8                        */
__sbit __at (0x9A) RB80        ;  /* SCON.2 - RECEIVE BIT 8                        */
__sbit __at (0x9B) TB8         ;  /* SCON.3 - TRANSMIT BIT 8                       */
__sbit __at (0x9B) TB80        ;  /* SCON.3 - TRANSMIT BIT 8                       */
__sbit __at (0x9C) REN         ;  /* SCON.4 - RECEIVE ENABLE                       */
__sbit __at (0x9C) REN0        ;  /* SCON.4 - RECEIVE ENABLE                       */
__sbit __at (0x9D) SM2         ;  /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE  */
__sbit __at (0x9D) MCE0        ;  /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE  */
__sbit __at (0x9F) SM0         ;  /* SCON.7 - SERIAL MODE CONTROL BIT 0            */
__sbit __at (0x9F) S0MODE      ;  /* SCON.7 - SERIAL MODE CONTROL BIT 0            */

/*  P2  0xA0 */
__sbit __at (0xA0) P2_0        ;
__sbit __at (0xA1) P2_1        ;
__sbit __at (0xA2) P2_2        ;
__sbit __at (0xA3) P2_3        ;
__sbit __at (0xA4) P2_4        ;
__sbit __at (0xA5) P2_5        ;
__sbit __at (0xA6) P2_6        ;
__sbit __at (0xA7) P2_7        ;

/*  IE  0xA8 */
__sbit __at (0xA8) EX0         ;  /* IE.0 - EXTERNAL INTERRUPT 0 ENABLE            */
__sbit __at (0xA9) ET0         ;  /* IE.1 - TIMER 0 INTERRUPT ENABLE               */
__sbit __at (0xAA) EX1         ;  /* IE.2 - EXTERNAL INTERRUPT 1 ENABLE            */
__sbit __at (0xAB) ET1         ;  /* IE.3 - TIMER 1 INTERRUPT ENABLE               */
__sbit __at (0xAC) ES          ;  /* IE.4 - SERIAL PORT INTERRUPT ENABLE           */
__sbit __at (0xAC) ES0         ;  /* IE.4 - SERIAL PORT INTERRUPT ENABLE           */
__sbit __at (0xAD) ET2         ;  /* IE.5 - TIMER 2 INTERRUPT ENABLE               */
__sbit __at (0xAE) ESPI0       ;  /* IE.6 - SPI0 INTERRUPT ENABLE                  */
__sbit __at (0xAF) EA          ;  /* IE.7 - GLOBAL INTERRUPT ENABLE                */

/*  P0ODEN  0xB0 */
__sbit __at (0xB0) P0OD_0      ;  /* P0ODEN.0 - PORT0.0 OVERDRIVE ENABLE           */
__sbit __at (0xB1) P0OD_1      ;  /* P0ODEN.1 - PORT0.1 OVERDRIVE ENABLE           */
__sbit __at (0xB2) P0OD_2      ;  /* P0ODEN.2 - PORT0.2 OVERDRIVE ENABLE           */
__sbit __at (0xB3) P0OD_3      ;  /* P0ODEN.3 - PORT0.3 OVERDRIVE ENABLE           */
__sbit __at (0xB4) P0OD_4      ;  /* P0ODEN.4 - PORT0.4 OVERDRIVE ENABLE           */
__sbit __at (0xB5) P0OD_5      ;  /* P0ODEN.5 - PORT0.5 OVERDRIVE ENABLE           */
__sbit __at (0xB6) P0OD_6      ;  /* P0ODEN.6 - PORT0.6 OVERDRIVE ENABLE           */
__sbit __at (0xB7) P0OD_7      ;  /* P0ODEN.7 - PORT0.7 OVERDRIVE ENABLE           */

/*  IP  0xB8 */
__sbit __at (0xB8) PX0         ;  /* IP.0 - EXTERNAL INTERRUPT 0 PRIORITY          */
__sbit __at (0xB9) PT0         ;  /* IP.1 - TIMER 0 PRIORITY                       */
__sbit __at (0xBA) PX1         ;  /* IP.2 - EXTERNAL INTERRUPT 1 PRIORITY          */
__sbit __at (0xBB) PT1         ;  /* IP.3 - TIMER 1 PRIORITY                       */
__sbit __at (0xBC) PS          ;  /* IP.4 - SERIAL PORT PRIORITY                   */
__sbit __at (0xBC) PS0         ;  /* IP.4 - SERIAL PORT PRIORITY                   */
__sbit __at (0xBD) PT2         ;  /* IP.5 - TIMER 2 PRIORITY                       */
__sbit __at (0xBE) PSPI0       ;  /* IP.6 - SPI0 PRIORITY                          */

/*  SMB0CN  0xC0 */
__sbit __at (0xC0) SI          ;  /* SMB0CN.0 - SMBUS 0 INTERRUPT PENDING FLAG     */
__sbit __at (0xC1) ACK         ;  /* SMB0CN.1 - SMBUS 0 ACKNOWLEDGE FLAG           */
__sbit __at (0xC2) ARBLOST     ;  /* SMB0CN.2 - SMBUS 0 ARBITRATION LOST INDICATOR */
__sbit __at (0xC3) ACKRQ       ;  /* SMB0CN.3 - SMBUS 0 ACKNOWLEDGE REQUEST        */
__sbit __at (0xC4) STO         ;  /* SMB0CN.4 - SMBUS 0 STOP FLAG                  */
__sbit __at (0xC5) STA         ;  /* SMB0CN.5 - SMBUS 0 START FLAG                 */
__sbit __at (0xC6) TXMODE      ;  /* SMB0CN.6 - SMBUS 0 TRANSMIT MODE INDICATOR    */
__sbit __at (0xC7) MASTER      ;  /* SMB0CN.7 - SMBUS 0 MASTER/SLAVE INDICATOR     */

/*  TMR2CN  0xC8 */
__sbit __at (0xC8) T2XCLK      ;  /* TMR2CN.0 - TIMER 2 EXTERNAL CLOCK SELECT      */
__sbit __at (0xC9) T2RCLK      ;  /* TMR2CN.1 - TIMER 2 CAPTURE MODE               */
__sbit __at (0xCA) TR2         ;  /* TMR2CN.2 - TIMER 2 ON/OFF CONTROL             */
__sbit __at (0xCB) T2SPLIT     ;  /* TMR2CN.3 - TIMER 2 SPLIT MODE ENABLE          */
__sbit __at (0xCC) TF2CEN      ;  /* TMR2CN.4 - TIMER 2 LOW-FREQ OSC CAPTURE ENABLE*/
__sbit __at (0xCD) TF2LEN      ;  /* TMR2CN.5 - TIMER 2 LOW BYTE INTERRUPT ENABLE  */
__sbit __at (0xCE) TF2L        ;  /* TMR2CN.6 - TIMER 2 LOW BYTE OVERFLOW FLAG     */
__sbit __at (0xCF) TF2         ;  /* TMR2CN.7 - TIMER 2 OVERFLOW FLAG              */
__sbit __at (0xCF) TF2H        ;  /* TMR2CN.7 - TIMER 2 HIGH BYTE OVERFLOW FLAG    */

/*  PSW  0xD0 */
__sbit __at (0xD0) PARITY      ;  /* PSW.0 - ACCUMULATOR PARITY FLAG               */
__sbit __at (0xD1) F1          ;  /* PSW.1 - FLAG 1                                */
__sbit __at (0xD2) OV          ;  /* PSW.2 - OVERFLOW FLAG                         */
__sbit __at (0xD3) RS0         ;  /* PSW.3 - REGISTER BANK SELECT 0                */
__sbit __at (0xD4) RS1         ;  /* PSW.4 - REGISTER BANK SELECT 1                */
__sbit __at (0xD5) F0          ;  /* PSW.5 - FLAG 0                                */
__sbit __at (0xD6) AC          ;  /* PSW.6 - AUXILIARY CARRY FLAG                  */
__sbit __at (0xD7) CY          ;  /* PSW.7 - CARRY FLAG                            */

/*  PCA0CN  0xD8 */
__sbit __at (0xD8) CCF0        ;  /* PCA0CN.0 - PCA MODULE 0 CAPTURE/COMPARE FLAG  */
__sbit __at (0xD9) CCF1        ;  /* PCA0CN.1 - PCA MODULE 1 CAPTURE/COMPARE FLAG  */
__sbit __at (0xDA) CCF2        ;  /* PCA0CN.2 - PCA MODULE 2 CAPTURE/COMPARE FLAG  */
__sbit __at (0xDB) CCF3        ;  /* PCA0CN.3 - PCA MODULE 3 CAPTURE/COMPARE FLAG  */
__sbit __at (0xDC) CCF4        ;  /* PCA0CN.4 - PCA MODULE 4 CAPTURE/COMPARE FLAG  */
__sbit __at (0xDD) CCF5        ;  /* PCA0CN.5 - PCA MODULE 5 CAPTURE/COMPARE FLAG  */
__sbit __at (0xDE) CR          ;  /* PCA0CN.6 - PCA COUNTER/TIMER RUN CONTROL      */
__sbit __at (0xDF) CF          ;  /* PCA0CN.7 - PCA COUNTER/TIMER OVERFLOW FLAG    */

/*  ADC0CN  0xE8 */
__sbit __at (0xE8) AD0CM0      ;  /* ADC0CN.0 - ADC 0 START OF CONV. MODE BIT 0    */
__sbit __at (0xE9) AD0CM1      ;  /* ADC0CN.1 - ADC 0 START OF CONV. MODE BIT 1    */
__sbit __at (0xEA) AD0LJST     ;  /* ADC0CN.2 - ADC 0 LEFT JUSTIFY SELECT          */
__sbit __at (0xEB) AD0WINT     ;  /* ADC0CN.3 - ADC 0 WINDOW COMPARE INT. FLAG     */
__sbit __at (0xEC) AD0BUSY     ;  /* ADC0CN.4 - ADC 0 BUSY FLAG                    */
__sbit __at (0xED) AD0INT      ;  /* ADC0CN.5 - ADC 0 CONV. COMPLETE INT. FLAG     */
__sbit __at (0xEE) BURSTEN     ;  /* ADC0CN.6 - ADC 0 BURST MODE ENABLE            */
__sbit __at (0xEF) AD0EN       ;  /* ADC0CN.7 - ADC 0 ENABLE                       */

/*  SPI0CN  0xF8 */
__sbit __at (0xF8) SPIEN       ;  /* SPI0CN.0 - SPI0 ENABLE                        */
__sbit __at (0xF9) TXBMT       ;  /* SPI0CN.1 - TRANSMIT BUFFER EMPTY              */
__sbit __at (0xFA) NSSMD0      ;  /* SPI0CN.2 - SLAVE SELECT MODE BIT 0            */
__sbit __at (0xFB) NSSMD1      ;  /* SPI0CN.3 - SLAVE SELECT MODE BIT 1            */
__sbit __at (0xFC) RXOVRN      ;  /* SPI0CN.4 - RECEIVE OVERRUN FLAG               */
__sbit __at (0xFD) MODF        ;  /* SPI0CN.5 - MODE FAULT FLAG                    */
__sbit __at (0xFE) WCOL        ;  /* SPI0CN.6 - WRITE COLLISION FLAG               */
__sbit __at (0xFF) SPIF        ;  /* SPI0CN.7 - SPI0 INTERRUPT FLAG                */


/* Predefined SFR Bit Masks */

#define PCON_IDLE         0x01    /* PCON                                */
#define PCON_STOP         0x02    /* PCON                                */
#define T1M               0x08    /* CKCON                               */
#define PSWE              0x01    /* PSCTL                               */
#define PSEE              0x02    /* PSCTL                               */
#define ECP0              0x20    /* EIE1                                */
#define PORSF             0x02    /* RSTSRC                              */
#define SWRSF             0x10    /* RSTSRC                              */
#define ECCF              0x01    /* PCA0CPMn                            */
#define PWM               0x02    /* PCA0CPMn                            */
#define TOG               0x04    /* PCA0CPMn                            */
#define MAT               0x08    /* PCA0CPMn                            */
#define CAPN              0x10    /* PCA0CPMn                            */
#define CAPP              0x20    /* PCA0CPMn                            */
#define ECOM              0x40    /* PCA0CPMn                            */
#define PWM16             0x80    /* PCA0CPMn                            */
#define CP0E              0x10    /* XBR0                                */
#define CP0OEN            0x10    /* XBR0                                */
#define CP0AE             0x20    /* XBR0                                */
#define CP0AOEN           0x20    /* XBR0                                */

/* Interrupts */

#define INT_EXT0          0       // External Interrupt 0
#define INT_TIMER0        1       // Timer0 Overflow
#define INT_EXT1          2       // External Interrupt 1
#define INT_TIMER1        3       // Timer1 Overflow
#define INT_UART0         4       // Serial Port 0
#define INT_TIMER2        5       // Timer2 Overflow
#define INT_SPI0          6       // Serial Peripheral Interface 0
#define INT_SMBUS0        7       // SMBus0 Interface
#define INT_RTC0          8       // RTC0 Interface
#define INT_ADC0_WINDOW   9       // ADC0 Window Comparison
#define INT_ADC0_EOC      10      // ADC0 End Of Conversion
#define INT_PCA0          11      // PCA0 Peripheral
#define INT_COMPARATOR0   12      // Comparator0
#define INT_COMPARATOR1   13      // Comparator1
#define INT_TIMER3        14      // Timer3 Overflow
#define INT_VREG_DROPOUT  15      // VREG dropout
#define INT_PORT_MATCH    16      // Port Match

#endif
/*-------------------------------------------------------------------------
   msc1210.h - register declarations for Texas Intruments MSC12xx MCU family

   Copyright (C) 2006, Philippe Latu <philippe.latu AT linux-france.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef __MSC1210_H__
#define __MSC1210_H__

/*  BYTE Registers with bit definitions */

__sfr __at (0x80) P0;           /* Port 0                               */
__sfr __at (0x81) SP;           /* Stack Pointer                        */
__sfr __at (0x82) DPL;          /* Data Pointer 0: low byte             */
__sfr __at (0x82) DPL0;         /* Data Pointer 0: low byte             */
__sfr __at (0x83) DPH;          /* Data Pointer 0: high byte            */
__sfr __at (0x83) DPH0;         /* Data Pointer 0: high byte            */
__sfr __at (0x84) DPL1;         /* Data Pointer 1: low byte             */
__sfr __at (0x85) DPH1;         /* Data Pointer 1: high byte            */
__sfr __at (0x86) DPS;          /* Data Pointer Select                  */
__sfr __at (0x87) PCON;         /* Power Control                        */
__sfr __at (0x88) TCON;         /* Timer Control                        */
        /*  _7_ _6_ _5_ _4_ _3_ _2_ _1_ _0_                             */
        /* |TF1|TR1|TF0|TR0|IE1|IT1|IE0|IT0|                            */
  __sbit __at (0x88) IT0;         /* External Interrupt 0 Type          */
  __sbit __at (0x89) IE0;         /* External Interrupt 0 Edge Flag     */
  __sbit __at (0x8a) IT1;         /* External Interrupt 1 Type          */
  __sbit __at (0x8b) IE1;         /* External Interrupt 1 Edge Flag     */
  __sbit __at (0x8c) TR0;         /* Timer 0 On/Off Control             */
  __sbit __at (0x8d) TF0;         /* Timer 0 Overflow Flag              */
  __sbit __at (0x8e) TR1;         /* Timer 1 On/Off Control             */
  __sbit __at (0x8f) TF1;         /* Timer 1 Overflow Flag              */
__sfr __at (0x89) TMOD;         /* Timer Mode                           */
__sfr __at (0x8a) TL0;          /* Timer 0: low byte                    */
__sfr __at (0x8b) TL1;          /* Timer 1: low byte                    */
__sfr __at (0x8c) TH0;          /* Timer 0: high byte                   */
__sfr __at (0x8d) TH1;          /* Timer 1: high byte                   */
__sfr __at (0x8e) CKCON;        /* Clock Control                        */
__sfr __at (0x8f) MWS;          /* Memory Write Select                  */
__sfr __at (0x90) P1;           /* Port 1                               */
        /*  _7_ _6_ _5_ _4_ _3_ _2_ _1_  _0_                            */
        /* |   |   |   |   |   |   |T2EX|T2 |                           */
  __sbit __at (0x90) T2;          /* Timer 2 External Input             */
  __sbit __at (0x91) T2EX;        /* Timer 2 Capture/Reload             */
__sfr __at (0x91) EXIF;         /* External Interrupt Flag              */
__sfr __at (0x92) MPAGE;        /* Memory Page                          */
__sfr __at (0x92) _XPAGE;       /* XDATA/PDATA PAGE                     */
__sfr __at (0x93) CADDR;        /* Configuration Address Register       */
__sfr __at (0x94) CDATA;        /* Configuration Data Register          */
__sfr __at (0x95) MCON;         /* Memory Configuration                 */
__sfr __at (0x98) SCON;         /* Serial Control 0                     */
__sfr __at (0x98) SCON0;        /* Serial Control 0                     */
        /*  _7_ _6_ _5_ _4_ _3_ _2_ _1_ _0_                             */
        /* |SM0|SM1|SM2|REN|TB8|RB8|TI |RI |                            */
  __sbit __at (0x98) RI;          /* Receive Interrupt Flag             */
  __sbit __at (0x98) RI0;         /* Receive Interrupt Flag             */
  __sbit __at (0x98) RI_0;        /* Receive Interrupt Flag             */
  __sbit __at (0x99) TI;          /* Transmit Interrupt Flag            */
  __sbit __at (0x99) TI0;         /* Transmit Interrupt Flag            */
  __sbit __at (0x99) TI_0;        /* Transmit Interrupt Flag            */
  __sbit __at (0x9a) RB8;         /* Receive Bit 8                      */
  __sbit __at (0x9a) RB8_0;       /* Receive Bit 8                      */
  __sbit __at (0x9b) TB8;         /* Transmit Bit 8                     */
  __sbit __at (0x9b) TB8_0;       /* Transmit Bit 8                     */
  __sbit __at (0x9c) REN;         /* Receive Enable                     */
  __sbit __at (0x9c) REN_0;       /* Receive Enable                     */
  __sbit __at (0x9d) SM2;         /* Multiprocessor Communication Enable*/
  __sbit __at (0x9d) SM2_0;       /* Multiprocessor Communication Enable*/
  __sbit __at (0x9e) SM1;         /* Serial Port Select Mode 1          */
  __sbit __at (0x9e) SM1_0;       /* Serial Port Select Mode 1          */
  __sbit __at (0x9f) SM0;         /* Serial Port Select Mode 0          */
  __sbit __at (0x9f) SM0_0;       /* Serial Port Select Mode 0          */
__sfr __at (0x99) SBUF;         /* Serial Buffer 0                      */
__sfr __at (0x99) SBUF0;        /* Serial Buffer 0                      */
__sfr __at (0x9a) SPICON;       /* SPI Control                          */
__sfr __at (0x9a) I2CCON;       /* I2C Control                          */
        /*  _7_   _6_   _5_   _4_  _3_   _2_  _1_  _0_                  */
        /* |SCLK2|SCLK1|SCLK0|FIFO|ORDER|MSTR|CPHA|CPOL|                */
  __sbit __at (0x9a) CPOL;        /* Serial Clock Polarity              */
  __sbit __at (0x9b) CPHA;        /* Serial Clock Phase Control         */
  __sbit __at (0x9c) MSTR;        /* Set Master Mode                    */
  __sbit __at (0x9d) ORDER;       /* Set Bit Order Transmit/Receive     */
  __sbit __at (0x9e) FIFO;        /* Enable Fifo Buffer                 */
  __sbit __at (0x9f) SCLK0;       /* Clock Divider Select 0             */
  __sbit __at (0xa0) SCLK1;       /* Clock Divider Select 1             */
  __sbit __at (0xa1) SCLK2;       /* Clock Divider Select 2             */
__sfr __at (0x9b) SPIDATA;      /* SPI Data                             */
__sfr __at (0x9b) I2CDATA;      /* I2C Data                             */
__sfr __at (0x9c) SPIRCON;      /* SPI Receive Control                  */
__sfr __at (0x9c) I2CGM;        /* I2C GM Register                      */
__sfr __at (0x9d) SPITCON;      /* SPI Transmit Control                 */
__sfr __at (0x9d) I2CSTAT;      /* I2C Status                           */
__sfr __at (0x9e) SPISTART;     /* SPI Buffer Start Address             */
__sfr __at (0x9e) I2CSTART;     /* I2C Start                            */
__sfr __at (0x9f) SPIEND;       /* SPI Buffer End Address               */
__sfr __at (0xa0) P2;           /* Port 2                               */
__sfr __at (0xa1) PWMCON;       /* PWM Control                          */
        /*  _7_ _6_ _5_  _4_    _3_    _2_     _1_     _0_              */
        /* |   |   |PPOL|PWMSEL|SPDSEL|TPCNTL2|TPCNTL1|TPCNTL0|         */
  __sbit __at (0xa1) TPCNTL0;     /* Generator Control                  */
  __sbit __at (0xa2) TPCNTL1;     /* Generator Control                  */
  __sbit __at (0xa3) TPCNTL2;     /* Generator Control                  */
  __sbit __at (0xa4) SPDSEL;      /* Speed Selection                    */
  __sbit __at (0xa5) PWMSEL;      /* PWM Register Select                */
  __sbit __at (0xa6) PPOL;        /* Period Polarity                    */
__sfr __at (0xa2) PWMLOW;       /* PWM low byte                         */
__sfr __at (0xa2) TONELOW;      /* Tone low byte                        */
__sfr __at (0xa3) PWMHI;        /* PWM high byte                        */
__sfr __at (0xa3) TONEHI;       /* Tone high byte                       */
__sfr __at (0xa4) AIPOL;        /* Auxiliary Interrupt Poll             */
__sfr __at (0xa5) PAI;          /* Pending Auxiliary Interrupt          */
__sfr __at (0xa6) AIE;          /* Auxiliary Interrupt Enable           */
__sfr __at (0xa7) AISTAT;       /* Auxiliary Interrupt Status           */
__sfr __at (0xa8) IE;           /* Interrupt Enable                     */
        /*  _7_ _6_ _5_ _4_ _3_ _2_ _1_ _0_                             */
        /* |EA |ES1|ET2|ES0|ET1|EX1|ET0|EX0|                            */
  __sbit __at (0xa8) EX0;         /* Enable External Interrupt 0        */
  __sbit __at (0xa9) ET0;         /* Enable Timer 0 Interrupt           */
  __sbit __at (0xaa) EX1;         /* Enable External Interrupt 1        */
  __sbit __at (0xab) ET1;         /* Enable Timer 1 Interrupt           */
  __sbit __at (0xac) ES0;         /* Enable Serial Port 0 Interrupt     */
  __sbit __at (0xad) ET2;         /* Enable Timer 2 Interrupt           */
  __sbit __at (0xae) ES1;         /* Enable Serial Port 1 Interrupt     */
  __sbit __at (0xaf) EA;          /* Global Interrupt Enable            */
__sfr __at (0xa9) BPCON;        /* Breakpoint Control                   */
__sfr __at (0xaa) BPL;          /* Breakpoint Address Low               */
__sfr __at (0xab) BPH;          /* Breakpoint Address High              */
__sfr __at (0xac) P0DDRL;       /* Port 0 Data Direction Low            */
__sfr __at (0xad) P0DDRH;       /* Port 0 Data Direction High           */
__sfr __at (0xae) P1DDRL;       /* Port 1 Data Direction Low            */
__sfr __at (0xaf) P1DDRH;       /* Port 1 Data Direction High           */
__sfr __at (0xb0) P3;           /* Port 3                               */
        /*  _7_ _6_ _5_ _4_ _3_  _2_  _1_ _0_                           */
        /* |RD |WR |T1 |T0 |INT1|INT0|TXD|RXD|                          */
  __sbit __at (0xb0) RXD;         /* Serial Port 0 Receive              */
  __sbit __at (0xb0) RXD0;        /* Serial Port 0 Receive              */
  __sbit __at (0xb1) TXD;         /* Serial Port 0 Transmit             */
  __sbit __at (0xb1) TXD0;        /* Serial Port 0 Transmit             */
  __sbit __at (0xb2) INT0;        /* External Interrupt 0               */
  __sbit __at (0xb3) INT1;        /* External Interrupt 1               */
  __sbit __at (0xb4) T0;          /* Timer 0 External Input             */
  __sbit __at (0xb5) T1;          /* Timer 1 External Input             */
  __sbit __at (0xb6) WR;          /* External Memory Write Strobe       */
  __sbit __at (0xb7) RD;          /* External Memory Read Strobe        */
__sfr __at (0xb1) P2DDRL;       /* Port 2 Data Direction Low            */
__sfr __at (0xb2) P2DDRH;       /* Port 2 Data Direction High           */
__sfr __at (0xb3) P3DDRL;       /* Port 3 Data Direction Low            */
__sfr __at (0xb4) P3DDRH;       /* Port 3 Data Direction High           */
__sfr __at (0xb5) DACL;         /* Digital-to-Analog Converter Low      */
__sfr __at (0xb6) DACH;         /* Digital-to-Analog Converter High     */
__sfr __at (0xb7) DACSEL;       /* Digital-to-Analog Converter Select   */
__sfr __at (0xb8) IP;           /* Interrupt Priority                   */
        /*  _7_ _6_ _5_ _4_ _3_ _2_ _1_ _0_                             */
        /* |   |   |PT2|PS |PT1|PX1|PT0|PX0|                            */
  __sbit __at (0xb8) PX0;         /* External Interrupt 0               */
  __sbit __at (0xb9) PT0;         /* Timer 0                            */
  __sbit __at (0xba) PX1;         /* External Interrupt 1               */
  __sbit __at (0xbb) PT1;         /* Timer 1                            */
  __sbit __at (0xbc) PS;          /* Serial Port                        */
  __sbit __at (0xbd) PT2;         /* Timer 2                            */
__sfr __at (0xc0) SCON1;        /* Serial Control 1                     */
        /*  _7_ _6_ _5_ _4_ _3_ _2_ _1_ _0_                             */
        /* |SM0|SM1|SM2|REN|TB8|RB8|TI |RI |                            */
  __sbit __at (0xc0) RI1;         /* Receive Interrupt Flag             */
  __sbit __at (0xc0) RI_1;        /* Receive Interrupt Flag             */
  __sbit __at (0xc1) TI1;         /* Transmit Interrupt Flag            */
  __sbit __at (0xc1) TI_1;        /* Transmit Interrupt Flag            */
  __sbit __at (0xc2) RB8_1;       /* Receive Bit 8                      */
  __sbit __at (0xc3) TB8_1;       /* Transmit Bit 8                     */
  __sbit __at (0xc4) REN_1;       /* Receive Enable                     */
  __sbit __at (0xc5) SM2_1;       /* Multiprocessor Communication Enable*/
  __sbit __at (0xc6) SM1_1;       /* Serial Port Select Mode 1          */
  __sbit __at (0xc7) SM0_1;       /* Serial Port Select Mode 0          */
__sfr __at (0xc1) SBUF1;        /* Serial Buffer 1                      */
__sfr __at (0xc6) EWU;          /* Enable Wake Up                       */
        /*  _7_ _6_ _5_ _4_ _3_ _2_    _1_    _0_                       */
        /* |   |   |   |   |   |EWUEX1|EWUEX0|EWUWDT|                   */
  __sbit __at (0xc6) EWUWDT;      /* Enable Watchdog Interrupt          */
  __sbit __at (0xc7) EWUEX0;      /* Enable External Interrupt 0        */
  __sbit __at (0xc8) EWUEX1;      /* Enable External Interrupt 1        */
__sfr __at (0xc7) SYSCLK;       /* System Clock Divider                 */
__sfr __at (0xc8) T2CON;        /* Timer 2 Control                      */
        /*  _7_ _6_  _5_  _4_  _3_   _2_ _1_  _0_                       */
        /* |TF2|EXF2|RCLK|TCLK|EXEN2|TR2|C_T2|CP_RL2 |                  */
  __sbit __at (0xc8) CP_RL2;      /* Capture/Reload Flag                */
  __sbit __at (0xc9) C_T2;        /* Overflow Flag                      */
  __sbit __at (0xca) TR2;         /* Timer Run                          */
  __sbit __at (0xcb) EXEN2;       /* Timer External Enable              */
  __sbit __at (0xcc) TCLK;        /* Transmit Clock Flag                */
  __sbit __at (0xcd) RCLK;        /* Receive Clock Flag                 */
  __sbit __at (0xce) EXF2;        /* External Flag                      */
  __sbit __at (0xcf) TF2;         /* Overflow Flag                      */
__sfr __at (0xca) RCAP2L;       /* Timer 2 Capture Low                  */
__sfr __at (0xcb) RCAP2H;       /* Timer 2 Capture High                 */
__sfr __at (0xcc) TL2;          /* Timer 2 Low byte                     */
__sfr __at (0xcd) TH2;          /* Timer 2 High byte                    */
__sfr __at (0xd0) PSW;          /* Program Status Word                  */
        /*  _7_ _6_ _5_ _4_ _3_ _2_ _1_ _0_                             */
        /* |CY |AC |F0 |RS1|RS0|OV |F1 |P  |                            */
  __sbit __at (0xd0) P;           /* Parity Flag                        */
  __sbit __at (0xd1) F1;          /* General Purpose User Flag 1        */
  __sbit __at (0xd2) OV;          /* Overflow Flag                      */
  __sbit __at (0xd3) RS0;         /* Register Bank Select 0 Flag        */
  __sbit __at (0xd4) RS1;         /* Register Bank Select 1 Flag        */
  __sbit __at (0xd5) F0;          /* General Purpose User Flag 0        */
  __sbit __at (0xd6) AC;          /* Auxiliary Carry Flag               */
  __sbit __at (0xd7) CY;          /* Carry Flag                         */
__sfr __at (0xd1) OCL;          /* (ADC) Offset Calibration Low byte    */
__sfr __at (0xd2) OCM;          /* (ADC) Offset Calibration Middle byte */
__sfr __at (0xd3) OCH;          /* (ADC) Offset Calibration High byte   */
__sfr __at (0xd4) GCL;          /* (ADC) Gain Low byte                  */
__sfr __at (0xd5) GCM;          /* (ADC) Gain Middle byte               */
__sfr __at (0xd6) GCH;          /* (ADC) Gain High byte                 */
__sfr __at (0xd7) ADMUX;        /* ADC Multiplexer Register             */
__sfr __at (0xd8) EICON;        /* Enable Interrupt Control             */
        /*  _7_   _6_ _5_ _4_ _3_  _2_ _1_ _0_                          */
        /* |SMOD1|   |EAI|AI |WDTI|   |   |   |                         */
  __sbit __at (0xdb) WDTI;        /* Watchdog Timer Interrupt Flag      */
  __sbit __at (0xdc) AI;          /* Auxiliary Interrupt Flag           */
  __sbit __at (0xdd) EAI;         /* Enable Auxiliary Interrupt         */
  __sbit __at (0xdf) SMOD1;       /* Serial Port 1 Mode                 */
__sfr __at (0xd9) ADRESL;       /* ADC Conversion Result Low byte       */
__sfr __at (0xda) ADRESM;       /* ADC Conversion Result Middle byte    */
__sfr __at (0xdb) ADRESH;       /* ADC Conversion Result High byte      */
__sfr __at (0xdc) ADCON0;       /* ADC Control 0                        */
__sfr __at (0xdd) ADCON1;       /* ADC Control 1                        */
__sfr __at (0xde) ADCON2;       /* ADC Control 2                        */
__sfr __at (0xdf) ADCON3;       /* ADC Control 3                        */
__sfr __at (0xe0) ACC;          /* Accumulator                          */
__sfr __at (0xe1) SSCON;        /* Summation and Shift Control          */
__sfr __at (0xe2) SUMR0;        /* Summation Register 0 (LSB)           */
__sfr __at (0xe3) SUMR1;        /* Summation Register 1                 */
__sfr __at (0xe4) SUMR2;        /* Summation Register 2                 */
__sfr __at (0xe5) SUMR3;        /* Summation Register 3 (MSB)           */
__sfr __at (0xe6) ODAC;         /* (ADC) Offset DAC Register            */
__sfr __at (0xe7) LVDCON;       /* Low Voltage Detection Control        */
__sfr __at (0xe8) EIE;          /* Extended Interrupt Enable            */
        /*  _7_ _6_ _5_ _4_  _3_ _2_ _1_ _0_                            */
        /* |   |   |   |EWDI|EX5|EX4|EX3|EX2|                           */
  __sbit __at (0xe8) EX2;         /* Enable External Interrupt 2        */
  __sbit __at (0xe9) EX3;         /* Enable External Interrupt 3        */
  __sbit __at (0xea) EX4;         /* Enable External Interrupt 4        */
  __sbit __at (0xeb) EX5;         /* Enable External Interrupt 5        */
  __sbit __at (0xec) EWDI;        /* Enable Watchdog Interrupt          */
__sfr __at (0xe9) HWPC0;        /* Hardware Product Code 0              */
__sfr __at (0xea) HWPC1;        /* Hardware Product Code 1              */
__sfr __at (0xeb) HWVER;        /* Hardware Version number              */
__sfr __at (0xee) FMCON;        /* Flash Memory Control                 */
__sfr __at (0xef) FTCON;        /* Flash Memory Timing Control          */
__sfr __at (0xf0) B;            /* B Register                           */
__sfr __at (0xf1) PDCON;        /* Power Down Control                   */
        /*  _7_ _6_ _5_ _4_   _3_  _2_   _1_  _0_                       */
        /* |   |   |   |PDPWM|PDAD|PDWDT|PDST|PDSPI|                    */
  __sbit __at (0xf1) PDSPI;       /* SPI System Control                 */
  __sbit __at (0xf2) PDST;        /* System Timer Control               */
  __sbit __at (0xf3) PDWDT;       /* Watchdog Timer Control             */
  __sbit __at (0xf4) PDAD;        /* A/D Control                        */
  __sbit __at (0xf5) PDPWM;       /* PWM Control                        */
__sfr __at (0xf2) PASEL;        /* /PSEN|ALE Select                     */
__sfr __at (0xf6) ACLK;         /* Analog Clock                         */
__sfr __at (0xf7) SRST;         /* System Reset Register                */
__sfr __at (0xf8) EIP;          /* Extended Interrupt Priority          */
        /*  _7_ _6_ _5_ _4_  _3_ _2_ _1_ _0_                            */
        /* |   |   |   |PWDI|PX5|PX4|PX3|PX2|                           */
  __sbit __at (0xf8) PX2;         /* External Interrupt 2 Priority      */
  __sbit __at (0xf9) PX3;         /* External Interrupt 3 Priority      */
  __sbit __at (0xfa) PX4;         /* External Interrupt 4 Priority      */
  __sbit __at (0xfb) PX5;         /* External Interrupt 5 Priority      */
  __sbit __at (0xfc) PWDI;        /* Watchdog Interrupt Priority        */
__sfr __at (0xf9) SECINT;       /* Seconds Timer Interrupt              */
__sfr __at (0xfa) MSINT;        /* Milliseconds Interrupt               */
__sfr __at (0xfb) USEC;         /* Microsecond Register                 */
__sfr __at (0xfc) MSECL;        /* Millisecond Low byte                 */
__sfr __at (0xfd) MSECH;        /* Millisecond High byte                */
__sfr __at (0xfe) HMSEC;        /* Hundred Millisecond Clock            */
__sfr __at (0xff) WDTCON;       /* Watchdog Control                     */

/* Word Registers */
__sfr16  __at (0x8c8a) TMR0;
__sfr16  __at (0x8d8b) TMR1;
__sfr16  __at (0xa3a2) PWM;
__sfr16  __at (0xa3a2) TONE;
__sfr16  __at (0xabaa) BP;
__sfr16  __at (0xabaa) BREAKPT;
__sfr16  __at (0xadac) P0DDR;
__sfr16  __at (0xafae) P1DDR;
__sfr16  __at (0xb2b1) P2DDR;
__sfr16  __at (0xb4b3) P3DDR;
__sfr16  __at (0xcbca) RCAP2;
__sfr16  __at (0xcdcc) TMR2;
__sfr16  __at (0xdfde) DECIMATION;
__sfr16  __at (0xfdfc) ONEMS;
__sfr16  __at (0xfdfc) MSEC;

/* Double Word Registers */
__sfr32  __at (0xe5e4e3e2) SUMR;

#endif
/*-------------------------------------------------------------------------
   at89S8252.h - register declarations for ATMEL 89S8252 and 89LS8252 processors

   Copyright (C) 2005, Dipl.-Ing. (FH) Michael Schmitt <michael.schmitt AT t-online.de>

   Bug-Fix Jun 29 1999

   Additional definitions Nov 23 1999
     by Bernd Krueger-Knauber <bkk AT infratec-plus.de>

   based on reg51.h by Sandeep Dutta <sandeep.dutta AT usa.net>
   KEIL C compatible definitions are included

   Bug-Fix Feb 16 2006
     by Krzysztof Polomka <del_p AT op.pl>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef AT89S8252_H
#define AT89S8252_H

/* BYTE addressable registers */
__sfr __at (0x80) P0          ;
__sfr __at (0x81) SP          ;
__sfr __at (0x82) DPL         ;
__sfr __at (0x82) DP0L        ; /* as called by Atmel */
__sfr __at (0x83) DPH         ;
__sfr __at (0x83) DP0H        ; /* as called by Atmel */
__sfr __at (0x84) DP1L        ; /* at89S8252 specific register */
__sfr __at (0x85) DP1H        ; /* at89S8252 specific register */
__sfr __at (0x86) SPDR        ; /* at89S8252 specific register */
__sfr __at (0x87) PCON        ;
__sfr __at (0x88) TCON        ;
__sfr __at (0x89) TMOD        ;
__sfr __at (0x8A) TL0         ;
__sfr __at (0x8B) TL1         ;
__sfr __at (0x8C) TH0         ;
__sfr __at (0x8D) TH1         ;
__sfr __at (0x90) P1          ;
__sfr __at (0x96) WMCON       ; /* at89S8252 specific register */
__sfr __at (0x98) SCON        ;
__sfr __at (0x99) SBUF        ;
__sfr __at (0xA0) P2          ;
__sfr __at (0xA8) IE          ;
__sfr __at (0xAA) SPSR        ; /* at89S8252 specific register */
__sfr __at (0xB0) P3          ;
__sfr __at (0xB8) IP          ;
__sfr __at (0xC8) T2CON       ;
__sfr __at (0xC9) T2MOD       ;
__sfr __at (0xCA) RCAP2L      ;
__sfr __at (0xCB) RCAP2H      ;
__sfr __at (0xCC) TL2         ;
__sfr __at (0xCD) TH2         ;
__sfr __at (0xD0) PSW         ;
__sfr __at (0xD5) SPCR        ; /* at89S8252 specific register */
__sfr __at (0xE0) ACC         ;
__sfr __at (0xE0) A           ;
__sfr __at (0xF0) B           ;


/* BIT addressable registers */
/* P0 */
__sbit __at (0x80) P0_0       ;
__sbit __at (0x81) P0_1       ;
__sbit __at (0x82) P0_2       ;
__sbit __at (0x83) P0_3       ;
__sbit __at (0x84) P0_4       ;
__sbit __at (0x85) P0_5       ;
__sbit __at (0x86) P0_6       ;
__sbit __at (0x87) P0_7       ;

/* TCON */
__sbit __at (0x88) IT0        ;
__sbit __at (0x89) IE0        ;
__sbit __at (0x8A) IT1        ;
__sbit __at (0x8B) IE1        ;
__sbit __at (0x8C) TR0        ;
__sbit __at (0x8D) TF0        ;
__sbit __at (0x8E) TR1        ;
__sbit __at (0x8F) TF1        ;

/* P1 */
__sbit __at (0x90) P1_0       ;
__sbit __at (0x91) P1_1       ;
__sbit __at (0x92) P1_2       ;
__sbit __at (0x93) P1_3       ;
__sbit __at (0x94) P1_4       ;
__sbit __at (0x95) P1_5       ;
__sbit __at (0x96) P1_6       ;
__sbit __at (0x97) P1_7       ;

__sbit __at (0x90) T2         ;
__sbit __at (0x91) T2EX       ;

/* P1 SPI portpins */
__sbit __at (0x94) SS         ; /* SPI: SS - Slave port select input */
__sbit __at (0x95) MOSI       ; /* SPI: MOSI - Master data output, slave data input */
__sbit __at (0x96) MISO       ; /* SPI: MISO - Master data input, slave data output */
__sbit __at (0x97) SCK        ; /* SPI: SCK - Master clock output, slave clock input */


/* SCON */
__sbit __at (0x98) RI         ;
__sbit __at (0x99) TI         ;
__sbit __at (0x9A) RB8        ;
__sbit __at (0x9B) TB8        ;
__sbit __at (0x9C) REN        ;
__sbit __at (0x9D) SM2        ;
__sbit __at (0x9E) SM1        ;
__sbit __at (0x9F) SM0        ;

/* P2 */
__sbit __at (0xA0) P2_0       ;
__sbit __at (0xA1) P2_1       ;
__sbit __at (0xA2) P2_2       ;
__sbit __at (0xA3) P2_3       ;
__sbit __at (0xA4) P2_4       ;
__sbit __at (0xA5) P2_5       ;
__sbit __at (0xA6) P2_6       ;
__sbit __at (0xA7) P2_7       ;

/* IE */
__sbit __at (0xA8) EX0        ;
__sbit __at (0xA9) ET0        ;
__sbit __at (0xAA) EX1        ;
__sbit __at (0xAB) ET1        ;
__sbit __at (0xAC) ES         ;
__sbit __at (0xAD) ET2        ;
__sbit __at (0xAF) EA         ;

/* P3 */
__sbit __at (0xB0) P3_0       ;
__sbit __at (0xB1) P3_1       ;
__sbit __at (0xB2) P3_2       ;
__sbit __at (0xB3) P3_3       ;
__sbit __at (0xB4) P3_4       ;
__sbit __at (0xB5) P3_5       ;
__sbit __at (0xB6) P3_6       ;
__sbit __at (0xB7) P3_7       ;

__sbit __at (0xB0) RXD        ;
__sbit __at (0xB1) TXD        ;
__sbit __at (0xB2) INT0       ;
__sbit __at (0xB3) INT1       ;
__sbit __at (0xB4) T0         ;
__sbit __at (0xB5) T1         ;
__sbit __at (0xB6) WR         ;
__sbit __at (0xB7) RD         ;

/* IP */
__sbit __at (0xB8) PX0        ;
__sbit __at (0xB9) PT0        ;
__sbit __at (0xBA) PX1        ;
__sbit __at (0xBB) PT1        ;
__sbit __at (0xBC) PS         ;
__sbit __at (0xBD) PT2        ;

/* T2CON */
__sbit __at (0xC8) T2CON_0    ;
__sbit __at (0xC9) T2CON_1    ;
__sbit __at (0xCA) T2CON_2    ;
__sbit __at (0xCB) T2CON_3    ;
__sbit __at (0xCC) T2CON_4    ;
__sbit __at (0xCD) T2CON_5    ;
__sbit __at (0xCE) T2CON_6    ;
__sbit __at (0xCF) T2CON_7    ;

__sbit __at (0xC8) CP_RL2     ;
__sbit __at (0xC9) C_T2       ;
__sbit __at (0xCA) TR2        ;
__sbit __at (0xCB) EXEN2      ;
__sbit __at (0xCC) TCLK       ;
__sbit __at (0xCD) RCLK       ;
__sbit __at (0xCE) EXF2       ;
__sbit __at (0xCF) TF2        ;

/* PSW */
__sbit __at (0xD0) P          ;
__sbit __at (0xD1) FL         ;
__sbit __at (0xD2) OV         ;
__sbit __at (0xD3) RS0        ;
__sbit __at (0xD4) RS1        ;
__sbit __at (0xD5) F0         ;
__sbit __at (0xD6) AC         ;
__sbit __at (0xD7) CY         ;

/* B */
__sbit __at (0xF0) BREG_F0    ;
__sbit __at (0xF1) BREG_F1    ;
__sbit __at (0xF2) BREG_F2    ;
__sbit __at (0xF3) BREG_F3    ;
__sbit __at (0xF4) BREG_F4    ;
__sbit __at (0xF5) BREG_F5    ;
__sbit __at (0xF6) BREG_F6    ;
__sbit __at (0xF7) BREG_F7    ;


/* BIT definitions for bits that are not directly accessible */
/* PCON bits */
#define IDL             0x01
#define PD              0x02
#define GF0             0x04
#define GF1             0x08
#define SMOD            0x80

#define IDL_            0x01
#define PD_             0x02
#define GF0_            0x04
#define GF1_            0x08
#define SMOD_           0x80

/* TMOD bits */
#define M0_0            0x01
#define M1_0            0x02
#define C_T0            0x04
#define GATE0           0x08
#define M0_1            0x10
#define M1_1            0x20
#define C_T1            0x40
#define GATE1           0x80

#define M0_0_           0x01
#define M1_0_           0x02
#define C_T0_           0x04
#define GATE0_          0x08
#define M0_1_           0x10
#define M1_1_           0x20
#define C_T1_           0x40
#define GATE1_          0x80

#define T0_M0           0x01
#define T0_M1           0x02
#define T0_CT           0x04
#define T0_GATE         0x08
#define T1_M0           0x10
#define T1_M1           0x20
#define T1_CT           0x40
#define T1_GATE         0x80

#define T0_M0_          0x01
#define T0_M1_          0x02
#define T0_CT_          0x04
#define T0_GATE_        0x08
#define T1_M0_          0x10
#define T1_M1_          0x20
#define T1_CT_          0x40
#define T1_GATE_        0x80

#define T0_MASK         0x0F
#define T1_MASK         0xF0

#define T0_MASK_        0x0F
#define T1_MASK_        0xF0

/* T2MOD bits */
#define DCEN            0x01
#define T2OE            0x02

#define DCEN_           0x01
#define T2OE_           0x02

/* WMCON bits */
#define WMCON_WDTEN     0x01
#define WMCON_WDTRST    0x02
#define WMCON_DPS       0x04
#define WMCON_EEMEN     0x08
#define WMCON_EEMWE     0x10
#define WMCON_PS0       0x20
#define WMCON_PS1       0x40
#define WMCON_PS2       0x80

/* SPCR-SPI bits */
#define SPCR_SPR0       0x01
#define SPCR_SPR1       0x02
#define SPCR_CPHA       0x04
#define SPCR_CPOL       0x08
#define SPCR_MSTR       0x10
#define SPCR_DORD       0x20
#define SPCR_SPE        0x40
#define SPCR_SPIE       0x80

/* SPSR-SPI bits */
#define SPSR_WCOL       0x40
#define SPSR_SPIF       0x80

/* SPDR-SPI bits */
#define SPDR_SPD0       0x01
#define SPDR_SPD1       0x02
#define SPDR_SPD2       0x04
#define SPDR_SPD3       0x08
#define SPDR_SPD4       0x10
#define SPDR_SPD5       0x20
#define SPDR_SPD6       0x40
#define SPDR_SPD7       0x80

/* Interrupt numbers: address = (number * 8) + 3 */
#define IE0_VECTOR      0       /* 0x03 external interrupt 0 */
#define EX0_VECTOR      0       /* 0x03 external interrupt 0 */
#define TF0_VECTOR      1       /* 0x0b timer 0 */
#define IE1_VECTOR      2       /* 0x13 external interrupt 1 */
#define EX1_VECTOR      2       /* 0x13 external interrupt 1 */
#define TF1_VECTOR      3       /* 0x1b timer 1 */
#define SI0_VECTOR      4       /* 0x23 serial port 0 */
#define TF2_VECTOR      5       /* 0x2B timer 2 */
#define EX2_VECTOR      5       /* 0x2B external interrupt 2 */


/* This is one of the addons coming from Bernd Krueger-Knauber   */

/* ALE (0x8E) Bit Values */
__sfr __at 0x8E ALE;     	/* at89S8252 specific register */

/* Macro to enable and disable the toggling of the ALE-pin (EMV) */

/* Explanation : Original Intel 8051 Cores (Atmel has to use the */
/* Intel Core) have a feature that ALE is only active during     */
/* MOVX or MOVC instruction. Otherwise the ALE-Pin is weakly     */
/* pulled high. This can be used to force some external devices  */
/* into standby mode and reduced EMI noise                       */

#define ALE_OFF  ALE = ALE | 0x01
#define ALE_ON   ALE = ALE & 0xFE

#endif
/*-------------------------------------------------------------------------
   stc12.h - Register Declarations for STC10/11/12 Series
   Based on 8051.h and compiler.h

   Copyright (c) 2012, intron@intron.ac

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*
   Brief:

       STC10/11/12 series are 8051-compatible MCU's. The "official" website
   is http://www.stcmcu.com/ (In Chinese Han only), and datasheets in Chinese
   Han and English can be downloaded there.

   Reference:

   1. The "official" C header file (written for another C51 compiler):
        http://www.stcmcu.com/datasheet/stc/STC-AD-PDF/STC_NEW_8051.H
   2. Datasheets for STC12(C/LE)5Axx(S2/AD) series:
      Chinese Han:
        http://www.stcmcu.com/datasheet/stc/STC-AD-PDF/STC12C5A60S2.pdf
      English:
        http://www.stcmcu.com/datasheet/stc/STC-AD-PDF/STC12C5A60S2-english.pdf
   3. Datasheets for STC12(C/LE)52xxAD series:
      Chinese Han:
        http://www.stcmcu.com/datasheet/stc/STC-AD-PDF/STC12C5201AD.pdf
      English:
        http://www.stcmcu.com/datasheet/stc/STC-AD-PDF/STC12C5201AD-english.pdf
   4. Datasheets for STC11/10 series:
      Chinese Han:
        http://www.stcmcu.com/datasheet/stc/STC-AD-PDF/STC11F-10Fxx.pdf
      English:
        http://www.stcmcu.com/datasheet/stc/STC-AD-PDF/STC11F-10Fxx-english.pdf
 */

#ifndef _STC12_H_
#define _STC12_H_

#include <8051.h>
#include <compiler.h>

#ifdef REG8051_H
#undef REG8051_H
#endif

/*
 * Auxiliary Register
 *   Bit Mapping: T0x12 T1x12 UART_M0x6 BRTR S2SMOD BRTx12 EXTRAM S1BRS
 *   Reset Value: 0000,0000
 */
SFR(AUXR, 0x8E);

/*
 * Auxiliary Register 1
 *   Bit Mapping: - PCA_P4 SPI_P4 S2_P4 GF2 ADRJ - DPS
 *   Reset Value: x000,00x0
 */
SFR(AUXR1, 0xA2);

/*
 * Control Register for Clock Output and Power Down Wake-up
 *   Bit Mapping: PCAWAKEUP RXD_PIN_IE T1_PIN_IE T0_PIN_IE
 *                LVD_WAKE BRTCLKO T1CLKO T0CLKO
 *                (Here "O" is the letter meaning "output", not the digit.)
 *   Reset Value: 0000,0000
 */
SFR(WAKE_CLKO, 0x8F);

/*
 * Clock Devider Register
 *   Bit Mapping: - - - - - CLKS2 CLKS1 CLKS0 
 *   Reset Value: xxxx,x000
 */
SFR(CLK_DIV, 0x97);

/*
 * Stretch register
 *   Bit Mapping: - - ALES1 ALES0 - RWS2 RWS1 RWS0
 *   Reset Value: xx10,x011
 */
SFR(BUS_SPEED, 0xA1);

/* Two extended bits in IE */
SBIT(ELVD, 0xA8, 6); /* Enable Low Voltage Detection Interrupt */
SBIT(EADC, 0xA8, 5); /* Enable ADC Interrupt */

/*
 * Auxiliary Interrupt Register
 *   Bit Mapping: - - - - - - ESPI ES2
 *   Reset Value: xxxx,xx00
 */
SFR(IE2, 0xAF);

/* Three extended bits in IP */
SBIT(PPCA, 0xB8, 7); /* Interrupt Priority for PCA */
SBIT(PLVD, 0xB8, 6); /* Interrupt Priority for Low Voltage Detection */
SBIT(PADC, 0xB8, 5); /* Interrupt Priority for ADC */

/*
 * Higher bits for Interrupt Priority
 *   Bit Mapping: PPCAH PLVDH PADCH PSH PT1H PX1H PT0H PX0H
 *   Reset Value: 0000,0000
 */
SFR(IPH, 0xB7);

/*
 * The 2nd Interrupt Priority Register, Lower bits
 *   Bit Mapping: - - - - - - PSPI PS2
 *   Reset Value: xxxx,xx00
 */
SFR(IP2, 0xB5);

/*
 * The 2nd Interrupt Priority Register, Higher bits
 *   Bit Mapping: - - - - - - PSPIH PS2H
 *   Reset Value: xxxx,xx00
 */
SFR(IP2H, 0xB6);

/*
 * Two Extended GPIO Ports: P4 and P5
 * - For DIP-40 and QFN-40 packages, only higher 4 bits of P4 are available.
 * - For PLCC-44 and LQFP-44 packages, only all 8 bits of P4 are available.
 * - For LQFP-48 package, all 8 bits of P4 and lower 4 bits of P5 are
 *   available.
 */
SFR(P4, 0xC0);
    SBIT(P4_0, 0xC0, 0);
    SBIT(P4_1, 0xC0, 1);
    SBIT(P4_2, 0xC0, 2);
    SBIT(P4_3, 0xC0, 3);
    SBIT(P4_4, 0xC0, 4);
    SBIT(P4_5, 0xC0, 5);
    SBIT(P4_6, 0xC0, 6);
    SBIT(P4_7, 0xC0, 7);
SFR(P5, 0xC8); /* Only lower 4 bits */
    SBIT(P5_0, 0xC8, 0);
    SBIT(P5_1, 0xC8, 1);
    SBIT(P5_2, 0xC8, 2);
    SBIT(P5_3, 0xC8, 3);

/* Working Mode Registers for P0, P1, P2, P3, P4 and P5 */
SFR(P0M0, 0x94);
SFR(P0M1, 0x93);
SFR(P1M0, 0x92);
SFR(P1M1, 0x91);
SFR(P2M0, 0x96);
SFR(P2M1, 0x95);
SFR(P3M0, 0xB2);
SFR(P3M1, 0xB1);
SFR(P4M0, 0xB4);
SFR(P4M1, 0xB3);
SFR(P4SW, 0xBB); /* - LVD_P4.6 ALE_P4.5 NA_P4.4 - - - -   Reset: x000,xxxx */
SFR(P5M0, 0xCA);
SFR(P5M1, 0xC9);

/* Slave Address Mask for Serial Communication */
SFR(SADEN, 0xB9);

/* Slave Address for Serial Communication */
SFR(SADDR, 0xA9);

/*
 * The Control Register for the 2nd Serial Communication Port
 *   Bit Mapping: S2SM0 S2SM1 S2SM2 S2REN S2TB8 S2RB8 S2TI S2RI
 *   Reset Value: 0000,0000
 */
SFR(S2CON, 0x9A);

/* Data Buffer Register for the 2nd Serial Communication Port */
SFR(S2BUF, 0x9B);

/*
 * Reload Value Register for the Specific Baud Rate Generator
 * (Independent from the 8051 Timer)
 */
SFR(BRT, 0x9C);

/*
 * Watchdog Timer Control Register
 *   Bit Mapping: WDT_FLAG - EN_WDT CLR_WDT IDLE_WDT PS2 PS1 PS0
 *   Reset Value: 0x00,0000
 */
SFR(WDT_CONTR, 0xC1);

/*
 * PCA Control Register
 *   Bit Mapping: CF CR - - - - CCF1 CCF0
 *   Reset Value: 00xx,xx00
 */
SFR(CCON, 0xD8);
    SBIT(CF, 0xD8, 7);
    SBIT(CR, 0xD8, 6);
    SBIT(CCF1, 0xD8, 1);
    SBIT(CCF0, 0xD8, 0);

/*
 * PCA Mode Register
 *   Bit Mapping: CIDL - - - CPS2 CPS1 CPS0 ECF
 *   Reset Value: 0xxx,x000
 */
SFR(CMOD, 0xD9);

/* PCA Counter Registers */
SFR(CL, 0xE9); /* Lower 8 bits */
SFR(CH, 0xF9); /* Higher 8 bits */

/*
 * PCA Module 0 PWM Register
 *   Bit Mapping: - ECOM0 CAPP0 CAPN0 MAT0 TOG0 PWM0 ECCF0
 *   Reset Value: x000,0000
 */
SFR(CCAPM0, 0xDA);

/*
 * PCA Module 1 PWM Register
 *   Bit Mapping: - ECOM1 CAPP1 CAPN1 MAT1 TOG1 PWM1 ECCF1
 *   Reset Value: x000,0000
 */
SFR(CCAPM1, 0xDB);

/* PCA Module 0/1 Capture/Comparison Registers */
SFR(CCAP0L, 0xEA);
SFR(CCAP0H, 0xFA);
SFR(CCAP1L, 0xEB);
SFR(CCAP1H, 0xFB);

/*
 * PCA Module 0 PWM Auxiliary Register
 *   Bit Mapping: - - - - - - EPC0H EPC0L
 *   Reset Value: xxxx,xx00
 */
SFR(PCA_PWM0, 0xF2);

/*
 * PCA Module 1 PWM Auxiliary Register
 *   Bit Mapping: - - - - - - EPC1H EPC1L
 *   Reset Value: xxxx,xx00
 */
SFR(PCA_PWM1, 0xF3);

/* Switch P1 pins between ADC inputs and GPIO Port pins */
SFR(P1ASF, 0x9D);

/*
 * ADC Control Register
 *   Bit Mapping: ADC_POWER SPEED1 SPEED0 ADC_FLAG ADC_START CHS2 CHS1 CHS0
 *   Reset Value: 0000,0000
 */
SFR(ADC_CONTR, 0xBC);

/* ADC Converting Result Registers */
SFR(ADC_RES, 0xBD); /* Higher Bits */
SFR(ADC_RESL, 0xBE); /* Lower Bits */

/*
 * SPI Control Register
 *   Bit Mapping: SSIG SPEN DORD MSTR CPOL CPHA SPR1 SPR0
 *   Reset Value: 0000,0100
 */
SFR(SPCTL, 0xCE);

/*
 * SPI Status Register
 *   Bit Mapping: SPIF WCOL - - - - - -
 *   Reset Value: 00xx,xxxx
 */
SFR(SPSTAT, 0xCD);

/* SPI Data Register */
SFR(SPDAT, 0xCF);

/* In-Application-Programming Data Register */
SFR(IAP_DATA, 0xC2);

/* In-Application-Programming Address Registers */
SFR(IAP_ADDRH, 0xC3); /* Higher 8 bits */
SFR(IAP_ADDRL, 0xC4); /* Lower 8 bits */

/*
 * In-Application-Programming Address Registers
 *   Bit Mapping: - - - - - - MS1 MS0
 *   Reset Value: xxxx,xx00
 */
SFR(IAP_CMD, 0xC5);

/* In-Application-Programming Trigger Registers */
SFR(IAP_TRIG, 0xC6);

/*
 * In-Application-Programming Control Register
 *   Bit Mapping: IAPEN SWBS SWRST CFAIL - WT2 WT1 WT0
 *   Reset Value: 0000,x000
 */
SFR(IAP_CONTR, 0xC7);

#endif /* _STC12_H_ */

/*-------------------------------------------------------------------------
   C8051F350.h - Register Declarations for the SiLabs C8051F35x
   Processor Range

   Copyright (C) 2004, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef C8051F350_H
#define C8051F350_H


/*  BYTE Registers  */

__sfr __at (0x80) P0           ;  /* PORT 0                                        */
__sfr __at (0x81) SP           ;  /* STACK POINTER                                 */
__sfr __at (0x82) DPL          ;  /* DATA POINTER - LOW BYTE                       */
__sfr __at (0x83) DPH          ;  /* DATA POINTER - HIGH BYTE                      */
__sfr __at (0x87) PCON         ;  /* POWER CONTROL                                 */
__sfr __at (0x88) TCON         ;  /* TIMER CONTROL                                 */
__sfr __at (0x89) TMOD         ;  /* TIMER MODE                                    */
__sfr __at (0x8A) TL0          ;  /* TIMER 0 - LOW BYTE                            */
__sfr __at (0x8B) TL1          ;  /* TIMER 1 - LOW BYTE                            */
__sfr __at (0x8C) TH0          ;  /* TIMER 0 - HIGH BYTE                           */
__sfr __at (0x8D) TH1          ;  /* TIMER 1 - HIGH BYTE                           */
__sfr __at (0x8E) CKCON        ;  /* CLOCK CONTROL                                 */
__sfr __at (0x8F) PSCTL        ;  /* PROGRAM STORE R/W CONTROL                     */
__sfr __at (0x90) P1           ;  /* PORT 1                                        */
__sfr __at (0x91) TMR3CN       ;  /* TIMER 3 CONTROL                               */
__sfr __at (0x92) TMR3RLL      ;  /* TIMER 3 CAPTURE REGISTER - LOW BYTE           */
__sfr __at (0x93) TMR3RLH      ;  /* TIMER 3 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at (0x94) TMR3L        ;  /* TIMER 3 - LOW BYTE                            */
__sfr __at (0x95) TMR3H        ;  /* TIMER 3 - HIGH BYTE                           */
__sfr __at (0x96) IDA0         ;  /* CURRENT MODE DAC 0                            */
__sfr __at (0x98) SCON         ;  /* SERIAL PORT CONTROL                           */
__sfr __at (0x98) SCON0        ;  /* SERIAL PORT CONTROL                           */
__sfr __at (0x99) SBUF         ;  /* SERIAL PORT BUFFER                            */
__sfr __at (0x99) SBUF0        ;  /* SERIAL PORT BUFFER                            */
__sfr __at (0x9A) ADC0DECL     ;  /* ADC DECIMATION LOW                            */
__sfr __at (0x9B) ADC0DECH     ;  /* ADC DECIMATION HIGH                           */
__sfr __at (0x9C) CPT0CN       ;  /* COMPARATOR 0 CONTROL                          */
__sfr __at (0x9D) CPT0MD       ;  /* COMPARATOR 0 MODE SELECTION                   */
__sfr __at (0x9F) CPT0MX       ;  /* COMPARATOR 0 MUX SELECTION                    */
__sfr __at (0xA0) P2           ;  /* PORT 2                                        */
__sfr __at (0xA1) SPI0CFG      ;  /* SPI0 CONFIGURATION                            */
__sfr __at (0xA2) SPI0CKR      ;  /* SPI0 CLOCK RATE CONTROL                       */
__sfr __at (0xA3) SPI0DAT      ;  /* SPI0 DATA                                     */
__sfr __at (0xA4) P0MDOUT      ;  /* PORT 0 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA5) P1MDOUT      ;  /* PORT 1 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA6) P2MDOUT      ;  /* PORT 2 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA8) IE           ;  /* INTERRUPT ENABLE                              */
__sfr __at (0xA9) CLKSEL       ;  /* SYSTEM CLOCK SELECT                           */
__sfr __at (0xAA) EMI0CN       ;  /* EXTERNAL MEMORY INTERFACE CONTROL             */
__sfr __at (0xAA) _XPAGE       ;  /* XDATA/PDATA PAGE                              */
__sfr __at (0xAB) ADC0CGL      ;  /* ADC 0 GAIN CALIBRATION LOW                    */
__sfr __at (0xAC) ADC0CGM      ;  /* ADC 0 GAIN CALIBRATION MIDDLE                 */
__sfr __at (0xAD) ADC0CGH      ;  /* ADC 0 GAIN CALIBRATION HIGH                   */
__sfr __at (0xB1) OSCXCN       ;  /* EXTERNAL OSCILLATOR CONTROL                   */
__sfr __at (0xB2) OSCICN       ;  /* INTERNAL OSCILLATOR CONTROL                   */
__sfr __at (0xB3) OSCICL       ;  /* INTERNAL OSCILLATOR CALIBRATION               */
__sfr __at (0xB6) FLSCL        ;  /* FLASH MEMORY TIMING PRESCALER                 */
__sfr __at (0xB7) FLKEY        ;  /* FLASH ACESS LIMIT                             */
__sfr __at (0xB8) IP           ;  /* INTERRUPT PRIORITY                            */
__sfr __at (0xB9) IDA0CN       ;  /* CURRENT MODE DAC 0 - CONTROL                  */
__sfr __at (0xBA) ADC0COL      ;  /* ADC 0 OFFSET CALIBRATION LOW                  */
__sfr __at (0xBB) ADC0COM      ;  /* ADC 0 OFFSET CALIBRATION MIDDLE               */
__sfr __at (0xBC) ADC0COH      ;  /* ADC 0 OFFSET CALIBRATION HIGH                 */
__sfr __at (0xBD) ADC0BUF      ;  /* ADC 0 BUFFER CONTROL                          */
__sfr __at (0xBE) CLKMUL       ;  /* CLOCK MULTIPLIER                              */
__sfr __at (0xBF) ADC0DAC      ;  /* ADC 0 OFFSET DAC                              */
__sfr __at (0xC0) SMB0CN       ;  /* SMBUS CONTROL                                 */
__sfr __at (0xC1) SMB0CF       ;  /* SMBUS CONFIGURATION                           */
__sfr __at (0xC2) SMB0DAT      ;  /* SMBUS DATA                                    */
__sfr __at (0xC3) ADC0L        ;  /* ADC 0 OUTPUT LOW BYTE                         */
__sfr __at (0xC4) ADC0M        ;  /* ADC 0 OUTPUT MIDDLE BYTE                      */
__sfr __at (0xC5) ADC0H        ;  /* ADC 0 OUTPUT HIGH BYTE                        */
__sfr __at (0xC6) ADC0MUX      ;  /* ADC 0 MULTIPLEXER                             */
__sfr __at (0xC8) T2CON        ;  /* TIMER 2 CONTROL                               */
__sfr __at (0xC8) TMR2CN       ;  /* TIMER 2 CONTROL                               */
__sfr __at (0xCA) RCAP2L       ;  /* TIMER 2 CAPTURE REGISTER - LOW BYTE           */
__sfr __at (0xCA) TMR2RLL      ;  /* TIMER 2 CAPTURE REGISTER - LOW BYTE           */
__sfr __at (0xCB) RCAP2H       ;  /* TIMER 2 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at (0xCB) TMR2RLH      ;  /* TIMER 2 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at (0xCC) TL2          ;  /* TIMER 2 - LOW BYTE                            */
__sfr __at (0xCC) TMR2L        ;  /* TIMER 2 - LOW BYTE                            */
__sfr __at (0xCD) TH2          ;  /* TIMER 2 - HIGH BYTE                           */
__sfr __at (0xCD) TMR2H        ;  /* TIMER 2 - HIGH BYTE                           */
__sfr __at (0xD0) PSW          ;  /* PROGRAM STATUS WORD                           */
__sfr __at (0xD1) REF0CN       ;  /* VOLTAGE REFERENCE 0 CONTROL                   */
__sfr __at (0xD4) P0SKIP       ;  /* PORT 0 SKIP                                   */
__sfr __at (0xD5) P1SKIP       ;  /* PORT 1 SKIP                                   */
__sfr __at (0xD7) IDA1CN       ;  /* CURRENT MODE DAC 1 - CONTROL                  */
__sfr __at (0xD8) PCA0CN       ;  /* PCA CONTROL                                   */
__sfr __at (0xD9) PCA0MD       ;  /* PCA MODE                                      */
__sfr __at (0xDA) PCA0CPM0     ;  /* PCA MODULE 0 MODE REGISTER                    */
__sfr __at (0xDB) PCA0CPM1     ;  /* PCA MODULE 1 MODE REGISTER                    */
__sfr __at (0xDC) PCA0CPM2     ;  /* PCA MODULE 2 MODE REGISTER                    */
__sfr __at (0xDD) IDA1         ;  /* CURRENT MODE DAC 1                            */
__sfr __at (0xE0) ACC          ;  /* ACCUMULATOR                                   */
__sfr __at (0xE1) XBR0         ;  /* PORT MUX CONFIGURATION REGISTER 0             */
__sfr __at (0xE2) XBR1         ;  /* PORT MUX CONFIGURATION REGISTER 1             */
__sfr __at (0xE3) PFE0CN       ;  /* PREFETCH ENGINE CONTROL                       */
__sfr __at (0xE4) IT01CF       ;  /* INT0/INT1 CONFIGURATION REGISTER              */
__sfr __at (0xE4) INT01CF      ;  /* INT0/INT1 CONFIGURATION REGISTER              */
__sfr __at (0xE6) EIE1         ;  /* EXTERNAL INTERRUPT ENABLE 1                   */
__sfr __at (0xE8) ADC0STA      ;  /* ADC 0 STATUS                                  */
__sfr __at (0xE9) PCA0CPL0     ;  /* PCA CAPTURE 0 LOW                             */
__sfr __at (0xEA) PCA0CPH0     ;  /* PCA CAPTURE 0 HIGH                            */
__sfr __at (0xEB) PCA0CPL1     ;  /* PCA CAPTURE 1 LOW                             */
__sfr __at (0xEC) PCA0CPH1     ;  /* PCA CAPTURE 1 HIGH                            */
__sfr __at (0xED) PCA0CPL2     ;  /* PCA CAPTURE 2 LOW                             */
__sfr __at (0xEE) PCA0CPH2     ;  /* PCA CAPTURE 2 HIGH                            */
__sfr __at (0xEF) RSTSRC       ;  /* RESET SOURCE                                  */
__sfr __at (0xF0) B            ;  /* B REGISTER                                    */
__sfr __at (0xF1) P0MODE       ;  /* PORT 0 INPUT MODE CONFIGURATION               */
__sfr __at (0xF1) P0MDIN       ;  /* PORT 0 INPUT MODE CONFIGURATION               */
__sfr __at (0xF2) P1MODE       ;  /* PORT 1 INPUT MODE CONFIGURATION               */
__sfr __at (0xF2) P1MDIN       ;  /* PORT 1 INPUT MODE CONFIGURATION               */
__sfr __at (0xF3) ADC0MD       ;  /* ADC 0 MODE                                    */
__sfr __at (0xF4) ADC0CN       ;  /* ADC 0 CONTROL                                 */
__sfr __at (0xF6) EIP1         ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 1        */
__sfr __at (0xF7) ADC0CLK      ;  /* ADC 0 CLOCK                                   */
__sfr __at (0xF8) SPI0CN       ;  /* SPI0 CONTROL                                  */
__sfr __at (0xF9) PCA0L        ;  /* PCA COUNTER LOW                               */
__sfr __at (0xFA) PCA0H        ;  /* PCA COUNTER HIGH                              */
__sfr __at (0xFB) ADC0CF       ;  /* ADC 0 CONFIGURATION                           */
__sfr __at (0xFC) ADC0FL       ;  /* ADC 0 FAST FILTER OUTPUT LOW                  */
__sfr __at (0xFD) ADC0FM       ;  /* ADC 0 FAST FILTER OUTPUT MIDDLE               */
__sfr __at (0xFE) ADC0FH       ;  /* ADC 0 FAST FILTER OUTPUT HIGH                 */
__sfr __at (0xFF) VDM0CN       ;  /* VDD MONITOR CONTROL                           */


/*  WORD/DWORD Registers  */

__sfr16 __at (0x8C8A) TMR0     ;  /* TIMER 0 COUNTER                               */
__sfr16 __at (0x8D8B) TMR1     ;  /* TIMER 1 COUNTER                               */
__sfr16 __at (0xCDCC) TMR2     ;  /* TIMER 2 COUNTER                               */
__sfr16 __at (0xCBCA) RCAP2    ;  /* TIMER 2 CAPTURE REGISTER WORD                 */
__sfr16 __at (0xCBCA) TMR2RL   ;  /* TIMER 2 CAPTURE REGISTER WORD                 */
__sfr16 __at (0x9594) TMR3     ;  /* TIMER 3 COUNTER                               */
__sfr16 __at (0x9392) TMR3RL   ;  /* TIMER 3 CAPTURE REGISTER WORD                 */

__sfr16 __at (0x9B9A) ADC0DEC  ;  /* ADC 0 DECIMATION RATIO REGISTER  WORD         */
/* Unfortunately the C8051F350 does not have an sfr that always reads 0x00 and     */
/* ignores what is written to it. That could have enabled sfr32 definitions for    */
/* the 24 bit ADC0 sfr combinations.                                               */
__sfr16 __at (0xC5C4) ADC0     ;  /* 16 bit ADC 0 SINC3 FILTER OUTPUT WORD         */
__sfr16 __at (0xFEFD) ADC0F    ;  /* 16 bit ADC 0 FAST FILTER OUTPUT WORD          */

__sfr16 __at (0xFAF9) PCA0     ;  /* PCA COUNTER                                   */
__sfr16 __at (0xEAE9) PCA0CP0  ;  /* PCA CAPTURE 0 WORD                            */
__sfr16 __at (0xECEB) PCA0CP1  ;  /* PCA CAPTURE 1 WORD                            */
__sfr16 __at (0xEEED) PCA0CP2  ;  /* PCA CAPTURE 2 WORD                            */


/*  BIT Registers  */

/*  P0  0x80 */
__sbit __at (0x80) P0_0        ;
__sbit __at (0x81) P0_1        ;
__sbit __at (0x82) P0_2        ;
__sbit __at (0x83) P0_3        ;
__sbit __at (0x84) P0_4        ;
__sbit __at (0x85) P0_5        ;
__sbit __at (0x86) P0_6        ;
__sbit __at (0x87) P0_7        ;

/*  TCON  0x88 */
__sbit __at (0x88) IT0         ;  /* TCON.0 - EXT. INTERRUPT 0 TYPE                */
__sbit __at (0x89) IE0         ;  /* TCON.1 - EXT. INTERRUPT 0 EDGE FLAG           */
__sbit __at (0x8A) IT1         ;  /* TCON.2 - EXT. INTERRUPT 1 TYPE                */
__sbit __at (0x8B) IE1         ;  /* TCON.3 - EXT. INTERRUPT 1 EDGE FLAG           */
__sbit __at (0x8C) TR0         ;  /* TCON.4 - TIMER 0 ON/OFF CONTROL               */
__sbit __at (0x8D) TF0         ;  /* TCON.5 - TIMER 0 OVERFLOW FLAG                */
__sbit __at (0x8E) TR1         ;  /* TCON.6 - TIMER 1 ON/OFF CONTROL               */
__sbit __at (0x8F) TF1         ;  /* TCON.7 - TIMER 1 OVERFLOW FLAG                */

/*  P1  0x90 */
__sbit __at (0x90) P1_0        ;
__sbit __at (0x91) P1_1        ;
__sbit __at (0x92) P1_2        ;
__sbit __at (0x93) P1_3        ;
__sbit __at (0x94) P1_4        ;
__sbit __at (0x95) P1_5        ;
__sbit __at (0x96) P1_6        ;
__sbit __at (0x97) P1_7        ;

/*  SCON  0x98 */
__sbit __at (0x98) RI          ;  /* SCON.0 - RECEIVE INTERRUPT FLAG               */
__sbit __at (0x98) RI0         ;  /* SCON.0 - RECEIVE INTERRUPT FLAG               */
__sbit __at (0x99) TI          ;  /* SCON.1 - TRANSMIT INTERRUPT FLAG              */
__sbit __at (0x99) TI0         ;  /* SCON.1 - TRANSMIT INTERRUPT FLAG              */
__sbit __at (0x9A) RB8         ;  /* SCON.2 - RECEIVE BIT 8                        */
__sbit __at (0x9A) RB80        ;  /* SCON.2 - RECEIVE BIT 8                        */
__sbit __at (0x9B) TB8         ;  /* SCON.3 - TRANSMIT BIT 8                       */
__sbit __at (0x9B) TB80        ;  /* SCON.3 - TRANSMIT BIT 8                       */
__sbit __at (0x9C) REN         ;  /* SCON.4 - RECEIVE ENABLE                       */
__sbit __at (0x9C) REN0        ;  /* SCON.4 - RECEIVE ENABLE                       */
__sbit __at (0x9D) SM2         ;  /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE  */
__sbit __at (0x9D) MCE0        ;  /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE  */
__sbit __at (0x9F) SM0         ;  /* SCON.7 - SERIAL MODE CONTROL BIT 0            */
__sbit __at (0x9F) S0MODE      ;  /* SCON.7 - SERIAL MODE CONTROL BIT 0            */

/*  P2  0xA0 */
__sbit __at (0xA0) P2_0        ;
__sbit __at (0xA1) P2_1        ;
__sbit __at (0xA2) P2_2        ;
__sbit __at (0xA3) P2_3        ;
__sbit __at (0xA4) P2_4        ;
__sbit __at (0xA5) P2_5        ;
__sbit __at (0xA6) P2_6        ;
__sbit __at (0xA7) P2_7        ;

/*  IE  0xA8 */
__sbit __at (0xA8) EX0         ;  /* IE.0 - EXTERNAL INTERRUPT 0 ENABLE            */
__sbit __at (0xA9) ET0         ;  /* IE.1 - TIMER 0 INTERRUPT ENABLE               */
__sbit __at (0xAA) EX1         ;  /* IE.2 - EXTERNAL INTERRUPT 1 ENABLE            */
__sbit __at (0xAB) ET1         ;  /* IE.3 - TIMER 1 INTERRUPT ENABLE               */
__sbit __at (0xAC) ES          ;  /* IE.4 - SERIAL PORT INTERRUPT ENABLE           */
__sbit __at (0xAC) ES0         ;  /* IE.4 - SERIAL PORT INTERRUPT ENABLE           */
__sbit __at (0xAD) ET2         ;  /* IE.5 - TIMER 2 INTERRUPT ENABLE               */
__sbit __at (0xAE) ESPI0       ;  /* IE.6 - SPI0 INTERRUPT ENABLE                  */
__sbit __at (0xAF) EA          ;  /* IE.7 - GLOBAL INTERRUPT ENABLE                */

/*  IP  0xB8 */
__sbit __at (0xB8) PX0         ;  /* IP.0 - EXTERNAL INTERRUPT 0 PRIORITY          */
__sbit __at (0xB9) PT0         ;  /* IP.1 - TIMER 0 PRIORITY                       */
__sbit __at (0xBA) PX1         ;  /* IP.2 - EXTERNAL INTERRUPT 1 PRIORITY          */
__sbit __at (0xBB) PT1         ;  /* IP.3 - TIMER 1 PRIORITY                       */
__sbit __at (0xBC) PS          ;  /* IP.4 - SERIAL PORT PRIORITY                   */
__sbit __at (0xBC) PS0         ;  /* IP.4 - SERIAL PORT PRIORITY                   */
__sbit __at (0xBD) PT2         ;  /* IP.5 - TIMER 2 PRIORITY                       */
__sbit __at (0xBE) PSPI0       ;  /* IP.6 - SPI0 PRIORITY                          */

/*  SMB0CN  0xC0 */
__sbit __at (0xC0) SI          ;  /* SMB0CN.0 - SMBUS 0 INTERRUPT PENDING FLAG     */
__sbit __at (0xC1) ACK         ;  /* SMB0CN.1 - SMBUS 0 ACKNOWLEDGE FLAG           */
__sbit __at (0xC2) ARBLOST     ;  /* SMB0CN.2 - SMBUS 0 ARBITRATION LOST INDICATOR */
__sbit __at (0xC3) ACKRQ       ;  /* SMB0CN.3 - SMBUS 0 ACKNOWLEDGE REQUEST        */
__sbit __at (0xC4) STO         ;  /* SMB0CN.4 - SMBUS 0 STOP FLAG                  */
__sbit __at (0xC5) STA         ;  /* SMB0CN.5 - SMBUS 0 START FLAG                 */
__sbit __at (0xC6) TXMODE      ;  /* SMB0CN.6 - SMBUS 0 TRANSMIT MODE INDICATOR    */
__sbit __at (0xC7) MASTER      ;  /* SMB0CN.7 - SMBUS 0 MASTER/SLAVE INDICATOR     */

/*  TMR2CN  0xC8 */
__sbit __at (0xC8) T2XCLK      ;  /* TMR2CN.0 - TIMER 2 EXTERNAL CLOCK SELECT      */
__sbit __at (0xCA) TR2         ;  /* TMR2CN.2 - TIMER 2 ON/OFF CONTROL             */
__sbit __at (0xCB) T2SPLIT     ;  /* TMR2CN.3 - TIMER 2 SPLIT MODE ENABLE          */
__sbit __at (0xCC) TF2CEN      ;  /* TMR2CN.4 - TIMER 2 LOW-FREQ OSC CAPTURE ENABLE*/
__sbit __at (0xCD) TF2LEN      ;  /* TMR2CN.5 - TIMER 2 LOW BYTE INTERRUPT ENABLE  */
__sbit __at (0xCE) TF2L        ;  /* TMR2CN.6 - TIMER 2 LOW BYTE OVERFLOW FLAG     */
__sbit __at (0xCF) TF2         ;  /* TMR2CN.7 - TIMER 2 OVERFLOW FLAG              */
__sbit __at (0xCF) TF2H        ;  /* TMR2CN.7 - TIMER 2 HIGH BYTE OVERFLOW FLAG    */

/*  PSW  0xD0 */
__sbit __at (0xD0) PARITY      ;  /* PSW.0 - ACCUMULATOR PARITY FLAG               */
__sbit __at (0xD1) F1          ;  /* PSW.1 - FLAG 1                                */
__sbit __at (0xD2) OV          ;  /* PSW.2 - OVERFLOW FLAG                         */
__sbit __at (0xD3) RS0         ;  /* PSW.3 - REGISTER BANK SELECT 0                */
__sbit __at (0xD4) RS1         ;  /* PSW.4 - REGISTER BANK SELECT 1                */
__sbit __at (0xD5) F0          ;  /* PSW.5 - FLAG 0                                */
__sbit __at (0xD6) AC          ;  /* PSW.6 - AUXILIARY CARRY FLAG                  */
__sbit __at (0xD7) CY          ;  /* PSW.7 - CARRY FLAG                            */

/*  PCA0CN  0xD8 */
__sbit __at (0xD8) CCF0        ;  /* PCA0CN.0 - PCA MODULE 0 CAPTURE/COMPARE FLAG  */
__sbit __at (0xD9) CCF1        ;  /* PCA0CN.1 - PCA MODULE 1 CAPTURE/COMPARE FLAG  */
__sbit __at (0xDA) CCF2        ;  /* PCA0CN.2 - PCA MODULE 2 CAPTURE/COMPARE FLAG  */
__sbit __at (0xDE) CR          ;  /* PCA0CN.6 - PCA COUNTER/TIMER RUN CONTROL      */
__sbit __at (0xDF) CF          ;  /* PCA0CN.7 - PCA COUNTER/TIMER OVERFLOW FLAG    */

/*  ADC0STA  0xE8 */
__sbit __at (0xE8) AD0OVR      ;  /* ADC0CN.0 - ADC 0 OVERRUN FLAG                 */
__sbit __at (0xE9) AD0ERR      ;  /* ADC0CN.1 - ADC 0 ERROR FLAG                   */
__sbit __at (0xEA) AD0CALC     ;  /* ADC0CN.2 - ADC 0 CALIBRATION COMPLETE FLAG    */
__sbit __at (0xEB) AD0FFC      ;  /* ADC0CN.3 - ADC 0 FAST FILTER CLIP FLAG        */
__sbit __at (0xEC) AD0S3C      ;  /* ADC0CN.4 - ADC 0 SINC3 FILTER CLIP FLAG       */
__sbit __at (0xED) AD0INT      ;  /* ADC0CN.5 - ADC 0 CONV. COMPLETE INT. FLAG     */
__sbit __at (0xEE) AD0CBSY     ;  /* ADC0CN.6 - ADC 0 CALIBRATION IN PROGRESS FLAG */
__sbit __at (0xEF) AD0BUSY     ;  /* ADC0CN.7 - ADC 0 CONVERSION IN PROGRESS FLAG  */

/*  SPI0CN  0xF8 */
__sbit __at (0xF8) SPIEN       ;  /* SPI0CN.0 - SPI0 ENABLE                        */
__sbit __at (0xF9) TXBMT       ;  /* SPI0CN.1 - TRANSMIT BUFFER EMPTY              */
__sbit __at (0xFA) NSSMD0      ;  /* SPI0CN.2 - SLAVE SELECT MODE BIT 0            */
__sbit __at (0xFB) NSSMD1      ;  /* SPI0CN.3 - SLAVE SELECT MODE BIT 1            */
__sbit __at (0xFC) RXOVRN      ;  /* SPI0CN.4 - RECEIVE OVERRUN FLAG               */
__sbit __at (0xFD) MODF        ;  /* SPI0CN.5 - MODE FAULT FLAG                    */
__sbit __at (0xFE) WCOL        ;  /* SPI0CN.6 - WRITE COLLISION FLAG               */
__sbit __at (0xFF) SPIF        ;  /* SPI0CN.7 - SPI0 INTERRUPT FLAG                */


/* Predefined SFR Bit Masks */

#define PCON_IDLE         0x01    /* PCON                                */
#define PCON_STOP         0x02    /* PCON                                */
#define T1M               0x08    /* CKCON                               */
#define PSWE              0x01    /* PSCTL                               */
#define PSEE              0x02    /* PSCTL                               */
#define ECP0              0x20    /* EIE1                                */
#define PORSF             0x02    /* RSTSRC                              */
#define SWRSF             0x10    /* RSTSRC                              */
#define ECCF              0x01    /* PCA0CPMn                            */
#define PWM               0x02    /* PCA0CPMn                            */
#define TOG               0x04    /* PCA0CPMn                            */
#define MAT               0x08    /* PCA0CPMn                            */
#define CAPN              0x10    /* PCA0CPMn                            */
#define CAPP              0x20    /* PCA0CPMn                            */
#define ECOM              0x40    /* PCA0CPMn                            */
#define PWM16             0x80    /* PCA0CPMn                            */
#define CP0E              0x10    /* XBR0                                */
#define CP0OEN            0x10    /* XBR0                                */
#define CP0AE             0x20    /* XBR0                                */
#define CP0AOEN           0x20    /* XBR0                                */

#endif
/*-------------------------------------------------------------------------
   at89s53.h - Register Declarations for the Atmel AT89S53 Processor

   Copyright (C) 2005, Jesus Calvino-Fraga / jesusc at ece.ubc.ca

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef REG_AT89S53_H
#define REG_AT89S53_H

#include <8052.h>     /* load difinitions for the 8052 core */

#ifdef REG8052_H
#undef REG8052_H
#endif

/* define AT89S53 specific registers only */
__sfr __at (0x84) DP1L;     /* Data Pointer 1 Low Byte */
__sfr __at (0x85) DP1H;     /* Data Pointer 1 High Byte */
__sfr __at (0x86) SPDR;     /* SPI Data Register */
__sfr __at (0xAA) SPSR;     /* SPI Status Register */
__sfr __at (0x96) WMCON;    /* Watchdog and Memory Control Register */
__sfr __at (0xD5) SPCR;     /* SPI Control Register */

/*------------------------------------------------
SPSR (0xAA) Bit Values - Reset Value = 0000.0000
------------------------------------------------*/
#define WCOL_   0x40    /* SPI Write Collision Flag: 1=Collision */
#define SPIF_   0x80    /* SPI Interrupt Flag */

/*------------------------------------------------
WMCON (0x96) Bit Values
------------------------------------------------*/
#define WDTEN_   0x01

#define WDTRST_  0x02   /* Watchdog Timer Reset and EEPROM Ready,/Busy Flag*/
#define EERDY_   0x02   /* Watchdog Timer Reset and EEPROM Ready,/Busy Flag */

#define DPS_     0x04   /* Data Pointer Select: 0=DP0, 1=DP1 */
#define EEMEN_   0x08   /* Internal EEPROM Access Enable: 1=Enabled */
#define EEMWE_   0x10   /* Internal EEPROM Write Enable: 1=Enabled */
#define PS0_     0x20   /* Prescaler bit 0 for the Watchdog Timer */
#define PS1_     0x40   /* Prescaler bit 1 for the Watchdog Timer */
#define PS2_     0x80   /* Prescaler bit 2 for the Watchdog Timer */
                        /* 000 =   16ms Timeout */
                        /* 001 =   32ms Timeout */
                        /* 010 =   64ms Timeout */
                        /* 011 =  128ms Timeout */
                        /* 100 =  256ms Timeout */
                        /* 101 =  512ms Timeout */
                        /* 110 = 1024ms Timeout */
                        /* 111 = 2048ms Timeout */

/*------------------------------------------------
SPCR (0xD5) Bit Values - Reset Value = 0000.01XX
------------------------------------------------*/
#define SPR0_   0x01    /* SPI Clock Rate Select bit 0 */
#define SPR1_   0x02    /* SPI Clock Rate Select bit 1 */
                        /* 00 = Fosc / 4   */
                        /* 01 = Fosc / 16  */
                        /* 10 = Fosc / 64  */
                        /* 11 = Fosc / 128 */

#define CPHA_   0x04    /* SPI Clock Phase */
#define CPOL_   0x08    /* SPI Clock Polarity */
#define MSTR_   0x10    /* SPI Master/Slave Select: 0=Slave, 1=Master */
#define DORD_   0x20    /* SPI Data Order: 0=MSB First, 1=LSB First */
#define SPE_    0x40    /* SPI Enable: 0=Disabled, 1=Enabled */
#define SPIE_   0x80    /* SPI Interrupt Enable: 0=Disabled, 1=Enabled */

#endif /*REG_AT89S53_H*/
/*-------------------------------------------------------------------------
   C8051T610.h - Register Declarations for the SiLabs C8051T61x Processor
   Range

   Copyright (C) 2008, Steven Borley, steven.borley@partnerelectronics.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/
#ifndef C8051T610_H
#define C8051T610_H

#include <compiler.h>

/*  BYTE Registers  */

SFR(       P0, 0x80 )  ; /* PORT 0 */
SFR(       SP, 0x81 )  ; /* STACK POINTER */
SFR(      DPL, 0x82 )  ; /* DATA POINTER - LOW BYTE */
SFR(      DPH, 0x83 )  ; /* DATA POINTER - HIGH BYTE */
SFR(    TOFFL, 0x85 )  ; /* TEMPERATURE SENSOR OFFSET - LOW BYTE */
SFR(    TOFFH, 0x86 )  ; /* TEMPERATURE SENSOR OFFSET - HIGH BYTE */
SFR(     PCON, 0x87 )  ; /* POWER CONTROL */
SFR(     TCON, 0x88 )  ; /* TIMER CONTROL */
SFR(     TMOD, 0x89 )  ; /* TIMER MODE */
SFR(      TL0, 0x8A )  ; /* TIMER 0 - LOW BYTE */
SFR(      TL1, 0x8B )  ; /* TIMER 1 - LOW BYTE */
SFR(      TH0, 0x8C )  ; /* TIMER 0 - HIGH BYTE */
SFR(      TH1, 0x8D )  ; /* TIMER 1 - HIGH BYTE */
SFR(    CKCON, 0x8E )  ; /* CLOCK CONTROL */
SFR(       P1, 0x90 )  ; /* PORT 1 */
SFR(   TMR3CN, 0x91 )  ; /* TIMER 3 CONTROL */
SFR(  TMR3RLL, 0x92 )  ; /* TIMER 3 CAPTURE REGISTER - LOW BYTE */
SFR(  TMR3RLH, 0x93 )  ; /* TIMER 3 CAPTURE REGISTER - HIGH BYTE */
SFR(    TMR3L, 0x94 )  ; /* TIMER 3 - LOW BYTE */
SFR(    TMR3H, 0x95 )  ; /* TIMER 3 - HIGH BYTE */
SFR(     SCON, 0x98 )  ; /* SERIAL PORT CONTROL */
SFR(    SCON0, 0x98 )  ; /* SERIAL PORT CONTROL */
SFR(     SBUF, 0x99 )  ; /* SERIAL PORT BUFFER */
SFR(    SBUF0, 0x99 )  ; /* SERIAL PORT BUFFER */
SFR(   CPT1CN, 0x9A )  ; /* COMPARATOR 1 CONTROL */
SFR(   CPT0CN, 0x9B )  ; /* COMPARATOR 0 CONTROL */
SFR(   CPT1MD, 0x9C )  ; /* COMPARATOR 1 MODE SELECTION */
SFR(   CPT0MD, 0x9D )  ; /* COMPARATOR 0 MODE SELECTION */
SFR(   CPT1MX, 0x9E )  ; /* COMPARATOR 1 MUX SELECTION */
SFR(   CPT0MX, 0x9F )  ; /* COMPARATOR 0 MUX SELECTION */
SFR(       P2, 0xA0 )  ; /* PORT 2 */
SFR(  SPI0CFG, 0xA1 )  ; /* SPI0 CONFIGURATION */
SFR(  SPI0CKR, 0xA2 )  ; /* SPI0 CLOCK RATE CONTROL */
SFR(  SPI0DAT, 0xA3 )  ; /* SPI0 DATA */
SFR(  P0MDOUT, 0xA4 )  ; /* PORT 0 OUTPUT MODE CONFIGURATION */
SFR(  P1MDOUT, 0xA5 )  ; /* PORT 1 OUTPUT MODE CONFIGURATION */
SFR(  P2MDOUT, 0xA6 )  ; /* PORT 2 OUTPUT MODE CONFIGURATION */
SFR(  P3MDOUT, 0xA7 )  ; /* PORT 3 OUTPUT MODE CONFIGURATION */
SFR(       IE, 0xA8 )  ; /* INTERRUPT ENABLE */
SFR(   CLKSEL, 0xA9 )  ; /* SYSTEM CLOCK SELECT */
SFR(   EMI0CN, 0xAA )  ; /* EXTERNAL MEMORY INTERFACE CONTROL */
SFR(   _XPAGE, 0xAA )  ; /* XDATA/PDATA PAGE */
SFR(       P3, 0xB0 )  ; /* PORT 3 */
SFR(   OSCXCN, 0xB1 )  ; /* EXTERNAL OSCILLATOR CONTROL */
SFR(   OSCICN, 0xB2 )  ; /* INTERNAL OSCILLATOR CONTROL */
SFR(   OSCICL, 0xB3 )  ; /* INTERNAL OSCILLATOR CALIBRATION */
SFR(       IP, 0xB8 )  ; /* INTERRUPT PRIORITY */
SFR(    AMX0P, 0xBB )  ; /* ADC 0 MUX POSITIVE CHANNEL SELECTION */
SFR(   ADC0CF, 0xBC )  ; /* ADC 0 CONFIGURATION */
SFR(    ADC0L, 0xBD )  ; /* ADC 0 DATA WORD LSB */
SFR(    ADC0H, 0xBE )  ; /* ADC 0 DATA WORD MSB */
SFR(   SMB0CN, 0xC0 )  ; /* SMBUS CONTROL */
SFR(   SMB0CF, 0xC1 )  ; /* SMBUS CONFIGURATION */
SFR(  SMB0DAT, 0xC2 )  ; /* SMBUS DATA */
SFR(  ADC0GTL, 0xC3 )  ; /* ADC 0 GREATER-THAN LOW BYTE */
SFR(  ADC0GTH, 0xC4 )  ; /* ADC 0 GREATER-THAN HIGH BYTE */
SFR(  ADC0LTL, 0xC5 )  ; /* ADC 0 LESS-THAN LOW BYTE */
SFR(  ADC0LTH, 0xC6 )  ; /* ADC 0 LESS-THAN HIGH BYTE */
SFR(   REG0CN, 0xC7 )  ; /* Voltage Regulator Control */
SFR(    T2CON, 0xC8 )  ; /* TIMER 2 CONTROL */
SFR(   TMR2CN, 0xC8 )  ; /* TIMER 2 CONTROL */
SFR(   RCAP2L, 0xCA )  ; /* TIMER 2 CAPTURE REGISTER - LOW BYTE */
SFR(  TMR2RLL, 0xCA )  ; /* TIMER 2 CAPTURE REGISTER - LOW BYTE */
SFR(   RCAP2H, 0xCB )  ; /* TIMER 2 CAPTURE REGISTER - HIGH BYTE */
SFR(  TMR2RLH, 0xCB )  ; /* TIMER 2 CAPTURE REGISTER - HIGH BYTE */
SFR(      TL2, 0xCC )  ; /* TIMER 2 - LOW BYTE */
SFR(    TMR2L, 0xCC )  ; /* TIMER 2 - LOW BYTE */
SFR(      TH2, 0xCD )  ; /* TIMER 2 - HIGH BYTE */
SFR(    TMR2H, 0xCD )  ; /* TIMER 2 - HIGH BYTE */
SFR(      PSW, 0xD0 )  ; /* PROGRAM STATUS WORD */
SFR(   REF0CN, 0xD1 )  ; /* VOLTAGE REFERENCE 0 CONTROL */
SFR(   P0SKIP, 0xD4 )  ; /* PORT 0 SKIP */
SFR(   P1SKIP, 0xD5 )  ; /* PORT 1 SKIP */
SFR(   P2SKIP, 0xD6 )  ; /* PORT 2 SKIP */
SFR(   PCA0CN, 0xD8 )  ; /* PCA CONTROL */
SFR(   PCA0MD, 0xD9 )  ; /* PCA MODE */
SFR( PCA0CPM0, 0xDA )  ; /* PCA MODULE 0 MODE REGISTER */
SFR( PCA0CPM1, 0xDB )  ; /* PCA MODULE 1 MODE REGISTER */
SFR( PCA0CPM2, 0xDC )  ; /* PCA MODULE 2 MODE REGISTER */
SFR( PCA0CPM3, 0xDD )  ; /* PCA MODULE 3 MODE REGISTER */
SFR( PCA0CPM4, 0xDE )  ; /* PCA MODULE 4 MODE REGISTER */
SFR(      ACC, 0xE0 )  ; /* ACCUMULATOR */
SFR(     XBR0, 0xE1 )  ; /* PORT MUX CONFIGURATION REGISTER 0 */
SFR(     XBR1, 0xE2 )  ; /* PORT MUX CONFIGURATION REGISTER 1 */
SFR(   IT01CF, 0xE4 )  ; /* INT0/INT1 CONFIGURATION REGISTER */
SFR(  INT01CF, 0xE4 )  ; /* INT0/INT1 CONFIGURATION REGISTER */
SFR(     EIE1, 0xE6 )  ; /* EXTERNAL INTERRUPT ENABLE 1 */
SFR(   ADC0CN, 0xE8 )  ; /* ADC 0 CONTROL */
SFR( PCA0CPL1, 0xE9 )  ; /* PCA CAPTURE 1 LOW */
SFR( PCA0CPH1, 0xEA )  ; /* PCA CAPTURE 1 HIGH */
SFR( PCA0CPL2, 0xEB )  ; /* PCA CAPTURE 2 LOW */
SFR( PCA0CPH2, 0xEC )  ; /* PCA CAPTURE 2 HIGH */
SFR( PCA0CPL3, 0xED )  ; /* PCA CAPTURE 3 LOW */
SFR( PCA0CPH3, 0xEE )  ; /* PCA CAPTURE 3 HIGH */
SFR(   RSTSRC, 0xEF )  ; /* RESET SOURCE */
SFR(        B, 0xF0 )  ; /* B REGISTER */
SFR(   P0MODE, 0xF1 )  ; /* PORT 0 INPUT MODE CONFIGURATION */
SFR(   P0MDIN, 0xF1 )  ; /* PORT 0 INPUT MODE CONFIGURATION */
SFR(   P1MODE, 0xF2 )  ; /* PORT 1 INPUT MODE CONFIGURATION */
SFR(   P1MDIN, 0xF2 )  ; /* PORT 1 INPUT MODE CONFIGURATION */
SFR(   P2MODE, 0xF3 )  ; /* PORT 2 INPUT MODE CONFIGURATION */
SFR(   P2MDIN, 0xF3 )  ; /* PORT 2 INPUT MODE CONFIGURATION */
SFR(   P3MODE, 0xF4 )  ; /* PORT 3 INPUT MODE CONFIGURATION */
SFR(   P3MDIN, 0xF4 )  ; /* PORT 3 INPUT MODE CONFIGURATION */
SFR(     EIP1, 0xF6 )  ; /* EXTERNAL INTERRUPT PRIORITY REGISTER 1 */
SFR(   SPI0CN, 0xF8 )  ; /* SPI0 CONTROL */
SFR(    PCA0L, 0xF9 )  ; /* PCA COUNTER LOW */
SFR(    PCA0H, 0xFA )  ; /* PCA COUNTER HIGH */
SFR( PCA0CPL0, 0xFB )  ; /* PCA CAPTURE 0 LOW */
SFR( PCA0CPH0, 0xFC )  ; /* PCA CAPTURE 0 HIGH */
SFR( PCA0CPL4, 0xFD )  ; /* PCA CAPTURE 4 LOW */
SFR( PCA0CPH4, 0xFE )  ; /* PCA CAPTURE 4 HIGH */
SFR(   VDM0CN, 0xFF )  ; /* VDD MONITOR CONTROL */


/*  WORD/DWORD Registers  */

SFR16E(     TOFF, 0x8685 )  ; /* TEMPERATURE SENSOR OFFSET WORD */
SFR16E(     TMR0, 0x8C8A )  ; /* TIMER 0 COUNTER */
SFR16E(     TMR1, 0x8D8B )  ; /* TIMER 1 COUNTER */
SFR16E(     TMR2, 0xCDCC )  ; /* TIMER 2 COUNTER */
SFR16E(    RCAP2, 0xCBCA )  ; /* TIMER 2 CAPTURE REGISTER WORD */
SFR16E(   TMR2RL, 0xCBCA )  ; /* TIMER 2 CAPTURE REGISTER WORD */
SFR16E(     TMR3, 0x9594 )  ; /* TIMER 3 COUNTER */
SFR16E(   TMR3RL, 0x9392 )  ; /* TIMER 3 CAPTURE REGISTER WORD */
SFR16E(     ADC0, 0xBEBD )  ; /* ADC 0 DATA WORD */
SFR16E(   ADC0GT, 0xC4C3 )  ; /* ADC 0 GREATER-THAN REGISTER WORD */
SFR16E(   ADC0LT, 0xC6C5 )  ; /* ADC 0 LESS-THAN REGISTER WORD */
SFR16E(     PCA0, 0xFAF9 )  ; /* PCA COUNTER */
SFR16E(  PCA0CP0, 0xFCFB )  ; /* PCA CAPTURE 0 WORD */
SFR16E(  PCA0CP1, 0xEAE9 )  ; /* PCA CAPTURE 1 WORD */
SFR16E(  PCA0CP2, 0xECEB )  ; /* PCA CAPTURE 2 WORD */
SFR16E(  PCA0CP3, 0xEEED )  ; /* PCA CAPTURE 3 WORD */
SFR16E(  PCA0CP4, 0xFEFD )  ; /* PCA CAPTURE 4 WORD */


/*  BIT Registers  */

/*  P0  0x80 */
SBIT(     P0_0, 0x80, 0 )  ;
SBIT(     P0_1, 0x80, 1 )  ;
SBIT(     P0_2, 0x80, 2 )  ;
SBIT(     P0_3, 0x80, 3 )  ;
SBIT(     P0_4, 0x80, 4 )  ;
SBIT(     P0_5, 0x80, 5 )  ;
SBIT(     P0_6, 0x80, 6 )  ;
SBIT(     P0_7, 0x80, 7 )  ;

/*  TCON  0x88 */
SBIT(      IT0, 0x88, 0 )  ; /* TCON.0 - EXT. INTERRUPT 0 TYPE */
SBIT(      IE0, 0x88, 1 )  ; /* TCON.1 - EXT. INTERRUPT 0 EDGE FLAG */
SBIT(      IT1, 0x88, 2 )  ; /* TCON.2 - EXT. INTERRUPT 1 TYPE */
SBIT(      IE1, 0x88, 3 )  ; /* TCON.3 - EXT. INTERRUPT 1 EDGE FLAG */
SBIT(      TR0, 0x88, 4 )  ; /* TCON.4 - TIMER 0 ON/OFF CONTROL */
SBIT(      TF0, 0x88, 5 )  ; /* TCON.5 - TIMER 0 OVERFLOW FLAG */
SBIT(      TR1, 0x88, 6 )  ; /* TCON.6 - TIMER 1 ON/OFF CONTROL */
SBIT(      TF1, 0x88, 7 )  ; /* TCON.7 - TIMER 1 OVERFLOW FLAG */

/*  P1  0x90 */
SBIT(     P1_0, 0x90, 0 )  ;
SBIT(     P1_1, 0x90, 1 )  ;
SBIT(     P1_2, 0x90, 2 )  ;
SBIT(     P1_3, 0x90, 3 )  ;
SBIT(     P1_4, 0x90, 4 )  ;
SBIT(     P1_5, 0x90, 5 )  ;
SBIT(     P1_6, 0x90, 6 )  ;
SBIT(     P1_7, 0x90, 7 )  ;

/*  SCON  0x98 */
SBIT(       RI, 0x98, 0 )  ; /* SCON.0 - RECEIVE INTERRUPT FLAG */
SBIT(      RI0, 0x98, 0 )  ; /* SCON.0 - RECEIVE INTERRUPT FLAG */
SBIT(       TI, 0x98, 1 )  ; /* SCON.1 - TRANSMIT INTERRUPT FLAG */
SBIT(      TI0, 0x98, 1 )  ; /* SCON.1 - TRANSMIT INTERRUPT FLAG */
SBIT(      RB8, 0x98, 2 )  ; /* SCON.2 - RECEIVE BIT 8 */
SBIT(     RB80, 0x98, 2 )  ; /* SCON.2 - RECEIVE BIT 8 */
SBIT(      TB8, 0x98, 3 )  ; /* SCON.3 - TRANSMIT BIT 8 */
SBIT(     TB80, 0x98, 3 )  ; /* SCON.3 - TRANSMIT BIT 8 */
SBIT(      REN, 0x98, 4 )  ; /* SCON.4 - RECEIVE ENABLE */
SBIT(     REN0, 0x98, 4 )  ; /* SCON.4 - RECEIVE ENABLE */
SBIT(      SM2, 0x98, 5 )  ; /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE */
SBIT(     MCE0, 0x98, 5 )  ; /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE */
SBIT(      SM0, 0x98, 7 )  ; /* SCON.7 - SERIAL MODE CONTROL BIT 0 */
SBIT(   S0MODE, 0x98, 7 )  ; /* SCON.7 - SERIAL MODE CONTROL BIT 0 */

/*  P2  0xA0 */
SBIT(     P2_0, 0xA0, 0 )  ;
SBIT(     P2_1, 0xA0, 1 )  ;
SBIT(     P2_2, 0xA0, 2 )  ;
SBIT(     P2_3, 0xA0, 3 )  ;
SBIT(     P2_4, 0xA0, 4 )  ;
SBIT(     P2_5, 0xA0, 5 )  ;
SBIT(     P2_6, 0xA0, 6 )  ;
SBIT(     P2_7, 0xA0, 7 )  ;

/*  IE  0xA8 */
SBIT(      EX0, 0xA8, 0 )  ; /* IE.0 - EXTERNAL INTERRUPT 0 ENABLE */
SBIT(      ET0, 0xA8, 1 )  ; /* IE.1 - TIMER 0 INTERRUPT ENABLE */
SBIT(      EX1, 0xA8, 2 )  ; /* IE.2 - EXTERNAL INTERRUPT 1 ENABLE */
SBIT(      ET1, 0xA8, 3 )  ; /* IE.3 - TIMER 1 INTERRUPT ENABLE */
SBIT(       ES, 0xA8, 4 )  ; /* IE.4 - SERIAL PORT INTERRUPT ENABLE */
SBIT(      ES0, 0xA8, 4 )  ; /* IE.4 - SERIAL PORT INTERRUPT ENABLE */
SBIT(      ET2, 0xA8, 5 )  ; /* IE.5 - TIMER 2 INTERRUPT ENABLE */
SBIT(    ESPI0, 0xA8, 6 )  ; /* IE.6 - SPI0 INTERRUPT ENABLE */
SBIT(       EA, 0xA8, 7 )  ; /* IE.7 - GLOBAL INTERRUPT ENABLE */

/*  P3  0xB0 */
SBIT(     P3_0, 0xB0, 0 )  ;
SBIT(     P3_1, 0xB0, 1 )  ;
SBIT(     P3_2, 0xB0, 2 )  ;
SBIT(     P3_3, 0xB0, 3 )  ;
SBIT(     P3_4, 0xB0, 4 )  ;
SBIT(     P3_5, 0xB0, 5 )  ;
SBIT(     P3_6, 0xB0, 6 )  ;
SBIT(     P3_7, 0xB0, 7 )  ;

/*  IP  0xB8 */
SBIT(      PX0, 0xB8, 0 )  ; /* IP.0 - EXTERNAL INTERRUPT 0 PRIORITY */
SBIT(      PT0, 0xB8, 1 )  ; /* IP.1 - TIMER 0 PRIORITY */
SBIT(      PX1, 0xB8, 2 )  ; /* IP.2 - EXTERNAL INTERRUPT 1 PRIORITY */
SBIT(      PT1, 0xB8, 3 )  ; /* IP.3 - TIMER 1 PRIORITY */
SBIT(       PS, 0xB8, 4 )  ; /* IP.4 - SERIAL PORT PRIORITY */
SBIT(      PS0, 0xB8, 4 )  ; /* IP.4 - SERIAL PORT PRIORITY */
SBIT(      PT2, 0xB8, 5 )  ; /* IP.5 - TIMER 2 PRIORITY */
SBIT(    PSPI0, 0xB8, 6 )  ; /* IP.6 - SPI0 PRIORITY */

/*  SMB0CN  0xC0 */
SBIT(       SI, 0xC0, 0 )  ; /* SMB0CN.0 - SMBUS 0 INTERRUPT PENDING FLAG */
SBIT(      ACK, 0xC0, 1 )  ; /* SMB0CN.1 - SMBUS 0 ACKNOWLEDGE FLAG */
SBIT(  ARBLOST, 0xC0, 2 )  ; /* SMB0CN.2 - SMBUS 0 ARBITRATION LOST INDICATOR */
SBIT(    ACKRQ, 0xC0, 3 )  ; /* SMB0CN.3 - SMBUS 0 ACKNOWLEDGE REQUEST */
SBIT(      STO, 0xC0, 4 )  ; /* SMB0CN.4 - SMBUS 0 STOP FLAG */
SBIT(      STA, 0xC0, 5 )  ; /* SMB0CN.5 - SMBUS 0 START FLAG */
SBIT(   TXMODE, 0xC0, 6 )  ; /* SMB0CN.6 - SMBUS 0 TRANSMIT MODE INDICATOR */
SBIT(   MASTER, 0xC0, 7 )  ; /* SMB0CN.7 - SMBUS 0 MASTER/SLAVE INDICATOR */

/*  TMR2CN  0xC8 */
SBIT(   T2XCLK, 0xC8, 0 )  ; /* TMR2CN.0 - TIMER 2 EXTERNAL CLOCK SELECT */
SBIT(      TR2, 0xC8, 2 )  ; /* TMR2CN.2 - TIMER 2 ON/OFF CONTROL */
SBIT(  T2SPLIT, 0xC8, 3 )  ; /* TMR2CN.3 - TIMER 2 SPLIT MODE ENABLE */
SBIT(   TF2LEN, 0xC8, 5 )  ; /* TMR2CN.5 - TIMER 2 LOW BYTE INTERRUPT ENABLE */
SBIT(     TF2L, 0xC8, 6 )  ; /* TMR2CN.6 - TIMER 2 LOW BYTE OVERFLOW FLAG */
SBIT(      TF2, 0xC8, 7 )  ; /* TMR2CN.7 - TIMER 2 OVERFLOW FLAG */
SBIT(     TF2H, 0xC8, 7 )  ; /* TMR2CN.7 - TIMER 2 HIGH BYTE OVERFLOW FLAG */

/*  PSW  0xD0 */
SBIT(   PARITY, 0xD0, 0 )  ; /* PSW.0 - ACCUMULATOR PARITY FLAG */
SBIT(       F1, 0xD0, 1 )  ; /* PSW.1 - FLAG 1 */
SBIT(       OV, 0xD0, 2 )  ; /* PSW.2 - OVERFLOW FLAG */
SBIT(      RS0, 0xD0, 3 )  ; /* PSW.3 - REGISTER BANK SELECT 0 */
SBIT(      RS1, 0xD0, 4 )  ; /* PSW.4 - REGISTER BANK SELECT 1 */
SBIT(       F0, 0xD0, 5 )  ; /* PSW.5 - FLAG 0 */
SBIT(       AC, 0xD0, 6 )  ; /* PSW.6 - AUXILIARY CARRY FLAG */
SBIT(       CY, 0xD0, 7 )  ; /* PSW.7 - CARRY FLAG */

/*  PCA0CN  0xD8 */
SBIT(     CCF0, 0xD8, 0 )  ; /* PCA0CN.0 - PCA MODULE 0 CAPTURE/COMPARE FLAG */
SBIT(     CCF1, 0xD8, 1 )  ; /* PCA0CN.1 - PCA MODULE 1 CAPTURE/COMPARE FLAG */
SBIT(     CCF2, 0xD8, 2 )  ; /* PCA0CN.2 - PCA MODULE 2 CAPTURE/COMPARE FLAG */
SBIT(     CCF3, 0xD8, 3 )  ; /* PCA0CN.3 - PCA MODULE 3 CAPTURE/COMPARE FLAG */
SBIT(     CCF4, 0xD8, 4 )  ; /* PCA0CN.4 - PCA MODULE 4 CAPTURE/COMPARE FLAG */
SBIT(       CR, 0xD8, 6 )  ; /* PCA0CN.6 - PCA COUNTER/TIMER RUN CONTROL */
SBIT(       CF, 0xD8, 7 )  ; /* PCA0CN.7 - PCA COUNTER/TIMER OVERFLOW FLAG */

/*  ADC0CN  0xE8 */
SBIT(   AD0CM0, 0xE8, 0 )  ; /* ADC0CN.0 - ADC 0 START OF CONV. MODE BIT 0 */
SBIT(   AD0CM1, 0xE8, 1 )  ; /* ADC0CN.1 - ADC 0 START OF CONV. MODE BIT 1 */
SBIT(   AD0CM2, 0xE8, 2 )  ; /* ADC0CN.2 - ADC 0 START OF CONV. MODE BIT 2 */
SBIT(  AD0WINT, 0xE8, 3 )  ; /* ADC0CN.3 - ADC 0 WINDOW COMPARE INT. FLAG */
SBIT(  AD0BUSY, 0xE8, 4 )  ; /* ADC0CN.4 - ADC 0 BUSY FLAG */
SBIT(   AD0INT, 0xE8, 5 )  ; /* ADC0CN.5 - ADC 0 CONV. COMPLETE INT. FLAG */
SBIT(    AD0TM, 0xE8, 6 )  ; /* ADC0CN.6 - ADC 0 TRACK MODE */
SBIT(    AD0EN, 0xE8, 7 )  ; /* ADC0CN.7 - ADC 0 ENABLE */
                             
/*  SPI0CN  0xF8 */          
SBIT(    SPIEN, 0xF8, 0 )  ; /* SPI0CN.0 - SPI0 ENABLE */
SBIT(    TXBMT, 0xF8, 1 )  ; /* SPI0CN.1 - TRANSMIT BUFFER EMPTY */
SBIT(   NSSMD0, 0xF8, 2 )  ; /* SPI0CN.2 - SLAVE SELECT MODE BIT 0 */
SBIT(   NSSMD1, 0xF8, 3 )  ; /* SPI0CN.3 - SLAVE SELECT MODE BIT 1 */
SBIT(   RXOVRN, 0xF8, 4 )  ; /* SPI0CN.4 - RECEIVE OVERRUN FLAG */
SBIT(     MODF, 0xF8, 5 )  ; /* SPI0CN.5 - MODE FAULT FLAG */
SBIT(     WCOL, 0xF8, 6 )  ; /* SPI0CN.6 - WRITE COLLISION FLAG */
SBIT(     SPIF, 0xF8, 7 )  ; /* SPI0CN.7 - SPI0 INTERRUPT FLAG */


/* Predefined SFR Bit Masks */

#define PCON_IDLE         0x01    /* PCON                                */
#define PCON_STOP         0x02    /* PCON                                */
#define T1M               0x08    /* CKCON                               */
#define PSWE              0x01    /* PSCTL                               */
#define PSEE              0x02    /* PSCTL                               */
#define ECP0              0x20    /* EIE1                                */
#define ECP1              0x40    /* EIE1                                */
#define PORSF             0x02    /* RSTSRC                              */
#define SWRSF             0x10    /* RSTSRC                              */
#define ECCF              0x01    /* PCA0CPMn                            */
#define PWM               0x02    /* PCA0CPMn                            */
#define TOG               0x04    /* PCA0CPMn                            */
#define MAT               0x08    /* PCA0CPMn                            */
#define CAPN              0x10    /* PCA0CPMn                            */
#define CAPP              0x20    /* PCA0CPMn                            */
#define ECOM              0x40    /* PCA0CPMn                            */
#define PWM16             0x80    /* PCA0CPMn                            */
#define CP0E              0x10    /* XBR0                                */
#define CP0OEN            0x10    /* XBR0                                */
#define CP0AE             0x20    /* XBR0                                */
#define CP0AOEN           0x20    /* XBR0                                */
#define CP1E              0x40    /* XBR0                                */
#define CP1AE             0x80    /* XBR0                                */

/* Interrupts */

#define INT_EXT0          0       /* External Interrupt 0 */
#define INT_TIMER0        1       /* Timer0 Overflow */
#define INT_EXT1          2       /* External Interrupt 1 */
#define INT_TIMER1        3       /* Timer1 Overflow */
#define INT_UART0         4       /* Serial Port 0 */
#define INT_TIMER2        5       /* Timer2 Overflow */
#define INT_SPI0          6       /* Serial Peripheral Interface 0 */
#define INT_SMBUS0        7       /* SMBus0 Interface */
/*                        8          Reserved */
#define INT_ADC0_WINDOW   9       /* ADC0 Window Comparison */
#define INT_ADC0_EOC      10      /* ADC0 End Of Conversion */
#define INT_PCA0          11      /* PCA0 Peripheral */
#define INT_COMPARATOR0   12      /* Comparator0 */
#define INT_COMPARATOR1   13      /* Comparator1 */
#define INT_TIMER3        14      /* Timer3 Overflow */

#endif
/*-------------------------------------------------------------------------
   ser.h - this file is the header to be included by modules which use the
           ser.c module.

   Copyright (C) 1999, Sandeep Dutta <sandeep.dutta AT ieee.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*KA******************************************************************
* PROJECT: PLOne/8052
**********************************************************************
* FILE: ser.h
**********************************************************************
* CHANGES:
* date      author            description
* --------------------------------------------------------------------
* 04/26/99  we                update
* 04/27/99  we                add comments/header
**********************************************************************
* DESCRIPTION:
* This file is the header to be included by modules which use the
* ser.c module.
**********************************************************************
* FUNCTIONS DECLARED:
* see ser.c
**********************************************************************
* COMPILE TIME OPTIONS: -
* DEBUG OPTIONS: -
******************************************************************KE*/

#ifndef _SER_H_
#define _SER_H_

void ser_init(void);
void ser_interrupt_handler(void) __interrupt 4 __using 1;
void ser_putc(unsigned char);
unsigned char ser_getc(void);
void ser_printString(char *String);
char ser_charAvail(void);

/*********************End of File************************************/
#endif
/*-------------------------------------------------------------------------
   C8051F520.h - Register Declarations for the SiLabs C8051F52x-F53x
   Processor Range

   Copyright (C) 2006, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef C8051F520_H
#define C8051F520_H

#include <compiler.h>

SFR(P0,         0x80);      // Port 0
   SBIT(P0_0,     0x80, 0); // Port 0 bit 0
   SBIT(P0_1,     0x80, 1); // Port 0 bit 1
   SBIT(P0_2,     0x80, 2); // Port 0 bit 2
   SBIT(P0_3,     0x80, 3); // Port 0 bit 3
   SBIT(P0_4,     0x80, 4); // Port 0 bit 4
   SBIT(P0_5,     0x80, 5); // Port 0 bit 5
   SBIT(P0_6,     0x80, 6); // Port 0 bit 6
   SBIT(P0_7,     0x80, 7); // Port 0 bit 7
SFR(SP,         0x81);      // Stack Pointer
SFR(DPL,        0x82);      // Data Pointer Low Byte
SFR(DPH,        0x83);      // Data Pointer High Byte
SFR(PCON,       0x87);      // Power Mode Control
SFR(TCON,       0x88);      // Timer Control
   SBIT(IT0,      0x88, 0); // Ext. Interrupt 0 Type Select
   SBIT(IE0,      0x88, 1); // Ext. Interrupt 0 Flag
   SBIT(IT1,      0x88, 2); // Ext. Interrupt 1 Type Select
   SBIT(IE1,      0x88, 3); // Ext. Interrupt 1 Flag
   SBIT(TR0,      0x88, 4); // Timer 0 Run Control
   SBIT(TF0,      0x88, 5); // Timer 0 Overflow Flag
   SBIT(TR1,      0x88, 6); // Timer 1 Run Control
   SBIT(TF1,      0x88, 7); // Timer 1 Overflow Flag
SFR(TMOD,       0x89);      // Timer Mode
SFR16E(TMR0,    0x8C8A);    // Timer/Counter 0 Word
   SFR(TL0,       0x8A);    // Timer/Counter 0 Low Byte
   SFR(TH0,       0x8C);    // Timer/Counter 0 High Byte
SFR16E(TMR1,    0x8D8B);    // Timer/Counter 1 Word
   SFR(TL1,       0x8B);    // Timer/Counter 1 Low Byte
   SFR(TH1,       0x8D);    // Timer/Counter 1 High Byte
SFR(CKCON,      0x8E);      // Clock Control
SFR(PSCTL,      0x8F);      // Program Store R/W Control
SFR(P1,         0x90);      // Port 1
   SBIT(P1_0,     0x90, 0); // Port 1 bit 0
   SBIT(P1_1,     0x90, 1); // Port 1 bit 1
   SBIT(P1_2,     0x90, 2); // Port 1 bit 2
   SBIT(P1_3,     0x90, 3); // Port 1 bit 3
   SBIT(P1_4,     0x90, 4); // Port 1 bit 4
   SBIT(P1_5,     0x90, 5); // Port 1 bit 5
   SBIT(P1_6,     0x90, 6); // Port 1 bit 6
   SBIT(P1_7,     0x90, 7); // Port 1 bit 7
SFR(LINADDR,    0x92);      // LIN Indirect Address Pointer
SFR(LINDATA,    0x93);      // LIN Indirect Data Buffer
SFR(LINCF,      0x95);      // LIN Control Mode
SFR(SCON0,      0x98);      // Serial Port 0 Control
   SBIT(RI0,      0x98, 0); // Receive Interrupt Flag
   SBIT(TI0,      0x98, 1); // Transmit Interrupt Flag
   SBIT(RB80,     0x98, 2); // Ninth Receive Bit
   SBIT(TB80,     0x98, 3); // Ninth Transmission Bit
   SBIT(REN0,     0x98, 4); // Receive Enable
   SBIT(MCE0,     0x98, 5); // Multiprocessor Communication Enable
   SBIT(S0MODE,   0x98, 7); // Serial Port 0 Operation Mode
SFR(SBUF0,      0x99);      // Serial Port 0 Data Buffer
SFR(CPT0CN,     0x9B);      // Comparator 0 Control
SFR(CPT0MD,     0x9D);      // Comparator 0 Mode Selection
SFR(CPT0MX,     0x9F);      // Comparator 0 MUX Selection
SFR(SPI0CFG,    0xA1);      // SPI Configuration
SFR(SPI0CKR,    0xA2);      // SPI Clock Rate Control
SFR(SPI0DAT,    0xA3);      // SPI Data
SFR(P0MDOUT,    0xA4);      // Port 0 Output Mode Configuration
SFR(P1MDOUT,    0xA5);      // Port 1 Output Mode Configuration
SFR(IE,         0xA8);      // Interrupt Enable
   SBIT(EX0,      0xA8, 0); // Enable External Interrupt 0
   SBIT(ET0,      0xA8, 1); // Enable Timer 0 Interrupt
   SBIT(EX1,      0xA8, 2); // Enable External Interrupt 1
   SBIT(ET1,      0xA8, 3); // Enable Timer 1 Interrupt
   SBIT(ES0,      0xA8, 4); // Enable Serial Port Interrupt
   SBIT(ET2,      0xA8, 5); // Enable Timer 2 Interrupt
   SBIT(ESPI0,    0xA8, 6); // Enable SPI0 Interrupt
   SBIT(EA,       0xA8, 7); // Global Interrupt Enable
SFR(CLKSEL,     0xA9);      // Clock Select
SFR(OSCIFIN,    0xB0);      // Internal Oscillator Fine Calibration
SFR(OSCXCN,     0xB1);      // External Oscillator Control
SFR(OSCICN,     0xB2);      // Internal Oscillator Control
SFR(OSCICL,     0xB3);      // Internal Oscillator Calibration
SFR(FLKEY,      0xB7);      // Flash Lock and Key
SFR(IP,         0xB8);      // Interrupt Priority
   SBIT(PX0,      0xB8, 0); // External Interrupt 0 Priority
   SBIT(PT0,      0xB8, 1); // Timer 0 Interrupt Priority
   SBIT(PX1,      0xB8, 2); // External Interrupt 1 Priority
   SBIT(PT1,      0xB8, 3); // Timer 1 Interrupt Priority
   SBIT(PS0,      0xB8, 4); // Serial Port Interrupt Priority
   SBIT(PT2,      0xB8, 5); // Timer 2 Interrupt Priority
   SBIT(PSPI0,    0xB8, 6); // SPI0 Interrupt Priority
SFR(ADC0TK,     0xBA);      // ADC0 Tracking Mode Select
SFR(ADC0MX,     0xBB);      // ADC0 Channel Select
SFR(ADC0CF,     0xBC);      // ADC0 Configuration
SFR16(ADC0,     0xBD);      // ADC0 Word
   SFR(ADC0L,     0xBD);    // ADC0 Low Byte
   SFR(ADC0H,     0xBE);    // ADC0 High Byte
SFR(P1MASK,     0xBF);      // Port 1 Mask
SFR16(ADC0GT,   0xC3);      // ADC0 Greater-Than Data Word
   SFR(ADC0GTL,   0xC3);    // ADC0 Greater-Than Data Low Byte
   SFR(ADC0GTH,   0xC4);    // ADC0 Greater-Than Data High Byte
SFR16(ADC0LT,   0xC5);      // ADC0 Less-Than Data Word
   SFR(ADC0LTL,   0xC5);    // ADC0 Less-Than Data Low Byte
   SFR(ADC0LTH,   0xC6);    // ADC0 Less-Than Data High Byte
SFR(P0MASK,     0xC7);      // Port 0 Mask
SFR(TMR2CN,     0xC8);      // Timer/Counter 2 Control
SFR(REG0CN,     0xC9);      // Voltage Regulator Control
SFR16(TMR2RL,   0xCA);      // Timer/Counter 2 Reload Word
   SFR(TMR2RLL,   0xCA);    // Timer/Counter 2 Reload Low Byte
   SFR(TMR2RLH,   0xCB);    // Timer/Counter 2 Reload High Byte
SFR16(TMR2,     0xCC);      // Timer/Counter 2 Word
   SFR(TMR2L,     0xCC);    // Timer/Counter 2 Low Byte
   SFR(TMR2H,     0xCD);    // Timer/Counter 2 High Byte
SFR(P1MAT,      0xCF);      // Port 1 Match
SFR(PSW,        0xD0);      // Program Status Word
   SBIT(P,        0xD0, 0); // Parity Flag
   SBIT(F1,       0xD0, 1); // User-Defined Flag
   SBIT(OV,       0xD0, 2); // Overflow Flag
   SBIT(RS0,      0xD0, 3); // Register Bank Select 0
   SBIT(RS1,      0xD0, 4); // Register Bank Select 1
   SBIT(F0,       0xD0, 5); // User-Defined Flag
   SBIT(AC,       0xD0, 6); // Auxiliary Carry Flag
   SBIT(CY,       0xD0, 7); // Carry Flag
SFR(REF0CN,     0xD1);      // Voltage Reference Control
SFR(P0SKIP,     0xD4);      // Port 0 Skip
SFR(P1SKIP,     0xD5);      // Port 1 Skip
SFR(P0MAT,      0xD7);      // Port 0 Match
SFR(PCA0CN,     0xD8);      // PCA Control
   SBIT(CCF0,     0xD8, 0); // PCA Module 0 Capture/Compare Flag
   SBIT(CCF1,     0xD8, 1); // PCA Module 1 Capture/Compare Flag
   SBIT(CCF2,     0xD8, 2); // PCA Module 2 Capture/Compare Flag
   SBIT(CR,       0xD8, 6); // PCA Counter/Timer Run Control
   SBIT(CF,       0xD8, 7); // PCA Counter/Timer Overflow Flag
SFR(PCA0MD,     0xD9);      // PCA Mode
SFR(PCA0CPM0,   0xDA);      // PCA Module 0 Mode
SFR(PCA0CPM1,   0xDB);      // PCA Module 1 Mode
SFR(PCA0CPM2,   0xDC);      // PCA Module 2 Mode
SFR(ACC,        0xE0);      // Accumulator
SFR(XBR0,       0xE1);      // Port I/O Crossbar Control 0
SFR(XBR1,       0xE2);      // Port I/O Crossbar Control 1
SFR(IT01CF,     0xE4);      // INT0/INT1 Configuration
SFR(EIE1,       0xE6);      // Extended Interrupt Enable 1
SFR(ADC0CN,     0xE8);      // ADC0 Control
   SBIT(AD0CM0,   0xE8, 0); // ADC0 Conversion Start Mode Select Bit 0
   SBIT(AD0CM1,   0xE8, 1); // ADC0 Conversion Start Mode Select Bit 1
   SBIT(AD0LJST,  0xE8, 2); // ADC0 Left Justify Select
   SBIT(AD0WINT,  0xE8, 3); // ADC0 Window Compare Interrupt Flag
   SBIT(AD0BUSY,  0xE8, 4); // ADC0 Busy Bit
   SBIT(AD0INT,   0xE8, 5); // ADC0 Conversion Complete Interrupt Flag
   SBIT(BURSTEN,  0xE8, 6); // ADC0 Burst Mode Enable Bit
   SBIT(AD0EN,    0xE8, 7); // ADC0 Enable Bit
SFR16(PCA0CP1,  0xE9);      // PCA Capture 1 Word
   SFR(PCA0CPL1,  0xE9);    // PCA Capture 1 Low Byte
   SFR(PCA0CPH1,  0xEA);    // PCA Capture 1 High Byte
SFR16(PCA0CP2,  0xEB);      // PCA Capture 2 Word
   SFR(PCA0CPL2,  0xEB);    // PCA Capture 2 Low Byte
   SFR(PCA0CPH2,  0xEC);    // PCA Capture 2 High Byte
SFR(RSTSRC,     0xEF);      // Reset Source Configuration/Status
SFR(B,          0xF0);      // B Register
SFR(P0MDIN,     0xF1);      // Port 0 Input Mode Configuration
SFR(P1MDIN,     0xF2);      // Port 1 Input Mode Configuration
SFR(EIP1,       0xF6);      // Extended Interrupt Priority 1
SFR(SPI0CN,     0xF8);      // SPI0 Control
   SBIT(SPIEN,    0xF8, 0); // SPI0 Enable
   SBIT(TXBMT,    0xF8, 1); // SPI0 Transmit Buffer Empty
   SBIT(NSSMD0,   0xF8, 2); // SPI0 Slave Select Mode Bit 0
   SBIT(NSSMD1,   0xF8, 3); // SPI0 Slave Select Mode Bit 1
   SBIT(RXOVRN,   0xF8, 4); // SPI0 Receive Overrun Flag
   SBIT(MODF,     0xF8, 5); // SPI0 Mode Fault Flag
   SBIT(WCOL,     0xF8, 6); // SPI0 Write Collision Flag
   SBIT(SPIF,     0xF8, 7); // SPI0 Interrupt Flag
SFR16(PCA0,     0xF9);      // PCA Counter Word
   SFR(PCA0L,    0xF9);    // PCA Counter Low Byte
   SFR(PCA0H,     0xFA);    // PCA Counter High Byte
SFR16(PCA0CP0,  0xFB);      // PCA Capture 0 Word
   SFR(PCA0CPL0,  0xFB);    // PCA Capture 0 Low Byte
   SFR(PCA0CPH0,  0xFC);    // PCA Capture 0 High Byte
SFR(VDDMON,     0xFF);      // VDD Control

/* Predefined SFR Bit Masks */

#define PCON_IDLE         0x01    /* PCON                                */
#define PCON_STOP         0x02    /* PCON                                */
#define T1M               0x08    /* CKCON                               */
#define PSWE              0x01    /* PSCTL                               */
#define PSEE              0x02    /* PSCTL                               */
#define PORSF             0x02    /* RSTSRC                              */
#define SWRSF             0x10    /* RSTSRC                              */
#define ECCF              0x01    /* PCA0CPMn                            */
#define PWM               0x02    /* PCA0CPMn                            */
#define TOG               0x04    /* PCA0CPMn                            */
#define MAT               0x08    /* PCA0CPMn                            */
#define CAPN              0x10    /* PCA0CPMn                            */
#define CAPP              0x20    /* PCA0CPMn                            */
#define ECOM              0x40    /* PCA0CPMn                            */
#define PWM16             0x80    /* PCA0CPMn                            */
#define CP0E              0x10    /* XBR0                                */
#define CP0AE             0x20    /* XBR0                                */

/* Interrupts */

#define INT_EXT0          0       // External Interrupt 0
#define INT_TIMER0        1       // Timer0 Overflow
#define INT_EXT1          2       // External Interrupt 1
#define INT_TIMER1        3       // Timer1 Overflow
#define INT_UART0         4       // Serial Port 0
#define INT_TIMER2        5       // Timer2 Overflow
#define INT_SPI0          6       // Serial Peripheral Interface 0
#define INT_ADC0_WINDOW   7       // ADC0 Window Comparison
#define INT_ADC0_EOC      8       // ADC0 End Of Conversion
#define INT_PCA0          9       // PCA0 Peripheral
#define INT_COMP_FALLING  10      // Comparator0 Falling
#define INT_COMP_RISING   11      // Comparator0 Rising
#define INT_LIN           12      // LIN
#define INT_VREG_DROPOUT  13      // VREG dropout
#define INT_PORT_MATCH    14      // Port Match

#endif
/*-------------------------------------------------------------------------
   uPSD23xx.h - Register Declarations for ST's uPSD325x
   Based upon  uPSD33xx.h from SDCC compiler set, and
   uPSD3254/3253 datasheet - November 2004
   Register Declarations for ST's uPSD32xx "Fast 8032 MCU with Programmable Logic"

   Copyright (C) 2009, GHJ Morsink
   Original 33xx file Written By -  Jesus Calvino-Fraga / jesusc at ece.ubc.ca (May 2007)

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef REG_UPSD32XX_H
#define REG_UPSD32XX_H

#include <compiler.h>

#ifndef PSD_CSIOP
#define PSD_CSIOP 0x00                /* for reference for PSD registers as default (page 99 datasheet) */
                                      /* This must be set in PSDSoft "Define PSD pin/node Functions"
                                         Step3 'Next', tab "Chip Select Equations"  */
#endif

//Interrupt vector numbers (see table 24 on datasheet page 39)
#define EXT0_INTERRUPT   ((0x03-3)/8)
#define TIMER0_INTERRUPT ((0x0B-3)/8)
#define EXT1_INTERRUPT   ((0x13-3)/8)
#define TIMER1_INTERRUPT ((0x1B-3)/8)
#define UART0_INTERRUPT  ((0x23-3)/8)
#define TIMER2_INTERRUPT ((0x2B-3)/8)
#define TX2_INTERRUPT    ((0x2B-3)/8)
#define USB_INTERRUPT    ((0x33-3)/8)
#define DDC_INTERRUPT    ((0x3B-3)/8)
#define I2C_INTERRUPT    ((0x43-3)/8)
#define UART1_INTERRUPT  ((0x4B-3)/8)


SFR(P0, 0x80); // Port 0
    SBIT(P0_0, 0x80, 0); // Port 0 bit 0.
    SBIT(P0_1, 0x80, 1); // Port 0 bit 1.
    SBIT(P0_2, 0x80, 2); // Port 0 bit 2.
    SBIT(P0_3, 0x80, 3); // Port 0 bit 3.
    SBIT(P0_4, 0x80, 4); // Port 0 bit 4.
    SBIT(P0_5, 0x80, 5); // Port 0 bit 5.
    SBIT(P0_6, 0x80, 6); // Port 0 bit 6.
    SBIT(P0_7, 0x80, 7); // Port 0 bit 7.


SFR(SP,   0x81); // Stack Pointer.
SFR(DPL,  0x82); // Data Pointer Low.
SFR(DPH,  0x83); // Data Pointer High.

SFR(DPTC, 0x85); // Data Pointer Control Register.
SFR(DPS,  0x85); // Data Pointer Control Register alias for SDCC
    #define AT 0x40 //0:Manually Select Data Pointer / 1:Auto Toggle between DPTR0 and DPTR1
    #define DPSE0 0x01 // 0:DPTR0 Selected for use as DPTR / 1:DPTR1 Selected for use as DPTR

SFR(PCON, 0x87); // Power Control.
    #define SMOD0  0x80 //Baud Rate Double Bit (UART0)
    #define SMOD1  0x40 //Baud Rate Double Bit (UART1)
    #define POR    0x10 //Only a power-on reset sets this bit (cold reset).
    #define RCLK1  0x08 //Receive Clock Flag (UART1)
    #define TCLK1  0x04 //Transmit Clock Flag (UART1)
    #define PD     0x02 //Power-Down Mode Enable.
    #define IDL    0x01 //Idle Mode Enable.

SFR(TCON, 0x88); // Timer/Counter Control.
    SBIT(TF1, 0x88, 7); // Timer 1 overflow flag.
    SBIT(TR1, 0x88, 6); // Timer 1 run control flag.
    SBIT(TF0, 0x88, 5); // Timer 0 overflow flag.
    SBIT(TR0, 0x88, 4); // Timer 0 run control flag.
    SBIT(IE1, 0x88, 3); // Interrupt 1 flag.
    SBIT(IT1, 0x88, 2); // Interrupt 1 type control bit.
    SBIT(IE0, 0x88, 1); // Interrupt 0 flag.
    SBIT(IT0, 0x88, 0); // Interrupt 0 type control bit.

SFR(TMOD, 0x89); // Timer/Counter Mode Control.
    #define GATE1 0x80 // External enable for timer 1.
    #define C_T1  0x40 // Timer or counter select for timer 1.
    #define M1_1  0x20 // Operation mode bit 1 for timer 1.
    #define M0_1  0x10 // Operation mode bit 0 for timer 1.
    #define GATE0 0x08 // External enable for timer 0.
    #define C_T0  0x04 // Timer or counter select for timer 0.
    #define M1_0  0x02 // Operation mode bit 1 for timer 0.
    #define M0_0  0x01 // Operation mode bit 0 for timer 0.

SFR(TL0, 0x8A); // Timer 0 LSB.
SFR(TL1, 0x8B); // Timer 1 LSB.
SFR(TH0, 0x8C); // Timer 0 MSB.
SFR(TH1, 0x8D); // Timer 1 MSB.

SFR(P1, 0x90); // Port 1
    SBIT(P1_0, 0x90, 0); // Port 1 bit 0.
    SBIT(P1_1, 0x90, 1); // Port 1 bit 1.
    SBIT(P1_2, 0x90, 2); // Port 1 bit 2.
    SBIT(P1_3, 0x90, 3); // Port 1 bit 3.
    SBIT(P1_4, 0x90, 4); // Port 1 bit 4.
    SBIT(P1_5, 0x90, 5); // Port 1 bit 5.
    SBIT(P1_6, 0x90, 6); // Port 1 bit 6.
    SBIT(P1_7, 0x90, 7); // Port 1 bit 7.
    //Alternate names (from figure 3)
    SBIT(T2,     0x90, 0); //Input to Timer/Counter 2.
    SBIT(T2X,    0x90, 1); //Capture/reload trigger for Counter 2.
    SBIT(RXD1,   0x90, 2);
    SBIT(TXD1,   0x90, 3);
    SBIT(SPICLK, 0x90, 4);
    SBIT(SPIRXD, 0x90, 5);
    SBIT(SPITXD, 0x90, 6);
    SBIT(SPISEL, 0x90, 7);

SFR(P1SFS, 0x91); // Port 1 Special Function Select Register
    #define P1SF7 0x80
    #define P1SF6 0x40
    #define P1SF5 0x20
    #define P1SF4 0x10
    #define P1SF3 0x08
    #define P1SF2 0x04
    #define P1SF1 0x02
    #define P1SF0 0x01

SFR(P3SFS, 0x93); // Port 3 Special Function Select Register
    #define P3SF7 0x80
    #define P3SF6 0x40
    #define P3SF5 0x20
    #define P3SF4 0x10
    #define P3SF3 0x08
    #define P3SF2 0x04
    #define P3SF1 0x02
    #define P3SF0 0x01

SFR(P4SFS, 0x94); //Port 4 Special Function Select Register.
    #define P4SF7 0x80
    #define P4SF6 0x40
    #define P4SF5 0x20
    #define P4SF4 0x10
    #define P4SF3 0x08
    #define P4SF2 0x04
    #define P4SF1 0x02
    #define P4SF0 0x01

SFR(ASCL, 0x95); // ADC pre-scaler
    #define ADCCE  0x08 // ADC Conversion Reference Clock Enable.
    //ADC Reference Clock PreScaler. Only three Prescaler values are allowed:
    #define ADCPS2 0x02 // Resulting ADC clock is fOSC.
    #define ADCPS1 0x01 // Resulting ADC clock is fOSC/2.
    #define ADCPS0 0x00 // Resulting ADC clock is fOSC/4.

SFR(ADAT, 0x96); // A/D result register (bits 0 to 7).
SFR(ACON, 0x97); // A/D control register.
    #define AINTF  0x80 // ADC Interrupt flag. This bit must be cleared with software.
    #define AINTEN 0x40 // ADC Interrupt Enable.
    #define ADEN   0x20 // ADC Enable Bit.
    #define ADS2   0x10 // Analog channel Select bit 3.
    #define ADS1   0x08 // Analog channel Select bit 2.
    #define ADS0   0x04 // Analog channel Select bit 1.
    #define ADST   0x02 // ADC Start Bit.
    #define ADSF   0x01 // ADC Status Bit.

SFR(SCON, 0x98); // For compatibity with legacy code
SFR(SCON0, 0x98); // Serial Port UART0 Control Register
    SBIT(SM0, 0x98, 7); // Serial Port Mode Bit 0.
    SBIT(SM1, 0x98, 6); // Serial Port Mode Bit 1.
    SBIT(SM2, 0x98, 5); // Serial Port Mode Bit 2.
    SBIT(REN, 0x98, 4); // Enables serial reception.
    SBIT(TB8, 0x98, 3); // The 9th data bit that will be transmitted in Modes 2 and 3.
    SBIT(RB8, 0x98, 2); // In Modes 2 and 3, the 9th data bit that was received.
    SBIT(TI,  0x98, 1); // Transmit interrupt flag.
    SBIT(RI,  0x98, 0); // Receive interrupt flag.

SFR(SBUF, 0x99);  // For compatibity with legacy code.
SFR(SBUF0, 0x99); // Serial Port UART0 Data Buffer.

SFR(SCON2, 0x9A); // Serial Port Control.
/* These bits are not bit-addressable */
    #define SM01  0x80  // Serial Port Mode Bit 0.
    #define SM11  0x40  // Serial Port Mode Bit 1.
    #define SM21  0x20  // Serial Port Mode Bit 2.
    #define REN1  0x10  // Enables serial reception.
    #define TB81  0x08  // The 9th data bit that will be transmitted in Modes 2 and 3.
    #define RB81  0x04  // In Modes 2 and 3, the 9th data bit that was received.
    #define TI1   0x02  // Transmit interrupt flag.
    #define RI1   0x01  // Receive interrupt flag.

SFR(SBUF2, 0x9B);   // Data buffer for UART1.

SFR(P2, 0xA0); // Port 2
    SBIT(P2_0, 0xA0, 0); // Port 2 bit 0.
    SBIT(P2_1, 0xA0, 1); // Port 2 bit 1.
    SBIT(P2_2, 0xA0, 2); // Port 2 bit 2.
    SBIT(P2_3, 0xA0, 3); // Port 2 bit 3.
    SBIT(P2_4, 0xA0, 4); // Port 2 bit 4.
    SBIT(P2_5, 0xA0, 5); // Port 2 bit 5.
    SBIT(P2_6, 0xA0, 6); // Port 2 bit 6.
    SBIT(P2_7, 0xA0, 7); // Port 2 bit 7.

SFR(PWMCON, 0xA1);      // PWM control register for 4+1 channels
    #define PWML   0x80 // Polarity 0-3
    #define PWMP   0x40 // Polarity 4
    #define PWME   0x20 // Enable Bit. (0 = disabled)
    #define CFG4   0x10 // Output4: 0=open drain, 1=pushpull
    #define CFG3   0x08 // Output3: 0=open drain, 1=pushpull
    #define CFG2   0x04 // Output2: 0=open drain, 1=pushpull
    #define CFG1   0x02 // Output1: 0=open drain, 1=pushpull
    #define CFG0   0x01 // Output0: 0=open drain, 1=pushpull


SFR(PWM0, 0xA2); // PWM0 counter.
SFR(PWM1, 0xA3); //  counter.
SFR(PWM2, 0xA4); //
SFR(PWM3, 0xA5); //
SFR(PWM4P, 0xAA); // PWM4 Period
SFR(PWM4W, 0xAB); // PWM4 Width
SFR(PSCL0L, 0xB1); // The low 8 bits of PSCL 0 16-bit counter. (Prescaler for PWM)
SFR(PSCL0H, 0xB2); // The high 8 bits of PSCL 0 16-bit counter.
SFR(PSCL1L, 0xB3); // The low 8 bits of PSCL 1 16-bit counter.
SFR(PSCL1H, 0xB4); // The high 8 bits of PSCL 1 16-bit counter.


SFR(IEA, 0xA7); // Interrupt Enable Addition Register.
    #define EADC 0x80 // Enable ADC Interrupt.
    #define ESPI 0x40 // Enable SPI Interrupt.
    #define EPCA 0x20 // Enable Programmable Counter Array Interrupt.
    #define ES1  0x10 // Enable UART1 Interrupt.
    #define EI2C 0x02 // Enable I2C Interrupt.

SFR(IE, 0xA8); // Interrupt Enable Register.
    SBIT(EA,  0xA8, 7); // Global disable bit.
    SBIT(ET2, 0xA8, 5); // Enable Timer 2 Interrupt.
    SBIT(ES0, 0xA8, 4); // Enable UART0 Interrupt.
    SBIT(ET1, 0xA8, 3); // Enable Timer 1 Interrupt.
    SBIT(EX1, 0xA8, 2); // Enable External Interrupt INT1.
    SBIT(ET0, 0xA8, 1); // Enable Timer 0 Interrupt.
    SBIT(EX0, 0xA8, 0); // Enable External Interrupt INT0.


SFR(WDRST, 0xA6);   // Watchdog Timer Reset Counter Register.
SFR(WDKEY, 0xAE);   //Watchdog Timer Key Register.

SFR(P3, 0xB0); // Port 3
    SBIT(P3_0, 0xB0, 0); // Port 3 bit 0.
    SBIT(P3_1, 0xB0, 1); // Port 3 bit 1.
    SBIT(P3_2, 0xB0, 2); // Port 3 bit 2.
    SBIT(P3_3, 0xB0, 3); // Port 3 bit 3.
    SBIT(P3_4, 0xB0, 4); // Port 3 bit 4.
    SBIT(P3_5, 0xB0, 5); // Port 3 bit 5.
    SBIT(P3_6, 0xB0, 6); // Port 3 bit 6.
    SBIT(P3_7, 0xB0, 7); // Port 3 bit 7.

SFR(IPA, 0xB7); // Interrupt Priority Addition register.
    #define PDDC 0x80 // DDC Interrupt priority level.
    #define PS1  0x10 // UART1 Interrupt priority.
    #define PI2C 0x02 // I2C Interrupt priority level.
    #define PUSB 0x01 // USB Interrupt priority level.

SFR(IP, 0xB8);  // Interrupt Priority Register.
    SBIT(PT2, 0xB8, 5); // Timer 2 Interrupt priority level.
    SBIT(PS0, 0xB8, 4); // UART0 Interrupt priority level.
    SBIT(PT1, 0xB8, 3); // Timer 1 Interrupt priority level.
    SBIT(PX1, 0xB8, 2); // External Interrupt INT1 priority level.
    SBIT(PT0, 0xB8, 1); // Timer 0 Interrupt priority level.
    SBIT(PX0, 0xB8, 0); // External Interrupt INT0 priority level.

SFR(P4, 0xC0); // I/O Port 4 Register
    SBIT(P4_0, 0xC0, 0); // Port 4 bit 0.
    SBIT(P4_1, 0xC0, 1); // Port 4 bit 1.
    SBIT(P4_2, 0xC0, 2); // Port 4 bit 2.
    SBIT(P4_3, 0xC0, 3); // Port 4 bit 3.
    SBIT(P4_4, 0xC0, 4); // Port 4 bit 4.
    SBIT(P4_5, 0xC0, 5); // Port 4 bit 5.
    SBIT(P4_6, 0xC0, 6); // Port 4 bit 6.
    SBIT(P4_7, 0xC0, 7); // Port 4 bit 7.


SFR(T2CON, 0xC8); // Timer / Counter 2 Control.
    SBIT(TF2,   0xC8, 7); // Timer 2 overflow flag.
    SBIT(EXF2,  0xC8, 6); // Timer 2 external flag.
    SBIT(RCLK,  0xC8, 5); // Receive clock flag.
    SBIT(TCLK,  0xC8, 4); // Transmit clock flag.
    SBIT(EXEN2, 0xC8, 3); // Timer 2 external enable flag.
    SBIT(TR2,   0xC8, 2); // Start/stop control for timer 2.
    SBIT(CNT2,  0xC8, 1); // Timer or coutner select.
    SBIT(CAP2,  0xC8, 0); // Capture/reload flag.

SFR(T2MOD, 0xC9); // Timer / Counter 2 Mode
   #define DCEN   0x01   // DC Enable

SFR(RCAP2L, 0xCA); // Timer 2 Capture LSB.
SFR(RCAP2H, 0xCB); // Timer 2 Capture MSB.
SFR(TL2,    0xCC); // Timer 2 LSB.
SFR(TH2,    0xCD); // Timer 2 MSB.

SFR(PSW, 0xD0); // Program Status Word.
    SBIT(CY,  0xD0, 7); // Carry Flag.
    SBIT(AC,  0xD0, 6); // Auxiliary Carry Flag.
    SBIT(F0,  0xD0, 5); // User-Defined Flag.
    SBIT(RS1, 0xD0, 4); // Register Bank Select 1.
    SBIT(RS0, 0xD0, 3); // Register Bank Select 0.
    SBIT(OV,  0xD0, 2); // Overflow Flag.
    SBIT(P,   0xD0, 0); // Parity Flag.

SFR(S1SETUP, 0xD1); // I2C START Condition Sample Setup register.
    #define EN_SS     0x80 // Enable Sample Setup.
    #define SMPL_SET6 0x40 // Sample Setting bit 7.
    #define SMPL_SET5 0x20 // Sample Setting bit 6.
    #define SMPL_SET4 0x10 // Sample Setting bit 5.
    #define SMPL_SET3 0x08 // Sample Setting bit 4.
    #define SMPL_SET2 0x04 // Sample Setting bit 3.
    #define SMPL_SET1 0x02 // Sample Setting bit 2.
    #define SMPL_SET0 0x01 // Sample Setting bit 1.

SFR(S2SETUP, 0xD2); // I2C (S2) SETUP
SFR(RAMBUF,  0xD4); // DDC Ram Buffer
SFR(DDCDAT,  0xD5); // DDC (I2C) data xmit register
SFR(DDCADR,  0xD6); // DDC (I2C) address pointer register
SFR(DDCCON,  0xD7); // DDC Control Register
   #define EX_DAT 0x40
   #define SWENB  0x20
   #define DDC_AX 0x10
   #define DDCINT 0x08
   #define DDC1EN 0x04
   #define SWHINT 0x02
   #define M0     0x01

SFR(S1CON, 0xD8); // I2C Interface Control Register.
SFR(S2CON, 0xDC); // I2C Interface Control Register.
    #define CR2  0x80 // SCL clock frequency select bit 3.
    #define ENI1 0x40 // I2C Interface Enable.
    #define STA  0x20 // START flag.
    #define STO  0x10 // STOP flag.
    #define ADDR 0x08 // Slave mode address.
    #define AA   0x04 // Assert Acknowledge enable.
    #define CR1  0x02 // SCL clock frequency select bit 2.
    #define CR0  0x01 // SCL clock frequency select bit 1.

SFR(S1STA, 0xD9); // I2C Interface Status Register.
SFR(S2STA, 0xDD); // I2C Interface Status Register.
    #define GC       0x80 // General Call flag.
    #define STOP     0x40 // STOP flag.
    #define INTR     0x20 // Interrupt flag.
    #define TX_MODE  0x10 // Transmission Mode flag.
    #define BBUSY    0x08 // Bus Busy flag.
    #define BLOST    0x04 // Bus Lost flag.
    #define ACK_RESP 0x02 // Not Acknowledge Response flag.
    #define SLV      0x01 // Slave Mode flag.

SFR(S1DAT, 0xDA); // I2C Data Shift Register.
SFR(S1ADR, 0xDB); // I2C Address Register (bit 0 not used).
SFR(S2DAT, 0xDE); // I2C Data Shift Register.
SFR(S2ADR, 0xDF); // I2C Address Register (bit 0 not used).

SFR(A, 0xE0);
SFR(ACC, 0xE0); // Accumulator
    SBIT(ACC_0, 0xE0, 0); // Accumulator bit 0.
    SBIT(ACC_1, 0xE0, 1); // Accumulator bit 1.
    SBIT(ACC_2, 0xE0, 2); // Accumulator bit 2.
    SBIT(ACC_3, 0xE0, 3); // Accumulator bit 3.
    SBIT(ACC_4, 0xE0, 4); // Accumulator bit 4.
    SBIT(ACC_5, 0xE0, 5); // Accumulator bit 5.
    SBIT(ACC_6, 0xE0, 6); // Accumulator bit 6.
    SBIT(ACC_7, 0xE0, 7); // Accumulator bit 7.

/*
 The USB function are described in the datasheet page 83 and further.
 Further notes can be found in application note AN1877 Rev.1 page 37 up; downloadable from ST.Com
 */
SFR(USCL, 0xE1);  // USB Prescaler

SFR(UDT1,  0xE6); // USB Endpt1 Data Xmit
SFR(UDT0,  0xE7); // USB Endpt0 Data Xmit
SFR(UISTA, 0xE8); // USB Interrupt Status
   #define SUSPND 0x80
   #define RSTF   0x20
   #define TXD0F  0x10
   #define RXD0F  0x08
   #define RXD1F  0x04
   #define EOPF   0x02
   #define RESUMF 0x01

SFR(UIEN, 0xE9); // USB Interrupt Enable
   #define SUSPNDIE  0x80
   #define RSTE      0x40
   #define RSTFIE    0x20
   #define TXD0IE    0x10
   #define RXD0IE    0x08
   #define TXD1IE    0x04
   #define EOPIE     0x02
   #define RESUMIE   0x01

SFR(UCON0, 0xEA); // USB Endpt0 Xmit Control
   #define TSEQ0     0x80
   #define STALL0    0x40
   #define TX0E      0x20
   #define RX0E      0x10
   #define TP0SIZ3   0x08
   #define TP0SIZ2   0x04
   #define TP0SIZ1   0x02
   #define TP0SIZ0   0x01

SFR(UCON1, 0xEB);  // USB Endpt1 Xmit Control
   #define TSEQ1     0x80
   #define EP12SEL   0x40
   #define FRESUM    0x10
   #define TP1SIZ3   0x08
   #define TP1SIZ2   0x04
   #define TP1SIZ1   0x02
   #define TP1SIZ0   0x01

SFR(UCON2, 0xEC );  // USB Control Register
   #define SOUT      0x10
   #define EP2E      0x08
   #define EP1E      0x04
   #define STALL2    0x02
   #define STALL1    0x01

SFR(USTA, 0xED); // USB Endpt0 Status
   #define RSEQ      0x80
   #define SETUP     0x40
   #define IN        0x20
   #define OUT       0x10
   #define RP0SIZ3   0x08
   #define RP0SIZ2   0x04
   #define RP0SIZ1   0x02
   #define RP0SIZ0   0x01

SFR(UADR, 0xEE); // USB Address Register
   #define USBEN     0x80

SFR(UDR0, 0xEF); // USB Endpt0 Data Recv

SFR(B, 0xF0); // B Register
    SBIT(B_0, 0xF0, 0); // Register B bit 0.
    SBIT(B_1, 0xF0, 1); // Register B bit 1.
    SBIT(B_2, 0xF0, 2); // Register B bit 2.
    SBIT(B_3, 0xF0, 3); // Register B bit 3.
    SBIT(B_4, 0xF0, 4); // Register B bit 4.
    SBIT(B_5, 0xF0, 5); // Register B bit 5.
    SBIT(B_6, 0xF0, 6); // Register B bit 6.
    SBIT(B_7, 0xF0, 7); // Register B bit 7.


// PSD registers definition - by Jan Waclawek - wek at efton dot sk - May 2007
// all defines here are with PSD_ prefix to identify them as PSD-related
//
// Based on uPSD33xx datasheet (preliminary) - Jan 2005, Table 79 at pages 145/146
// and subsequent text
// Based on uPSD3254A datasheet Rev.4 - 4 Nov 2004, Table 84 at page 99
// and subsequent text

// requires to have PSD_CSIOP defined to the base address of the PSD IO area,
//     as defined in PSDSoftExpress or CUPS
#ifndef PSD_CSIOP
#error PSD_CSIOP has to be #define-d (before #include-ing this file) to the base address of the PSD registers area, according to csiop setting in CUPS/PSDSoftExpress
#else
                                         //  -- Port A not available on 52-pin uPSD33xx devices
SFRX(PSD_DATAIN_A,    PSD_CSIOP+0x00);   // MCU I/O Mode Port A Data In Register
                                         //   reads 0 if pin is log.0, 1 if pin is log. 1
                                         //   READ only
SFRX(PSD_DATAOUT_A,   PSD_CSIOP+0x04);   // MCU I/O Mode Port A Data Out Register
                                         //   write 0 to set pin to log. 0, 1 to set pin to log. 1
                                         //   read back written value
                                         //   reset default = 00
SFRX(PSD_DIRECTION_A, PSD_CSIOP+0x06);   // MCU I/O Mode Port A Direction Register
                                         //   write 1 to set pin as output, 0 to set pin as input
                                         //   read back written value
                                         //   reset default = 00
SFRX(PSD_DRIVE_A,     PSD_CSIOP+0x08);   // Select Open Drain or High Slew Rate for port A
                                         //   PA0-PA3: write 0 to select standard push-pull CMOS output, 1 to select High Slew Rate push-pull CMOS output
                                         //   PA4-PA7: write 0 to select standard push-pull CMOS output, 1 to select Open Drain output
                                         //   reset default = 00
SFRX(PSD_CONTROL_A,   PSD_CSIOP+0x02);   // Selects MCU I/O or Latched Address Out mode for port A
                                         //   write 0 to select standard I/O pin, 1 to drive demultiplexed address signal on pin
                                         //   read back written value
                                         //   reset default = 00
SFRX(PSD_OUTENABLE_A, PSD_CSIOP+0x0C);   // Read state of Output Enable Logic on each I/O port driver of Port A
                                         //   1 - driver output is enabled, 0 - driver is off (high impedance)
                                         //   READ only

                                         // -- for comment on individual registers, see above Port A
SFRX(PSD_DATAIN_B,    PSD_CSIOP+0x01);   // MCU I/O Mode Port B Data In Register
SFRX(PSD_DATAOUT_B,   PSD_CSIOP+0x05);   // MCU I/O Mode Port B Data Out Register
SFRX(PSD_DIRECTION_B, PSD_CSIOP+0x07);   // MCU I/O Mode Port B Direction Register
SFRX(PSD_DRIVE_B,     PSD_CSIOP+0x09);   // Select Open Drain or High Slew Rate for port B
                                         // PB0-PB3: standard/High Slew Rate, PB4-PB7: standard/Open Drain
SFRX(PSD_CONTROL_B,   PSD_CSIOP+0x03);   // Selects MCU I/O or Latched Address Out mode for port B
SFRX(PSD_OUTENABLE_B, PSD_CSIOP+0x0D);   // Read state of Output Enable Logic on each I/O port driver of Port B

                                         // -- for comment on individual registers, see above Port A
                                         // only pins PC2, PC3, PC4, PC7 available; other bits in registers are undefined
SFRX(PSD_DATAIN_C,    PSD_CSIOP+0x10);   // MCU I/O Mode Port C Data In Register
SFRX(PSD_DATAOUT_C,   PSD_CSIOP+0x12);   // MCU I/O Mode Port C Data Out Register
SFRX(PSD_DIRECTION_C, PSD_CSIOP+0x14);   // MCU I/O Mode Port C Direction Register
SFRX(PSD_DRIVE_C,     PSD_CSIOP+0x16);   // Select Open Drain for port C
SFRX(PSD_OUTENABLE_C, PSD_CSIOP+0x1A);   // Read state of Output Enable Logic on each I/O port driver of Port C

                                         // -- for comment on individual registers, see above Port A
                                         // only pins PD1, PD2 available (PD2 not available on 52-pin package); other bits in registers are undefined
SFRX(PSD_DATAIN_D,    PSD_CSIOP+0x11);   // MCU I/O Mode Port D Data In Register
SFRX(PSD_DATAOUT_D,   PSD_CSIOP+0x13);   // MCU I/O Mode Port D Data Out Register
SFRX(PSD_DIRECTION_D, PSD_CSIOP+0x15);   // MCU I/O Mode Port D Direction Register
SFRX(PSD_DRIVE_D,     PSD_CSIOP+0x17);   // Select High Slew Rate for port D
SFRX(PSD_OUTENABLE_D, PSD_CSIOP+0x1B);   // Read state of Output Enable Logic on each I/O port driver of Port D

SFRX(PSD_IMC_A,       PSD_CSIOP+0x0A);   // Read to obtain logic state of Input Macrocells connected to Port A
                                         //   READ only
SFRX(PSD_IMC_B,       PSD_CSIOP+0x0B);   // Read to obtain logic state of Input Macrocells connected to Port B
SFRX(PSD_IMC_C,       PSD_CSIOP+0x18);   // Read to obtain logic state of Input Macrocells connected to Port C
                                         //   only pins PC2, PC3, PC4, PC7 available; other bits in register are undefined
SFRX(PSD_OMC_AB,      PSD_CSIOP+0x20);   // Read logic state of macrocells AB. Write to load macrocell AB flip-flops.
SFRX(PSD_OMC_BC,      PSD_CSIOP+0x21);   // Read logic state of macrocells BC. Write to load macrocell BC flip-flops.
SFRX(PSD_OMCMASK_AB,  PSD_CSIOP+0x22);   // Write to set mask for macrocell AB.
                                         //    1 blocks READs/WRITEs of OMF, 0 will pass OMF value
                                         //    Read back written value.
SFRX(PSD_OMCMASK_BC,  PSD_CSIOP+0x23);   // Write to set mask for macrocell BC.

// -- all three Power Management Register are set to 00 after PowerUp, but unchanged during reset (/RST)
SFRX(PSD_PMMR0,       PSD_CSIOP+0xB0);   // -- Power Management Register 0 - write/read
// bit 0 unused and should be set to 0
#define PSD_APD_ENA            0x02      // 0 - Automatic Power Down (APD) counter is disabled, 1 - APD enabled
// bit 2 unused and should be set to 0
#define PSD_TURBO_DISA         0x08      // 0 - PSD Turbo mode enabled, 1 - Turbo mode off, saving power
#define PSD_BLOCK_CLKIN_PLD    0x10      // 0 - CLKIN to PLD not blocked, 1 - no CLKIN to PLD Input Bus, saving power
#define PSD_BLOCK_CLKIN_OMC    0x20      // 0 - CLKIN to Output Macrocells not blocked, 1 - blocked, saving power
// bits 6 and 7 unused and should be set to 0

SFRX(PSD_PMMR2,       PSD_CSIOP+0xB4);   // -- Power Management Register 2 - write/read
// bits 0 and 1 unused and should be set to 0
#define PSD_BLOCK_WR_PLD       0x04      // 0 - /WR from 8032 to PLD Input Bus not blocked, 1 - blocked, saving power
#define PSD_BLOCK_RD_PLD       0x08      // 0 - /RD from 8032 to PLD Input Bus not blocked, 1 - blocked, saving power
#define PSD_BLOCK_PSEN_PLD     0x10      // 0 - /PSEN from 8032 to PLD Input Bus not blocked, 1 - blocked, saving power
#define PSD_BLOCK_ALE_PLD      0x20      // 0 - ALE from 8032 to PLD Input Bus not blocked, 1 - blocked, saving power
#define PSD_BLOCK_PC7_PDL      0x40      // 0 - input from Port C pin 7 to PLD Input Bus not blocked, 1 - blocked, saving power
// bit 7 unused and should be set to 0

SFRX(PSD_PMMR3,       PSD_CSIOP+0xC7);   // -- Power Management Register 3 - write/read
// bit 0 unused and should be set to 0
#define PSD_FORCE_PD           0x02      // 0 - APD counter, if enabled, will cause powerdown, 1 - powerdown will be entered immediately
                                         //   - once set, cleared only by reset condition
// bit 2 not defined by datasheet
// bits 3 to 7 unused and should be set to 0

SFRX(PSD_MAINPROTECT, PSD_CSIOP+0xC0);   // -- Main Flash Memory Protection Definition
                                         //   bit 0 to bit 7 - sector 0 to sector 7 protection status
                                         //      - 1 - flash sector write protected, 0 - not write protected
                                         //   READ only
SFRX(PSD_ALTPROTECT,  PSD_CSIOP+0xC2);   // -- Secondary Flash Memory Protection Definition
                                         //   bit 0 to bit 3 - sector 0 to sector 3 protection status
                                         //      - 1 - flash sector write protected, 0 - not write protected
                                         //   bit 7 - Security Bit
                                         //      - 1 - device is secured against external reading and writing, 0 - not secured
                                         //   READ only

SFRX(PSD_PAGE,        PSD_CSIOP+0xE0);   // -- Memory Page Register

SFRX(PSD_VM,          PSD_CSIOP+0xE2);   // -- Memory Mapping Register
                                         //   Places PSD Module memories into 8032 Program Address Space
                                         //   and/or 8032 XDATA Address Space
                                         //   Default value of bits 0 to 4 is loaded from Non-Volatile
                                         //   setting as specified from PSDsoft Express upon any reset
                                         //   or power-up condition. The default value of these bits
                                         //   can be overridden by 8032 at run-time.
#define PSD_VM_SRAM_CODE       0x01      // 0 - SRAM not accessible as CODE (/PSEN) memory, 1 - SRAM accessible as CODE memory
#define PSD_VM_ALT_CODE        0x02      // 0 - secondary FLASH not accessible as CODE (/PSEN) memory, 1 - secondary FLASH accessible as CODE memory
#define PSD_VM_MAIN_CODE       0x04      // 0 - primary FLASH not accessible as CODE (/PSEN) memory, 1 - primary FLASH accessible as CODE memory
#define PSD_VM_ALT_XDATA       0x08      // 0 - secondary FLASH not accessible as XDATA (/RD/WR) memory, 1 - secondary FLASH accessible as XDATA memory
#define PSD_VM_MAIN_XDATA      0x10      // 0 - primary FLASH not accessible as XDATA (/RD/WR) memory, 1 - primary FLASH accessible as XDATA memory
// bits 5 and 6 unused
#define PSD_VM_PIO_EN          0x80      // 0 - disable, 1- enable peripheral I/O mode on Port A

// another terminology for FLASH - MAIN/ALTERNATIVE -> PRIMARY/SECONDARY
#define PSD_VM_PRI_CODE   PSD_VM_MAIN_CODE
#define PSD_VM_SEC_CODE   PSD_VM_ALT_CODE
#define PSD_VM_PRI_XDATA  PSD_VM_MAIN_XDATA
#define PSD_VM_SEC_XDATA  PSD_VM_ALT_XDATA

#endif

#endif //REG_UPSD32XX_H
/*-------------------------------------------------------------------------
   p89v66x.h - This header allows to use the microcontroler NXP
   (formerly Philips) p89v66x where x stands for 0,2,4.

   Copyright (C) 2008, Gudjon I. Gudjonsson <gudjon AT gudjon.org>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------
 The registered are ordered in the same way as in the NXP data sheet:
 http://www.standardics.nxp.com/products/80c51/datasheet/p89v660.p89v662.p89v664.pdf
-------------------------------------------------------------------------*/

#ifndef __P89V66X_H__
#define __P89V66X_H__
#include <compiler.h>

/*BYTE Registers*/
SFR(ACC, 0xE0); // Accumulator
	SBIT(ACC_7, 0xE0, 7);
	SBIT(ACC_6, 0xE0, 6);
	SBIT(ACC_5, 0xE0, 5);
	SBIT(ACC_4, 0xE0, 4);
	SBIT(ACC_3, 0xE0, 3);
	SBIT(ACC_2, 0xE0, 2);
	SBIT(ACC_1, 0xE0, 1);
	SBIT(ACC_0, 0xE0, 0);
SFR(AUXR, 0x8E); // Auxiliary
	#define  EXTRAM   0x02
	#define  AO       0x01
SFR(AUXR1, 0xA2); // Auxiliary 1
	#define  ENBOOT   0x20
	#define  GF2      0x08
	// Bit 2 must be zero
	#define  DPS      0x01
SFR(B, 0xF0); // B register
	SBIT(B7, 0xF0, 7);
	SBIT(B6, 0xF0, 6);
	SBIT(B5, 0xF0, 5);
	SBIT(B4, 0xF0, 4);
	SBIT(B3, 0xF0, 3);
	SBIT(B2, 0xF0, 2);
	SBIT(B1, 0xF0, 1);
	SBIT(B0, 0xF0, 0);
SFR(CCAP0H, 0xFA); // Module 0 Capture High
SFR(CCAP1H, 0xFB); // Module 1 Capture High
SFR(CCAP2H, 0xFC); // Module 2 Capture High
SFR(CCAP3H, 0xFD); // Module 3 Capture High
SFR(CCAP4H, 0xFE); // Module 4 Capture High
SFR(CCAP0L, 0xEA); // Module 0 Capture Low
SFR(CCAP1L, 0xEB); // Module 1 Capture Low
SFR(CCAP2L, 0xEC); // Module 2 Capture Low
SFR(CCAP3L, 0xED); // Module 3 Capture Low
SFR(CCAP4L, 0xEE); // Module 4 Capture Low
SFR(CCAPM0, 0xC2); // Module 0 Mode
	#define ECOM_0   0x40
	#define CAPP_0   0x20
	#define CAPN_0   0x10
	#define  MAT_0   0x08
	#define  TOG_0   0x04
	#define  PWM_0   0x02
	#define ECCF_0   0x01
SFR(CCAPM1, 0xC3); // Module 1 Mode
	#define ECOM_1   0x40
	#define CAPP_1   0x20
	#define CAPN_1   0x10
	#define  MAT_1   0x08
	#define  TOG_1   0x04
	#define  PWM_1   0x02
	#define ECCF_1   0x01
SFR(CCAPM2, 0xC4); // Module 2 Mode
	#define ECOM_2   0x40
	#define CAPP_2   0x20
	#define CAPN_2   0x10
	#define  MAT_2   0x08
	#define  TOG_2   0x04
	#define  PWM_2   0x02
	#define ECCF_2   0x01
SFR(CCAPM3, 0xC5); // Module 3 Mode
	#define ECOM_3   0x40
	#define CAPP_3   0x20
	#define CAPN_3   0x10
	#define  MAT_3   0x08
	#define  TOG_3   0x04
	#define  PWM_3   0x02
	#define ECCF_3   0x01
SFR(CCAPM4, 0xC6); // Module 4 Mode
	#define ECOM_4   0x40
	#define CAPP_4   0x20
	#define CAPN_4   0x10
	#define  MAT_4   0x08
	#define  TOG_4   0x04
	#define  PWM_4   0x02
	#define ECCF_4   0x01
	#define ECOM     0x40
	#define CAPP     0x20
	#define CAPN     0x10
	#define MAT      0x08
	#define TOG      0x04
	#define PWM      0x02
	#define ECCF     0x01
SFR(CCON,   0xC0); // PCA Counter Control
	SBIT(CF,   0xC0, 7);
	SBIT(CR,   0xC0, 6);
	SBIT(CCF4, 0xC0, 4);
	SBIT(CCF3, 0xC0, 3);
	SBIT(CCF2, 0xC0, 2);
	SBIT(CCF1, 0xC0, 1);
	SBIT(CCF0, 0xC0, 0);
SFR(CH,   0xF9); // PCA Counter High
SFR(CL,   0xE9); // PCA Counter Low
SFR(CMOD, 0xC1); // PCA Counter Mode
	#define CIDL    0x80
	#define WDTE    0x40
	#define CPS1    0x04
	#define CPS0    0x02
	#define  ECF    0x01
SFR(DPH,  0x83); // Data Pointer High
SFR(DPL,  0x82); // Data Pointer Low
SFR(IEN0, 0xA8); // Interrupt Enable 0
	SBIT(EA,  0xA8, 7);
	SBIT(EC,  0xA8, 6);
	SBIT(ES1, 0xA8, 5);
	SBIT(ES0, 0xA8, 4);
	SBIT(ET1, 0xA8, 3);
	SBIT(EX1, 0xA8, 2);
	SBIT(ET0, 0xA8, 1);
	SBIT(EX0, 0xA8, 0);
SFR(IEN1, 0xE8); // Interrupt Enable 1
	SBIT(ES3, 0xE8, 2);
	SBIT(ES2, 0xE8, 1);
	SBIT(ET2, 0xE8, 0);
SFR(IP0, 0xB8); // Interrupt Priority 0
	SBIT(PT2, 0xB8, 7);
	SBIT(PPC, 0xB8, 6);
	SBIT(PS1, 0xB8, 5);
	SBIT(PS0, 0xB8, 4);
	SBIT(PT1, 0xB8, 3);
	SBIT(PX1, 0xB8, 2);
	SBIT(PT0, 0xB8, 1);
	SBIT(PX0, 0xB8, 0);
SFR(IP0H, 0xB7); // Interrupt Priority 0 High
	#define PT2H  0x80
	#define PPCH  0x40
	#define PS1H  0x20
	#define PS0H  0x10
	#define PT1H  0x08
	#define PX1H  0x04
	#define PT0H  0x02
	#define PX0H  0x01
SFR(IP1, 0x91); // Interrupt Priority 1
	#define PS3  0x02
	#define PS2  0x01
SFR(IP1H, 0x92); // Interrupt Priority 1 High
	#define PS3H  0x02
	#define PS2H  0x01
SFR(P0, 0x80); // Port 0
	SBIT(AD7,  0x80, 7);
	SBIT(P0_7, 0x80, 7);
	SBIT(AD6,  0x80, 6);
	SBIT(P0_6, 0x80, 6);
	SBIT(AD5,  0x80, 5);
	SBIT(P0_5, 0x80, 5);
	SBIT(AD4,  0x80, 4);
	SBIT(P0_4, 0x80, 4);
	SBIT(AD3,  0x80, 3);
	SBIT(P0_3, 0x80, 3);
	SBIT(AD2,  0x80, 2);
	SBIT(P0_2, 0x80, 2);
	SBIT(AD1,  0x80, 1);
	SBIT(P0_1, 0x80, 1);
	SBIT(AD0,  0x80, 0);
	SBIT(P0_0, 0x80, 0);
SFR(P1, 0x90); // Port 1
	SBIT(T1_CEX4, 0x90, 7);
	SBIT(P1_7,    0x90, 7);
	SBIT(T0_CEX3, 0x90, 6);
	SBIT(P1_6,    0x90, 6);
	SBIT(CEX2,    0x90, 5);
	SBIT(P1_5,    0x90, 5);
	SBIT(CEX1,    0x90, 4);
	SBIT(P1_4,    0x90, 4);
	SBIT(CEX0,    0x90, 3);
	SBIT(P1_3,    0x90, 3);
	SBIT(ECI,     0x90, 2);
	SBIT(P1_2,    0x90, 2);
	SBIT(T2EX,    0x90, 1);
	SBIT(P1_1,    0x90, 1);
	SBIT(T2,      0x90, 0);
	SBIT(P1_0,    0x90, 0);
SFR(P2, 0xA0); // Port 2
	SBIT(AD15, 0xA0, 7);
	SBIT(P2_7, 0xA0, 7);
	SBIT(AD14, 0xA0, 6);
	SBIT(P2_6, 0xA0, 6);
	SBIT(AD13, 0xA0, 5);
	SBIT(P2_5, 0xA0, 5);
	SBIT(AD12, 0xA0, 4);
	SBIT(P2_4, 0xA0, 4);
	SBIT(AD11, 0xA0, 3);
	SBIT(P2_3, 0xA0, 3);
	SBIT(AD10, 0xA0, 2);
	SBIT(P2_2, 0xA0, 2);
	SBIT(AD9,  0xA0, 1);
	SBIT(P2_1, 0xA0, 1);
	SBIT(AD8,  0xA0, 0);
	SBIT(P2_0, 0xA0, 0);
SFR(P3, 0xB0); // Port 3
	SBIT(RD,   0xB0, 7);
	SBIT(P3_7, 0xB0, 7);
	SBIT(WR,   0xB0, 6);
	SBIT(P3_6, 0xB0, 6);
	SBIT(T1,   0xB0, 5);
	SBIT(P3_5, 0xB0, 5);
	SBIT(T0,   0xB0, 4);
	SBIT(P3_4, 0xB0, 4);
	SBIT(INT1, 0xB0, 3);
	SBIT(P3_3, 0xB0, 3);
	SBIT(INT0, 0xB0, 2);
	SBIT(P3_2, 0xB0, 2);
	SBIT(TXD,  0xB0, 1);
	SBIT(P3_1, 0xB0, 1);
	SBIT(RXD,  0xB0, 0);
	SBIT(P3_0, 0xB0, 0);
SFR(P4, 0xA1); // Port 3
	#define SS    0x08
	#define P4_3  0x08
	#define MOSI  0x04
	#define P4_2  0x04
	#define MISO  0x02
	#define SDA_1 0x02
	#define P4_1  0x02
	#define SCK   0x01
	#define SCL_1 0x01
	#define P4_0  0x01
SFR(PCON, 0x87); // Power Control
	#define SMOD1  0x80
	#define SMOD0  0x40
	#define POF    0x10
	#define GF1    0x08
	#define GF0    0x04
	#define PD     0x02
	#define IDL    0x01
SFR(PSW, 0xD0); // Program Status Word
	SBIT(CY,  0xD0, 7);
	SBIT(AC,  0xD0, 6);
	SBIT(F0,  0xD0, 5);
	SBIT(RS1, 0xD0, 4);
	SBIT(RS0, 0xD0, 3);
	SBIT(OV,  0xD0, 2);
	SBIT(F1,  0xD0, 1);
	SBIT(P,   0xD0, 0);
SFR(RCAP2H, 0xCB); // Timer 2 Capture High
SFR(RCAP2L, 0xCA); // Timer 2 Capture Low
SFR(S0CON,  0x98); // Serial Control 
	SBIT(SM0_FE,0x98, 7);
	SBIT(SM1,   0x98, 6);
	SBIT(SM2,   0x98, 5);
	SBIT(REN,   0x98, 4);
	SBIT(TB8,   0x98, 3);
	SBIT(RB8,   0x98, 2);
	SBIT(TI,    0x98, 1);
	SBIT(RI,    0x98, 0);
SFR(S0BUF, 0x99); // Serial Data Buffer
SFR(SADDR, 0xA9); // I2C Slave Address
SFR(SADEN, 0xB9); // I2C Slave Address Mask
SFR(SPCR,  0xD5); // SPI Control Register
	#define SPIE  0x80
	#define SPEN  0x40
	#define DORD  0x20
	#define MSTR  0x10
	#define CPOL  0x08
	#define CPHA  0x04
	#define SPR1  0x02
	#define SPR0  0x01
/*	SBIT(SPIE,   0x80, 7);   // SPCR is not bit addressable, not yet at least, according to the manual.
	SBIT(SPEN,   0x80, 6);
	SBIT(DORD,   0x80, 5);
	SBIT(MSTR,   0x80, 4);
	SBIT(CPOL,   0x80, 3);
	SBIT(CPHA,   0x80, 2);
	SBIT(SPR1,   0x80, 1);
	SBIT(SPR0,   0x80, 0);*/
SFR(SPSR,  0xAA); // SPI Configuration Register
	#define SPIF  0x80
	#define WCOL  0x40
SFR(SPDAT, 0x86); // SPI Data
SFR(SP,    0x81); // Stack Pointer
SFR(S1DAT, 0xDA); // I2C Serial 1 Data
SFR(S1ADR, 0xDB); // I2C Serial 1 Address 
	#define S1ADR_6  0x80
	#define S1ADR_5  0x40
	#define S1ADR_4  0x20
	#define S1ADR_3  0x10
	#define S1ADR_2  0x08
	#define S1ADR_1  0x04
	#define S1ADR_0  0x02
	#define S1GC     0x01
SFR(S1STA, 0xD9); // I2C Serial 1 Status 
	#define SC4  0x80
	#define SC3  0x40
	#define SC2  0x20
	#define SC1  0x10
	#define SC0  0x08    // Only write 0 to the lowest three bits
SFR(S1CON, 0xD8); // I2C Serial 1 Control
	SBIT(CR2,  0xD8, 7);
	SBIT(ENS1, 0xD8, 6);
	SBIT(STA,  0xD8, 5);
	SBIT(STO,  0xD8, 4);
	SBIT(SI,   0xD8, 3);
	SBIT(AA,   0xD8, 2);
	SBIT(CR1,  0xD8, 1);
	SBIT(CR0,  0xD8, 0);
SFR(S2DAT, 0xE2); // I2C Serial 1 Data
SFR(S2ADR, 0xE3); // I2C Serial 1 Address 
	#define S2ADR_6  0x80
	#define S2ADR_5  0x40
	#define S2ADR_4  0x20
	#define S2ADR_3  0x10
	#define S2ADR_2  0x08
	#define S2ADR_1  0x04
	#define S2ADR_0  0x02
	#define S2GC     0x01
SFR(S2STA, 0xE1); // I2C Serial 1 Status 
	#define SC24  0x80
	#define SC23  0x40
	#define SC22  0x20
	#define SC21  0x10
	#define SC20  0x08  // Only write 0 to the lowest three bits
SFR(S2CON, 0xF8); // I2C Serial 1 Control
	SBIT(CR22,  0xF8, 7);
	SBIT(ENS21, 0xF8, 6);
	SBIT(STA2,  0xF8, 5);
	SBIT(STO2,  0xF8, 4);
	SBIT(SI2,   0xF8, 3);
	SBIT(AA2,   0xF8, 2);
	SBIT(CR21,  0xF8, 1);
	SBIT(CR20,  0xF8, 0);
SFR(TCON, 0x88); // Timer Control
	SBIT(TF1, 0x88, 7);
	SBIT(TR1, 0x88, 6);
	SBIT(TF0, 0x88, 5);
	SBIT(TR0, 0x88, 4);
	SBIT(IE1, 0x88, 3);
	SBIT(IT1, 0x88, 2);
	SBIT(IE0, 0x88, 1);
	SBIT(IT0, 0x88, 0);
SFR(T2CON, 0xC8); // Timer 2 Control
	SBIT(TF2,    0xC8, 7);
	SBIT(EXF2,   0xC8, 6);
	SBIT(RCLK,   0xC8, 5);
	SBIT(TCLK,   0xC8, 4);
	SBIT(EXEN2,  0xC8, 3);
	SBIT(TR2,    0xC8, 2);
	SBIT(C_T2,   0xC8, 1);
	SBIT(CP_RL2, 0xC8, 0);
SFR(T2MOD,  0xC9); // Timer 2 Mode Control
	#define ENT2  0x20
	#define T2OE  0x02
	#define DCEN  0x01
SFR(TH0,  0x8C); // Timer High 0
SFR(TH1,  0x8D); // Timer High 1
SFR(TH2,  0xCD); // Timer High 2
SFR(TL0,  0x8A); // Timer Low 0
SFR(TL1,  0x8B); // Timer Low 1
SFR(TL2,  0xCC); // Timer Low 2
SFR(TMOD, 0x89); // Timer Mode
	#define GATE_1  0x80
	#define  C_T_1  0x40
	#define   M1_1  0x20
	#define   M0_1  0x10
	#define GATE_0  0x08
	#define  C_T_0  0x04
	#define   M1_0  0x02
	#define   M0_0  0x01
SFR(WDTRST, 0xA6); // Watchdog Timer Reset

#endif  //__P89V66X_H__
/*-------------------------------------------------------------------------
   compiler.h

   Copyright (C) 2006, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

 /*
  * Header file to overcome 8051 compiler differences for specifying
  * special function registers. The following compilers are supported:
  * SDCC, Keil, Raisonance, IAR, Hi-Tech, Tasking, Crossware, Wickenhaeuser.
  * Unfortunately not for use with Dunfield. The compilers are identified by
  * their unique predefined macros. See also:
  * http://predef.sourceforge.net/precomp.html
  *
  * SBIT and SFR define special bit and special function registers at the given
  * address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  * little-endian format. SFR16E and SFR32E define sfr combinations without
  * prerequisite byte order or adjacency. None of these multi-byte sfr
  * combinations will guarantee the order in which they are accessed when read
  * or written.
  * SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  * to avoid portability issues because of compiler endianness.
  * This file is to be included in every microcontroller specific header file.
  * Example:
  *
  * // my_mcu.h: sfr definitions for my mcu
  * #include <compiler.h>
  *
  * SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  *
  * SFR   (P0, 0x80);           // Port 0
  *
  * SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in xdata memory at 0xE600
  *
  * SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  *
  * SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  *
  * SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator, lsb at 0x93, msb at 0x96
  *
  * SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register, lsb at 0xE2, msb at 0xE5
  *
 */

#ifndef COMPILER_H
#define COMPILER_H

/** SDCC - Small Device C Compiler
  * http://sdcc.sf.net
 */
#if defined (SDCC) || defined (__SDCC)
# define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                    name
# define SFR(name, addr)        __sfr   __at(addr)                        name
# define SFRX(name, addr)       __xdata volatile unsigned char __at(addr) name
# define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)       name
# define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                    name
# define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr) name
# define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                    name

/** Keil C51
  * http://www.keil.com
 */
#elif defined __CX51__
# define SBIT(name, addr, bit)  sbit  name = addr^bit
# define SFR(name, addr)        sfr   name = addr
# define SFRX(name, addr)       volatile unsigned char xdata name _at_ addr
# define SFR16(name, addr)      sfr16 name = addr
# define SFR16E(name, fulladdr) /* not supported */
# define SFR32(name, fulladdr)  /* not supported */
# define SFR32E(name, fulladdr) /* not supported */

/** Raisonance
  * http://www.raisonance.com
 */
#elif defined __RC51__
# define SBIT(name, addr, bit)  at (addr+bit) sbit                   name
# define SFR(name, addr)        sfr at addr                          name
# define SFRX(name, addr)       xdata at addr volatile unsigned char name
# define SFR16(name, addr)      sfr16 at addr                        name
# define SFR16E(name, fulladdr) /* not supported */
# define SFR32(name, fulladdr)  /* not supported */
# define SFR32E(name, fulladdr) /* not supported */

/** IAR 8051
  * http://www.iar.com
 */
#elif defined __ICC8051__
# define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
# define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
# define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
# define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
# define SFR16E(name, fulladdr) /* not supported */
# define SFR32(name, fulladdr)  __sfr __no_init volatile unsigned long name @ addr
# define SFR32E(name, fulladdr) /* not supported */

/** Tasking / Altium
  * http://www.altium.com/tasking
 */
#elif defined _CC51
# define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
# define SFR(name, addr)        _sfrbyte name _at(addr)
# define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
#if _CC51 > 71
# define SFR16(name, addr)      _sfrword _little name _at(addr)
#else
# define SFR16(name, addr)      /* not supported */
#endif
# define SFR16E(name, fulladdr) /* not supported */
# define SFR32(name, fulladdr)  /* not supported */
# define SFR32E(name, fulladdr) /* not supported */

/** Hi-Tech 8051
  * http://www.htsoft.com
 */
#elif defined HI_TECH_C
# define SBIT(name, addr, bit)  volatile bit           name @ (addr+bit)
# define SFR(name, addr)        volatile unsigned char name @ addr
# define SFRX(name, addr)       volatile far unsigned char name @ addr
# define SFR16(name, addr)      /* not supported */
# define SFR16E(name, fulladdr) /* not supported */
# define SFR32(name, fulladdr)  /* not supported */
# define SFR32E(name, fulladdr) /* not supported */

/** Crossware
  * http://www.crossware.com
 */
#elif defined _XC51_VER
# define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
# define SFR(name, addr)        _sfr     name = addr
# define SFRX(name, addr)       volatile unsigned char _xdata name _at addr
# define SFR16(name, addr)      _sfrword name = addr
# define SFR16E(name, fulladdr) /* not supported */
# define SFR32(name, fulladdr)  /* not supported */
# define SFR32E(name, fulladdr) /* not supported */

/** Wickenhaeuser
  * http://www.wickenhaeuser.de
 */
#elif defined __UC__
# define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
# define SFR(name, addr)        near unsigned char name @ addr
# define SFRX(name, addr)       xdata volatile unsigned char name @ addr
# define SFR16(name, addr)      /* not supported */
# define SFR16E(name, fulladdr) /* not supported */
# define SFR32(name, fulladdr)  /* not supported */
# define SFR32E(name, fulladdr) /* not supported */

/** default
  * unrecognized compiler
 */
#else
# warning unrecognized compiler
# define SBIT(name, addr, bit)  volatile bool           name
# define SFR(name, addr)        volatile unsigned char  name
# define SFRX(name, addr)       volatile unsigned char  name
# define SFR16(name, addr)      volatile unsigned short name
# define SFR16E(name, fulladdr) volatile unsigned short name
# define SFR32(name, fulladdr)  volatile unsigned long  name
# define SFR32E(name, fulladdr) volatile unsigned long  name

#endif

#endif //COMPILER_H

/*-------------------------------------------------------------------------
   p89lpc9331.h - Register Declarations for NXP  the P89LPC9331/P89LPC9341
   (Based on user manual (UM10308_3) Rev. 03  17 June 2009)

   Copyright (C) 2009, Jesus Calvino-Fraga / jesusc at ece.ubc.ca

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef REG_P89LPC9331_H
#define REG_P89LPC9331_H

#include <compiler.h>

SFR(ACC,     0xe0); // Accumulator
    SBIT(ACC_7,   0xe0, 7);
    SBIT(ACC_6,   0xe0, 6);
    SBIT(ACC_5,   0xe0, 5);
    SBIT(ACC_4,   0xe0, 4);
    SBIT(ACC_3,   0xe0, 3);
    SBIT(ACC_2,   0xe0, 2);
    SBIT(ACC_1,   0xe0, 1);
    SBIT(ACC_0,   0xe0, 0);
SFR(ADCON0,  0x8e); // A/D control register 0
    #define ENBI0    0x80
    #define ENADCI0  0x40
    #define TMM0     0x20
    #define EDGE0    0x10
    #define ADCI0    0x08
    #define ENADC0   0x04
    #define ADCS01   0x02
    #define ADCS00   0x01
SFR(ADCON1,  0x97); // A/D control register 1
    #define ENBI1    0x80
    #define ENADCI1  0x40
    #define TMM1     0x20
    #define EDGE1    0x10
    #define ADCI1    0x08
    #define ENADC1   0x04
    #define ADCS11   0x02
    #define ADCS10   0x01
SFR(ADINS,   0xa3); // A/D input select
    #define ADI13    0x80
    #define ADI12    0x40
    #define ADI11    0x20
    #define ADI10    0x10
    #define ADI03    0x08
    #define ADI02    0x04
    #define ADI01    0x02
    #define ADI00    0x01
SFR(ADMODA,  0xc0); // A/D mode register A
    SBIT(ADMODA_7, 0xc0, 7);
    SBIT(ADMODA_6, 0xc0, 6);
    SBIT(ADMODA_5, 0xc0, 5);
    SBIT(ADMODA_4, 0xc0, 4);
    SBIT(ADMODA_3, 0xc0, 3);
    SBIT(ADMODA_2, 0xc0, 2);
    SBIT(ADMODA_1, 0xc0, 1);
    SBIT(ADMODA_0, 0xc0, 0);
    SBIT(BNDI1,   0xc0, 7);
    SBIT(BURST1,  0xc0, 6);
    SBIT(SCC1,    0xc0, 5);
    SBIT(SCAN1,   0xc0, 4);
    SBIT(BNDI0,   0xc0, 3);
    SBIT(BURST0,  0xc0, 2);
    SBIT(SCC0,    0xc0, 1);
    SBIT(SCAN0,   0xc0, 0);
SFR(ADMODB,  0xa1); // A/D mode register B
    #define CLK2     0x80
    #define CLK1     0x40
    #define CLK0     0x20
    #define INBND0   0x10
    #define ENDAC1   0x08
    #define ENDAC0   0x04
    #define BSA1     0x02
    #define BSA0     0x01
SFR(AD0BH,   0xbb); // A/D_0 boundary high register
SFR(AD0BL,   0xa6); // A/D_0 boundary low register
SFR(AD0DAT0, 0xc5); // A/D_0 data register 0
SFR(AD0DAT1, 0xc6); // A/D_0 data register 1
SFR(AD0DAT2, 0xc7); // A/D_0 data register 2
SFR(AD0DAT3, 0xf4); // A/D_0 data register 3
SFR(AD1BH,   0xc4); // A/D_1 boundary high register
SFR(AD1BL,   0xbc); // A/D_1 boundary low register
SFR(AD1DAT0, 0xd5); // A/D_1 data register 0
SFR(AD1DAT1, 0xd6); // A/D_1 data register 1
SFR(AD1DAT2, 0xd7); // A/D_1 data register 2
SFR(AD1DAT3, 0xf5); // A/D_1 data register 3
SFR(AUXR1,   0xa2); // Auxiliary function register
    #define CLKLP    0x80
    #define EBRR     0x40
    #define ENT1     0x20
    #define ENT0     0x10
    #define SRST     0x08
    #define DPS      0x01
SFR(B,       0xf0); // B register
    SBIT(B_7,     0xf0, 7);
    SBIT(B_6,     0xf0, 6);
    SBIT(B_5,     0xf0, 5);
    SBIT(B_4,     0xf0, 4);
    SBIT(B_3,     0xf0, 3);
    SBIT(B_2,     0xf0, 2);
    SBIT(B_1,     0xf0, 1);
    SBIT(B_0,     0xf0, 0);
SFR(BRGR0,   0xbe); // Baud rate generator 0 rate low
SFR(BRGR1,   0xbf); // Baud rate generator 0 rate high
SFR(BRGCON,  0xbd); // Baud rate generator 0 control
    #define SBRGS    0x02
    #define BRGEN    0x01
SFR(CMP1,    0xac); // Comparator 1 control register
    #define CE1      0x20
    #define CP1      0x10
    #define CN1      0x08
    #define OE1      0x04
    #define CO1      0x02
    #define CMF1     0x01
SFR(CMP2,    0xad); // Comparator 2 control register
    #define CE2      0x20
    #define CP2      0x10
    #define CN2      0x08
    #define OE2      0x04
    #define CO2      0x02
    #define CMF2     0x01
SFR(DIVM,    0x95); // CPU clock divide-by-M control
SFR(DPH,     0x83); // Data pointer high
SFR(DPL,     0x82); // Data pointer low
SFR(FMADRH,  0xe7); // Program flash address high
SFR(FMADRL,  0xe6); // Program flash address low
SFR(FMCON,   0xe4); // Program flash control Read
    #define BUSY     0x80
    #define HVA      0x08
    #define HVE      0x04
    #define SV       0x02
    #define OI       0x01
    #define FMCMD_7  0x80
    #define FMCMD_6  0x40
    #define FMCMD_5  0x20
    #define FMCMD_4  0x10
    #define FMCMD_3  0x08
    #define FMCMD_2  0x04
    #define FMCMD_1  0x02
    #define FMCMD_0  0x01
SFR(FMDATA,  0xe5); // Program flash data
SFR(I2ADR,   0xdb); // I2C-bus slave address register
    #define I2ADR_6  0x80
    #define I2ADR_5  0x40
    #define I2ADR_4  0x20
    #define I2ADR_3  0x10
    #define I2ADR_2  0x08
    #define I2ADR_1  0x04
    #define I2ADR_0  0x02
    #define GC       0x01
SFR(I2CON,   0xd8); // I2C-bus control register
    SBIT(I2CON_7, 0xd8, 7);
    SBIT(I2CON_6, 0xd8, 6);
    SBIT(I2CON_5, 0xd8, 5);
    SBIT(I2CON_4, 0xd8, 4);
    SBIT(I2CON_3, 0xd8, 3);
    SBIT(I2CON_2, 0xd8, 2);
    SBIT(I2CON_1, 0xd8, 1);
    SBIT(I2CON_0, 0xd8, 0);
    SBIT(I2EN,    0xd8, 6);
    SBIT(STA,     0xd8, 5);
    SBIT(STO,     0xd8, 4);
    SBIT(SI,      0xd8, 3);
    SBIT(AA,      0xd8, 2);
    SBIT(CRSEL,   0xd8, 0);
SFR(I2DAT,   0xda); // I2C-bus data register
SFR(I2SCLH,  0xdd); // Serial clock generator/SCL duty cycle register high
SFR(I2SCLL,  0xdc); // Serial clock generator/SCL duty cycle register low
SFR(I2STAT,  0xd9); // I2C-bus status register
    #define STA_4    0x80
    #define STA_3    0x40
    #define STA_2    0x20
    #define STA_1    0x10
    #define STA_0    0x08
SFR(IEN0,    0xa8); // Interrupt enable 0
    SBIT(IEN0_7,  0xa8, 7);
    SBIT(IEN0_6,  0xa8, 6);
    SBIT(IEN0_5,  0xa8, 5);
    SBIT(IEN0_4,  0xa8, 4);
    SBIT(IEN0_3,  0xa8, 3);
    SBIT(IEN0_2,  0xa8, 2);
    SBIT(IEN0_1,  0xa8, 1);
    SBIT(IEN0_0,  0xa8, 0);
    SBIT(EA,      0xa8, 7);
    SBIT(EWDRT,   0xa8, 6);
    SBIT(EBO,     0xa8, 5);
    SBIT(ES,      0xa8, 4);
    SBIT(ESR,     0xa8, 4);
    SBIT(ET1,     0xa8, 3);
    SBIT(EX1,     0xa8, 2);
    SBIT(ET0,     0xa8, 1);
    SBIT(EX0,     0xa8, 0);
SFR(IEN1,    0xe8); // Interrupt enable 1
    SBIT(IEN1_7,  0xe8, 7);
    SBIT(IEN1_6,  0xe8, 6);
    SBIT(IEN1_5,  0xe8, 5);
    SBIT(IEN1_4,  0xe8, 4);
    SBIT(IEN1_3,  0xe8, 3);
    SBIT(IEN1_2,  0xe8, 2);
    SBIT(IEN1_1,  0xe8, 1);
    SBIT(IEN1_0,  0xe8, 0);
    SBIT(EAD,     0xe8, 7);
    SBIT(EST,     0xe8, 6);
    SBIT(ESPI,    0xe8, 3);
    SBIT(EC,      0xe8, 2);
    SBIT(EKBI,    0xe8, 1);
    SBIT(EI2C,    0xe8, 0);
SFR(IP0,     0xb8); // Interrupt priority 0
    SBIT(IP0_7,   0xb8, 7);
    SBIT(IP0_6,   0xb8, 6);
    SBIT(IP0_5,   0xb8, 5);
    SBIT(IP0_4,   0xb8, 4);
    SBIT(IP0_3,   0xb8, 3);
    SBIT(IP0_2,   0xb8, 2);
    SBIT(IP0_1,   0xb8, 1);
    SBIT(IP0_0,   0xb8, 0);
    SBIT(PWDRT,   0xb8, 6);
    SBIT(PBO,     0xb8, 5);
    SBIT(PS,      0xb8, 4);
    SBIT(PSR,     0xb8, 4);
    SBIT(PT1,     0xb8, 3);
    SBIT(PX1,     0xb8, 2);
    SBIT(PT0,     0xb8, 1);
    SBIT(PX0,     0xb8, 0);
SFR(IP0H,    0xb7); // Interrupt priority 0 high
    #define PWDRTH   0x40
    #define PBOH     0x20
    #define PSH      0x10
    #define PSRH     0x10
    #define PT1H     0x08
    #define PX1H     0x04
    #define PT0H     0x02
    #define PX0H     0x01
SFR(IP1,     0xf8); // Interrupt priority 1
    SBIT(IP1_7,   0xf8, 7);
    SBIT(IP1_6,   0xf8, 6);
    SBIT(IP1_5,   0xf8, 5);
    SBIT(IP1_4,   0xf8, 4);
    SBIT(IP1_3,   0xf8, 3);
    SBIT(IP1_2,   0xf8, 2);
    SBIT(IP1_1,   0xf8, 1);
    SBIT(IP1_0,   0xf8, 0);
    SBIT(PAD,     0xf8, 7);
    SBIT(PST,     0xf8, 6);
    SBIT(PSPI,    0xf8, 3);
    SBIT(PC,      0xf8, 2);
    SBIT(PKBI,    0xf8, 1);
    SBIT(PI2C,    0xf8, 0);
SFR(IP1H,    0xf7); // Interrupt priority 1 high
    #define PADH     0x80
    #define PSTH     0x40
    #define PSPIH    0x08
    #define PCH      0x04
    #define PKBIH    0x02
    #define PI2CH    0x01
SFR(KBCON,   0x94); // Keypad control register
    #define PATN     0x02
    #define _SEL     0x01
SFR(KBMASK,  0x86); // Keypad interrupt mask register
SFR(KBPATN,  0x93); // Keypad pattern register
SFR(P0,      0x80); // Port 0
    SBIT(P0_7,    0x80, 7);
    SBIT(P0_6,    0x80, 6);
    SBIT(P0_5,    0x80, 5);
    SBIT(P0_4,    0x80, 4);
    SBIT(P0_3,    0x80, 3);
    SBIT(P0_2,    0x80, 2);
    SBIT(P0_1,    0x80, 1);
    SBIT(P0_0,    0x80, 0);
    SBIT(T1,      0x80, 7);
    SBIT(KB7,     0x80, 7);
    SBIT(CMP_1,   0x80, 6);
    SBIT(KB6,     0x80, 6);
    SBIT(CMPREF,  0x80, 5);
    SBIT(KB5,     0x80, 5);
    SBIT(CIN1A,   0x80, 4);
    SBIT(KB4,     0x80, 4);
    SBIT(CIN1B,   0x80, 3);
    SBIT(KB3,     0x80, 3);
    SBIT(CIN2A,   0x80, 2);
    SBIT(KB2,     0x80, 2);
    SBIT(CIN2B,   0x80, 1);
    SBIT(KB1,     0x80, 1);
    SBIT(CMP_2,   0x80, 0);
    SBIT(KB0,     0x80, 0);
SFR(P1,      0x90); // Port 1
    SBIT(P1_7,    0x90, 7);
    SBIT(P1_6,    0x90, 6);
    SBIT(P1_5,    0x90, 5);
    SBIT(P1_4,    0x90, 4);
    SBIT(P1_3,    0x90, 3);
    SBIT(P1_2,    0x90, 2);
    SBIT(P1_1,    0x90, 1);
    SBIT(P1_0,    0x90, 0);
    SBIT(RST,     0x90, 5);
    SBIT(INT1,    0x90, 4);
    SBIT(INT0,    0x90, 3);
    SBIT(SDA,     0x90, 3);
    SBIT(T0,      0x90, 2);
    SBIT(SCL,     0x90, 2);
    SBIT(RXD,     0x90, 1);
    SBIT(TXD,     0x90, 0);
SFR(P2,      0xa0); // Port 2
    SBIT(P2_7,    0xa0, 7);
    SBIT(P2_6,    0xa0, 6);
    SBIT(P2_5,    0xa0, 5);
    SBIT(P2_4,    0xa0, 4);
    SBIT(P2_3,    0xa0, 3);
    SBIT(P2_2,    0xa0, 2);
    SBIT(P2_1,    0xa0, 1);
    SBIT(P2_0,    0xa0, 0);
    SBIT(SPICLK,  0xa0, 5);
    SBIT(SS,      0xa0, 4);
    SBIT(MISO,    0xa0, 3);
    SBIT(MOSI,    0xa0, 2);
SFR(P3,      0xb0); // Port 3
    SBIT(P3_7,    0xb0, 7);
    SBIT(P3_6,    0xb0, 6);
    SBIT(P3_5,    0xb0, 5);
    SBIT(P3_4,    0xb0, 4);
    SBIT(P3_3,    0xb0, 3);
    SBIT(P3_2,    0xb0, 2);
    SBIT(P3_1,    0xb0, 1);
    SBIT(P3_0,    0xb0, 0);
    SBIT(XTAL1,   0xb0, 1);
    SBIT(XTAL2,   0xb0, 0);
SFR(P0M1,    0x84); // Port 0 output mode 1
    #define P0M1_7   0x80
    #define P0M1_6   0x40
    #define P0M1_5   0x20
    #define P0M1_4   0x10
    #define P0M1_3   0x08
    #define P0M1_2   0x04
    #define P0M1_1   0x02
    #define P0M1_0   0x01
SFR(P0M2,    0x85); // Port 0 output mode 2
    #define P0M2_7   0x80
    #define P0M2_6   0x40
    #define P0M2_5   0x20
    #define P0M2_4   0x10
    #define P0M2_3   0x08
    #define P0M2_2   0x04
    #define P0M2_1   0x02
    #define P0M2_0   0x01
SFR(P1M1,    0x91); // Port 1 output mode 1
    #define P1M1_7   0x80
    #define P1M1_6   0x40
    #define P1M1_4   0x10
    #define P1M1_3   0x08
    #define P1M1_2   0x04
    #define P1M1_1   0x02
    #define P1M1_0   0x01
SFR(P1M2,    0x92); // Port 1 output mode 2
    #define P1M2_7   0x80
    #define P1M2_6   0x40
    #define P1M2_4   0x10
    #define P1M2_3   0x08
    #define P1M2_2   0x04
    #define P1M2_1   0x02
    #define P1M2_0   0x01
SFR(P2M1,    0xa4); // Port 2 output mode 1
    #define P2M1_7   0x80
    #define P2M1_6   0x40
    #define P2M1_5   0x20
    #define P2M1_4   0x10
    #define P2M1_3   0x08
    #define P2M1_2   0x04
    #define P2M1_1   0x02
    #define P2M1_0   0x01
SFR(P2M2,    0xa5); // Port 2 output mode 2
    #define P2M2_7   0x80
    #define P2M2_6   0x40
    #define P2M2_5   0x20
    #define P2M2_4   0x10
    #define P2M2_3   0x08
    #define P2M2_2   0x04
    #define P2M2_1   0x02
    #define P2M2_0   0x01
SFR(P3M1,    0xb1); // Port 3 output mode 1
    #define P3M1_1   0x02
    #define P3M1_0   0x01
SFR(P3M2,    0xb2); // Port 3 output mode 2
    #define P3M2_1   0x02
    #define P3M2_0   0x01
SFR(PCON,    0x87); // Power control register
    #define SMOD1    0x80
    #define SMOD0    0x40
    #define BOI      0x10
    #define GF1      0x08
    #define GF0      0x04
    #define PMOD1    0x02
    #define PMOD0    0x01
SFR(PCONA,   0xb5); // Power control register A
    #define RTCPD    0x80
    #define VCPD     0x20
    #define ADPD     0x10
    #define I2PD     0x08
    #define SPPD     0x04
    #define SPD      0x02
SFR(PSW,     0xd0); // Programstatus word
    SBIT(PSW_7,   0xd0, 7);
    SBIT(PSW_6,   0xd0, 6);
    SBIT(PSW_5,   0xd0, 5);
    SBIT(PSW_4,   0xd0, 4);
    SBIT(PSW_3,   0xd0, 3);
    SBIT(PSW_2,   0xd0, 2);
    SBIT(PSW_1,   0xd0, 1);
    SBIT(PSW_0,   0xd0, 0);
    SBIT(CY,      0xd0, 7);
    SBIT(AC,      0xd0, 6);
    SBIT(F0,      0xd0, 5);
    SBIT(RS1,     0xd0, 4);
    SBIT(RS0,     0xd0, 3);
    SBIT(OV,      0xd0, 2);
    SBIT(F1,      0xd0, 1);
    SBIT(P,       0xd0, 0);
SFR(PT0AD,   0xf6); // Port 0 digital input disable
    #define PT0AD_5  0x20
    #define PT0AD_4  0x10
    #define PT0AD_3  0x08
    #define PT0AD_2  0x04
    #define PT0AD_1  0x02
SFR(RSTSRC,  0xdf); // Reset source register
    #define BOIF     0x40
    #define BOF      0x20
    #define POF      0x10
    #define R_BK     0x08
    #define R_WD     0x04
    #define R_SF     0x02
    #define R_EX     0x01
SFR(RTCCON,  0xd1); // RTC control
    #define RTCF     0x80
    #define RTCS1    0x40
    #define RTCS0    0x20
    #define ERTC     0x02
    #define RTCEN    0x01
SFR(RTCH,    0xd2); // RTC register high
SFR(RTCL,    0xd3); // RTC register low
SFR(SADDR,   0xa9); // Serial port address register
SFR(SADEN,   0xb9); // Serial port address enable
SFR(SBUF,    0x99); // Serial Port data buffer register
SFR(SCON,    0x98); // Serial port control
    SBIT(SCON_7,  0x98, 7);
    SBIT(SCON_6,  0x98, 6);
    SBIT(SCON_5,  0x98, 5);
    SBIT(SCON_4,  0x98, 4);
    SBIT(SCON_3,  0x98, 3);
    SBIT(SCON_2,  0x98, 2);
    SBIT(SCON_1,  0x98, 1);
    SBIT(SCON_0,  0x98, 0);
    SBIT(SM0,     0x98, 7);
    SBIT(FE,      0x98, 7);
    SBIT(SM1,     0x98, 6);
    SBIT(SM2,     0x98, 5);
    SBIT(REN,     0x98, 4);
    SBIT(TB8,     0x98, 3);
    SBIT(RB8,     0x98, 2);
    SBIT(TI,      0x98, 1);
    SBIT(RI,      0x98, 0);
SFR(SSTAT,   0xba); // Serial port extended status register
    #define DBMOD    0x80
    #define INTLO    0x40
    #define CIDIS    0x20
    #define DBISEL   0x10
    #define FE       0x08
    #define BR       0x04
    #define OE       0x02
    #define STINT    0x01
SFR(SP,      0x81); // Stack pointer
SFR(SPCTL,   0xe2); // SPI control register
    #define SSIG     0x80
    #define SPEN     0x40
    #define DORD     0x20
    #define MSTR     0x10
    #define CPOL     0x08
    #define CPHA     0x04
    #define SPR1     0x02
    #define SPR0     0x01
SFR(SPSTAT,  0xe1); // SPI status register
    #define SPIF     0x80
    #define WCOL     0x40
SFR(SPDAT,   0xe3); // SPI data register
SFR(TAMOD,   0x8f); // Timer 0 and 1 auxiliary mode
    #define T1M2     0x10
    #define T0M2     0x01
SFR(TCON,    0x88); // Timer 0 and 1 control
    SBIT(TCON_7,  0x88, 7);
    SBIT(TCON_6,  0x88, 6);
    SBIT(TCON_5,  0x88, 5);
    SBIT(TCON_4,  0x88, 4);
    SBIT(TCON_3,  0x88, 3);
    SBIT(TCON_2,  0x88, 2);
    SBIT(TCON_1,  0x88, 1);
    SBIT(TCON_0,  0x88, 0);
    SBIT(TF1,     0x88, 7);
    SBIT(TR1,     0x88, 6);
    SBIT(TF0,     0x88, 5);
    SBIT(TR0,     0x88, 4);
    SBIT(IE1,     0x88, 3);
    SBIT(IT1,     0x88, 2);
    SBIT(IE0,     0x88, 1);
    SBIT(IT0,     0x88, 0);
SFR(TH0,     0x8c); // Timer 0 high
SFR(TH1,     0x8d); // Timer 1 high
SFR(TL0,     0x8a); // Timer 0 low
SFR(TL1,     0x8b); // Timer 1 low
SFR(TMOD,    0x89); // Timer 0 and 1 mode
    #define T1GATE   0x80
    #define T1C_T    0x40
    #define T1M1     0x20
    #define T1M0     0x10
    #define T0GATE   0x08
    #define T0C_T    0x04
    #define T0M1     0x02
    #define T0M0     0x01
SFR(TRIM,    0x96); // Internal oscillator trim register
    #define RCCLK    0x80
    #define ENCLK    0x40
    #define TRIM_5   0x20
    #define TRIM_4   0x10
    #define TRIM_3   0x08
    #define TRIM_2   0x04
    #define TRIM_1   0x02
    #define TRIM_0   0x01
SFR(WDCON,   0xa7); // Watchdog control register
    #define PRE2     0x80
    #define PRE1     0x40
    #define PRE0     0x20
    #define WDRUN    0x04
    #define WDTOF    0x02
    #define WDCLK    0x01
SFR(WDL,     0xc1); // Watchdog load
SFR(WFEED1,  0xc2); // Watchdog feed 1
SFR(WFEED2,  0xc3); // Watchdog feed 2
SFRX(BODCFG,  0xffc8); // BOD configuration register
    #define BOICFG1  0x02
    #define BOICFG0  0x01
SFRX(CLKCON,  0xffde); // CLOCK Control register
    #define CLKOK    0x80
    #define XTALWD   0x10
    #define CLKDBL   0x08
    #define FOSC2    0x04
    #define FOSC1    0x02
    #define FOSC0    0x01
SFRX(TPSCON,  0xffca); // Temperature sensor control register
    #define TSEL1    0x08
    #define TSEL0    0x04
SFRX(RTCDATH, 0xffbf); // Real-time clock data register high
SFRX(RTCDATL, 0xffbe); // Real-time clock data register low
#endif /*REG_P89LPC9331_H*/
/*-------------------------------------------------------------------------
   at89c51ed2.h: Register Declarations for the Atmel AT89C51RD2/ED2 Processor

   Copyright (C) 2005, Jesus Calvino-Fraga / jesusc at ece.ubc.ca

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef REG_AT89C51ED2_H
#define REG_AT89C51ED2_H

#include <8052.h>     // Load definitions for the 8052

#ifdef REG8052_H
#undef REG8052_H
#endif

// Define AT89C51RD2/ED2 specific registers only

__sfr __at (0x8E) AUXR;		//Auxiliary function register
	#define DPU  0x80		//'1'=Disables weak pull-up
	#define M0   0x20		//'1'=Strechs MOVX control signals
	#define XRS2 0x10		// XRAM select bit 2
	#define XRS1 0x08		// XRAM select bit 1
	#define XRS0 0x04		// XRAM select bit 0
     	// XRS2 XRS1 XRS2  XRAM Size
	    //  0    0    0    256  bytes
    	//  0    0    1    512  bytes
	    //  0    1    0    768  bytes (default)
    	//  0    1    1    1024 bytes
    	//  1    0    0    1792 bytes
	#define EXTRAM 0x02		//'0'=uses internal XRAM.
	#define AO 0x01			//'1'=Disables ALE generation.

__sfr __at (0xA2) AUXR1;	//Auxiliary function register 1
    #define ENBOOT 0x20     //'0'=Disables boot ROM
	#define GF3 0x08		//General purpose user-defined flag.
	#define DPS 0x01		//Data pointer select.

__sfr __at (0x97) CKRL;     //Clock Reload Register
__sfr __at (0x8F) CKCON0;   //Clock control Register 0
    #define WDTX2 0x40      //Watch Dog Clock speed '1'=12 ck/cy, '0'=6 ck/cy
    #define PCAX2 0x20      //Programmable Counter Array Clock speed '1'=12 ck/cy, '0'=6 ck/cy
    #define SIX2  0x10      //Enhanced UART Clock (Mode 0 and 2) speed '1'=12 ck/cy, '0'=6 ck/cy
    #define T2X2  0x08      //Timer2 Clock speed '1'=12 ck/cy, '0'=6 ck/cy
    #define T1X2  0x04      //Timer1 Clock speed '1'=12 ck/cy, '0'=6 ck/cy
    #define T0X2  0x02      //Timer0 Clock speed '1'=12 ck/cy, '0'=6 ck/cy
    #define X2    0x01      //CPU Clock '0'=12 ck/cy, '1'=6 ck/cy
__sfr __at (0xAF) CKCON1;   //Clock control Register 1
    #define XPIX2 0x01      //SPI Clock speed '1'=12 ck/cy, '0'=6 ck/cy

__sfr __at (0xFA) CCAP0H;	//Module 0 Capture HIGH.
__sfr __at (0xFB) CCAP1H;	//Module 1 Capture HIGH.
__sfr __at (0xFC) CCAP2H;	//Module 2 Capture HIGH.
__sfr __at (0xFD) CCAP3H;	//Module 3 Capture HIGH.
__sfr __at (0xFE) CCAP4H;	//Module 4 Capture HIGH.
__sfr __at (0xEA) CCAP0L;	//Module 0 Capture LOW.
__sfr __at (0xEB) CCAP1L;	//Module 1 Capture LOW.
__sfr __at (0xEC) CCAP2L;	//Module 2 Capture LOW.
__sfr __at (0xED) CCAP3L;	//Module 3 Capture LOW.
__sfr __at (0xEE) CCAP4L;	//Module 4 Capture LOW.

__sfr __at (0xDA) CCAPM0;	//Module 0 Mode.
__sfr __at (0xDB) CCAPM1;	//Module 1 Mode.
__sfr __at (0xDC) CCAPM2;	//Module 2 Mode.
__sfr __at (0xDD) CCAPM3;	//Module 3 Mode.
__sfr __at (0xDE) CCAPM4;	//Module 4 Mode.
//The preceding five registers have the following bits:
	#define ECOM 0x40		//Enable Comparator.
	#define CAPP 0x20		//1=enables positive edge capture.
	#define CAPN 0x10		//1=enables negative edge capture.
	#define MAT  0x08		//When counter matches sets CCF_n bit causing and interrupt.
	#define TOG  0x04		//Toggle output on match.
	#define PWM  0x02		//Pulse width modulation mode.
	#define ECCF 0x01		//Enable CCF interrupt.

__sfr __at (0xD8) CCON;	//PCA Counter Control
	__sbit __at (0xDF) CF;	//PCA Counter overflow flag.
	__sbit __at (0xDE) CR ; //PCA Counter Run Control Bit. 1=counter on.  0=counter off.
	__sbit __at (0xDC) CCF4;//PCA Module 4 Interrupt Flag.
	__sbit __at (0xDB) CCF3;//PCA Module 3 Interrupt Flag.
	__sbit __at (0xDA) CCF2;//PCA Module 2 Interrupt Flag.
	__sbit __at (0xD9) CCF1;//PCA Module 1 Interrupt Flag.
	__sbit __at (0xD8) CCF0;//PCA Module 0 Interrupt Flag.

__sfr __at (0xF9) CH;		//PCA Counter HIGH.
__sfr __at (0xE9) CL;		//PCA Counter LOW.

__sfr __at (0xD9) CMOD;		//PCA Counter Mode.
	#define CIDL 0x80		//CIDL=0 program the PCA counter to work during idle mode.
	#define WDTE 0x40		//Watchdog Timer Enable.
	#define CPS1 0x04		//PCA Count Pulse Select bit 1.
	#define CPS0 0x02		//PCA Count Pulse Select bit 0.
							//00=Internal clock, Fosc/6
							//01=Internal clock, Fosc/6
							//10=Timer 0 overflow
							//11=External clock at ECI/P1.2 pin (max rate=Fosc/4)
	#define ECF 0x01		//PCA Enable Counter Overflow Interrupt.

//Attention IEN0 is the same as register IE found in <8051.h> only bit EC added here.
__sfr __at (0xA8) IEN0;		//Interrupt Enable 1.
	__sbit __at (0xAE) EC;	//PCA Interrupt Enable bit.

__sfr __at (0xB1) IEN1;		//Interrupt Enable 1
	#define ESPI 0x04		//SPA Interrupt Enable bit.
	#define KBD  0x01		//Keyboard Interrupt Enable bit.

//Attention IPL0 is the same as register IP found in <8051.h>
__sfr __at (0xB8) IPL0;	    //Interrupt Priority 0 LOW
	__sbit __at (0xBE) PPCL;//PCA Interrupt Priority low bit.
	__sbit __at (0xBD) PT2L;//Timer 2 Interrupt Priority Low Bit.
	__sbit __at (0xBC) PLS; //Serial Port Interrupt Priority Low Bit.
	__sbit __at (0xBB) PT1L;//Timer 1 Interrupt Priority Low Bit.
	__sbit __at (0xBA) PX1L;//External Interrupt 1 Priority Low Bit.
	__sbit __at (0xB9) PT0L;//Timer 0 Interrupt Priority Low Bit.
	__sbit __at (0xB8) PX0L;//External Interrupt 0 Priority Low Bit.

__sfr __at (0xB7) IPH0;		//Interrupt Priority 0 HIGH
	#define PPCH 0x40		//PCA Interrupt Priority High Bit.
	#define PT2H 0x20		//Timer 2 Interrupt Priority High Bit.
	#define PHS  0x10		//Serial Port Interrupt Priority High Bit.
	#define PT1H 0x08		//Timer 1 Interrupt Priority High Bit.
	#define PX1H 0x04		//External Interrupt 1 Priority High Bit.
	#define PT0H 0x02		//Timer 0 Interrupt Priority High Bit.
	#define PX0H 0x01		//External Interrupt 0 Priority High Bit.

__sfr __at (0xB2) IPL1;		//Interrupt Priority 1 LOW.
    #define SPIL 0x04       //SPI Priority Low Bit
    #define KBDL 0x01       //Keyboard Priority Low Bit

__sfr __at (0xB3) IPH1;		//Interrupt Priority 1 HIGH.
    #define SPIH 0x04       //SPI Priority High Bit
    #define KBDH 0x01       //Keyboard Priority High Bit

__sfr __at (0xC0) P4;       //8-bit port 4
    __sbit __at (0xC0) P4_0 ;
    __sbit __at (0xC1) P4_1 ;
    __sbit __at (0xC2) P4_2 ;
    __sbit __at (0xC3) P4_3 ;
    __sbit __at (0xC4) P4_4 ;
    __sbit __at (0xC5) P4_5 ;
    __sbit __at (0xC6) P4_6 ;
    __sbit __at (0xC7) P4_7 ;

// S. Qu  12/30/2008 4:23PM
__sfr __at (0xE8) P5;       //8-bit port 5
    __sbit __at (0xE8) P5_0 ;
    __sbit __at (0xE9) P5_1 ;
    __sbit __at (0xEA) P5_2 ;
    __sbit __at (0xEB) P5_3 ;
    __sbit __at (0xEC) P5_4 ;
    __sbit __at (0xED) P5_5 ;
    __sbit __at (0xEE) P5_6 ;
    __sbit __at (0xEF) P5_7 ;

__sfr __at (0xA6) WDTRST;   //WatchDog Timer Reset
__sfr __at (0xA7) WDTPRG;   //WatchDog Timer Program
	#define WTO2 0x04		//WDT Time-out select bit 2
	#define WTO1 0x02		//WDT Time-out select bit 1
	#define WTO0 0x01		//WDT Time-out select bit 0
	//This names appear also in the datasheet:
	#define S2 0x04 		//WDT Time-out select bit 2
	#define S1 0x02 		//WDT Time-out select bit 1
	#define S0 0x01 		//WDT Time-out select bit 0
	//S2 S1 S0 Selected Time-out
	//0  0  0  (2^14 - 1) machine cycles, 16.3 ms @ FOSCA=12 MHz
	//0  0  1  (2^15 - 1) machine cycles, 32.7 ms @ FOSCA=12 MHz
	//0  1  0  (2^16 - 1) machine cycles, 65.5 ms @ FOSCA=12 MHz
	//0  1  1  (2^17 - 1) machine cycles, 131  ms @ FOSCA=12 MHz
	//1  0  0  (2^18 - 1) machine cycles, 262  ms @ FOSCA=12 MHz
	//1  0  1  (2^19 - 1) machine cycles, 542  ms @ FOSCA=12 MHz
	//1  1  0  (2^20 - 1) machine cycles, 1.05  s @ FOSCA=12 MHz
	//1  1  1  (2^21 - 1) machine cycles, 2.09  s @ FOSCA=12 MHz

__sfr __at (0xA9) SADDR;	//Serial Port Address Register.
__sfr __at (0xB9) SADEN;	//Serial Port Address Enable.

__sfr __at (0xC3) SPCON;	//SPI Control Register
	#define SPR2  0x80		//SPI Clork Rate select bit 2.
	#define SPEN  0x40      //SPI enable bit.  When set enables SPI.
	#define SSDIS 0x20		//Cleared to enable SS in both Master and Slave modes.
	#define MSTR  0x10		//1=master mode.  0=slave mode.
	#define CPOL  0x08		//1=SCK is high when idle (active low), 0=SCK is low when idle (active high).
	#define CPHA  0x04		//1=shift triggered on the trailing edge of SCK.  0=shift trig. on leading edge.
	#define SPR1  0x02		//SPI Clork Rate select bit 1.
	#define SPR0  0x01		//SPI Clork Rate select bit 0.
		//SPR2 SPR1 SPR0  Baud Rate Divisor
		//  0    0    0   2
		//  0    0    1   4
		//  0    1    0   8
		//  0    1    1   16
		//  1    0    0   32
		//  1    0    1   64
		//  1    1    0   128
		//  1    1    1   Invalid: Don't Use

__sfr __at (0xC4) SPSTA;	//Serial Peripheral Status register
	#define SPIF  0x80		//Serial Peripheral Data Transfer Flag
	#define WCOL  0x40		//Write collision Flag.
	#define SSERR 0x20      //Synchronous Serial Slave Error Flag
	#define MODF  0x10      //Mode Fault Flag

__sfr __at (0xC5) SPDAT;	//SPI Data

__sfr __at (0xC9) T2MOD;	//Timer 2 mode control
	#define T2OE  0x02		//Timer 2 Output Enable bit.
	#define DCEN  0x01		//Down count enable

__sfr __at (0x9B) BDRCON;	//Baud Rate Control
	#define BRR   0x10		//Baud Rate Run Control bit. '1'=enable
	#define TBCK  0x08		//Transmission Baud rate Generator Selection bit for UART
	#define RBCK  0x04		//Reception Baud Rate Generator Selection bit for UART
	#define SPD   0x02		//Baud Rate Speed Control bit for UART
	#define SRC   0x01		//Baud Rate Source select bit in Mode 0 for UART

__sfr __at (0x9A) BRL;      //Baud Rate Reload

__sfr __at (0x9C) KBLS;     //Keyboard level Selector
__sfr __at (0x9D) KBE;      //Keyboard Input Enable
__sfr __at (0x9E) KBF;      //Keyboard Flag Register

__sfr __at (0xD2) EECON;    //EEPROM Data Control
	#define EEE    0x02		//EEPROM Enable. '1'=use EEPROM, '0'=use XRAM
	#define EEBUSY 0x01		//EEPROM Busy. '1'=EEPROM is busy programming

#endif /*REG_AT89C51ED2_H*/
/*-------------------------------------------------------------------------
   C8051F300.h - Register Declarations for the Cygnal/SiLabs C8051F30x
   Processor Range

   Copyright (C) 2004, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#ifndef C8051F300_H
#define C8051F300_H


/*  BYTE Registers  */

__sfr __at (0x80) P0           ;  /* PORT 0                                        */
__sfr __at (0x81) SP           ;  /* STACK POINTER                                 */
__sfr __at (0x82) DPL          ;  /* DATA POINTER - LOW BYTE                       */
__sfr __at (0x83) DPH          ;  /* DATA POINTER - HIGH BYTE                      */
__sfr __at (0x87) PCON         ;  /* POWER CONTROL                                 */
__sfr __at (0x88) TCON         ;  /* TIMER CONTROL                                 */
__sfr __at (0x89) TMOD         ;  /* TIMER MODE                                    */
__sfr __at (0x8A) TL0          ;  /* TIMER 0 - LOW BYTE                            */
__sfr __at (0x8B) TL1          ;  /* TIMER 1 - LOW BYTE                            */
__sfr __at (0x8C) TH0          ;  /* TIMER 0 - HIGH BYTE                           */
__sfr __at (0x8D) TH1          ;  /* TIMER 1 - HIGH BYTE                           */
__sfr __at (0x8E) CKCON        ;  /* CLOCK CONTROL                                 */
__sfr __at (0x8F) PSCTL        ;  /* PROGRAM STORE R/W CONTROL                     */
__sfr __at (0x98) SCON         ;  /* SERIAL PORT CONTROL                           */
__sfr __at (0x98) SCON0        ;  /* SERIAL PORT CONTROL                           */
__sfr __at (0x99) SBUF         ;  /* SERIAL PORT BUFFER                            */
__sfr __at (0x99) SBUF0        ;  /* SERIAL PORT BUFFER                            */
__sfr __at (0x9D) CPT0MD       ;  /* COMPARATOR 0 MODE SELECTION                   */
__sfr __at (0x9F) CPT0MX       ;  /* COMPARATOR 0 MUX SELECTION                    */
__sfr __at (0xA4) P0MDOUT      ;  /* PORT 0 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA8) IE           ;  /* INTERRUPT ENABLE                              */
__sfr __at (0xB1) OSCXCN       ;  /* EXTERNAL OSCILLATOR CONTROL                   */
__sfr __at (0xB2) OSCICN       ;  /* INTERNAL OSCILLATOR CONTROL                   */
__sfr __at (0xB3) OSCICL       ;  /* INTERNAL OSCILLATOR CALIBRATION               */
__sfr __at (0xB6) FLSCL        ;  /* FLASH MEMORY TIMING PRESCALER                 */
__sfr __at (0xB7) FLKEY        ;  /* FLASH ACESS LIMIT                             */
__sfr __at (0xB8) IP           ;  /* INTERRUPT PRIORITY                            */
__sfr __at (0xBB) AMX0SL       ;  /* ADC 0 MUX CHANNEL SELECTION                   */
__sfr __at (0xBC) ADC0CF       ;  /* ADC 0 CONFIGURATION                           */
__sfr __at (0xBE) ADC0         ;  /* ADC 0 DATA                                    */
__sfr __at (0xC0) SMB0CN       ;  /* SMBUS CONTROL                                 */
__sfr __at (0xC1) SMB0CF       ;  /* SMBUS CONFIGURATION                           */
__sfr __at (0xC2) SMB0DAT      ;  /* SMBUS DATA                                    */
__sfr __at (0xC4) ADC0GT       ;  /* ADC 0 GREATER-THAN REGISTER                   */
__sfr __at (0xC6) ADC0LT       ;  /* ADC 0 LESS-THAN REGISTER                      */
__sfr __at (0xC8) T2CON        ;  /* TIMER 2 CONTROL                               */
__sfr __at (0xC8) TMR2CN       ;  /* TIMER 2 CONTROL                               */
__sfr __at (0xCA) RCAP2L       ;  /* TIMER 2 CAPTURE REGISTER - LOW BYTE           */
__sfr __at (0xCA) TMR2RLL      ;  /* TIMER 2 CAPTURE REGISTER - LOW BYTE           */
__sfr __at (0xCB) RCAP2H       ;  /* TIMER 2 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at (0xCB) TMR2RLH      ;  /* TIMER 2 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at (0xCC) TL2          ;  /* TIMER 2 - LOW BYTE                            */
__sfr __at (0xCC) TMR2L        ;  /* TIMER 2 - LOW BYTE                            */
__sfr __at (0xCD) TH2          ;  /* TIMER 2 - HIGH BYTE                           */
__sfr __at (0xCD) TMR2H        ;  /* TIMER 2 - HIGH BYTE                           */
__sfr __at (0xD0) PSW          ;  /* PROGRAM STATUS WORD                           */
__sfr __at (0xD1) REF0CN       ;  /* VOLTAGE REFERENCE 0 CONTROL                   */
__sfr __at (0xD8) PCA0CN       ;  /* PCA CONTROL                                   */
__sfr __at (0xD9) PCA0MD       ;  /* PCA MODE                                      */
__sfr __at (0xDA) PCA0CPM0     ;  /* PCA MODULE 0 MODE REGISTER                    */
__sfr __at (0xDB) PCA0CPM1     ;  /* PCA MODULE 1 MODE REGISTER                    */
__sfr __at (0xDC) PCA0CPM2     ;  /* PCA MODULE 2 MODE REGISTER                    */
__sfr __at (0xE0) ACC          ;  /* ACCUMULATOR                                   */
__sfr __at (0xE1) PRT0MX       ;  /* PORT MUX CONFIGURATION REGISTER 0             */
__sfr __at (0xE1) XBR0         ;  /* PORT MUX CONFIGURATION REGISTER 0             */
__sfr __at (0xE2) PRT1MX       ;  /* PORT MUX CONFIGURATION REGISTER 1             */
__sfr __at (0xE2) XBR1         ;  /* PORT MUX CONFIGURATION REGISTER 1             */
__sfr __at (0xE3) PRT2MX       ;  /* PORT MUX CONFIGURATION REGISTER 2             */
__sfr __at (0xE3) XBR2         ;  /* PORT MUX CONFIGURATION REGISTER 2             */
__sfr __at (0xE4) IT01CF       ;  /* INT0/INT1 CONFIGURATION REGISTER              */
__sfr __at (0xE4) INT01CF      ;  /* INT0/INT1 CONFIGURATION REGISTER              */
__sfr __at (0xE6) EIE1         ;  /* EXTERNAL INTERRUPT ENABLE 1                   */
__sfr __at (0xE8) ADC0CN       ;  /* ADC 0 CONTROL                                 */
__sfr __at (0xE9) PCA0CPL1     ;  /* PCA CAPTURE 1 LOW                             */
__sfr __at (0xEA) PCA0CPH1     ;  /* PCA CAPTURE 1 HIGH                            */
__sfr __at (0xEB) PCA0CPL2     ;  /* PCA CAPTURE 2 LOW                             */
__sfr __at (0xEC) PCA0CPH2     ;  /* PCA CAPTURE 2 HIGH                            */
__sfr __at (0xEF) RSTSRC       ;  /* RESET SOURCE                                  */
__sfr __at (0xF0) B            ;  /* B REGISTER                                    */
__sfr __at (0xF1) P0MODE       ;  /* PORT 0 INPUT MODE CONFIGURATION               */
__sfr __at (0xF1) P0MDIN       ;  /* PORT 0 INPUT MODE CONFIGURATION               */
__sfr __at (0xF6) EIP1         ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 1        */
__sfr __at (0xF8) CPT0CN       ;  /* COMPARATOR 0 CONTROL                          */
__sfr __at (0xF9) PCA0L        ;  /* PCA COUNTER LOW                               */
__sfr __at (0xFA) PCA0H        ;  /* PCA COUNTER HIGH                              */
__sfr __at (0xFB) PCA0CPL0     ;  /* PCA CAPTURE 0 LOW                             */
__sfr __at (0xFC) PCA0CPH0     ;  /* PCA CAPTURE 0 HIGH                            */


/*  WORD/DWORD Registers  */

__sfr16 __at (0x8C8A) TMR0     ;  /* TIMER 0 COUNTER                               */
__sfr16 __at (0x8D8B) TMR1     ;  /* TIMER 1 COUNTER                               */
__sfr16 __at (0xCDCC) TMR2     ;  /* TIMER 2 COUNTER                               */
__sfr16 __at (0xCBCA) RCAP2    ;  /* TIMER 2 CAPTURE REGISTER WORD                 */
__sfr16 __at (0xCBCA) TMR2RL   ;  /* TIMER 2 CAPTURE REGISTER WORD                 */
__sfr16 __at (0xFAF9) PCA0     ;  /* PCA COUNTER                                   */
__sfr16 __at (0xFCFB) PCA0CP0  ;  /* PCA CAPTURE 0 WORD                            */
__sfr16 __at (0xEAE9) PCA0CP1  ;  /* PCA CAPTURE 1 WORD                            */
__sfr16 __at (0xECEB) PCA0CP2  ;  /* PCA CAPTURE 2 WORD                            */


/*  BIT Registers  */

/*  P0  0x80 */
__sbit __at (0x80) P0_0        ;
__sbit __at (0x81) P0_1        ;
__sbit __at (0x82) P0_2        ;
__sbit __at (0x83) P0_3        ;
__sbit __at (0x84) P0_4        ;
__sbit __at (0x85) P0_5        ;
__sbit __at (0x86) P0_6        ;
__sbit __at (0x87) P0_7        ;

/*  TCON  0x88 */
__sbit __at (0x88) IT0         ;  /* TCON.0 - EXT. INTERRUPT 0 TYPE                */
__sbit __at (0x89) IE0         ;  /* TCON.1 - EXT. INTERRUPT 0 EDGE FLAG           */
__sbit __at (0x8A) IT1         ;  /* TCON.2 - EXT. INTERRUPT 1 TYPE                */
__sbit __at (0x8B) IE1         ;  /* TCON.3 - EXT. INTERRUPT 1 EDGE FLAG           */
__sbit __at (0x8C) TR0         ;  /* TCON.4 - TIMER 0 ON/OFF CONTROL               */
__sbit __at (0x8D) TF0         ;  /* TCON.5 - TIMER 0 OVERFLOW FLAG                */
__sbit __at (0x8E) TR1         ;  /* TCON.6 - TIMER 1 ON/OFF CONTROL               */
__sbit __at (0x8F) TF1         ;  /* TCON.7 - TIMER 1 OVERFLOW FLAG                */

/*  SCON  0x98 */
__sbit __at (0x98) RI          ;  /* SCON.0 - RECEIVE INTERRUPT FLAG               */
__sbit __at (0x98) RI0         ;  /* SCON.0 - RECEIVE INTERRUPT FLAG               */
__sbit __at (0x99) TI          ;  /* SCON.1 - TRANSMIT INTERRUPT FLAG              */
__sbit __at (0x99) TI0         ;  /* SCON.1 - TRANSMIT INTERRUPT FLAG              */
__sbit __at (0x9A) RB8         ;  /* SCON.2 - RECEIVE BIT 8                        */
__sbit __at (0x9A) RB80        ;  /* SCON.2 - RECEIVE BIT 8                        */
__sbit __at (0x9B) TB8         ;  /* SCON.3 - TRANSMIT BIT 8                       */
__sbit __at (0x9B) TB80        ;  /* SCON.3 - TRANSMIT BIT 8                       */
__sbit __at (0x9C) REN         ;  /* SCON.4 - RECEIVE ENABLE                       */
__sbit __at (0x9C) REN0        ;  /* SCON.4 - RECEIVE ENABLE                       */
__sbit __at (0x9D) SM2         ;  /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE  */
__sbit __at (0x9D) MCE0        ;  /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE  */
__sbit __at (0x9F) SM0         ;  /* SCON.7 - SERIAL MODE CONTROL BIT 0            */
__sbit __at (0x9F) S0MODE      ;  /* SCON.7 - SERIAL MODE CONTROL BIT 0            */

/*  IE  0xA8 */
__sbit __at (0xA8) EX0         ;  /* IE.0 - EXTERNAL INTERRUPT 0 ENABLE            */
__sbit __at (0xA9) ET0         ;  /* IE.1 - TIMER 0 INTERRUPT ENABLE               */
__sbit __at (0xAA) EX1         ;  /* IE.2 - EXTERNAL INTERRUPT 1 ENABLE            */
__sbit __at (0xAB) ET1         ;  /* IE.3 - TIMER 1 INTERRUPT ENABLE               */
__sbit __at (0xAC) ES          ;  /* IE.4 - SERIAL PORT INTERRUPT ENABLE           */
__sbit __at (0xAC) ES0         ;  /* IE.4 - SERIAL PORT INTERRUPT ENABLE           */
__sbit __at (0xAD) ET2         ;  /* IE.5 - TIMER 2 INTERRUPT ENABLE               */
__sbit __at (0xAE) IEGF0       ;  /* IE.6 - GENERAL PURPOSE FLAG 0                 */
__sbit __at (0xAF) EA          ;  /* IE.7 - GLOBAL INTERRUPT ENABLE                */

/*  IP  0xB8 */
__sbit __at (0xB8) PX0         ;  /* IP.0 - EXTERNAL INTERRUPT 0 PRIORITY          */
__sbit __at (0xB9) PT0         ;  /* IP.1 - TIMER 0 PRIORITY                       */
__sbit __at (0xBA) PX1         ;  /* IP.2 - EXTERNAL INTERRUPT 1 PRIORITY          */
__sbit __at (0xBB) PT1         ;  /* IP.3 - TIMER 1 PRIORITY                       */
__sbit __at (0xBC) PS          ;  /* IP.4 - SERIAL PORT PRIORITY                   */
__sbit __at (0xBC) PS0         ;  /* IP.4 - SERIAL PORT PRIORITY                   */
__sbit __at (0xBD) PT2         ;  /* IP.5 - TIMER 2 PRIORITY                       */

/*  SMB0CN  0xC0 */
__sbit __at (0xC0) SI          ;  /* SMB0CN.0 - SMBUS 0 INTERRUPT PENDING FLAG     */
__sbit __at (0xC1) ACK         ;  /* SMB0CN.1 - SMBUS 0 ACKNOWLEDGE FLAG           */
__sbit __at (0xC2) ARBLOST     ;  /* SMB0CN.2 - SMBUS 0 ARBITRATION LOST INDICATOR */
__sbit __at (0xC3) ACKRQ       ;  /* SMB0CN.3 - SMBUS 0 ACKNOWLEDGE REQUEST        */
__sbit __at (0xC4) STO         ;  /* SMB0CN.4 - SMBUS 0 STOP FLAG                  */
__sbit __at (0xC5) STA         ;  /* SMB0CN.5 - SMBUS 0 START FLAG                 */
__sbit __at (0xC6) TXMODE      ;  /* SMB0CN.6 - SMBUS 0 TRANSMIT MODE INDICATOR    */
__sbit __at (0xC7) MASTER      ;  /* SMB0CN.7 - SMBUS 0 MASTER/SLAVE INDICATOR     */

/*  TMR2CN  0xC8 */
__sbit __at (0xC8) T2XCLK      ;  /* TMR2CN.0 - TIMER 2 EXTERNAL CLOCK SELECT      */
__sbit __at (0xCA) TR2         ;  /* TMR2CN.2 - TIMER 2 ON/OFF CONTROL             */
__sbit __at (0xCB) T2SPLIT     ;  /* TMR2CN.3 - TIMER 2 SPLIT MODE ENABLE          */
__sbit __at (0xCD) TF2LEN      ;  /* TMR2CN.5 - TIMER 2 LOW BYTE INTERRUPT ENABLE  */
__sbit __at (0xCE) TF2L        ;  /* TMR2CN.6 - TIMER 2 LOW BYTE OVERFLOW FLAG     */
__sbit __at (0xCF) TF2         ;  /* TMR2CN.7 - TIMER 2 OVERFLOW FLAG              */
__sbit __at (0xCF) TF2H        ;  /* TMR2CN.7 - TIMER 2 HIGH BYTE OVERFLOW FLAG    */

/*  PSW  0xD0 */
__sbit __at (0xD0) PARITY      ;  /* PSW.0 - ACCUMULATOR PARITY FLAG               */
__sbit __at (0xD1) F1          ;  /* PSW.1 - FLAG 1                                */
__sbit __at (0xD2) OV          ;  /* PSW.2 - OVERFLOW FLAG                         */
__sbit __at (0xD3) RS0         ;  /* PSW.3 - REGISTER BANK SELECT 0                */
__sbit __at (0xD4) RS1         ;  /* PSW.4 - REGISTER BANK SELECT 1                */
__sbit __at (0xD5) F0          ;  /* PSW.5 - FLAG 0                                */
__sbit __at (0xD6) AC          ;  /* PSW.6 - AUXILIARY CARRY FLAG                  */
__sbit __at (0xD7) CY          ;  /* PSW.7 - CARRY FLAG                            */

/*  PCA0CN  0xD8 */
__sbit __at (0xD8) CCF0        ;  /* PCA0CN.0 - PCA MODULE 0 CAPTURE/COMPARE FLAG  */
__sbit __at (0xD9) CCF1        ;  /* PCA0CN.1 - PCA MODULE 1 CAPTURE/COMPARE FLAG  */
__sbit __at (0xDA) CCF2        ;  /* PCA0CN.2 - PCA MODULE 2 CAPTURE/COMPARE FLAG  */
__sbit __at (0xDE) CR          ;  /* PCA0CN.6 - PCA COUNTER/TIMER RUN CONTROL      */
__sbit __at (0xDF) CF          ;  /* PCA0CN.7 - PCA COUNTER/TIMER OVERFLOW FLAG    */

/*  ADC0CN  0xE8 */
__sbit __at (0xE8) AD0CM0      ;  /* ADC0CN.0 - ADC 0 START OF CONV. MODE BIT 0    */
__sbit __at (0xE9) AD0CM1      ;  /* ADC0CN.1 - ADC 0 START OF CONV. MODE BIT 1    */
__sbit __at (0xEA) AD0CM2      ;  /* ADC0CN.2 - ADC 0 START OF CONV. MODE BIT 2    */
__sbit __at (0xEB) AD0WINT     ;  /* ADC0CN.3 - ADC 0 WINDOW COMPARE INT. FLAG     */
__sbit __at (0xEC) AD0BUSY     ;  /* ADC0CN.4 - ADC 0 BUSY FLAG                    */
__sbit __at (0xED) AD0INT      ;  /* ADC0CN.5 - ADC 0 CONV. COMPLETE INT. FLAG     */
__sbit __at (0xEE) AD0TM       ;  /* ADC0CN.6 - ADC 0 TRACK MODE                   */
__sbit __at (0xEF) AD0EN       ;  /* ADC0CN.7 - ADC 0 ENABLE                       */

/*  CPT0CN  0xF8 */
__sbit __at (0xF8) CP0HYN0     ;  /* CPT0CN.0 - Comp.0 Neg. Hysteresis Control Bit0*/
__sbit __at (0xF9) CP0HYN1     ;  /* CPT0CN.1 - Comp.0 Neg. Hysteresis Control Bit1*/
__sbit __at (0xFA) CP0HYP0     ;  /* CPT0CN.2 - Comp.0 Pos. Hysteresis Control Bit0*/
__sbit __at (0xFB) CP0HYP1     ;  /* CPT0CN.3 - Comp.0 Pos. Hysteresis Control Bit1*/
__sbit __at (0xFC) CP0FIF      ;  /* CPT0CN.4 - Comparator0 Falling-Edge Int. Flag */
__sbit __at (0xFD) CP0RIF      ;  /* CPT0CN.5 - Comparator0 Rising-Edge Int. Flag  */
__sbit __at (0xFE) CP0OUT      ;  /* CPT0CN.6 - Comparator0 Output State Flag      */
__sbit __at (0xFF) CP0EN       ;  /* CPT0CN.7 - Comparator0 Enable Bit             */


/* Predefined SFR Bit Masks */

#define PCON_IDLE         0x01    /* PCON                                */
#define PCON_STOP         0x02    /* PCON                                */
#define T1M               0x10    /* CKCON                               */
#define PSWE              0x01    /* PSCTL                               */
#define PSEE              0x02    /* PSCTL                               */
#define ECP0F             0x10    /* EIE1                                */
#define ECP0R             0x20    /* EIE1                                */
#define PORSF             0x02    /* RSTSRC                              */
#define SWRSF             0x10    /* RSTSRC                              */
#define ECCF              0x01    /* PCA0CPMn                            */
#define PWM               0x02    /* PCA0CPMn                            */
#define TOG               0x04    /* PCA0CPMn                            */
#define MAT               0x08    /* PCA0CPMn                            */
#define CAPN              0x10    /* PCA0CPMn                            */
#define CAPP              0x20    /* PCA0CPMn                            */
#define ECOM              0x40    /* PCA0CPMn                            */
#define PWM16             0x80    /* PCA0CPMn                            */
#define CP0E              0x10    /* XBR1                                */
#define CP0OEN            0x10    /* XBR1                                */
#define CP0AE             0x20    /* XBR1                                */
#define CP0AOEN           0x20    /* XBR1                                */

#endif
/*-------------------------------------------------------------------------
   C8051F340.h - Register Declarations for the Cygnal/SiLabs C8051F34x
   Processor Range

   Copyright (C) 2006, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef C8051F340_H
#define C8051F340_H


/*  BYTE Registers  */
__sfr __at (0x80) P0           ;  /* PORT 0                                        */
__sfr __at (0x81) SP           ;  /* STACK POINTER                                 */
__sfr __at (0x82) DPL          ;  /* DATA POINTER - LOW BYTE                       */
__sfr __at (0x83) DPH          ;  /* DATA POINTER - HIGH BYTE                      */
__sfr __at (0x84) EMI0TC       ;  /* EXTERNAL MEMORY INTERFACE TIMING              */
__sfr __at (0x85) EMI0CF       ;  /* EXTERNAL MEMORY INTERFACE CONFIGURATION       */
__sfr __at (0x86) OSCLCN       ;  /* LOW-FREQUENCY OSCILLATOR CONTROL              */
__sfr __at (0x87) PCON         ;  /* POWER CONTROL                                 */
__sfr __at (0x88) TCON         ;  /* TIMER CONTROL                                 */
__sfr __at (0x89) TMOD         ;  /* TIMER MODE                                    */
__sfr __at (0x8A) TL0          ;  /* TIMER 0 - LOW BYTE                            */
__sfr __at (0x8B) TL1          ;  /* TIMER 1 - LOW BYTE                            */
__sfr __at (0x8C) TH0          ;  /* TIMER 0 - HIGH BYTE                           */
__sfr __at (0x8D) TH1          ;  /* TIMER 1 - HIGH BYTE                           */
__sfr __at (0x8E) CKCON        ;  /* CLOCK CONTROL                                 */
__sfr __at (0x8F) PSCTL        ;  /* PROGRAM STORE R/W CONTROL                     */
__sfr __at (0x90) P1           ;  /* PORT 1                                        */
__sfr __at (0x91) TMR3CN       ;  /* TIMER 3 CONTROL                               */
__sfr __at (0x92) TMR3RLL      ;  /* TIMER 3 CAPTURE REGISTER - LOW BYTE           */
__sfr __at (0x93) TMR3RLH      ;  /* TIMER 3 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at (0x94) TMR3L        ;  /* TIMER 3 - LOW BYTE                            */
__sfr __at (0x95) TMR3H        ;  /* TIMER 3 - HIGH BYTE                           */
__sfr __at (0x96) USB0ADR      ;  /* USB0 INDIRECT ADDRESS REGISTER                */
__sfr __at (0x97) USB0DAT      ;  /* USB0 DATA REGISTER                            */
__sfr __at (0x98) SCON         ;  /* SERIAL PORT CONTROL                           */
__sfr __at (0x98) SCON0        ;  /* SERIAL PORT CONTROL                           */
__sfr __at (0x99) SBUF         ;  /* SERIAL PORT BUFFER                            */
__sfr __at (0x99) SBUF0        ;  /* SERIAL PORT BUFFER                            */
__sfr __at (0x9A) CPT1CN       ;  /* COMPARATOR 1 CONTROL                          */
__sfr __at (0x9B) CPT0CN       ;  /* COMPARATOR 0 CONTROL                          */
__sfr __at (0x9C) CPT1MD       ;  /* COMPARATOR 1 MODE SELECTION                   */
__sfr __at (0x9D) CPT0MD       ;  /* COMPARATOR 0 MODE SELECTION                   */
__sfr __at (0x9E) CPT1MX       ;  /* COMPARATOR 1 MUX SELECTION                    */
__sfr __at (0x9F) CPT0MX       ;  /* COMPARATOR 0 MUX SELECTION                    */
__sfr __at (0xA0) P2           ;  /* PORT 2                                        */
__sfr __at (0xA1) SPI0CFG      ;  /* SPI0 CONFIGURATION                            */
__sfr __at (0xA2) SPI0CKR      ;  /* SPI0 CLOCK RATE CONTROL                       */
__sfr __at (0xA3) SPI0DAT      ;  /* SPI0 DATA                                     */
__sfr __at (0xA4) P0MDOUT      ;  /* PORT 0 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA5) P1MDOUT      ;  /* PORT 1 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA6) P2MDOUT      ;  /* PORT 2 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA7) P3MDOUT      ;  /* PORT 3 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA8) IE           ;  /* INTERRUPT ENABLE                              */
__sfr __at (0xA9) CLKSEL       ;  /* SYSTEM CLOCK SELECT                           */
__sfr __at (0xAA) EMI0CN       ;  /* EXTERNAL MEMORY INTERFACE CONTROL             */
__sfr __at (0xAA) _XPAGE       ;  /* XDATA/PDATA PAGE                              */
__sfr __at (0xAC) SBCON1       ;  /* UART 1 BAUDRATE GENERATOR CONTROL             */
__sfr __at (0xAE) P4MDOUT      ;  /* PORT 4 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xAF) PFE0CN       ;  /* PREFETCH ENGINE CONTROL                       */
__sfr __at (0xB0) P3           ;  /* PORT 3                                        */
__sfr __at (0xB1) OSCXCN       ;  /* EXTERNAL OSCILLATOR CONTROL                   */
__sfr __at (0xB2) OSCICN       ;  /* INTERNAL OSCILLATOR CONTROL                   */
__sfr __at (0xB3) OSCICL       ;  /* INTERNAL OSCILLATOR CALIBRATION               */
__sfr __at (0xB4) SBRLL1       ;  /* UART 1 BAUDRATE GENERATOR - LOW BYTE          */
__sfr __at (0xB5) SBRLH1       ;  /* UART 1 BAUDRATE GENERATOR - HIGH BYTE         */
__sfr __at (0xB6) FLSCL        ;  /* FLASH MEMORY TIMING PRESCALER                 */
__sfr __at (0xB7) FLKEY        ;  /* FLASH ACESS LIMIT                             */
__sfr __at (0xB8) IP           ;  /* INTERRUPT PRIORITY                            */
__sfr __at (0xB9) CLKMUL       ;  /* CLOCK MULTIPLIER CONTROL REGISTER             */
__sfr __at (0xBA) AMX0N        ;  /* ADC 0 MUX NEGATIVE CHANNEL SELECTION          */
__sfr __at (0xBB) AMX0P        ;  /* ADC 0 MUX POSITIVE CHANNEL SELECTION          */
__sfr __at (0xBC) ADC0CF       ;  /* ADC 0 CONFIGURATION                           */
__sfr __at (0xBD) ADC0L        ;  /* ADC 0 DATA WORD LSB                           */
__sfr __at (0xBE) ADC0H        ;  /* ADC 0 DATA WORD MSB                           */
__sfr __at (0xC0) SMB0CN       ;  /* SMBUS CONTROL                                 */
__sfr __at (0xC1) SMB0CF       ;  /* SMBUS CONFIGURATION                           */
__sfr __at (0xC2) SMB0DAT      ;  /* SMBUS DATA                                    */
__sfr __at (0xC3) ADC0GTL      ;  /* ADC 0 GREATER-THAN LOW BYTE                   */
__sfr __at (0xC4) ADC0GTH      ;  /* ADC 0 GREATER-THAN HIGH BYTE                  */
__sfr __at (0xC5) ADC0LTL      ;  /* ADC 0 LESS-THAN LOW BYTE                      */
__sfr __at (0xC6) ADC0LTH      ;  /* ADC 0 LESS-THAN HIGH BYTE                     */
__sfr __at (0xC7) P4           ;  /* PORT 4                                        */
__sfr __at (0xC8) T2CON        ;  /* TIMER 2 CONTROL                               */
__sfr __at (0xC8) TMR2CN       ;  /* TIMER 2 CONTROL                               */
__sfr __at (0xC9) REG0CN       ;  /* VOLTAGE REGULATOR CONTROL                     */
__sfr __at (0xCA) RCAP2L       ;  /* TIMER 2 CAPTURE REGISTER - LOW BYTE           */
__sfr __at (0xCA) TMR2RLL      ;  /* TIMER 2 CAPTURE REGISTER - LOW BYTE           */
__sfr __at (0xCB) RCAP2H       ;  /* TIMER 2 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at (0xCB) TMR2RLH      ;  /* TIMER 2 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at (0xCC) TL2          ;  /* TIMER 2 - LOW BYTE                            */
__sfr __at (0xCC) TMR2L        ;  /* TIMER 2 - LOW BYTE                            */
__sfr __at (0xCD) TH2          ;  /* TIMER 2 - HIGH BYTE                           */
__sfr __at (0xCD) TMR2H        ;  /* TIMER 2 - HIGH BYTE                           */
__sfr __at (0xD0) PSW          ;  /* PROGRAM STATUS WORD                           */
__sfr __at (0xD1) REF0CN       ;  /* VOLTAGE REFERENCE 0 CONTROL                   */
__sfr __at (0xD2) SCON1        ;  /* UART 1 CONTROL                                */
__sfr __at (0xD3) SBUF1        ;  /* UART 1 DATA BUFFER                            */
__sfr __at (0xD4) P0SKIP       ;  /* PORT 0 SKIP                                   */
__sfr __at (0xD5) P1SKIP       ;  /* PORT 1 SKIP                                   */
__sfr __at (0xD6) P2SKIP       ;  /* PORT 2 SKIP                                   */
__sfr __at (0xD7) USB0XCN      ;  /* USB0 TRANSCEIVER CONTROL                      */
__sfr __at (0xD8) PCA0CN       ;  /* PCA CONTROL                                   */
__sfr __at (0xD9) PCA0MD       ;  /* PCA MODE                                      */
__sfr __at (0xDA) PCA0CPM0     ;  /* PCA MODULE 0 MODE REGISTER                    */
__sfr __at (0xDB) PCA0CPM1     ;  /* PCA MODULE 1 MODE REGISTER                    */
__sfr __at (0xDC) PCA0CPM2     ;  /* PCA MODULE 2 MODE REGISTER                    */
__sfr __at (0xDD) PCA0CPM3     ;  /* PCA MODULE 3 MODE REGISTER                    */
__sfr __at (0xDE) PCA0CPM4     ;  /* PCA MODULE 4 MODE REGISTER                    */
__sfr __at (0xDF) P3SKIP       ;  /* PORT 3 SKIP                                   */
__sfr __at (0xE0) ACC          ;  /* ACCUMULATOR                                   */
__sfr __at (0xE1) XBR0         ;  /* PORT MUX CONFIGURATION REGISTER 0             */
__sfr __at (0xE2) XBR1         ;  /* PORT MUX CONFIGURATION REGISTER 1             */
__sfr __at (0xE3) XBR2         ;  /* PORT MUX CONFIGURATION REGISTER 2             */
__sfr __at (0xE4) IT01CF       ;  /* INT0/INT1 CONFIGURATION REGISTER              */
__sfr __at (0xE4) INT01CF      ;  /* INT0/INT1 CONFIGURATION REGISTER              */
__sfr __at (0xE5) SMOD1        ;  /* UART 1 MODE                                   */
__sfr __at (0xE6) EIE1         ;  /* EXTERNAL INTERRUPT ENABLE 1                   */
__sfr __at (0xE7) EIE2         ;  /* EXTERNAL INTERRUPT ENABLE 2                   */
__sfr __at (0xE8) ADC0CN       ;  /* ADC 0 CONTROL                                 */
__sfr __at (0xE9) PCA0CPL1     ;  /* PCA CAPTURE 1 LOW                             */
__sfr __at (0xEA) PCA0CPH1     ;  /* PCA CAPTURE 1 HIGH                            */
__sfr __at (0xEB) PCA0CPL2     ;  /* PCA CAPTURE 2 LOW                             */
__sfr __at (0xEC) PCA0CPH2     ;  /* PCA CAPTURE 2 HIGH                            */
__sfr __at (0xED) PCA0CPL3     ;  /* PCA CAPTURE 3 LOW                             */
__sfr __at (0xEE) PCA0CPH3     ;  /* PCA CAPTURE 3 HIGH                            */
__sfr __at (0xEF) RSTSRC       ;  /* RESET SOURCE                                  */
__sfr __at (0xF0) B            ;  /* B REGISTER                                    */
__sfr __at (0xF1) P0MODE       ;  /* PORT 0 INPUT MODE CONFIGURATION               */
__sfr __at (0xF1) P0MDIN       ;  /* PORT 0 INPUT MODE CONFIGURATION               */
__sfr __at (0xF2) P1MODE       ;  /* PORT 1 INPUT MODE CONFIGURATION               */
__sfr __at (0xF2) P1MDIN       ;  /* PORT 1 INPUT MODE CONFIGURATION               */
__sfr __at (0xF3) P2MODE       ;  /* PORT 2 INPUT MODE CONFIGURATION               */
__sfr __at (0xF3) P2MDIN       ;  /* PORT 2 INPUT MODE CONFIGURATION               */
__sfr __at (0xF4) P3MODE       ;  /* PORT 3 INPUT MODE CONFIGURATION               */
__sfr __at (0xF4) P3MDIN       ;  /* PORT 3 INPUT MODE CONFIGURATION               */
__sfr __at (0xF5) P4MDIN       ;  /* PORT 4 INPUT MODE CONFIGURATION               */
__sfr __at (0xF6) EIP1         ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 1        */
__sfr __at (0xF7) EIP2         ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 2        */
__sfr __at (0xF8) SPI0CN       ;  /* SPI0 CONTROL                                  */
__sfr __at (0xF9) PCA0L        ;  /* PCA COUNTER LOW                               */
__sfr __at (0xFA) PCA0H        ;  /* PCA COUNTER HIGH                              */
__sfr __at (0xFB) PCA0CPL0     ;  /* PCA CAPTURE 0 LOW                             */
__sfr __at (0xFC) PCA0CPH0     ;  /* PCA CAPTURE 0 HIGH                            */
__sfr __at (0xFD) PCA0CPL4     ;  /* PCA CAPTURE 4 LOW                             */
__sfr __at (0xFE) PCA0CPH4     ;  /* PCA CAPTURE 4 HIGH                            */
__sfr __at (0xFF) VDM0CN       ;  /* VDD MONITOR CONTROL                           */


/*  WORD/DWORD Registers  */

__sfr16 __at (0x8C8A) TMR0     ;  /* TIMER 0 COUNTER                               */
__sfr16 __at (0x8D8B) TMR1     ;  /* TIMER 1 COUNTER                               */
__sfr16 __at (0xCDCC) TMR2     ;  /* TIMER 2 COUNTER                               */
__sfr16 __at (0xCBCA) RCAP2    ;  /* TIMER 2 CAPTURE REGISTER WORD                 */
__sfr16 __at (0xCBCA) TMR2RL   ;  /* TIMER 2 CAPTURE REGISTER WORD                 */
__sfr16 __at (0x9594) TMR3     ;  /* TIMER 3 COUNTER                               */
__sfr16 __at (0x9392) TMR3RL   ;  /* TIMER 3 CAPTURE REGISTER WORD                 */
__sfr16 __at (0xB5B4) SBRL1    ;  /* UART 1 BAUDRATE GENERATOR WORD                */
__sfr16 __at (0xBEBD) ADC0     ;  /* ADC 0 DATA WORD                               */
__sfr16 __at (0xC4C3) ADC0GT   ;  /* ADC 0 GREATER-THAN REGISTER WORD              */
__sfr16 __at (0xC6C5) ADC0LT   ;  /* ADC 0 LESS-THAN REGISTER WORD                 */
__sfr16 __at (0xFAF9) PCA0     ;  /* PCA COUNTER                                   */
__sfr16 __at (0xFCFB) PCA0CP0  ;  /* PCA CAPTURE 0 WORD                            */
__sfr16 __at (0xEAE9) PCA0CP1  ;  /* PCA CAPTURE 1 WORD                            */
__sfr16 __at (0xECEB) PCA0CP2  ;  /* PCA CAPTURE 2 WORD                            */
__sfr16 __at (0xEEED) PCA0CP3  ;  /* PCA CAPTURE 3 WORD                            */
__sfr16 __at (0xFEFD) PCA0CP4  ;  /* PCA CAPTURE 4 WORD                            */


/*  BIT Registers  */

/*  P0  0x80 */
__sbit __at (0x80) P0_0        ;
__sbit __at (0x81) P0_1        ;
__sbit __at (0x82) P0_2        ;
__sbit __at (0x83) P0_3        ;
__sbit __at (0x84) P0_4        ;
__sbit __at (0x85) P0_5        ;
__sbit __at (0x86) P0_6        ;
__sbit __at (0x87) P0_7        ;

/*  TCON  0x88 */
__sbit __at (0x88) IT0         ;  /* TCON.0 - EXT. INTERRUPT 0 TYPE                */
__sbit __at (0x89) IE0         ;  /* TCON.1 - EXT. INTERRUPT 0 EDGE FLAG           */
__sbit __at (0x8A) IT1         ;  /* TCON.2 - EXT. INTERRUPT 1 TYPE                */
__sbit __at (0x8B) IE1         ;  /* TCON.3 - EXT. INTERRUPT 1 EDGE FLAG           */
__sbit __at (0x8C) TR0         ;  /* TCON.4 - TIMER 0 ON/OFF CONTROL               */
__sbit __at (0x8D) TF0         ;  /* TCON.5 - TIMER 0 OVERFLOW FLAG                */
__sbit __at (0x8E) TR1         ;  /* TCON.6 - TIMER 1 ON/OFF CONTROL               */
__sbit __at (0x8F) TF1         ;  /* TCON.7 - TIMER 1 OVERFLOW FLAG                */

/*  P1  0x90 */
__sbit __at (0x90) P1_0        ;
__sbit __at (0x91) P1_1        ;
__sbit __at (0x92) P1_2        ;
__sbit __at (0x93) P1_3        ;
__sbit __at (0x94) P1_4        ;
__sbit __at (0x95) P1_5        ;
__sbit __at (0x96) P1_6        ;
__sbit __at (0x97) P1_7        ;

/*  SCON  0x98 */
__sbit __at (0x98) RI          ;  /* SCON.0 - RECEIVE INTERRUPT FLAG               */
__sbit __at (0x98) RI0         ;  /* SCON.0 - RECEIVE INTERRUPT FLAG               */
__sbit __at (0x99) TI          ;  /* SCON.1 - TRANSMIT INTERRUPT FLAG              */
__sbit __at (0x99) TI0         ;  /* SCON.1 - TRANSMIT INTERRUPT FLAG              */
__sbit __at (0x9A) RB8         ;  /* SCON.2 - RECEIVE BIT 8                        */
__sbit __at (0x9A) RB80        ;  /* SCON.2 - RECEIVE BIT 8                        */
__sbit __at (0x9B) TB8         ;  /* SCON.3 - TRANSMIT BIT 8                       */
__sbit __at (0x9B) TB80        ;  /* SCON.3 - TRANSMIT BIT 8                       */
__sbit __at (0x9C) REN         ;  /* SCON.4 - RECEIVE ENABLE                       */
__sbit __at (0x9C) REN0        ;  /* SCON.4 - RECEIVE ENABLE                       */
__sbit __at (0x9D) SM2         ;  /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE  */
__sbit __at (0x9D) MCE0        ;  /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE  */
__sbit __at (0x9F) SM0         ;  /* SCON.7 - SERIAL MODE CONTROL BIT 0            */
__sbit __at (0x9F) S0MODE      ;  /* SCON.7 - SERIAL MODE CONTROL BIT 0            */

/*  P2  0xA0 */
__sbit __at (0xA0) P2_0        ;
__sbit __at (0xA1) P2_1        ;
__sbit __at (0xA2) P2_2        ;
__sbit __at (0xA3) P2_3        ;
__sbit __at (0xA4) P2_4        ;
__sbit __at (0xA5) P2_5        ;
__sbit __at (0xA6) P2_6        ;
__sbit __at (0xA7) P2_7        ;

/*  IE  0xA8 */
__sbit __at (0xA8) EX0         ;  /* IE.0 - EXTERNAL INTERRUPT 0 ENABLE            */
__sbit __at (0xA9) ET0         ;  /* IE.1 - TIMER 0 INTERRUPT ENABLE               */
__sbit __at (0xAA) EX1         ;  /* IE.2 - EXTERNAL INTERRUPT 1 ENABLE            */
__sbit __at (0xAB) ET1         ;  /* IE.3 - TIMER 1 INTERRUPT ENABLE               */
__sbit __at (0xAC) ES          ;  /* IE.4 - SERIAL PORT INTERRUPT ENABLE           */
__sbit __at (0xAC) ES0         ;  /* IE.4 - SERIAL PORT INTERRUPT ENABLE           */
__sbit __at (0xAD) ET2         ;  /* IE.5 - TIMER 2 INTERRUPT ENABLE               */
__sbit __at (0xAE) ESPI0       ;  /* IE.6 - SPI0 INTERRUPT ENABLE                  */
__sbit __at (0xAF) EA          ;  /* IE.7 - GLOBAL INTERRUPT ENABLE                */

/*  P3  0xB0 */
__sbit __at (0xB0) P3_0        ;
__sbit __at (0xB1) P3_1        ;
__sbit __at (0xB2) P3_2        ;
__sbit __at (0xB3) P3_3        ;
__sbit __at (0xB4) P3_4        ;
__sbit __at (0xB5) P3_5        ;
__sbit __at (0xB6) P3_6        ;
__sbit __at (0xB7) P3_7        ;

/*  IP  0xB8 */
__sbit __at (0xB8) PX0         ;  /* IP.0 - EXTERNAL INTERRUPT 0 PRIORITY          */
__sbit __at (0xB9) PT0         ;  /* IP.1 - TIMER 0 PRIORITY                       */
__sbit __at (0xBA) PX1         ;  /* IP.2 - EXTERNAL INTERRUPT 1 PRIORITY          */
__sbit __at (0xBB) PT1         ;  /* IP.3 - TIMER 1 PRIORITY                       */
__sbit __at (0xBC) PS          ;  /* IP.4 - SERIAL PORT PRIORITY                   */
__sbit __at (0xBC) PS0         ;  /* IP.4 - SERIAL PORT PRIORITY                   */
__sbit __at (0xBD) PT2         ;  /* IP.5 - TIMER 2 PRIORITY                       */
__sbit __at (0xBE) PSPI0       ;  /* IP.6 - SPI0 PRIORITY                          */

/*  SMB0CN  0xC0 */
__sbit __at (0xC0) SI          ;  /* SMB0CN.0 - SMBUS 0 INTERRUPT PENDING FLAG     */
__sbit __at (0xC1) ACK         ;  /* SMB0CN.1 - SMBUS 0 ACKNOWLEDGE FLAG           */
__sbit __at (0xC2) ARBLOST     ;  /* SMB0CN.2 - SMBUS 0 ARBITRATION LOST INDICATOR */
__sbit __at (0xC3) ACKRQ       ;  /* SMB0CN.3 - SMBUS 0 ACKNOWLEDGE REQUEST        */
__sbit __at (0xC4) STO         ;  /* SMB0CN.4 - SMBUS 0 STOP FLAG                  */
__sbit __at (0xC5) STA         ;  /* SMB0CN.5 - SMBUS 0 START FLAG                 */
__sbit __at (0xC6) TXMODE      ;  /* SMB0CN.6 - SMBUS 0 TRANSMIT MODE INDICATOR    */
__sbit __at (0xC7) MASTER      ;  /* SMB0CN.7 - SMBUS 0 MASTER/SLAVE INDICATOR     */

/*  TMR2CN  0xC8 */
__sbit __at (0xC8) T2XCLK      ;  /* TMR2CN.0 - TIMER 2 EXTERNAL CLOCK SELECT      */
__sbit __at (0xC9) T2CSS       ;  /* TMR2CN.1 - TIMER 2 CAPTURE SOURCE SELECT      */
__sbit __at (0xCA) TR2         ;  /* TMR2CN.2 - TIMER 2 ON/OFF CONTROL             */
__sbit __at (0xCB) T2SPLIT     ;  /* TMR2CN.3 - TIMER 2 SPLIT MODE ENABLE          */
__sbit __at (0xCC) T2CE        ;  /* TMR2CN.4 - TIMER 2 CAPTURE ENABLE             */
__sbit __at (0xCD) TF2LEN      ;  /* TMR2CN.5 - TIMER 2 LOW BYTE INTERRUPT ENABLE  */
__sbit __at (0xCE) TF2L        ;  /* TMR2CN.6 - TIMER 2 LOW BYTE OVERFLOW FLAG     */
__sbit __at (0xCF) TF2         ;  /* TMR2CN.7 - TIMER 2 OVERFLOW FLAG              */
__sbit __at (0xCF) TF2H        ;  /* TMR2CN.7 - TIMER 2 HIGH BYTE OVERFLOW FLAG    */

/*  PSW  0xD0 */
__sbit __at (0xD0) PARITY      ;  /* PSW.0 - ACCUMULATOR PARITY FLAG               */
__sbit __at (0xD1) F1          ;  /* PSW.1 - FLAG 1                                */
__sbit __at (0xD2) OV          ;  /* PSW.2 - OVERFLOW FLAG                         */
__sbit __at (0xD3) RS0         ;  /* PSW.3 - REGISTER BANK SELECT 0                */
__sbit __at (0xD4) RS1         ;  /* PSW.4 - REGISTER BANK SELECT 1                */
__sbit __at (0xD5) F0          ;  /* PSW.5 - FLAG 0                                */
__sbit __at (0xD6) AC          ;  /* PSW.6 - AUXILIARY CARRY FLAG                  */
__sbit __at (0xD7) CY          ;  /* PSW.7 - CARRY FLAG                            */

/*  PCA0CN  0xD8 */
__sbit __at (0xD8) CCF0        ;  /* PCA0CN.0 - PCA MODULE 0 CAPTURE/COMPARE FLAG  */
__sbit __at (0xD9) CCF1        ;  /* PCA0CN.1 - PCA MODULE 1 CAPTURE/COMPARE FLAG  */
__sbit __at (0xDA) CCF2        ;  /* PCA0CN.2 - PCA MODULE 2 CAPTURE/COMPARE FLAG  */
__sbit __at (0xDB) CCF3        ;  /* PCA0CN.3 - PCA MODULE 3 CAPTURE/COMPARE FLAG  */
__sbit __at (0xDC) CCF4        ;  /* PCA0CN.4 - PCA MODULE 4 CAPTURE/COMPARE FLAG  */
__sbit __at (0xDE) CR          ;  /* PCA0CN.6 - PCA COUNTER/TIMER RUN CONTROL      */
__sbit __at (0xDF) CF          ;  /* PCA0CN.7 - PCA COUNTER/TIMER OVERFLOW FLAG    */

/*  ADC0CN  0xE8 */
__sbit __at (0xE8) AD0CM0      ;  /* ADC0CN.0 - ADC 0 START OF CONV. MODE BIT 0    */
__sbit __at (0xE9) AD0CM1      ;  /* ADC0CN.1 - ADC 0 START OF CONV. MODE BIT 1    */
__sbit __at (0xEA) AD0CM2      ;  /* ADC0CN.2 - ADC 0 START OF CONV. MODE BIT 2    */
__sbit __at (0xEB) AD0WINT     ;  /* ADC0CN.3 - ADC 0 WINDOW COMPARE INT. FLAG     */
__sbit __at (0xEC) AD0BUSY     ;  /* ADC0CN.4 - ADC 0 BUSY FLAG                    */
__sbit __at (0xED) AD0INT      ;  /* ADC0CN.5 - ADC 0 CONV. COMPLETE INT. FLAG     */
__sbit __at (0xEE) AD0TM       ;  /* ADC0CN.6 - ADC 0 TRACK MODE                   */
__sbit __at (0xEF) AD0EN       ;  /* ADC0CN.7 - ADC 0 ENABLE                       */

/*  SPI0CN  0xF8 */
__sbit __at (0xF8) SPIEN       ;  /* SPI0CN.0 - SPI0 ENABLE                        */
__sbit __at (0xF9) TXBMT       ;  /* SPI0CN.1 - TRANSMIT BUFFER EMPTY              */
__sbit __at (0xFA) NSSMD0      ;  /* SPI0CN.2 - SLAVE SELECT MODE BIT 0            */
__sbit __at (0xFB) NSSMD1      ;  /* SPI0CN.3 - SLAVE SELECT MODE BIT 1            */
__sbit __at (0xFC) RXOVRN      ;  /* SPI0CN.4 - RECEIVE OVERRUN FLAG               */
__sbit __at (0xFD) MODF        ;  /* SPI0CN.5 - MODE FAULT FLAG                    */
__sbit __at (0xFE) WCOL        ;  /* SPI0CN.6 - WRITE COLLISION FLAG               */
__sbit __at (0xFF) SPIF        ;  /* SPI0CN.7 - SPI0 INTERRUPT FLAG                */


/* Predefined SFR Bit Masks */

#define PCON_IDLE         0x01    /* PCON                                */
#define PCON_STOP         0x02    /* PCON                                */
#define T1M               0x08    /* CKCON                               */
#define PSWE              0x01    /* PSCTL                               */
#define PSEE              0x02    /* PSCTL                               */
#define ECP0              0x20    /* EIE1                                */
#define ECP1              0x40    /* EIE1                                */
#define PORSF             0x02    /* RSTSRC                              */
#define SWRSF             0x10    /* RSTSRC                              */
#define ECCF              0x01    /* PCA0CPMn                            */
#define PWM               0x02    /* PCA0CPMn                            */
#define TOG               0x04    /* PCA0CPMn                            */
#define MAT               0x08    /* PCA0CPMn                            */
#define CAPN              0x10    /* PCA0CPMn                            */
#define CAPP              0x20    /* PCA0CPMn                            */
#define ECOM              0x40    /* PCA0CPMn                            */
#define PWM16             0x80    /* PCA0CPMn                            */
#define CP0E              0x10    /* XBR0                                */
#define CP0AE             0x20    /* XBR0                                */
#define CP1E              0x40    /* XBR0                                */
#define CP1AE             0x80    /* XBR0                                */

#endif
/*-------------------------------------------------------------------------
   cc2530.h - Register Declarations for Chipcon/Texas Intruments CC2530
   (Based on CC253x User's Guide (rev. B) SWRU191B)

   Copyright (C) 2011, Zafi Ramarosandratana / zramaro at gmail.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef REG_CC2530_H
#define REG_CC2530_H

#include <compiler.h>

// Interrupt Vectors

#define RFERR_VECTOR    0   // RF TX FIFO underflow and RX FIFO overflow.
#define ADC_VECTOR      1   // ADC end of conversion
#define URX0_VECTOR     2   // USART0 RX complete
#define URX1_VECTOR     3   // USART1 RX complete
#define ENC_VECTOR      4   // AES encryption/decryption complete
#define ST_VECTOR       5   // Sleep Timer compare
#define P2INT_VECTOR    6   // Port 2 inputs
#define UTX0_VECTOR     7   // USART0 TX complete
#define DMA_VECTOR      8   // DMA transfer complete
#define T1_VECTOR       9   // Timer 1 (16-bit) capture/compare/overflow
#define T2_VECTOR       10  // Timer 2 (MAC Timer)
#define T3_VECTOR       11  // Timer 3 (8-bit) capture/compare/overflow
#define T4_VECTOR       12  // Timer 4 (8-bit) capture/compare/overflow
#define P0INT_VECTOR    13  // Port 0 inputs
#define UTX1_VECTOR     14  // USART1 TX complete
#define P1INT_VECTOR    15  // Port 1 inputs
#define RF_VECTOR       16  // RF general interrupts
#define WDT_VECTOR      17  // Watchdog overflow in timer mode

// SFR Registers and BITs

SFR(P0,       0x80); // Port 0
   SBIT(P0_0,     0x80, 0); // Port 0 bit 0
   SBIT(P0_1,     0x80, 1); // Port 0 bit 1
   SBIT(P0_2,     0x80, 2); // Port 0 bit 2
   SBIT(P0_3,     0x80, 3); // Port 0 bit 3
   SBIT(P0_4,     0x80, 4); // Port 0 bit 4
   SBIT(P0_5,     0x80, 5); // Port 0 bit 5
   SBIT(P0_6,     0x80, 6); // Port 0 bit 6
   SBIT(P0_7,     0x80, 7); // Port 0 bit 7
SFR(SP,       0x81); // Stack Pointer
SFR(DPL0,     0x82); // Data Pointer 0 Low Byte
SFR(DPH0,     0x83); // Data Pointer 0 High Byte
SFR(DPL1,     0x84); // Data Pointer 1 Low Byte
SFR(DPH1,     0x85); // Data Pointer 1 High Byte
SFR(U0CSR,    0x86); // USART 0 Control and Status
SFR(PCON,     0x87); // Power Mode Control
SFR(TCON,     0x88); // Interrupt Flags
   SBIT(IT0,      0x88, 0); // reserved (must always be set to 1)
   SBIT(RFERRIF,  0x88, 1); // RF TX/RX FIFO interrupt flag
   SBIT(IT1,      0x88, 2); // reserved (must always be set to 1)
   SBIT(URX0IF,   0x88, 3); // USART0 RX Interrupt Flag
   SBIT(ADCIF,    0x88, 5); // ADC Interrupt Flag
   SBIT(URX1IF,   0x88, 7); // USART1 RX Interrupt Flag
SFR(P0IFG,    0x89); // Port 0 Interrupt Status Flag
SFR(P1IFG,    0x8A); // Port 1 Interrupt Status Flag
SFR(P2IFG,    0x8B); // Port 2 Interrupt Status Flag
SFR(PICTL,    0x8C); // Port Interrupt Control
SFR(P1IEN,    0x8D); // Port 1 Interrupt Mask
SFR(P0INP,    0x8F); // Port 0 Input Mode
SFR(P1,       0x90); // Port 1
   SBIT(P1_0,     0x90, 0); // Port 1 bit 0
   SBIT(P1_1,     0x90, 1); // Port 1 bit 1
   SBIT(P1_2,     0x90, 2); // Port 1 bit 2
   SBIT(P1_3,     0x90, 3); // Port 1 bit 3
   SBIT(P1_4,     0x90, 4); // Port 1 bit 4
   SBIT(P1_5,     0x90, 5); // Port 1 bit 5
   SBIT(P1_6,     0x90, 6); // Port 1 bit 6
   SBIT(P1_7,     0x90, 7); // Port 1 bit 7
SFR(RFIRQF1,  0x91); // RF Interrupt Flags MSB
SFR(DPS,      0x92); // Data Pointer Select
SFR(MPAGE,    0x93); // Memory Page Select
SFR(_XPAGE,   0x93); // XDATA/PDATA page alias for SDCC
SFR(T2CTRL,   0x94); // Timer 2 Control
SFR(ST0,      0x95); // Sleep Timer 0
SFR(ST1,      0x96); // Sleep Timer 1
SFR(ST2,      0x97); // Sleep Timer 2
SFR(S0CON,    0x98); // Interrupt Flags 2
   SBIT(ENCIF_0,  0x98, 0); // AES Interrupt Flag 0
   SBIT(ENCIF_1,  0x98, 1); // AES Interrupt Flag 1
SFR(IEN2,     0x9A); // Interrupt Enable 2
SFR(S1CON,    0x9B); // Interrupt Flags 3
SFR(T2EVTCFG, 0x9C); // Timer 2 Event Configuration
SFR(SLEEPSTA, 0x9D); // Sleep Mode Control Status
SFR(CLKCONSTA,0x9E); // Clock Control Status
SFR(PSBANK,   0x9F); // Identifier Name used by the trampoline __sdcc_banked_call
SFR(FMAP,     0x9F); // Flash Memory Bank Mapping
SFR(P2,       0xA0); // Port 2
   SBIT(P2_0,     0xA0, 0); // Port 2 bit 0
   SBIT(P2_1,     0xA0, 1); // Port 2 bit 1
   SBIT(P2_2,     0xA0, 2); // Port 2 bit 2
   SBIT(P2_3,     0xA0, 3); // Port 2 bit 3
   SBIT(P2_4,     0xA0, 4); // Port 2 bit 4
   SBIT(P2_5,     0xA0, 5); // Port 2 bit 5
   SBIT(P2_6,     0xA0, 6); // Port 2 bit 6
   SBIT(P2_7,     0xA0, 7); // Port 2 bit 7
SFR(T2IRQF,   0xA1); // Timer 2 Interrupt Flags
SFR(T2M0,     0xA2); // Timer 2 Multiplexed Register 0
SFR(T2M1,     0xA3); // Timer 2 Multiplexed Rgeister 1
SFR(T2MOVF0,  0xA4); // Timer 2 Multiplexed Overflow Register 0
SFR(T2MOVF1,  0xA5); // Timer 2 Multiplexed Overflow Register 1
SFR(T2MOVF2,  0xA6); // Timer 2 Multiplexed Overflow Register 2
SFR(T2IRQM,   0xA7); // Timer 2 Interrupt Mask
SFR(IEN0,     0xA8); // Interrupt Enable 0
   SBIT(RFERRIE,  0xA8, 0); // RF TX/RX FIFO interrupt Enable
   SBIT(ADCIE,    0xA8, 1); // ADC Interrupt Enable
   SBIT(URX0IE,   0xA8, 2); // USART0 RX Interrupt Enable
   SBIT(URX1IE,   0xA8, 3); // USART1 RX Interrupt Enable
   SBIT(ENCIE,    0xA8, 4); // AES Encryption/Decryption Interrupt Enable
   SBIT(STIE,     0xA8, 5); // Sleep Timer Interrupt Enable
   SBIT(EA,       0xA8, 7); // Global Interrupt Enable
SFR(IP0,      0xA9); // Interrupt Priority 0
SFR(P0IEN,    0xAB); // Port 0 Interrupt Mask
SFR(P2IEN,    0xAC); // Port 2 Interrupt Mask
SFR(STLOAD,   0xAD); // Sleep Timer Load Status
SFR(PMUX,     0xAE); // Power Down Signal Mux
SFR(T1STAT,   0xAF); // Timer 1 Status
SFR(ENCDI,    0xB1); // Encryption Input Data
SFR(ENCDO,    0xB2); // Encryption Output Data
SFR(ENCCS,    0xB3); // Encryption Control and Status
SFR(ADCCON1,  0xB4); // ADC Control 1
SFR(ADCCON2,  0xB5); // ADC Control 2
SFR(ADCCON3,  0xB6); // ADC Control 3
SFR(IEN1,     0xB8); // Interrupt Enable 1
   SBIT(DMAIE,    0xB8, 0); // DMA Transfer Interrupt Enable
   SBIT(T1IE,     0xB8, 1); // Timer 1 Interrupt Enable
   SBIT(T2IE,     0xB8, 2); // Timer 2 Interrupt Enable
   SBIT(T3IE,     0xB8, 3); // Timer 3 Interrupt Enable
   SBIT(T4IE,     0xB8, 4); // Timer 4 Interrupt Enable
   SBIT(P0IE,     0xB8, 5); // Port 0 Interrupt Enable
SFR(IP1,      0xB9); // Interrupt Priority 1
SFR(ADCL,     0xBA); // ADC Data Low
SFR(ADCH,     0xBB); // ADC Data High
SFR(RNDL,     0xBC); // Random Number Generator Data Low Byte
SFR(RNDH,     0xBD); // Random Number Generator Data High Byte
SFR(SLEEPCMD, 0xBE); // Sleep Mode Control Command
SFR(RFERRF,   0xBF); // RF Error Interrupt Flags
SFR(IRCON,    0xC0); // Interrupt Flags 4
   SBIT(DMAIF,    0xC0, 0); // DMA Complete Interrupt Flag
   SBIT(T1IF,     0xC0, 1); // Timer 1 Interrupt Flag
   SBIT(T2IF,     0xC0, 2); // Timer 2 Interrupt Flag
   SBIT(T3IF,     0xC0, 3); // Timer 3 Interrupt Flag
   SBIT(T4IF,     0xC0, 4); // Timer 4 Interrupt Flag
   SBIT(P0IF,     0xC0, 5); // Port 0 Interrupt Flag
   SBIT(STIF,     0xC0, 7); // Sleep Timer Interrupt Flag
SFR(U0DBUF,   0xC1); // USART 0 Receive/Transmit Data Buffer
SFR(U0BAUD,   0xC2); // USART 0 Baud Rate Control
SFR(T2MSEL,   0xC3); // Timer 2 Multiplex Select
SFR(U0UCR,    0xC4); // USART 0 UART Control
SFR(U0GCR,    0xC5); // USART 0 Generic Control
SFR(CLKCONCMD,0xC6); // Clock Control Command
SFR(MEMCTR,   0xC7); // Memory Arbitrer Control
SFR(WDCTL,    0xC9); // Watchdog Timer Control
SFR(T3CNT,    0xCA); // Timer 3 Counter
SFR(T3CTL,    0xCB); // Timer 3 Control
SFR(T3CCTL0,  0xCC); // Timer 3 Channel 0 Capture/Compare Control
SFR(T3CC0,    0xCD); // Timer 3 Channel 0 Capture/Compare Value
SFR(T3CCTL1,  0xCE); // Timer 3 Channel 1 Capture/Compare Control
SFR(T3CC1,    0xCF); // Timer 3 Channel 1 Capture/Compare Value
SFR(PSW,      0xD0); // Program Status Word
   SBIT(P,        0xD0, 0); // Parity Flag
   SBIT(F1,       0xD0, 1); // User-Defined Flag
   SBIT(OV,       0xD0, 2); // Overflow Flag
   SBIT(RS0,      0xD0, 3); // Register Bank Select 0
   SBIT(RS1,      0xD0, 4); // Register Bank Select 1
   SBIT(F0,       0xD0, 5); // User-Defined Flag
   SBIT(AC,       0xD0, 6); // Auxiliary Carry Flag
   SBIT(CY,       0xD0, 7); // Carry Flag
SFR(DMAIRQ,   0xD1); // DMA Interrupt Flag
SFR(DMA1CFGL, 0xD2); // DMA Channel 1-4 Configuration Address Low Byte
SFR(DMA1CFGH, 0xD3); // DMA Channel 1-4 Configuration Address High Byte
SFR(DMA0CFGL, 0xD4); // DMA Channel 0 Configuration Address Low Byte
SFR(DMA0CFGH, 0xD5); // DMA Channel 0 Configuration Address High Byte
SFR(DMAARM,   0xD6); // DMA Channel Arm
SFR(DMAREQ,   0xD7); // DMA Channel Start Request and Status
SFR(TIMIF,    0xD8); // Timers 1/3/4 Interrupt Mask/Flag
   SBIT(T3OVFIF,  0xD8, 0); // Timer 3 overflow interrupt flag 0:no pending 1:pending
   SBIT(T3CH0IF,  0xD8, 1); // Timer 3 channel 0 interrupt flag 0:no pending 1:pending
   SBIT(T3CH1IF,  0xD8, 2); // Timer 3 channel 1 interrupt flag 0:no pending 1:pending
   SBIT(T4OVFIF,  0xD8, 3); // Timer 4 overflow interrupt flag 0:no pending 1:pending
   SBIT(T4CH0IF,  0xD8, 4); // Timer 4 channel 0 interrupt flag 0:no pending 1:pending
   SBIT(T4CH1IF,  0xD8, 5); // Timer 4 channel 1 interrupt flag 0:no pending 1:pending
   SBIT(OVFIM,    0xD8, 6); // Timer 1 overflow interrupt mask
SFR(RFD,      0xD9); // RF Data
SFR(T1CC0L,   0xDA); // Timer 1 Channel 0 Capture/Compare Value Low
SFR(T1CC0H,   0xDB); // Timer 1 Channel 0 Capture/Compare Value High
SFR(T1CC1L,   0xDC); // Timer 1 Channel 1 Capture/Compare Value Low
SFR(T1CC1H,   0xDD); // Timer 1 Channel 1 Capture/Compare Value High
SFR(T1CC2L,   0xDE); // Timer 1 Channel 2 Capture/Compare Value Low
SFR(T1CC2H,   0xDF); // Timer 1 Channel 2 Capture/Compare Value High
SFR(ACC,      0xE0); // Accumulator
   SBIT(ACC_0,    0xE0, 0); // Accumulator bit 0
   SBIT(ACC_1,    0xE0, 1); // Accumulator bit 1
   SBIT(ACC_2,    0xE0, 2); // Accumulator bit 2
   SBIT(ACC_3,    0xE0, 3); // Accumulator bit 3
   SBIT(ACC_4,    0xE0, 4); // Accumulator bit 4
   SBIT(ACC_5,    0xE0, 5); // Accumulator bit 5
   SBIT(ACC_6,    0xE0, 6); // Accumulator bit 6
   SBIT(ACC_7,    0xE0, 7); // Accumulator bit 7
SFR(RFST,     0xE1); // RF CSMA-CA / Strobe Processor
SFR(T1CNTL,   0xE2); // Timer 1 Counter Low
SFR(T1CNTH,   0xE3); // Timer 1 Counter High
SFR(T1CTL,    0xE4); // Timer 1 Control and Status
SFR(T1CCTL0,  0xE5); // Timer 1 Channel 0 Capture/Compare Control
SFR(T1CCTL1,  0xE6); // Timer 1 Channel 1 Capture/Compare Control
SFR(T1CCTL2,  0xE7); // Timer 1 Channel 2 Capture/Compare Control
SFR(IRCON2,   0xE8); // Interrupt Flags 5
   SBIT(P2IF,     0xE8, 0); // Port 2 Interrupt Flag
   SBIT(UTX0IF,   0xE8, 1); // USART0 TX Interrupt Flag
   SBIT(UTX1IF,   0xE8, 2); // USART1 TX Interrupt Flag
   SBIT(P1IF,     0xE8, 3); // Port 1 Interrupt Flag
   SBIT(WDTIF,    0xE8, 4); // Watchdog Timer Interrupt Flag
SFR(RFIRQF0,  0xE9); // RF Interrupt Flags LSB
SFR(T4CNT,    0xEA); // Timer 4 Counter
SFR(T4CTL,    0xEB); // Timer 4 Control
SFR(T4CCTL0,  0xEC); // Timer 4 Channel 0 Capture/Compare Control
SFR(T4CC0,    0xED); // Timer 4 Channel 0 Capture/Compare Value
SFR(T4CCTL1,  0xEE); // Timer 4 Channel 1 Capture/Compare Control
SFR(T4CC1,    0xEF); // Timer 4 Channel 1 Capture/Compare Value
SFR(B,        0xF0); // B Register
   SBIT(B_0,      0xF0, 0); // Register B bit 0
   SBIT(B_1,      0xF0, 1); // Register B bit 1
   SBIT(B_2,      0xF0, 2); // Register B bit 2
   SBIT(B_3,      0xF0, 3); // Register B bit 3
   SBIT(B_4,      0xF0, 4); // Register B bit 4
   SBIT(B_5,      0xF0, 5); // Register B bit 5
   SBIT(B_6,      0xF0, 6); // Register B bit 6
   SBIT(B_7,      0xF0, 7); // Register B bit 7
SFR(PERCFG,   0xF1); // Peripheral I/O Control
SFR(APCFG,    0xF2); // Analog Peripheral I/O Configuration
SFR(P0SEL,    0xF3); // Port 0 Function Select
SFR(P1SEL,    0xF4); // Port 1 Function Select
SFR(P2SEL,    0xF5); // Port 2 Function Select
SFR(P1INP,    0xF6); // Port 1 Input Mode
SFR(P2INP,    0xF7); // Port 2 Input Mode
SFR(U1CSR,    0xF8); // USART 1 Control and Status
   SBIT(ACTIVE,   0xF8, 0); // USART transmit/receive active status 0:idle 1:busy
   SBIT(TX_BYTE,  0xF8, 1); // Transmit byte status 0:Byte not transmitted 1:Last byte transmitted
   SBIT(RX_BYTE,  0xF8, 2); // Receive byte status 0:No byte received 1:Received byte ready
   SBIT(ERR,      0xF8, 3); // UART parity error status 0:No error 1:parity error
   SBIT(FE,       0xF8, 4); // UART framing error status 0:No error 1:incorrect stop bit level
   SBIT(SLAVE,    0xF8, 5); // SPI master or slave mode select 0:master 1:slave
   SBIT(RE,       0xF8, 6); // UART receiver enable 0:disabled 1:enabled
   SBIT(MODE,     0xF8, 7); // USART mode select 0:SPI 1:UART
SFR(U1DBUF,   0xF9); // USART 1 Receive/Transmit Data Buffer
SFR(U1BAUD,   0xFA); // USART 1 Baud Rate Control
SFR(U1UCR,    0xFB); // USART 1 UART Control
SFR(U1GCR,    0xFC); // USART 1 Generic Control
SFR(P0DIR,    0xFD); // Port 0 Direction
SFR(P1DIR,    0xFE); // Port 1 Direction
SFR(P2DIR,    0xFF); // Port 2 Direction
//
//// From Table 2-2 : Overview of XREG Registers
//
SFRX(I2CCFG,     0x6230); // I2C control
SFRX(I2CSTAT,    0x6231); // I2C status
SFRX(I2CDATA,    0x6232); // I2C data
SFRX(I2CADDR,    0x6233); // I2C own slave address
SFRX(I2CWC,      0x6234); // Wrapper control
SFRX(I2CIO,      0x6235); // GPIO
SFRX(OBSSEL0,    0x6243); // Observation output control register 0
SFRX(OBSSEL1,    0x6244); // Observation output control register 1
SFRX(OBSSEL2,    0x6245); // Observation output control register 2
SFRX(OBSSEL3,    0x6246); // Observation output control register 3
SFRX(OBSSEL4,    0x6247); // Observation output control register 4
SFRX(OBSSEL5,    0x6248); // Observation output control register 5
SFRX(CHVER,      0x6249); // Chip version
SFRX(CHIPID,     0x624A); // Chip identification
SFRX(TESTREG0,   0x624B); // Test register 0, cannot use TR0 name from the datasheet due to TR0 (TCON.4) redefinition
SFRX(DBGDATA,    0x6260); // Debug interface write data
SFRX(SRCRC,      0x6262); // Sleep reset CRC
SFRX(BATTMON,    0x6264); // Battery monitor
SFRX(IVCTRL,     0x6265); // Analog control register
SFRX(FCTL,       0x6270); // Flash control
SFRX(FADDRL,     0x6271); // Flash address low
SFRX(FADDRH,     0x6272); // Flash address high
SFRX(FWDATA,     0x6273); // Flash write data
SFRX(CHIPINFO0,  0x6276); // Chip information byte 0
SFRX(CHIPINFO1,  0x6277); // Chip information byte 1
SFRX(IRCTL,      0x6281); // Timer 1 IR generation control
SFRX(CLD,        0x6290); // Clock-loss detection 
SFRX(X_T1CCTL0,    0x62A0); // Timer 1 channel 0 capture/compare control (additional XREG mapping of SFR register)
SFRX(X_T1CCTL1,    0x62A1); // Timer 1 channel 1 capture/compare control (additional XREG mapping of SFR register)
SFRX(X_T1CCTL2,    0x62A2); // Timer 1 channel 2 capture/compare control (additional XREG mapping of SFR register)
SFRX(T1CCTL3,    0x62A3); // Timer 1 channel 3 capture/compare control
SFRX(T1CCTL4,    0x62A4); // Timer 1 channel 4 capture/compare control
SFRX(X_T1CC0L,     0x62A6); // Timer 1 channel 0 capture/compare value low (additional XREG mapping of SFR register)
SFRX(X_T1CC0H,     0x62A7); // Timer 1 channel 0 capture/compare value high (additional XREG mapping of SFR register)
SFRX(X_T1CC1L,     0x62A8); // Timer 1 channel 1 capture/compare value low (additional XREG mapping of SFR register)
SFRX(X_T1CC1H,     0x62A9); // Timer 1 channel 1 capture/compare value high (additional XREG mapping of SFR register)
SFRX(X_T1CC2L,     0x62AA); // Timer 1 channel 2 capture/compare value low (additional XREG mapping of SFR register)
SFRX(X_T1CC2H,     0x62AB); // Timer 1 channel 2 capture/compare value high (additional XREG mapping of SFR register)
SFRX(T1CC3L,     0x62AC); // Timer 1 channel 3 capture/compare value low
SFRX(T1CC3H,     0x62AD); // Timer 1 channel 3 capture/compare value high
SFRX(T1CC4L,     0x62AE); // Timer 1 channel 4 capture/compare value low
SFRX(T1CC4H,     0x62AF); // Timer 1 channel 4 capture/compare value high
SFRX(STCC,       0x62B0); // Sleep Timer capture control
SFRX(STCS,       0x62B1); // Sleep Timer capture status
SFRX(STCV0,      0x62B2); // Sleep Timer capture value byte 0
SFRX(STCV1,      0x62B3); // Sleep Timer capture value byte 1
SFRX(STCV2,      0x62B4); // Sleep Timer capture value byte 2
SFRX(OPAMPC,     0x62C0); // Operational amplifier control
SFRX(OPAMPS,     0x62C1); // Operational amplifier status
SFRX(CMPCTL,     0x62D0); // Analog comparator control and status
//
//// From Section 21.12 : USB Registers
//
SFRX(USBADDR,    0x6200); // Function Address
SFRX(USBPOW,     0x6201); // Power/Control Register
SFRX(USBIIF,     0x6202); // IN Endpoints and EP0 Interrupt Flags
SFRX(USBOIF,     0x6204); // OUT-Endpoint Interrupt Flags
SFRX(USBCIF,     0x6206); // Common USB Interrupt Flags
SFRX(USBIIE,     0x6207); // IN Endpoints and EP0 Interrupt-Enable Mask
SFRX(USBOIE,     0x6209); // Out Endpoints Interrupt Enable Mask
SFRX(USBCIE,     0x620B); // Common USB Interrupt-Enable Mask
SFRX(USBFRML,    0x620C); // Current Frame Number (Low Byte)
SFRX(USBFRMH,    0x620D); // Current Frame Number (High Byte)
SFRX(USBINDEX,   0x620E); // Current-Endpoint Index Register
SFRX(USBCTRL,    0x620F); // USB Control Register
SFRX(USBMAXI,    0x6210); // Max. Packet Size for IN Endpoint{15}
SFRX(USBCS0,     0x6211); // EP0 Control and Status (USBINDEX = 0)
SFRX(USBCSIL,    0x6211); // IN EP{15} Control and Status, Low
SFRX(USBCSIH,    0x6212); // IN EP{15} Control and Status, High
SFRX(USBMAXO,    0x6213); // Max. Packet Size for OUT EP{15}
SFRX(USBCSOL,    0x6214); // OUT EP{15} Control and Status, Low
SFRX(USBCSOH,    0x6215); // OUT EP{15} Control and Status, High
SFRX(USBCNT0,    0x6216); // Number of Received Bytes in EP0 FIFO (USBINDEX = 0)
SFRX(USBCNTL,    0x6216); // Number of Bytes in EP{15} OUT FIFO, Low
SFRX(USBCNTH,    0x6217); // Number of Bytes in EP{15} OUT FIFO, High
SFRX(USBF0,      0x6220); // Endpoint-0 FIFO
SFRX(USBF1,      0x6222); // Endpoint-1 FIFO
SFRX(USBF2,      0x6224); // Endpoint-2 FIFO
SFRX(USBF3,      0x6226); // Endpoint-3 FIFO
SFRX(USBF4,      0x6228); // Endpoint-4 FIFO
SFRX(USBF5,      0x622A); // Endpoint-5 FIFO
//
//// From Table 23.1 : Frame Filtering
//
SFRX(SHORTADDRH, 0x6174); // Short Address High Byte
SFRX(SHORTADDRL, 0x6175); // Short Address Low Byte
SFRX(PANIDH,     0x6172); // PAN ID High Byte
SFRX(PANIDL,     0x6173); // PAN ID Low Byte
SFRX(IEEE_ADDR,  0x616A); // Extended Address MSB

//
//// From Table 23-5 : CC253x Radio Register Overview
//
SFRX(FRMFILT0,   0x6180); // Frame Filtering
SFRX(FRMFILT1,   0x6181); // Frame Filtering
SFRX(SRCMATCH,   0x6182); // Source Address Matching and Pending Bits
SFRX(SRCSHORTEN0,0x6183); // Short Address Matching
SFRX(SRCSHORTEN1,0x6184); // Short Address Matching
SFRX(SRCSHORTEN2,0x6185); // Short Address Matching
SFRX(SRCEXTEN0,  0x6186); // Extended Address Matching
SFRX(SRCEXTEN1,  0x6187); // Extended Address Matching
SFRX(SRCEXTEN2,  0x6188); // Extended Address Matching
SFRX(FRMCTRL0,   0x6189); // Frame Handling
SFRX(FRMCTRL1,   0x618A); // Frame Handling
SFRX(RXENABLE,   0x618B); // RX Enabling
SFRX(RXMASKSET,  0x618C); // RX Enabling
SFRX(RXMASKCLR,  0x618D); // RX Disabling
SFRX(FREQTUNE,   0x618E); // Crystal Oscillator Frequency Tuning
SFRX(FREQCTRL,   0x618F); // Controls the RF Frequency
SFRX(TXPOWER,    0x6190); // Controls the Output Power
SFRX(TXCTRL,     0x6191); // Controls the TX Settings
SFRX(FSMSTAT0,   0x6192); // Radio Status Register
SFRX(FSMSTAT1,   0x6193); // Radio Status Register
SFRX(FIFOPCTRL,  0x6194); // FIFOP Threshold
SFRX(FSMCTRL,    0x6195); // FSM Options
SFRX(CCACTRL0,   0x6196); // CCA Threshold
SFRX(CCACTRL1,   0x6197); // Other CCA Options
SFRX(RSSI,       0x6198); // RSSI Status Register
SFRX(RSSISTAT,   0x6199); // RSSI Valid Status Register
SFRX(RXFIRST,    0x619A); // First Byte in RXFIFO
SFRX(RXFIFOCNT,  0x619B); // Number of Bytes in RXFIFO
SFRX(TXFIFOCNT,  0x619C); // Number of Bytes in TXFIFO
SFRX(RXFIRST_PTR,0x619D); // RXFIFO Pointer
SFRX(RXLAST_PTR, 0x619E); // RXFIFO Pointer
SFRX(RXP1_PTR,   0x619F); // RXFIFO Pointer
SFRX(TXFIRST_PTR,0x61A1); // TXFIFO Pointer
SFRX(TXLAST_PTR, 0x61A2); // TXFIFO Pointer
SFRX(RFIRQM0,    0x61A3); // RF Interrupt Masks
SFRX(RFIRQM1,    0x61A4); // RF Interrupt Masks
SFRX(RFERRM,     0x61A5); // RF Error Interrupt Mask
SFRX(OPAMPMC,    0x61A6); // Operational amplifier mode control
SFRX(RFRND,      0x61A7); // Random Data
SFRX(MDMCTRL0,   0x61A8); // Controls Modem
SFRX(MDMCTRL1,   0x61A9); // Controls Modem
SFRX(FREQEST,    0x61AA); // Estimated RF Frequency Offset
SFRX(RXCTRL,     0x61AB); // Tune Receive Section
SFRX(FSCTRL,     0x61AC); // Tune Frequency Synthesizer
SFRX(FSCAL1,     0x61AE); // Tune Frequency Calibration
SFRX(FSCAL2,     0x61AF); // Tune Frequency Calibration
SFRX(FSCAL3,     0x61B0); // Tune Frequency Calibration
SFRX(AGCCTRL0,   0x61B1); // AGC Dynamic Range Control
SFRX(AGCCTRL1,   0x61B2); // AGC Reference Level
SFRX(AGCCTRL2,   0x61B3); // AGC Gain Override
SFRX(AGCCTRL3,   0x61B4); // AGC Control
SFRX(ADCTEST0,   0x61B5); // ADC Tuning
SFRX(ADCTEST1,   0x61B6); // ADC Tuning
SFRX(ADCTEST2,   0x61B7); // ADC Tuning
SFRX(MDMTEST0,   0x61B8); // Test Register for Modem
SFRX(MDMTEST1,   0x61B9); // Test Register for Modem
SFRX(DACTEST0,   0x61BA); // DAC Override Value
SFRX(DACTEST1,   0x61BB); // DAC Override Value
SFRX(DACTEST2,   0x61BC); // DAC Test Setting
SFRX(ATEST,      0x61BD); // Analog Test Control
SFRX(PTEST0,     0x61BE); // Override Power-Down Register
SFRX(PTEST1,     0x61BF); // Override Power-Down Register
SFRX(CSPPROG0,   0x61C0); // CSP Program 0
SFRX(CSPPROG1,   0x61C1); // CSP Program 1
SFRX(CSPPROG2,   0x61C2); // CSP Program 2
SFRX(CSPPROG3,   0x61C3); // CSP Program 3
SFRX(CSPPROG4,   0x61C4); // CSP Program 4
SFRX(CSPPROG5,   0x61C5); // CSP Program 5
SFRX(CSPPROG6,   0x61C6); // CSP Program 6
SFRX(CSPPROG7,   0x61C7); // CSP Program 7
SFRX(CSPPROG8,   0x61C8); // CSP Program 8
SFRX(CSPPROG9,   0x61C9); // CSP Program 9
SFRX(CSPPROG10,  0x61CA); // CSP Program 10
SFRX(CSPPROG11,  0x61CB); // CSP Program 11
SFRX(CSPPROG12,  0x61CC); // CSP Program 12
SFRX(CSPPROG13,  0x61CD); // CSP Program 13
SFRX(CSPPROG14,  0x61CE); // CSP Program 14
SFRX(CSPPROG15,  0x61CF); // CSP Program 15
SFRX(CSPPROG16,  0x61D0); // CSP Program 16
SFRX(CSPPROG17,  0x61D1); // CSP Program 17
SFRX(CSPPROG18,  0x61D2); // CSP Program 18
SFRX(CSPPROG19,  0x61D3); // CSP Program 19
SFRX(CSPPROG20,  0x61D4); // CSP Program 20
SFRX(CSPPROG21,  0x61D5); // CSP Program 21
SFRX(CSPPROG22,  0x61D6); // CSP Program 22
SFRX(CSPPROG23,  0x61D7); // CSP Program 23
SFRX(CSPCTRL,    0x61E0); // CSP Control Bit
SFRX(CSPSTAT,    0x61E1); // CSP Status Register
SFRX(CSPX,       0x61E2); // CSP X Register
SFRX(CSPY,       0x61E3); // CSP Y Register
SFRX(CSPZ,       0x61E4); // CSP Z Register
SFRX(CSPT,       0x61E5); // CSP T Register
SFRX(RFC_OBS_CTRL0, 0x61EB); // RF Observation Mux Control
SFRX(RFC_OBS_CTRL1, 0x61EC); // RF Observation Mux Control
SFRX(RFC_OBS_CTRL2, 0x61ED); // RF Observation Mux Control
SFRX(TXFILTCFG,  0x61FA); // TX Filter Configuration

#endif //REG_CC2530_H
/*--------------------------------------------------------------------------
P89LPC932.H
(English)
This header allows to use the microcontroler Philips P89LPC932
with the compiler SDCC.

Copyright (c) 2005 Omar Espinosa--e-mail: opiedrahita2003 AT yahoo.com.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

(Spanish-Español)
Archivo encabezador para el ucontrolador Philips P89LPC932.
Derechos de copy (DC) 2005.  OMAR ESPINOSA P.  E-mail: opiedrahita2003 AT yahoo.com
Uso libre
--------------------------------------------------------------------------*/
#ifndef __REG932_H__
#define __REG932_H__

/*  BYTE Registers  */
__sfr __at (0x80) P0     ;
__sfr __at (0x90) P1     ;
__sfr __at (0xA0) P2     ;
__sfr __at (0xB0) P3     ;
__sfr __at (0xD0) PSW    ;
__sfr __at (0xE0) ACC    ;
__sfr __at (0xF0) B      ;
__sfr __at (0x81) SP     ;
__sfr __at (0x82) DPL    ;
__sfr __at (0x83) DPH    ;
__sfr __at (0x87) PCON   ;
__sfr __at (0x88) TCON   ;
__sfr __at (0x89) TMOD   ;
__sfr __at (0x8A) TL0    ;
__sfr __at (0x8B) TL1    ;
__sfr __at (0x8C) TH0    ;
__sfr __at (0x8D) TH1    ;
__sfr __at (0xA8) IEN0   ;
__sfr __at (0xB8) IP0    ;
__sfr __at (0x98) SCON   ;
__sfr __at (0x99) SBUF   ;


__sfr __at (0xA2) AUXR1  ;
__sfr __at (0xA9) SADDR  ;
__sfr __at (0xB9) SADEN  ;
__sfr __at (0xCC) TL2    ;
__sfr __at (0xCD) TH2    ;
__sfr __at (0xBE) BRGR0  ;
__sfr __at (0xBF) BRGR1  ;
__sfr __at (0xBD) BRGCON ;
__sfr __at (0xEA) CCCRA  ;
__sfr __at (0xEB) CCCRB  ;
__sfr __at (0xEC) CCCRC  ;
__sfr __at (0xED) CCCRD  ;
__sfr __at (0xAC) CMP1   ;
__sfr __at (0xAD) CMP2   ;
__sfr __at (0xF1) DEECON ;
__sfr __at (0xF2) DEEDAT ;
__sfr __at (0xF3) DEEADR ;
__sfr __at (0x95) DIVM   ;
__sfr __at (0xDB) I2ADR  ;
__sfr __at (0xD8) I2CON  ;
__sfr __at (0xDA) I2DAT  ;
__sfr __at (0xDD) I2SCLH ;
__sfr __at (0xDC) I2SCLL ;
__sfr __at (0xD9) I2STAT ;
__sfr __at (0xAB) ICRAH  ;
__sfr __at (0xAA) ICRAL  ;
__sfr __at (0xAF) ICRBH  ;
__sfr __at (0xAE) ICRBL  ;
__sfr __at (0xE8) IEN1   ;
__sfr __at (0xF8) IP1    ;
__sfr __at (0xF7) IP1H   ;
__sfr __at (0x94) KBCON  ;
__sfr __at (0x86) KBMASK ;
__sfr __at (0x93) KBPATN ;
__sfr __at (0xEF) OCRAH  ;
__sfr __at (0xEE) OCRAL  ;
__sfr __at (0xFB) OCRBH  ;
__sfr __at (0xFA) OCRBL  ;
__sfr __at (0xFD) OCRCH  ;
__sfr __at (0xFC) OCRCL  ;
__sfr __at (0xFF) OCRDH  ;
__sfr __at (0xFE) OCRDL  ;
__sfr __at (0x84) P0M1   ;
__sfr __at (0x85) P0M2   ;
__sfr __at (0x91) P1M1   ;
__sfr __at (0x92) P1M2   ;
__sfr __at (0xA4) P2M1   ;
__sfr __at (0xA5) P2M2   ;
__sfr __at (0xB1) P3M1   ;
__sfr __at (0xB2) P3M2   ;
__sfr __at (0xB5) PCONA  ;
__sfr __at (0xF6) PT0AD  ;
__sfr __at (0xDF) RSTSRC ;
__sfr __at (0xD1) RTCCON ;
__sfr __at (0xD2) RTCH   ;
__sfr __at (0xD3) RTCL   ;
__sfr __at (0xBA) SSTAT  ;
__sfr __at (0xE2) SPCTL  ;
__sfr __at (0xE1) SPSTAT ;
__sfr __at (0xE3) SPDAT  ;
__sfr __at (0x8F) TAMOD  ;
__sfr __at (0xC8) TCR20  ;
__sfr __at (0xF9) TCR21  ;
__sfr __at (0xC9) TICR2  ;
__sfr __at (0xE9) TIFR2  ;
__sfr __at (0xDE) TISE2  ;
__sfr __at (0xCF) TOR2H  ;
__sfr __at (0xCE) TOR2L  ;
__sfr __at (0xCB) TPCR2H ;
__sfr __at (0xCA) TPCR2L ;
__sfr __at (0x96) TRIM   ;
__sfr __at (0xA7) WDCON  ;
__sfr __at (0xC1) WDL    ;
__sfr __at (0xC2) WFEED1 ;
__sfr __at (0xC3) WFEED2 ;
__sfr __at (0xB7) IP0H   ;

/*  BIT Registers  */
/*  PSW   */
__sbit __at (0xD7)    PSW_7;
__sbit __at (0xD6)    PSW_6;
__sbit __at (0xD5)    PSW_5;
__sbit __at (0xD4)    PSW_4;
__sbit __at (0xD3)    PSW_3;
__sbit __at (0xD2)    PSW_2;
__sbit __at (0xD1)    PSW_1;
__sbit __at (0xD0)    PSW_0;

#define CY      PSW_7
#define AC      PSW_6
#define F0      PSW_5
#define RS1     PSW_4
#define RS0     PSW_3
#define OV      PSW_2
#define F1      PSW_1
#define P       PSW_0

/*  TCON  */
__sbit __at (0x8F)    TCON_7;
__sbit __at (0x8E)    TCON_6;
__sbit __at (0x8D)    TCON_5;
__sbit __at (0x8C)    TCON_4;
__sbit __at (0x8B)    TCON_3;
__sbit __at (0x8A)    TCON_2;
__sbit __at (0x89)    TCON_1;
__sbit __at (0x88)    TCON_0;

#define  TF1    TCON_7
#define  TR1    TCON_6
#define  TF0    TCON_5
#define  TR0    TCON_4
#define  IE1    TCON_3
#define  IT1    TCON_2
#define  IE0    TCON_1
#define  IT0    TCON_0

/*  IEN0   */
__sbit __at (0xAF)    IEN0_7;
__sbit __at (0xAE)    IEN0_6;
__sbit __at (0xAD)    IEN0_5;
__sbit __at (0xAC)    IEN0_4; // alternatively "ESR"
__sbit __at (0xAC)    IEN0_4;
__sbit __at (0xAB)    IEN0_3;
__sbit __at (0xAA)    IEN0_2;
__sbit __at (0xA9)    IEN0_1;
__sbit __at (0xA8)    IEN0_0;

#define  EA	IEN0_7
#define  EWDRT  IEN0_6
#define  EBO    IEN0_5
#define  ES     IEN0_4  // alternatively "ESR"
#define  ESR    IEN0_4
#define  ET1    IEN0_3
#define  EX1    IEN0_2
#define  ET0    IEN0_1
#define  EX0    IEN0_0

/*  IEN1   */
__sbit __at (0xEF)   IEN1_7;
__sbit __at (0xEE)   IEN1_6;
__sbit __at (0xEC)   IEN1_4;
__sbit __at (0xEB)   IEN1_3;
__sbit __at (0xEA)   IEN1_2;
__sbit __at (0xE9)   IEN1_1;
__sbit __at (0xE8)   IEN1_0;

#define  EIEE   IEN1_7
#define  EST    IEN1_6
#define  ECCU   IEN1_4
#define  ESPI   IEN1_3
#define  EC     IEN1_2
#define  EKBI   IEN1_1
#define  EI2C   IEN1_0

/*  IP0   */
__sbit __at (0xBE)    IP0_6;
__sbit __at (0xBD)    IP0_5;
__sbit __at (0xBC)    IP0_4; // alternatively "PSR"
__sbit __at (0xBC)    IP0_4;
__sbit __at (0xBB)    IP0_3;
__sbit __at (0xBA)    IP0_2;
__sbit __at (0xB9)    IP0_1;
__sbit __at (0xB8)    IP0_0;

#define  PWDRT  IP0_6
#define  PB0    IP0_5
#define  PS     IP0_4 // alternatively "PSR"
#define  PSR    IP0_4
#define  PT1    IP0_3
#define  PX1    IP0_2
#define  PT0    IP0_1
#define  PX0    IP0_0

/*  SCON  */
__sbit __at (0x9F)    SCON_7; // alternatively "FE"
__sbit __at (0x9E)    SCON_6;
__sbit __at (0x9D)    SCON_5;
__sbit __at (0x9C)    SCON_4;
__sbit __at (0x9B)    SCON_3;
__sbit __at (0x9A)    SCON_2;
__sbit __at (0x99)    SCON_1;
__sbit __at (0x98)    SCON_0;

#define  SM0    SCON_7 // alternatively "FE"
#define  FE     SCON_7
#define  SM1    SCON_6
#define  SM2    SCON_5
#define  REN    SCON_4
#define  TB8    SCON_3
#define  RB8    SCON_2
#define  TI     SCON_1
#define  RI     SCON_0

/*  I2CON  */
__sbit __at (0xDE)    I2CON_6;
__sbit __at (0xDD)    I2CON_5;
__sbit __at (0xDC)    I2CON_4;
__sbit __at (0xDB)    I2CON_3;
__sbit __at (0xDA)    I2CON_2;
__sbit __at (0xD8)    I2CON_0;

#define  I2EN   I2CON_6;
#define  STA    I2CON_5;
#define  STO    I2CON_4;
#define  SI     I2CON_3;
#define  AA     I2CON_2;
#define  CRSEL  I2CON_0;

/*  P0  */
__sbit __at (0x87)    P0_7;
__sbit __at (0x86)    P0_6; // alternatively "CMP1"
__sbit __at (0x85)    P0_5;
__sbit __at (0x84)    P0_4;
__sbit __at (0x83)    P0_3;
__sbit __at (0x82)    P0_2;
__sbit __at (0x81)    P0_1;
__sbit __at (0x80)    P0_0; // alternatively "CMP2"

#define  KB7    P0_7  // alternatively "T1"
#define  T1     P0_7
#define  KB6    P0_6  // alternatively "CMP_1"
#define  CMP_1  P0_6
#define  KB5    P0_5
#define  KB4    P0_4
#define  KB3    P0_3
#define  KB2    P0_2
#define  KB1    P0_1
#define  KB0    P0_0  // alternatively "CMP_2"
#define  CMP_2  P0_0

/*  P1  */
__sbit __at (0x97)    P1_7;
__sbit __at (0x96)    P1_6;
__sbit __at (0x95)    P1_5;
__sbit __at (0x94)    P1_4;
__sbit __at (0x93)    P1_3;
__sbit __at (0x92)    P1_2;
__sbit __at (0x91)    P1_1;
__sbit __at (0x90)    P1_0;

#define  OCC    P1_7
#define  OCB    P1_6
#define  RST    P1_5
#define  INT1   P1_4
#define  INT0   P1_3 // alternatively "SDA"
#define  SDA    P1_3
#define  T0     P1_2 // alternatively "SCL"
#define  SCL    P1_2
#define  RxD    P1_1
#define  TxD    P1_0

/*  P2  */
__sbit __at (0xA7)    P2_7;
__sbit __at (0xA6)    P2_6;
__sbit __at (0xA5)    P2_5;
__sbit __at (0xA4)    P2_4;
__sbit __at (0xA3)    P2_3;
__sbit __at (0xA2)    P2_2;
__sbit __at (0xA1)    P2_1;
__sbit __at (0xA0)    P2_0;

#define  ICA    P2_7
#define  OCA    P2_6
#define  SPICLK P2_5
#define  SS     P2_4
#define  MISO   P2_3
#define  MOSI   P2_2
#define  OCD    P2_1
#define  ICB    P2_0

/*  P3  */
__sbit __at (0xB1)    P3_1;
__sbit __at (0xB0)    P3_0;

#define  XTAL1  P3_1
#define  XTAL2  P3_0

/* TCR20 */
__sbit __at (0xCF)    TCR20_7;
__sbit __at (0xCE)    TCR20_6;
__sbit __at (0xCD)    TCR20_5;
__sbit __at (0xCC)    TCR20_4;
__sbit __at (0xCB)    TCR20_3;
__sbit __at (0xCA)    TCR20_2;
__sbit __at (0xC9)    TCR20_1;
__sbit __at (0xC8)    TCR20_0;

#define  PLLEN  TCR20_7
#define  HLTRN  TCR20_6
#define  HLTEN  TCR20_5
#define  ALTCD  TCR20_4
#define  ALTAB  TCR20_3
#define  TDIR2  TCR20_2
#define  TMOD21 TCR20_1
#define  TMOD20 TCR20_0

#endif
/*-------------------------------------------------------------------------
   reg51.h - Register Declarations for 8051 Processor

   Copyright (C) 1998, Sandeep Dutta . sandeep.dutta@usa.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef REG51_H
#define REG51_H

#warning This file (reg51.h) is obsolete, use one appropriate for your harware!
#warning Falling back to include <8052.h>

#include <8052.h>

#endif
/*-------------------------------------------------------------------------
   serial_IO.h - Default putchar() and getchar() to the serial port

   Copyright (C) 2006, Jesus Calvino-Fraga / jesusc at ece.ubc.ca

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef SERIAL_IO_H
#define SERIAL_IO_H

__sfr __at (0x87) SIO_PCON;
__sfr __at (0x89) SIO_TMOD;
__sfr __at (0x8D) SIO_TH1;
__sfr __at (0x8B) SIO_TL1;
__sfr __at (0x98) SIO_SCON;
__sfr __at (0x99) SIO_SBUF;
__sbit __at (0x8E) SIO_TR1;

/*SCON bits*/
__sbit __at (0x98) SIO_RI;
__sbit __at (0x99) SIO_TI;
__sbit __at (0x9A) SIO_RB8;
__sbit __at (0x9B) SIO_TB8;
__sbit __at (0x9C) SIO_REN;
__sbit __at (0x9D) SIO_SM2;
__sbit __at (0x9E) SIO_SM1;
__sbit __at (0x9F) SIO_SM0;

void inituart (unsigned char t1_reload)
{
	SIO_TR1=0;
	SIO_TMOD=(SIO_TMOD&0x0f)|0x20;
	SIO_PCON|=0x80;
	SIO_TH1=SIO_TL1=t1_reload;
	SIO_TR1=1;
	SIO_SCON=0x52;
}

void putchar (char c)
{
	if((!SIO_SM0)&&(!SIO_SM1)) inituart(0xff);
	if (c=='\n')
	{
		while (!SIO_TI);
		SIO_TI=0;
		SIO_SBUF='\r';
	}
	while (!SIO_TI);
	SIO_TI=0;
	SIO_SBUF=c;
}

char getchar (void)
{
	char c;
	
	if((!SIO_SM0)&&(!SIO_SM1)) inituart(0xff);

	while (!SIO_RI);
	SIO_RI=0;
	c=SIO_SBUF;
	return c;
}
#endif
/*---------------------------------------------------------------------------
   C8051F018.h - Register Declarations for the Cygnal/SiLabs C8051F018-F019
   Processor Range

   Copyright (C) 2004, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef C8051F018_H
#define C8051F018_H


/*  BYTE Registers  */
__sfr __at (0x80) P0           ;  /* PORT 0                                                  */
__sfr __at (0x81) SP           ;  /* STACK POINTER                                           */
__sfr __at (0x82) DPL          ;  /* DATA POINTER - LOW BYTE                                 */
__sfr __at (0x83) DPH          ;  /* DATA POINTER - HIGH BYTE                                */
__sfr __at (0x87) PCON         ;  /* POWER CONTROL                                           */
__sfr __at (0x88) TCON         ;  /* TIMER CONTROL                                           */
__sfr __at (0x89) TMOD         ;  /* TIMER MODE                                              */
__sfr __at (0x8A) TL0          ;  /* TIMER 0 - LOW BYTE                                      */
__sfr __at (0x8B) TL1          ;  /* TIMER 1 - LOW BYTE                                      */
__sfr __at (0x8C) TH0          ;  /* TIMER 0 - HIGH BYTE                                     */
__sfr __at (0x8D) TH1          ;  /* TIMER 1 - HIGH BYTE                                     */
__sfr __at (0x8E) CKCON        ;  /* CLOCK CONTROL                                           */
__sfr __at (0x8F) PSCTL        ;  /* PROGRAM STORE R/W CONTROL                               */
__sfr __at (0x90) P1           ;  /* PORT 1                                                  */
__sfr __at (0x91) TMR3CN       ;  /* TIMER 3 CONTROL                                         */
__sfr __at (0x92) TMR3RLL      ;  /* TIMER 3 RELOAD REGISTER - LOW BYTE                      */
__sfr __at (0x93) TMR3RLH      ;  /* TIMER 3 RELOAD REGISTER - HIGH BYTE                     */
__sfr __at (0x94) TMR3L        ;  /* TIMER 3 - LOW BYTE                                      */
__sfr __at (0x95) TMR3H        ;  /* TIMER 3 - HIGH BYTE                                     */
__sfr __at (0x98) SCON         ;  /* SERIAL PORT CONTROL                                     */
__sfr __at (0x99) SBUF         ;  /* SERIAL PORT BUFFER                                      */
__sfr __at (0x9A) SPI0CFG      ;  /* SERIAL PERIPHERAL INTERFACE 0 CONFIGURATION             */
__sfr __at (0x9B) SPI0DAT      ;  /* SERIAL PERIPHERAL INTERFACE 0 DATA                      */
__sfr __at (0x9D) SPI0CKR      ;  /* SERIAL PERIPHERAL INTERFACE 0 CLOCK RATE CONTROL        */
__sfr __at (0x9E) CPT0CN       ;  /* COMPARATOR 0 CONTROL                                    */
__sfr __at (0x9F) CPT1CN       ;  /* COMPARATOR 1 CONTROL                                    */
__sfr __at (0xA0) P2           ;  /* PORT 2                                                  */
__sfr __at (0xA4) PRT0CF       ;  /* PORT 0 CONFIGURATION                                    */
__sfr __at (0xA5) PRT1CF       ;  /* PORT 1 CONFIGURATION                                    */
__sfr __at (0xA6) PRT2CF       ;  /* PORT 2 CONFIGURATION                                    */
__sfr __at (0xA7) PRT3CF       ;  /* PORT 3 CONFIGURATION                                    */
__sfr __at (0xA8) IE           ;  /* INTERRUPT ENABLE                                        */
__sfr __at (0xAD) PRT1IF       ;  /* PORT 1 EXTERNAL INTERRUPT FLAGS                         */
__sfr __at (0xAF) EMI0CN       ;  /* EXTERNAL MEMORY INTERFACE CONTROL                       */
__sfr __at (0xAF) _XPAGE       ;  /* XDATA/PDATA PAGE                                        */
__sfr __at (0xB0) P3           ;  /* PORT 3                                                  */
__sfr __at (0xB1) OSCXCN       ;  /* EXTERNAL OSCILLATOR CONTROL                             */
__sfr __at (0xB2) OSCICN       ;  /* INTERNAL OSCILLATOR CONTROL                             */
__sfr __at (0xB6) FLSCL        ;  /* FLASH MEMORY TIMING PRESCALER                           */
__sfr __at (0xB7) FLACL        ;  /* FLASH ACESS LIMIT                                       */
__sfr __at (0xB8) IP           ;  /* INTERRUPT PRIORITY                                      */
__sfr __at (0xBA) AMX0CF       ;  /* ADC 0 MUX CONFIGURATION                                 */
__sfr __at (0xBB) AMX0SL       ;  /* ADC 0 MUX CHANNEL SELECTION                             */
__sfr __at (0xBC) ADC0CF       ;  /* ADC 0 CONFIGURATION                                     */
__sfr __at (0xBE) ADC0L        ;  /* ADC 0 DATA - LOW BYTE                                   */
__sfr __at (0xBF) ADC0H        ;  /* ADC 0 DATA - HIGH BYTE                                  */
__sfr __at (0xC0) SMB0CN       ;  /* SMBUS 0 CONTROL                                         */
__sfr __at (0xC1) SMB0STA      ;  /* SMBUS 0 STATUS                                          */
__sfr __at (0xC2) SMB0DAT      ;  /* SMBUS 0 DATA                                            */
__sfr __at (0xC3) SMB0ADR      ;  /* SMBUS 0 SLAVE ADDRESS                                   */
__sfr __at (0xC4) ADC0GTL      ;  /* ADC 0 GREATER-THAN REGISTER - LOW BYTE                  */
__sfr __at (0xC5) ADC0GTH      ;  /* ADC 0 GREATER-THAN REGISTER - HIGH BYTE                 */
__sfr __at (0xC6) ADC0LTL      ;  /* ADC 0 LESS-THAN REGISTER - LOW BYTE                     */
__sfr __at (0xC7) ADC0LTH      ;  /* ADC 0 LESS-THAN REGISTER - HIGH BYTE                    */
__sfr __at (0xC8) T2CON        ;  /* TIMER 2 CONTROL                                         */
__sfr __at (0xCA) RCAP2L       ;  /* TIMER 2 CAPTURE REGISTER - LOW BYTE                     */
__sfr __at (0xCB) RCAP2H       ;  /* TIMER 2 CAPTURE REGISTER - HIGH BYTE                    */
__sfr __at (0xCC) TL2          ;  /* TIMER 2 - LOW BYTE                                      */
__sfr __at (0xCD) TH2          ;  /* TIMER 2 - HIGH BYTE                                     */
__sfr __at (0xCF) SMB0CR       ;  /* SMBUS 0 CLOCK RATE                                      */
__sfr __at (0xD0) PSW          ;  /* PROGRAM STATUS WORD                                     */
__sfr __at (0xD1) REF0CN       ;  /* VOLTAGE REFERENCE 0 CONTROL                             */
__sfr __at (0xD8) PCA0CN       ;  /* PCA 0 COUNTER CONTROL                                   */
__sfr __at (0xD9) PCA0MD       ;  /* PCA 0 COUNTER MODE                                      */
__sfr __at (0xDA) PCA0CPM0     ;  /* CONTROL REGISTER FOR PCA 0 MODULE 0                     */
__sfr __at (0xDB) PCA0CPM1     ;  /* CONTROL REGISTER FOR PCA 0 MODULE 1                     */
__sfr __at (0xDC) PCA0CPM2     ;  /* CONTROL REGISTER FOR PCA 0 MODULE 2                     */
__sfr __at (0xDD) PCA0CPM3     ;  /* CONTROL REGISTER FOR PCA 0 MODULE 3                     */
__sfr __at (0xDE) PCA0CPM4     ;  /* CONTROL REGISTER FOR PCA 0 MODULE 4                     */
__sfr __at (0xE0) ACC          ;  /* ACCUMULATOR                                             */
__sfr __at (0xE1) XBR0         ;  /* DIGITAL CROSSBAR CONFIGURATION REGISTER 0               */
__sfr __at (0xE2) XBR1         ;  /* DIGITAL CROSSBAR CONFIGURATION REGISTER 1               */
__sfr __at (0xE3) XBR2         ;  /* DIGITAL CROSSBAR CONFIGURATION REGISTER 2               */
__sfr __at (0xE6) EIE1         ;  /* EXTERNAL INTERRUPT ENABLE 1                             */
__sfr __at (0xE7) EIE2         ;  /* EXTERNAL INTERRUPT ENABLE 2                             */
__sfr __at (0xE8) ADC0CN       ;  /* ADC 0 CONTROL                                           */
__sfr __at (0xE9) PCA0L        ;  /* PCA 0 TIMER - LOW BYTE                                  */
__sfr __at (0xEA) PCA0CPL0     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 0 - LOW BYTE  */
__sfr __at (0xEB) PCA0CPL1     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 1 - LOW BYTE  */
__sfr __at (0xEC) PCA0CPL2     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 2 - LOW BYTE  */
__sfr __at (0xED) PCA0CPL3     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 3 - LOW BYTE  */
__sfr __at (0xEE) PCA0CPL4     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 4 - LOW BYTE  */
__sfr __at (0xEF) RSTSRC       ;  /* RESET SOURCE                                            */
__sfr __at (0xF0) B            ;  /* B REGISTER                                              */
__sfr __at (0xF6) EIP1         ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 1                  */
__sfr __at (0xF7) EIP2         ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 2                  */
__sfr __at (0xF8) SPI0CN       ;  /* SERIAL PERIPHERAL INTERFACE 0 CONTROL                   */
__sfr __at (0xF9) PCA0H        ;  /* PCA 0 TIMER - HIGH BYTE                                 */
__sfr __at (0xFA) PCA0CPH0     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 0 - HIGH BYTE */
__sfr __at (0xFB) PCA0CPH1     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 1 - HIGH BYTE */
__sfr __at (0xFC) PCA0CPH2     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 2 - HIGH BYTE */
__sfr __at (0xFD) PCA0CPH3     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 3 - HIGH BYTE */
__sfr __at (0xFE) PCA0CPH4     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 4 - HIGH BYTE */
__sfr __at (0xFF) WDTCN        ;  /* WATCHDOG TIMER CONTROL                                  */


/*  WORD/DWORD Registers  */

__sfr16 __at (0x8C8A) TMR0     ;  /* TIMER 0 COUNTER                                         */
__sfr16 __at (0x8D8B) TMR1     ;  /* TIMER 1 COUNTER                                         */
__sfr16 __at (0xCDCC) TMR2     ;  /* TIMER 2 COUNTER                                         */
__sfr16 __at (0xCBCA) RCAP2    ;  /* TIMER 2 CAPTURE REGISTER WORD                           */
__sfr16 __at (0x9594) TMR3     ;  /* TIMER 3 COUNTER                                         */
__sfr16 __at (0x9392) TMR3RL   ;  /* TIMER 3 CAPTURE REGISTER WORD                           */
__sfr16 __at (0xBFBE) ADC0     ;  /* ADC 0 DATA WORD                                         */
__sfr16 __at (0xC5C4) ADC0GT   ;  /* ADC 0 GREATER-THAN REGISTER WORD                        */
__sfr16 __at (0xC7C6) ADC0LT   ;  /* ADC 0 LESS-THAN REGISTER WORD                           */
__sfr16 __at (0xF9E9) PCA0     ;  /* PCA COUNTER                                             */
__sfr16 __at (0xFAEA) PCA0CP0  ;  /* PCA CAPTURE 0 WORD                                      */
__sfr16 __at (0xFBEB) PCA0CP1  ;  /* PCA CAPTURE 1 WORD                                      */
__sfr16 __at (0xFCEC) PCA0CP2  ;  /* PCA CAPTURE 2 WORD                                      */
__sfr16 __at (0xFDED) PCA0CP3  ;  /* PCA CAPTURE 3 WORD                                      */
__sfr16 __at (0xFEEE) PCA0CP4  ;  /* PCA CAPTURE 4 WORD                                      */


/*  BIT Registers  */

/*  P0  0x80 */
__sbit __at (0x87) P0_7        ;
__sbit __at (0x86) P0_6        ;
__sbit __at (0x85) P0_5        ;
__sbit __at (0x84) P0_4        ;
__sbit __at (0x83) P0_3        ;
__sbit __at (0x82) P0_2        ;
__sbit __at (0x81) P0_1        ;
__sbit __at (0x80) P0_0        ;

/*  TCON  0x88 */
__sbit __at (0x8F) TF1         ;  /* TIMER 1 OVERFLOW FLAG                                   */
__sbit __at (0x8E) TR1         ;  /* TIMER 1 ON/OFF CONTROL                                  */
__sbit __at (0x8D) TF0         ;  /* TIMER 0 OVERFLOW FLAG                                   */
__sbit __at (0x8C) TR0         ;  /* TIMER 0 ON/OFF CONTROL                                  */
__sbit __at (0x8B) IE1         ;  /* EXT. INTERRUPT 1 EDGE FLAG                              */
__sbit __at (0x8A) IT1         ;  /* EXT. INTERRUPT 1 TYPE                                   */
__sbit __at (0x89) IE0         ;  /* EXT. INTERRUPT 0 EDGE FLAG                              */
__sbit __at (0x88) IT0         ;  /* EXT. INTERRUPT 0 TYPE                                   */

/*  P1  0x90 */
__sbit __at (0x97) P1_7        ;
__sbit __at (0x96) P1_6        ;
__sbit __at (0x95) P1_5        ;
__sbit __at (0x94) P1_4        ;
__sbit __at (0x93) P1_3        ;
__sbit __at (0x92) P1_2        ;
__sbit __at (0x91) P1_1        ;
__sbit __at (0x90) P1_0        ;

/*  SCON  0x98 */
__sbit __at (0x9F) SM0         ;  /* SERIAL MODE CONTROL BIT 0                               */
__sbit __at (0x9E) SM1         ;  /* SERIAL MODE CONTROL BIT 1                               */
__sbit __at (0x9D) SM2         ;  /* MULTIPROCESSOR COMMUNICATION ENABLE                     */
__sbit __at (0x9C) REN         ;  /* RECEIVE ENABLE                                          */
__sbit __at (0x9B) TB8         ;  /* TRANSMIT BIT 8                                          */
__sbit __at (0x9A) RB8         ;  /* RECEIVE BIT 8                                           */
__sbit __at (0x99) TI          ;  /* TRANSMIT INTERRUPT FLAG                                 */
__sbit __at (0x98) RI          ;  /* RECEIVE INTERRUPT FLAG                                  */

/*  P2  0xA0 */
__sbit __at (0xA7) P2_7        ;
__sbit __at (0xA6) P2_6        ;
__sbit __at (0xA5) P2_5        ;
__sbit __at (0xA4) P2_4        ;
__sbit __at (0xA3) P2_3        ;
__sbit __at (0xA2) P2_2        ;
__sbit __at (0xA1) P2_1        ;
__sbit __at (0xA0) P2_0        ;

/*  IE  0xA8 */
__sbit __at (0xAF) EA          ;  /* GLOBAL INTERRUPT ENABLE                                 */
__sbit __at (0xAD) ET2         ;  /* TIMER 2 INTERRUPT ENABLE                                */
__sbit __at (0xAC) ES          ;  /* SERIAL PORT INTERRUPT ENABLE                            */
__sbit __at (0xAB) ET1         ;  /* TIMER 1 INTERRUPT ENABLE                                */
__sbit __at (0xAA) EX1         ;  /* EXTERNAL INTERRUPT 1 ENABLE                             */
__sbit __at (0xA9) ET0         ;  /* TIMER 0 INTERRUPT ENABLE                                */
__sbit __at (0xA8) EX0         ;  /* EXTERNAL INTERRUPT 0 ENABLE                             */

/*  P3  0xB0 */
__sbit __at (0xB7) P3_7        ;
__sbit __at (0xB6) P3_6        ;
__sbit __at (0xB5) P3_5        ;
__sbit __at (0xB4) P3_4        ;
__sbit __at (0xB3) P3_3        ;
__sbit __at (0xB2) P3_2        ;
__sbit __at (0xB1) P3_1        ;
__sbit __at (0xB0) P3_0        ;

/*  IP  0xB8 */
__sbit __at (0xBD) PT2         ;  /* TIMER 2 PRIORITY                                        */
__sbit __at (0xBC) PS          ;  /* SERIAL PORT PRIORITY                                    */
__sbit __at (0xBB) PT1         ;  /* TIMER 1 PRIORITY                                        */
__sbit __at (0xBA) PX1         ;  /* EXTERNAL INTERRUPT 1 PRIORITY                           */
__sbit __at (0xB9) PT0         ;  /* TIMER 0 PRIORITY                                        */
__sbit __at (0xB8) PX0         ;  /* EXTERNAL INTERRUPT 0 PRIORITY                           */

/*  SMB0CN  0xC0 */
__sbit __at (0xC7) BUSY        ;  /* SMBUS 0 BUSY                                            */
__sbit __at (0xC6) ENSMB       ;  /* SMBUS 0 ENABLE                                          */
__sbit __at (0xC5) STA         ;  /* SMBUS 0 START FLAG                                      */
__sbit __at (0xC4) STO         ;  /* SMBUS 0 STOP FLAG                                       */
__sbit __at (0xC3) SI          ;  /* SMBUS 0 INTERRUPT PENDING FLAG                          */
__sbit __at (0xC2) AA          ;  /* SMBUS 0 ASSERT/ACKNOWLEDGE FLAG                         */
__sbit __at (0xC1) SMBFTE      ;  /* SMBUS 0 FREE TIMER ENABLE                               */
__sbit __at (0xC0) SMBTOE      ;  /* SMBUS 0 TIMEOUT ENABLE                                  */

/*  T2CON  0xC8 */
__sbit __at (0xCF) TF2         ;  /* TIMER 2 OVERFLOW FLAG                                   */
__sbit __at (0xCE) EXF2        ;  /* EXTERNAL FLAG                                           */
__sbit __at (0xCD) RCLK        ;  /* RECEIVE CLOCK FLAG                                      */
__sbit __at (0xCC) TCLK        ;  /* TRANSMIT CLOCK FLAG                                     */
__sbit __at (0xCB) EXEN2       ;  /* TIMER 2 EXTERNAL ENABLE FLAG                            */
__sbit __at (0xCA) TR2         ;  /* TIMER 2 ON/OFF CONTROL                                  */
__sbit __at (0xC9) CT2         ;  /* TIMER OR COUNTER SELECT                                 */
__sbit __at (0xC8) CPRL2       ;  /* CAPTURE OR RELOAD SELECT                                */

/*  PSW  0xD0 */
__sbit __at (0xD7) CY          ;  /* CARRY FLAG                                              */
__sbit __at (0xD6) AC          ;  /* AUXILIARY CARRY FLAG                                    */
__sbit __at (0xD5) F0          ;  /* USER FLAG 0                                             */
__sbit __at (0xD4) RS1         ;  /* REGISTER BANK SELECT 1                                  */
__sbit __at (0xD3) RS0         ;  /* REGISTER BANK SELECT 0                                  */
__sbit __at (0xD2) OV          ;  /* OVERFLOW FLAG                                           */
__sbit __at (0xD1) F1          ;  /* USER FLAG 1                                             */
__sbit __at (0xD0) P           ;  /* ACCUMULATOR PARITY FLAG                                 */

/*  PCA0CN  0xD8H */
__sbit __at (0xDF) CF          ;  /* PCA 0 COUNTER OVERFLOW FLAG                             */
__sbit __at (0xDE) CR          ;  /* PCA 0 COUNTER RUN CONTROL BIT                           */
__sbit __at (0xDC) CCF4        ;  /* PCA 0 MODULE 4 INTERRUPT FLAG                           */
__sbit __at (0xDB) CCF3        ;  /* PCA 0 MODULE 3 INTERRUPT FLAG                           */
__sbit __at (0xDA) CCF2        ;  /* PCA 0 MODULE 2 INTERRUPT FLAG                           */
__sbit __at (0xD9) CCF1        ;  /* PCA 0 MODULE 1 INTERRUPT FLAG                           */
__sbit __at (0xD8) CCF0        ;  /* PCA 0 MODULE 0 INTERRUPT FLAG                           */

/*  ADC0CN  0xE8H */
__sbit __at (0xEF) AD0EN       ;  /* ADC 0 ENABLE                                            */
__sbit __at (0xEE) AD0TM       ;  /* ADC 0 TRACK MODE                                        */
__sbit __at (0xED) AD0INT      ;  /* ADC 0 CONVERISION COMPLETE INTERRUPT FLAG               */
__sbit __at (0xEC) AD0BUSY     ;  /* ADC 0 BUSY FLAG                                         */
__sbit __at (0xEB) ADSTM1      ;  /* ADC 0 START OF CONVERSION MODE BIT 1                    */
__sbit __at (0xEA) ADSTM0      ;  /* ADC 0 START OF CONVERSION MODE BIT 0                    */
__sbit __at (0xE9) AD0WINT     ;  /* ADC 0 WINDOW COMPARE INTERRUPT FLAG                     */
__sbit __at (0xE8) ADLJST      ;  /* ADC 0 RIGHT JUSTIFY DATA BIT                            */

/*  SPI0CN  0xF8H */
__sbit __at (0xFF) SPIF        ;  /* SPI 0 INTERRUPT FLAG                                    */
__sbit __at (0xFE) WCOL        ;  /* SPI 0 WRITE COLLISION FLAG                              */
__sbit __at (0xFD) MODF        ;  /* SPI 0 MODE FAULT FLAG                                   */
__sbit __at (0xFC) RXOVRN      ;  /* SPI 0 RX OVERRUN FLAG                                   */
__sbit __at (0xFB) TXBSY       ;  /* SPI 0 TX BUSY FLAG                                      */
__sbit __at (0xFA) SLVSEL      ;  /* SPI 0 SLAVE SELECT                                      */
__sbit __at (0xF9) MSTEN       ;  /* SPI 0 MASTER ENABLE                                     */
__sbit __at (0xF8) SPIEN       ;  /* SPI 0 SPI ENABLE                                        */


/* Predefined SFR Bit Masks */

#define PCON_IDLE         0x01    /* PCON                                */
#define PCON_STOP         0x02    /* PCON                                */
#define TF3               0x80    /* TMR3CN                              */
#define CPFIF             0x10    /* CPTnCN                              */
#define CPRIF             0x20    /* CPTnCN                              */
#define CPOUT             0x40    /* CPTnCN                              */
#define ECCF              0x01    /* PCA0CPMn                            */
#define PWM               0x02    /* PCA0CPMn                            */
#define TOG               0x04    /* PCA0CPMn                            */
#define MAT               0x08    /* PCA0CPMn                            */
#define CAPN              0x10    /* PCA0CPMn                            */
#define CAPP              0x20    /* PCA0CPMn                            */
#define ECOM              0x40    /* PCA0CPMn                            */

#endif
/*-------------------------------------------------------------------------
   at89Sx051.h - Register Declarations for Atmel AT89S2051 and AT89S4051
   Processors

   Copyright (C) 2009, Ben Boeckel mathstuf AT gmail.com

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------
   based on 8051.h (8051.h must be in mcs51 subdirectory)

   KEIL C compatible definitions are included
-------------------------------------------------------------------------*/

#ifndef AT89Sx051_H
#define AT89Sx051_H

#include <at89x051.h>     /* at89Sx051 adds to at89Cx051 definitions */

/* BYTE Register */
__sfr __at (0x8F) CLKREG ;
__sfr __at (0x97) ACSR   ;
__sfr __at (0xA9) SADDR  ;
__sfr __at (0xB7) IPH    ;
__sfr __at (0xB9) SADEN  ;

/* BIT register */
/* IE */
__sbit __at (0xAE) EC    ;

/* IP */
__sbit __at (0xBE) PC    ;

/* BIT definitions for bits that are not directly accessible */
/* PCON */
#define PWMEN            0x20
#define SMOD0            0x40
#define SMOD1            0x80

/* CLKREG */
#define X2               0x01
#define PWDEX            0x02

/* ACSR */
#define CM0              0x01
#define CM1              0x02
#define CM2              0x04
#define CEN              0x08
#define CF               0x10

/* IPH */
#define PX0H             0x01
#define PT0H             0x02
#define PX1H             0x04
#define PT1H             0x08
#define PSH              0x10
#define PCH              0x40


/* Interrupt numbers: address = (number * 8) + 3 */
#define CF0_VECTOR       6      /* 0x33 analog comparator */

#endif
/*-------------------------------------------------------------------------
   p89lpc9321.h - Register Declarations for NXP the P89LPC9321
   (Based on user manual (UM10310_1) Rev. 01  1 December 2008)

   Copyright (C) 2009, Jesus Calvino-Fraga / jesusc at ece.ubc.ca

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef REG_P89LPC9321_H
#define REG_P89LPC9321_H

#include <compiler.h>

SFR(ACC,     0xe0); // Accumulator
    SBIT(ACC_7,   0xe0, 7);
    SBIT(ACC_6,   0xe0, 6);
    SBIT(ACC_5,   0xe0, 5);
    SBIT(ACC_4,   0xe0, 4);
    SBIT(ACC_3,   0xe0, 3);
    SBIT(ACC_2,   0xe0, 2);
    SBIT(ACC_1,   0xe0, 1);
    SBIT(ACC_0,   0xe0, 0);
SFR(AUXR1,   0xa2); // Auxiliary function register
    #define CLKLP    0x80
    #define EBRR     0x40
    #define ENT1     0x20
    #define ENT0     0x10
    #define SRST     0x08
    #define DPS      0x01
SFR(B,       0xf0); // B register
    SBIT(B_7,     0xf0, 7);
    SBIT(B_6,     0xf0, 6);
    SBIT(B_5,     0xf0, 5);
    SBIT(B_4,     0xf0, 4);
    SBIT(B_3,     0xf0, 3);
    SBIT(B_2,     0xf0, 2);
    SBIT(B_1,     0xf0, 1);
    SBIT(B_0,     0xf0, 0);
SFR(BRGR0,   0xbe); // Baud rate generator 0 rate low
SFR(BRGR1,   0xbf); // Baud rate generator 0 rate high
SFR(BRGCON,  0xbd); // Baud rate generator 0 control
    #define SBRGS    0x02
    #define BRGEN    0x01
SFR(CCCRA,   0xea); // Capture compare A control register
    #define ICECA2   0x80
    #define ICECA1   0x40
    #define ICECA0   0x20
    #define ICESA    0x10
    #define ICNFA    0x08
    #define FCOA     0x04
    #define OCMA1    0x02
    #define OCMA0    0x01
SFR(CCCRB,   0xeb); // Capture compare B control register
    #define ICECB2   0x80
    #define ICECB1   0x40
    #define ICECB0   0x20
    #define ICESB    0x10
    #define ICNFB    0x08
    #define FCOB     0x04
    #define OCMB1    0x02
    #define OCMB0    0x01
SFR(CCCRC,   0xec); // Capture compare C control register
    #define FCOC     0x04
    #define OCMC1    0x02
    #define OCMC0    0x01
SFR(CCCRD,   0xed); // Capture compare D control register
    #define FCOD     0x04
    #define OCMD1    0x02
    #define OCMD0    0x01
SFR(CMP1,    0xac); // Comparator 1 control register
    #define CE1      0x20
    #define CP1      0x10
    #define CN1      0x08
    #define OE1      0x04
    #define CO1      0x02
    #define CMF1     0x01
SFR(CMP2,    0xad); // Comparator 2 control register
    #define CE2      0x20
    #define CP2      0x10
    #define CN2      0x08
    #define OE2      0x04
    #define CO2      0x02
    #define CMF2     0x01
SFR(DEECON,  0xf1); // Data EEPROM control register
    #define EEIF     0x80
    #define HVERR    0x40
    #define ECTL1    0x20
    #define ECTL0    0x10
    #define EWERR1   0x04
    #define EWERR0   0x02
    #define EADR8    0x01
SFR(DEEDAT,  0xf2); // Data EEPROM data register
SFR(DEEADR,  0xf3); // Data EEPROM address register
SFR(DIVM,    0x95); // CPU clock divide-by-M control
SFR(DPH,     0x83); // Data pointer high
SFR(DPL,     0x82); // Data pointer low
SFR(FMADRH,  0xe7); // Program flash address high
SFR(FMADRL,  0xe6); // Program flash address low
SFR(FMCON,   0xe4); // Program flash control Read
    #define BUSY     0x80
    #define HVA      0x08
    #define HVE      0x04
    #define SV       0x02
    #define OI       0x01
    #define FMCMD_7  0x80
    #define FMCMD_6  0x40
    #define FMCMD_5  0x20
    #define FMCMD_4  0x10
    #define FMCMD_3  0x08
    #define FMCMD_2  0x04
    #define FMCMD_1  0x02
    #define FMCMD_0  0x01
SFR(FMDATA,  0xe5); // Program flash data
SFR(I2ADR,   0xdb); // I2C-bus slave address register
    #define I2ADR_6  0x80
    #define I2ADR_5  0x40
    #define I2ADR_4  0x20
    #define I2ADR_3  0x10
    #define I2ADR_2  0x08
    #define I2ADR_1  0x04
    #define I2ADR_0  0x02
    #define GC       0x01
SFR(I2CON,   0xd8); // I2C-bus control register
    SBIT(I2CON_7, 0xd8, 7);
    SBIT(I2CON_6, 0xd8, 6);
    SBIT(I2CON_5, 0xd8, 5);
    SBIT(I2CON_4, 0xd8, 4);
    SBIT(I2CON_3, 0xd8, 3);
    SBIT(I2CON_2, 0xd8, 2);
    SBIT(I2CON_1, 0xd8, 1);
    SBIT(I2CON_0, 0xd8, 0);
    SBIT(I2EN,    0xd8, 6);
    SBIT(STA,     0xd8, 5);
    SBIT(STO,     0xd8, 4);
    SBIT(SI,      0xd8, 3);
    SBIT(AA,      0xd8, 2);
    SBIT(CRSEL,   0xd8, 0);
SFR(I2DAT,   0xda); // I2C-bus data register
SFR(I2SCLH,  0xdd); // Serial clock generator/SCL duty cycle register high
SFR(I2SCLL,  0xdc); // Serial clock generator/SCL duty cycle register low
SFR(I2STAT,  0xd9); // I2C-bus status register
    #define STA_4    0x80
    #define STA_3    0x40
    #define STA_2    0x20
    #define STA_1    0x10
    #define STA_0    0x08
SFR(ICRAH,   0xab); // Input capture A register high
SFR(ICRAL,   0xaa); // Input capture A register low
SFR(ICRBH,   0xaf); // Input capture B register high
SFR(ICRBL,   0xae); // Input capture B register low
SFR(IEN0,    0xa8); // Interrupt enable 0
    SBIT(IEN0_7,  0xa8, 7);
    SBIT(IEN0_6,  0xa8, 6);
    SBIT(IEN0_5,  0xa8, 5);
    SBIT(IEN0_4,  0xa8, 4);
    SBIT(IEN0_3,  0xa8, 3);
    SBIT(IEN0_2,  0xa8, 2);
    SBIT(IEN0_1,  0xa8, 1);
    SBIT(IEN0_0,  0xa8, 0);
    SBIT(EA,      0xa8, 7);
    SBIT(EWDRT,   0xa8, 6);
    SBIT(EBO,     0xa8, 5);
    SBIT(ES,      0xa8, 4);
    SBIT(ESR,     0xa8, 4);
    SBIT(ET1,     0xa8, 3);
    SBIT(EX1,     0xa8, 2);
    SBIT(ET0,     0xa8, 1);
    SBIT(EX0,     0xa8, 0);
SFR(IEN1,    0xe8); // Interrupt enable 1
    SBIT(IEN1_7,  0xe8, 7);
    SBIT(IEN1_6,  0xe8, 6);
    SBIT(IEN1_5,  0xe8, 5);
    SBIT(IEN1_4,  0xe8, 4);
    SBIT(IEN1_3,  0xe8, 3);
    SBIT(IEN1_2,  0xe8, 2);
    SBIT(IEN1_1,  0xe8, 1);
    SBIT(IEN1_0,  0xe8, 0);
    SBIT(EIEE,    0xe8, 7);
    SBIT(EST,     0xe8, 6);
    SBIT(ECCU,    0xe8, 4);
    SBIT(ESPI,    0xe8, 3);
    SBIT(EC,      0xe8, 2);
    SBIT(EKBI,    0xe8, 1);
    SBIT(EI2C,    0xe8, 0);
SFR(IP0,     0xb8); // Interrupt priority 0
    SBIT(IP0_7,   0xb8, 7);
    SBIT(IP0_6,   0xb8, 6);
    SBIT(IP0_5,   0xb8, 5);
    SBIT(IP0_4,   0xb8, 4);
    SBIT(IP0_3,   0xb8, 3);
    SBIT(IP0_2,   0xb8, 2);
    SBIT(IP0_1,   0xb8, 1);
    SBIT(IP0_0,   0xb8, 0);
    SBIT(PWDRT,   0xb8, 6);
    SBIT(PBO,     0xb8, 5);
    SBIT(PS,      0xb8, 4);
    SBIT(PSR,     0xb8, 4);
    SBIT(PT1,     0xb8, 3);
    SBIT(PX1,     0xb8, 2);
    SBIT(PT0,     0xb8, 1);
    SBIT(PX0,     0xb8, 0);
SFR(IP0H,    0xb7); // Interrupt priority 0 high
    #define PWDRTH   0x40
    #define PBOH     0x20
    #define PSH      0x10
    #define PSRH     0x10
    #define PT1H     0x08
    #define PX1H     0x04
    #define PT0H     0x02
    #define PX0H     0x01
SFR(IP1,     0xf8); // Interrupt priority 1
    SBIT(IP1_7,   0xf8, 7);
    SBIT(IP1_6,   0xf8, 6);
    SBIT(IP1_5,   0xf8, 5);
    SBIT(IP1_4,   0xf8, 4);
    SBIT(IP1_3,   0xf8, 3);
    SBIT(IP1_2,   0xf8, 2);
    SBIT(IP1_1,   0xf8, 1);
    SBIT(IP1_0,   0xf8, 0);
    SBIT(PIEE,    0xf8, 7);
    SBIT(PST,     0xf8, 6);
    SBIT(PCCU,    0xf8, 4);
    SBIT(PSPI,    0xf8, 3);
    SBIT(PC,      0xf8, 2);
    SBIT(PKBI,    0xf8, 1);
    SBIT(PI2C,    0xf8, 0);
SFR(IP1H,    0xf7); // Interrupt priority 1 high
    #define PIEEH    0x80
    #define PSTH     0x40
    #define PCCUH    0x10
    #define PSPIH    0x08
    #define PCH      0x04
    #define PKBIH    0x02
    #define PI2CH    0x01
SFR(KBCON,   0x94); // Keypad control register
    #define PATN     0x02
    #define _SEL     0x01
SFR(KBMASK,  0x86); // Keypad interrupt mask register
SFR(KBPATN,  0x93); // Keypad pattern register
SFR(OCRAH,   0xef); // Output compare A register high
SFR(OCRAL,   0xee); // Output compare A register low
SFR(OCRBH,   0xfb); // Output compare B register high
SFR(OCRBL,   0xfa); // Output compare B register low
SFR(OCRCH,   0xfd); // Output compare C register high
SFR(OCRCL,   0xfc); // Output compare C register low
SFR(OCRDH,   0xff); // Output compare D register high
SFR(OCRDL,   0xfe); // Output compare D register low
SFR(P0,      0x80); // Port 0
    SBIT(P0_7,    0x80, 7);
    SBIT(P0_6,    0x80, 6);
    SBIT(P0_5,    0x80, 5);
    SBIT(P0_4,    0x80, 4);
    SBIT(P0_3,    0x80, 3);
    SBIT(P0_2,    0x80, 2);
    SBIT(P0_1,    0x80, 1);
    SBIT(P0_0,    0x80, 0);
    SBIT(T1,      0x80, 7);
    SBIT(KB7,     0x80, 7);
    SBIT(CMP_1,   0x80, 6);
    SBIT(KB6,     0x80, 6);
    SBIT(CMPREF,  0x80, 5);
    SBIT(KB5,     0x80, 5);
    SBIT(CIN1A,   0x80, 4);
    SBIT(KB4,     0x80, 4);
    SBIT(CIN1B,   0x80, 3);
    SBIT(KB3,     0x80, 3);
    SBIT(CIN2A,   0x80, 2);
    SBIT(KB2,     0x80, 2);
    SBIT(CIN2B,   0x80, 1);
    SBIT(KB1,     0x80, 1);
    SBIT(CMP_2,   0x80, 0);
    SBIT(KB0,     0x80, 0);
SFR(P1,      0x90); // Port 1
    SBIT(P1_7,    0x90, 7);
    SBIT(P1_6,    0x90, 6);
    SBIT(P1_5,    0x90, 5);
    SBIT(P1_4,    0x90, 4);
    SBIT(P1_3,    0x90, 3);
    SBIT(P1_2,    0x90, 2);
    SBIT(P1_1,    0x90, 1);
    SBIT(P1_0,    0x90, 0);
    SBIT(OCC,     0x90, 7);
    SBIT(OCB,     0x90, 6);
    SBIT(RST,     0x90, 5);
    SBIT(INT1,    0x90, 4);
    SBIT(INT0,    0x90, 3);
    SBIT(SDA,     0x90, 3);
    SBIT(T0,      0x90, 2);
    SBIT(SCL,     0x90, 2);
    SBIT(RXD,     0x90, 1);
    SBIT(TXD,     0x90, 0);
SFR(P2,      0xa0); // Port 2
    SBIT(P2_7,    0xa0, 7);
    SBIT(P2_6,    0xa0, 6);
    SBIT(P2_5,    0xa0, 5);
    SBIT(P2_4,    0xa0, 4);
    SBIT(P2_3,    0xa0, 3);
    SBIT(P2_2,    0xa0, 2);
    SBIT(P2_1,    0xa0, 1);
    SBIT(P2_0,    0xa0, 0);
    SBIT(ICA,     0xa0, 7);
    SBIT(OCA,     0xa0, 6);
    SBIT(SPICLK,  0xa0, 5);
    SBIT(SS,      0xa0, 4);
    SBIT(MISO,    0xa0, 3);
    SBIT(MOSI,    0xa0, 2);
    SBIT(OCD,     0xa0, 1);
    SBIT(ICB,     0xa0, 0);
SFR(P3,      0xb0); // Port 3
    SBIT(P3_7,    0xb0, 7);
    SBIT(P3_6,    0xb0, 6);
    SBIT(P3_5,    0xb0, 5);
    SBIT(P3_4,    0xb0, 4);
    SBIT(P3_3,    0xb0, 3);
    SBIT(P3_2,    0xb0, 2);
    SBIT(P3_1,    0xb0, 1);
    SBIT(P3_0,    0xb0, 0);
    SBIT(XTAL1,   0xb0, 1);
    SBIT(XTAL2,   0xb0, 0);
SFR(P0M1,    0x84); // Port 0 output mode 1
    #define P0M1_7   0x80
    #define P0M1_6   0x40
    #define P0M1_5   0x20
    #define P0M1_4   0x10
    #define P0M1_3   0x08
    #define P0M1_2   0x04
    #define P0M1_1   0x02
    #define P0M1_0   0x01
SFR(P0M2,    0x85); // Port 0 output mode 2
    #define P0M2_7   0x80
    #define P0M2_6   0x40
    #define P0M2_5   0x20
    #define P0M2_4   0x10
    #define P0M2_3   0x08
    #define P0M2_2   0x04
    #define P0M2_1   0x02
    #define P0M2_0   0x01
SFR(P1M1,    0x91); // Port 1 output mode 1
    #define P1M1_7   0x80
    #define P1M1_6   0x40
    #define P1M1_4   0x10
    #define P1M1_3   0x08
    #define P1M1_2   0x04
    #define P1M1_1   0x02
    #define P1M1_0   0x01
SFR(P1M2,    0x92); // Port 1 output mode 2
    #define P1M2_7   0x80
    #define P1M2_6   0x40
    #define P1M2_4   0x10
    #define P1M2_3   0x08
    #define P1M2_2   0x04
    #define P1M2_1   0x02
    #define P1M2_0   0x01
SFR(P2M1,    0xa4); // Port 2 output mode 1
    #define P2M1_7   0x80
    #define P2M1_6   0x40
    #define P2M1_5   0x20
    #define P2M1_4   0x10
    #define P2M1_3   0x08
    #define P2M1_2   0x04
    #define P2M1_1   0x02
    #define P2M1_0   0x01
SFR(P2M2,    0xa5); // Port 2 output mode 2
    #define P2M2_7   0x80
    #define P2M2_6   0x40
    #define P2M2_5   0x20
    #define P2M2_4   0x10
    #define P2M2_3   0x08
    #define P2M2_2   0x04
    #define P2M2_1   0x02
    #define P2M2_0   0x01
SFR(P3M1,    0xb1); // Port 3 output mode 1
    #define P3M1_1   0x02
    #define P3M1_0   0x01
SFR(P3M2,    0xb2); // Port 3 output mode 2
    #define P3M2_1   0x02
    #define P3M2_0   0x01
SFR(PCON,    0x87); // Power control register
    #define SMOD1    0x80
    #define SMOD0    0x40
    #define BOI      0x10
    #define GF1      0x08
    #define GF0      0x04
    #define PMOD1    0x02
    #define PMOD0    0x01
SFR(PCONA,   0xb5); // Power control register A
    #define RTCPD    0x80
    #define DEEPD    0x40
    #define VCPD     0x20
    #define I2PD     0x08
    #define SPPD     0x04
    #define SPD      0x02
    #define CCUPD    0x01
SFR(PSW,     0xd0); // Program status word
    SBIT(PSW_7,   0xd0, 7);
    SBIT(PSW_6,   0xd0, 6);
    SBIT(PSW_5,   0xd0, 5);
    SBIT(PSW_4,   0xd0, 4);
    SBIT(PSW_3,   0xd0, 3);
    SBIT(PSW_2,   0xd0, 2);
    SBIT(PSW_1,   0xd0, 1);
    SBIT(PSW_0,   0xd0, 0);
    SBIT(CY,      0xd0, 7);
    SBIT(AC,      0xd0, 6);
    SBIT(F0,      0xd0, 5);
    SBIT(RS1,     0xd0, 4);
    SBIT(RS0,     0xd0, 3);
    SBIT(OV,      0xd0, 2);
    SBIT(F1,      0xd0, 1);
    SBIT(P,       0xd0, 0);
SFR(PT0AD,   0xf6); // Port 0 digital input disable
    #define PT0AD_5  0x20
    #define PT0AD_4  0x10
    #define PT0AD_3  0x08
    #define PT0AD_2  0x04
    #define PT0AD_1  0x02
SFR(RSTSRC,  0xdf); // Reset source register
    #define BOIF     0x40
    #define BOF      0x20
    #define POF      0x10
    #define R_BK     0x08
    #define R_WD     0x04
    #define R_SF     0x02
    #define R_EX     0x01
SFR(RTCCON,  0xd1); // RTC control
    #define RTCF     0x80
    #define RTCS1    0x40
    #define RTCS0    0x20
    #define ERTC     0x02
    #define RTCEN    0x01
SFR(RTCH,    0xd2); // RTC register high
SFR(RTCL,    0xd3); // RTC register low
SFR(SADDR,   0xa9); // Serial port address register
SFR(SADEN,   0xb9); // Serial port address enable
SFR(SBUF,    0x99); // Serial Port data buffer register
SFR(SCON,    0x98); // Serial port control
    SBIT(SCON_7,  0x98, 7);
    SBIT(SCON_6,  0x98, 6);
    SBIT(SCON_5,  0x98, 5);
    SBIT(SCON_4,  0x98, 4);
    SBIT(SCON_3,  0x98, 3);
    SBIT(SCON_2,  0x98, 2);
    SBIT(SCON_1,  0x98, 1);
    SBIT(SCON_0,  0x98, 0);
    SBIT(SM0,     0x98, 7);
    SBIT(FE,      0x98, 7);
    SBIT(SM1,     0x98, 6);
    SBIT(SM2,     0x98, 5);
    SBIT(REN,     0x98, 4);
    SBIT(TB8,     0x98, 3);
    SBIT(RB8,     0x98, 2);
    SBIT(TI,      0x98, 1);
    SBIT(RI,      0x98, 0);
SFR(SSTAT,   0xba); // Serial port extended status register
    #define DBMOD    0x80
    #define INTLO    0x40
    #define CIDIS    0x20
    #define DBISEL   0x10
    #define FE       0x08
    #define BR       0x04
    #define OE       0x02
    #define STINT    0x01
SFR(SP,      0x81); // Stack pointer
SFR(SPCTL,   0xe2); // SPI control register
    #define SSIG     0x80
    #define SPEN     0x40
    #define DORD     0x20
    #define MSTR     0x10
    #define CPOL     0x08
    #define CPHA     0x04
    #define SPR1     0x02
    #define SPR0     0x01
SFR(SPSTAT,  0xe1); // SPI status register
    #define SPIF     0x80
    #define WCOL     0x40
SFR(SPDAT,   0xe3); // SPI data register
SFR(TAMOD,   0x8f); // Timer 0 and 1 auxiliary mode
    #define T1M2     0x10
    #define T0M2     0x01
SFR(TCON,    0x88); // Timer 0 and 1 control
    SBIT(TCON_7,  0x88, 7);
    SBIT(TCON_6,  0x88, 6);
    SBIT(TCON_5,  0x88, 5);
    SBIT(TCON_4,  0x88, 4);
    SBIT(TCON_3,  0x88, 3);
    SBIT(TCON_2,  0x88, 2);
    SBIT(TCON_1,  0x88, 1);
    SBIT(TCON_0,  0x88, 0);
    SBIT(TF1,     0x88, 7);
    SBIT(TR1,     0x88, 6);
    SBIT(TF0,     0x88, 5);
    SBIT(TR0,     0x88, 4);
    SBIT(IE1,     0x88, 3);
    SBIT(IT1,     0x88, 2);
    SBIT(IE0,     0x88, 1);
    SBIT(IT0,     0x88, 0);
SFR(TCR20,   0xc8); // CCU control register 0
    SBIT(TCR20_7, 0xc8, 7);
    SBIT(TCR20_6, 0xc8, 6);
    SBIT(TCR20_5, 0xc8, 5);
    SBIT(TCR20_4, 0xc8, 4);
    SBIT(TCR20_3, 0xc8, 3);
    SBIT(TCR20_2, 0xc8, 2);
    SBIT(TCR20_1, 0xc8, 1);
    SBIT(TCR20_0, 0xc8, 0);
    SBIT(PLEEN,   0xc8, 7);
    SBIT(HLTRN,   0xc8, 6);
    SBIT(HLTEN,   0xc8, 5);
    SBIT(ALTCD,   0xc8, 4);
    SBIT(ALTAB,   0xc8, 3);
    SBIT(TDIR2,   0xc8, 2);
    SBIT(TMOD21,  0xc8, 1);
    SBIT(TMOD20,  0xc8, 0);
SFR(TCR21,   0xf9); // CCU control register 1
    #define TCOU2    0x80
    #define PLLDV_3  0x08
    #define PLLDV_2  0x04
    #define PLLDV_1  0x02
    #define PLLDV_0  0x01
SFR(TH0,     0x8c); // Timer 0 high
SFR(TH1,     0x8d); // Timer 1 high
SFR(TH2,     0xcd); // CCU timer high
SFR(TICR2,   0xc9); // CCU interrupt control register
    #define TOIE2    0x80
    #define TOCIE2D  0x40
    #define TOCIE2C  0x20
    #define TOCIE2B  0x10
    #define TOCIE2A  0x08
    #define TICIE2B  0x02
    #define TICIE2A  0x01
SFR(TIFR2,   0xe9); // CCU interrupt flag register
    #define TOIF2    0x80
    #define TOCF2D   0x40
    #define TOCF2C   0x20
    #define TOCF2B   0x10
    #define TOCF2A   0x08
    #define TICF2B   0x02
    #define TICF2A   0x01
SFR(TISE2,   0xde); // CCU interrupt status encode register
    #define ENCINT_2 0x04
    #define ENCINT_1 0x02
    #define ENCINT_0 0x01
SFR(TL0,     0x8a); // Timer 0 low
SFR(TL1,     0x8b); // Timer 1 low
SFR(TL2,     0xcc); // CCU timer low
SFR(TMOD,    0x89); // Timer 0 and 1 mode
    #define T1GATE   0x80
    #define T1C_T    0x40
    #define T1M1     0x20
    #define T1M0     0x10
    #define T0GATE   0x08
    #define T0C_T    0x04
    #define T0M1     0x02
    #define T0M0     0x01
SFR(TOR2H,   0xcf); // CCU reload register high
SFR(TOR2L,   0xce); // CCU reload register low
SFR(TPCR2H,  0xcb); // Prescaler control register high
    #define TPCR2H_1 0x02
    #define TPCR2H_0 0x01
SFR(TPCR2L,  0xca); // Prescaler control register low
    #define TPCR2L_7 0x80
    #define TPCR2L_6 0x40
    #define TPCR2L_5 0x20
    #define TPCR2L_4 0x10
    #define TPCR2L_3 0x08
    #define TPCR2L_2 0x04
    #define TPCR2L_1 0x02
    #define TPCR2L_0 0x01
SFR(TRIM,    0x96); // Internal oscillator trim register
    #define RCCLK    0x80
    #define ENCLK    0x40
    #define TRIM_5   0x20
    #define TRIM_4   0x10
    #define TRIM_3   0x08
    #define TRIM_2   0x04
    #define TRIM_1   0x02
    #define TRIM_0   0x01
SFR(WDCON,   0xa7); // Watchdog control register
    #define PRE2     0x80
    #define PRE1     0x40
    #define PRE0     0x20
    #define WDRUN    0x04
    #define WDTOF    0x02
    #define WDCLK    0x01
SFR(WDL,     0xc1); // Watchdog load
SFR(WFEED1,  0xc2); // Watchdog feed 1
SFR(WFEED2,  0xc3); // Watchdog feed 2
SFRX(BODCFG,  0xffc8); // BOD configuration register
    #define BOICFG1  0x02
    #define BOICFG0  0x01
SFRX(CLKCON,  0xffde); // CLOCK Control register
    #define CLKOK    0x80
    #define XTALWD   0x10
    #define CLKDBL   0x08
    #define FOSC2    0x04
    #define FOSC1    0x02
    #define FOSC0    0x01
SFRX(PGACON1, 0xffe1); // PGA1 control register
    #define ENPGA1   0x80
    #define PGASEL1_1 0x40
    #define PGASEL1_0 0x20
    #define PGATRIM_1 0x10
    #define PGAG11   0x02
    #define PGAG10   0x01
SFRX(PGACON1B, 0xffe4); // PGA1 control register B
    #define PGAENO   0x01
    #define FF1      0x01
SFRX(PGA1TRIM8X16X, 0xffe3); // PGA1 trim register
    #define PGA1_16XTRIM3 0x80
    #define PGA1_16XTRIM2 0x40
    #define PGA1_16XTRIM1 0x20
    #define PGA1_16XTRIM0 0x10
    #define PGA1_8XTRIM3 0x08
    #define PGA1_8XTRIM2 0x04
    #define PGA1_8XTRIM1 0x02
    #define PGA1_8XTRIM0 0x01
SFRX(PGA1TRIM2X4X, 0xffe2); // PGA1 trim register
    #define PGA1_4XTRIM3 0x80
    #define PGA1_4XTRIM2 0x40
    #define PGA1_4XTRIM1 0x20
    #define PGA1_4XTRIM0 0x10
    #define PGA1_2XTRIM3 0x08
    #define PGA1_2XTRIM2 0x04
    #define PGA1_2XTRIM1 0x02
    #define PGA1_2XTRIM0 0x01
SFRX(RTCDATH, 0xffbf); // Real-time clock data register high
SFRX(RTCDATL, 0xffbe); // Real-time clock data register low
#endif /*REG_P89LPC9321_H*/
/*-------------------------------------------------------------------------
   C8051F326.h - Register Declarations for the Cygnal/SiLabs C8051F326/7
   Processor Range

   Copyright (C) 2006, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef C8051F326_H
#define C8051F326_H


/*  BYTE Registers  */
__sfr __at (0x80) P0           ;  /* PORT 0                                        */
__sfr __at (0x81) SP           ;  /* STACK POINTER                                 */
__sfr __at (0x82) DPL          ;  /* DATA POINTER - LOW BYTE                       */
__sfr __at (0x83) DPH          ;  /* DATA POINTER - HIGH BYTE                      */
__sfr __at (0x87) PCON         ;  /* POWER CONTROL                                 */
__sfr __at (0x88) TCON         ;  /* TIMER CONTROL                                 */
__sfr __at (0x89) TMOD         ;  /* TIMER MODE                                    */
__sfr __at (0x8A) TL0          ;  /* TIMER 0 - LOW BYTE                            */
__sfr __at (0x8B) TL1          ;  /* TIMER 1 - LOW BYTE                            */
__sfr __at (0x8C) TH0          ;  /* TIMER 0 - HIGH BYTE                           */
__sfr __at (0x8D) TH1          ;  /* TIMER 1 - HIGH BYTE                           */
__sfr __at (0x8E) CKCON        ;  /* CLOCK CONTROL                                 */
__sfr __at (0x8F) PSCTL        ;  /* PROGRAM STORE R/W CONTROL                     */
__sfr __at (0x91) SBCON0       ;  /* BAUDRATE GENERATOR 0 CONTROL                  */
__sfr __at (0x93) SBRLL0       ;  /* BAUDRATE GENERATOR 0 RELOAD VALUE - LOW BYTE  */
__sfr __at (0x94) SBRLH0       ;  /* BAUDRATE GENERATOR 0 RELOAD VALUE - HIGH BYTE */
__sfr __at (0x96) USB0ADR      ;  /* USB0 INDIRECT ADDRESS REGISTER                */
__sfr __at (0x97) USB0DAT      ;  /* USB0 DATA REGISTER                            */
__sfr __at (0x98) SCON         ;  /* UART0 CONTROL                                 */
__sfr __at (0x98) SCON0        ;  /* UART0 CONTROL                                 */
__sfr __at (0x99) SBUF         ;  /* UART0 BUFFER                                  */
__sfr __at (0x99) SBUF0        ;  /* UART0 BUFFER                                  */
__sfr __at (0x9A) SMOD0        ;  /* UART0 MODE                                    */
__sfr __at (0xA0) P2           ;  /* PORT 2                                        */
__sfr __at (0xA4) P0MDOUT      ;  /* PORT 0 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA6) P2MDOUT      ;  /* PORT 2 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA7) P3MDOUT      ;  /* PORT 3 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA8) IE           ;  /* INTERRUPT ENABLE                              */
__sfr __at (0xA9) CLKSEL       ;  /* SYSTEM CLOCK SELECT                           */
__sfr __at (0xAA) EMI0CN       ;  /* EXTERNAL MEMORY INTERFACE CONTROL             */
__sfr __at (0xAA) _XPAGE       ;  /* XDATA/PDATA PAGE                              */
__sfr __at (0xB0) P3           ;  /* PORT 3                                        */
__sfr __at (0xB2) OSCICN       ;  /* INTERNAL OSCILLATOR CONTROL                   */
__sfr __at (0xB3) OSCICL       ;  /* INTERNAL OSCILLATOR CALIBRATION               */
__sfr __at (0xB6) FLSCL        ;  /* FLASH MEMORY TIMING PRESCALER                 */
__sfr __at (0xB7) FLKEY        ;  /* FLASH ACESS LIMIT                             */
__sfr __at (0xB8) IP           ;  /* INTERRUPT PRIORITY                            */
__sfr __at (0xB9) CLKMUL       ;  /* CLOCK MULTIPLIER CONTROL REGISTER             */
__sfr __at (0xC9) REG0CN       ;  /* VOLTAGE REGULATOR CONTROL                     */
__sfr __at (0xD0) PSW          ;  /* PROGRAM STATUS WORD                           */
__sfr __at (0xD7) USB0XCN      ;  /* USB0 TRANSCEIVER CONTROL                      */
__sfr __at (0xE0) ACC          ;  /* ACCUMULATOR                                   */
__sfr __at (0xE2) GPIOCN       ;  /* GLOBAL PORT I/O CONTROL                       */
__sfr __at (0xE3) OSCLCN       ;  /* LOW-FREQUENCY OSCILLATOR CONTROL              */
__sfr __at (0xE6) EIE1         ;  /* EXTERNAL INTERRUPT ENABLE 1                   */
__sfr __at (0xE7) EIE2         ;  /* EXTERNAL INTERRUPT ENABLE 2                   */
__sfr __at (0xEF) RSTSRC       ;  /* RESET SOURCE                                  */
__sfr __at (0xF0) B            ;  /* B REGISTER                                    */
__sfr __at (0xF6) EIP1         ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 1        */
__sfr __at (0xF7) EIP2         ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 2        */
__sfr __at (0xFF) VDM0CN       ;  /* VDD MONITOR CONTROL                           */


/*  WORD/DWORD Registers  */

__sfr16 __at (0x8C8A) TMR0     ;  /* TIMER 0 COUNTER                               */
__sfr16 __at (0x8D8B) TMR1     ;  /* TIMER 1 COUNTER                               */
__sfr16 __at (0x9493) SBRL0    ;  /* BAUDRATE GENERATOR 0 RELOAD VALUE WORD        */


/*  BIT Registers  */

/*  P0  0x80 */
__sbit __at (0x80) P0_0        ;
__sbit __at (0x81) P0_1        ;
__sbit __at (0x82) P0_2        ;
__sbit __at (0x83) P0_3        ;
__sbit __at (0x84) P0_4        ;
__sbit __at (0x85) P0_5        ;
__sbit __at (0x86) P0_6        ;
__sbit __at (0x87) P0_7        ;

/*  TCON  0x88 */
__sbit __at (0x88) IT0         ;  /* TCON.0 - EXT. INTERRUPT 0 TYPE                */
__sbit __at (0x89) IE0         ;  /* TCON.1 - EXT. INTERRUPT 0 EDGE FLAG           */
__sbit __at (0x8A) IT1         ;  /* TCON.2 - EXT. INTERRUPT 1 TYPE                */
__sbit __at (0x8B) IE1         ;  /* TCON.3 - EXT. INTERRUPT 1 EDGE FLAG           */
__sbit __at (0x8C) TR0         ;  /* TCON.4 - TIMER 0 ON/OFF CONTROL               */
__sbit __at (0x8D) TF0         ;  /* TCON.5 - TIMER 0 OVERFLOW FLAG                */
__sbit __at (0x8E) TR1         ;  /* TCON.6 - TIMER 1 ON/OFF CONTROL               */
__sbit __at (0x8F) TF1         ;  /* TCON.7 - TIMER 1 OVERFLOW FLAG                */

/*  SCON  0x98 */
__sbit __at (0x98) RI          ;  /* SCON.0 - RECEIVE INTERRUPT FLAG               */
__sbit __at (0x98) RI0         ;  /* SCON.0 - RECEIVE INTERRUPT FLAG               */
__sbit __at (0x99) TI          ;  /* SCON.1 - TRANSMIT INTERRUPT FLAG              */
__sbit __at (0x99) TI0         ;  /* SCON.1 - TRANSMIT INTERRUPT FLAG              */
__sbit __at (0x9A) RB8         ;  /* SCON.2 - RECEIVE BIT 8                        */
__sbit __at (0x9A) RBX0        ;  /* SCON.2 - EXTRA RECEIVE BIT                    */
__sbit __at (0x9B) TB8         ;  /* SCON.3 - TRANSMIT BIT 8                       */
__sbit __at (0x9B) TBX0        ;  /* SCON.3 - EXTRA TRANSMIT BIT                   */
__sbit __at (0x9C) REN         ;  /* SCON.4 - RECEIVE ENABLE                       */
__sbit __at (0x9C) REN0        ;  /* SCON.4 - RECEIVE ENABLE                       */
__sbit __at (0x9E) PERR0       ;  /* SCON.6 - PARITY ERROR FLAG                    */
__sbit __at (0x9F) OVR0        ;  /* SCON.7 - RECEIVE FIFO OVERRUN FLAG            */

/*  P2  0xA0 */
__sbit __at (0xA0) P2_0        ;
__sbit __at (0xA1) P2_1        ;
__sbit __at (0xA2) P2_2        ;
__sbit __at (0xA3) P2_3        ;
__sbit __at (0xA4) P2_4        ;
__sbit __at (0xA5) P2_5        ;

/*  IE  0xA8 */
__sbit __at (0xA8) EX0         ;  /* IE.0 - EXTERNAL INTERRUPT 0 ENABLE            */
__sbit __at (0xA9) ET0         ;  /* IE.1 - TIMER 0 INTERRUPT ENABLE               */
__sbit __at (0xAA) EX1         ;  /* IE.2 - EXTERNAL INTERRUPT 1 ENABLE            */
__sbit __at (0xAB) ET1         ;  /* IE.3 - TIMER 1 INTERRUPT ENABLE               */
__sbit __at (0xAC) ES          ;  /* IE.4 - SERIAL PORT INTERRUPT ENABLE           */
__sbit __at (0xAC) ES0         ;  /* IE.4 - SERIAL PORT INTERRUPT ENABLE           */
__sbit __at (0xAF) EA          ;  /* IE.7 - GLOBAL INTERRUPT ENABLE                */

/*  P3  0xB0 */
__sbit __at (0xB0) P3_0        ;

/*  IP  0xB8 */
__sbit __at (0xB8) PX0         ;  /* IP.0 - EXTERNAL INTERRUPT 0 PRIORITY          */
__sbit __at (0xB9) PT0         ;  /* IP.1 - TIMER 0 PRIORITY                       */
__sbit __at (0xBA) PX1         ;  /* IP.2 - EXTERNAL INTERRUPT 1 PRIORITY          */
__sbit __at (0xBB) PT1         ;  /* IP.3 - TIMER 1 PRIORITY                       */
__sbit __at (0xBC) PS          ;  /* IP.4 - SERIAL PORT PRIORITY                   */
__sbit __at (0xBC) PS0         ;  /* IP.4 - SERIAL PORT PRIORITY                   */

/*  PSW  0xD0 */
__sbit __at (0xD0) PARITY      ;  /* PSW.0 - ACCUMULATOR PARITY FLAG               */
__sbit __at (0xD1) F1          ;  /* PSW.1 - FLAG 1                                */
__sbit __at (0xD2) OV          ;  /* PSW.2 - OVERFLOW FLAG                         */
__sbit __at (0xD3) RS0         ;  /* PSW.3 - REGISTER BANK SELECT 0                */
__sbit __at (0xD4) RS1         ;  /* PSW.4 - REGISTER BANK SELECT 1                */
__sbit __at (0xD5) F0          ;  /* PSW.5 - FLAG 0                                */
__sbit __at (0xD6) AC          ;  /* PSW.6 - AUXILIARY CARRY FLAG                  */
__sbit __at (0xD7) CY          ;  /* PSW.7 - CARRY FLAG                            */


/* Predefined SFR Bit Masks */

#define PCON_IDLE         0x01    /* PCON                                */
#define PCON_STOP         0x02    /* PCON                                */
#define T0M               0x04    /* CKCON                               */
#define T1M               0x08    /* CKCON                               */
#define PSWE              0x01    /* PSCTL                               */
#define PSEE              0x02    /* PSCTL                               */
#define EUSB0             0x02    /* EIE1                                */
#define EVBUS             0x01    /* EIE2                                */
#define PORSF             0x02    /* RSTSRC                              */
#define SWRSF             0x10    /* RSTSRC                              */

#endif
/*--------------------------------------------------------------------------
P89c51RD2.H
(English)
This header allows to use the microcontroler Philips P89c51RD2
with the compiler SDCC.

Copyright (c) 2005 Omar Espinosa--e-mail: opiedrahita2003 AT yahoo.com.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

(Spanish-Español)
Archivo encabezador para el ucontrolador Philips P89c51RD2.
Derechos de copy (DC) 2005.  OMAR ESPINOSA P.  E-mail: opiedrahita2003 AT yahoo.com
Uso libre
--------------------------------------------------------------------------*/

#ifndef __P89c51RD2_H__
#define __P89c51RD2_H__

/*  BYTE Registers  */
__sfr __at (0x80) P0       ;
__sfr __at (0x90) P1       ;
__sfr __at (0xA0) P2       ;
__sfr __at (0xB0) P3       ;
__sfr __at (0xD0) PSW      ;
__sfr __at (0xE0) ACC      ;
__sfr __at (0xF0) B        ;
__sfr __at (0x81) SP       ;
__sfr __at (0x82) DPL      ;
__sfr __at (0x83) DPH      ;
__sfr __at (0x87) PCON     ;
__sfr __at (0x88) TCON     ;
__sfr __at (0x89) TMOD     ;
__sfr __at (0x8A) TL0      ;
__sfr __at (0x8B) TL1      ;
__sfr __at (0x8C) TH0      ;
__sfr __at (0x8D) TH1      ;
__sfr __at (0xA8) IE       ;
__sfr __at (0xB8) IP       ;
__sfr __at (0x98) SCON     ;
__sfr __at (0x99) SBUF     ;

/*  80C51Fx/Rx Extensions  */
__sfr __at (0x8E) AUXR     ;
__sfr __at (0xA2) AUXR1    ;
__sfr __at (0xA9) SADDR    ;
__sfr __at (0xB7) IPH      ;
__sfr __at (0xB9) SADEN    ;
__sfr __at (0xC8) T2CON    ;
__sfr __at (0xC9) T2MOD    ;
__sfr __at (0xCA) RCAP2L   ;
__sfr __at (0xCB) RCAP2H   ;
__sfr __at (0xCC) TL2      ;
__sfr __at (0xCD) TH2      ;
__sfr __at (0xD8) CCON     ;
__sfr __at (0xD9) CMOD     ;
__sfr __at (0xDA) CCAPM0   ;
__sfr __at (0xDB) CCAPM1   ;
__sfr __at (0xDC) CCAPM2   ;
__sfr __at (0xDD) CCAPM3   ;
__sfr __at (0xDE) CCAPM4   ;
__sfr __at (0xE9) CL       ;
__sfr __at (0xEA) CCAP0L   ;
__sfr __at (0xEB) CCAP1L   ;
__sfr __at (0xEC) CCAP2L   ;
__sfr __at (0xED) CCAP3L   ;
__sfr __at (0xEE) CCAP4L   ;
__sfr __at (0xF9) CH       ;
__sfr __at (0xFA) CCAP0H   ;
__sfr __at (0xFB) CCAP1H   ;
__sfr __at (0xFC) CCAP2H   ;
__sfr __at (0xFD) CCAP3H   ;
__sfr __at (0xFE) CCAP4H   ;


/*  BIT Registers  */
/*  PSW   */

__sbit __at (0xD7)    PSW_7;
__sbit __at (0xD6)    PSW_6;
__sbit __at (0xD5)    PSW_5;
__sbit __at (0xD4)    PSW_4;
__sbit __at (0xD3)    PSW_3;
__sbit __at (0xD2)    PSW_2;
__sbit __at (0xD0)    PSW_0;

#define  CY     PSW_7
#define  AC     PSW_6
#define  F0     PSW_5
#define  RS1    PSW_4
#define  RS0    PSW_3
#define  OV     PSW_2
#define  P      PSW_0

/*  TCON  */
__sbit __at (0x8F)    TCON_7;
__sbit __at (0x8E)    TCON_6;
__sbit __at (0x8D)    TCON_5;
__sbit __at (0x8C)    TCON_4;
__sbit __at (0x8B)    TCON_3;
__sbit __at (0x8A)    TCON_2;
__sbit __at (0x89)    TCON_1;
__sbit __at (0x88)    TCON_0;

#define  TF1    TCON_7
#define  TR1    TCON_6
#define  TF0    TCON_5
#define  TR0    TCON_4
#define  IE1    TCON_3
#define  IT1    TCON_2
#define  IE0    TCON_1
#define  IT0    TCON_0

/*  IE   */
__sbit __at (0xAF)    IE_7;
__sbit __at (0xAE)    IE_6;
__sbit __at (0xAD)    IE_5;
__sbit __at (0xAC)    IE_4;
__sbit __at (0xAB)    IE_3;
__sbit __at (0xAA)    IE_2;
__sbit __at (0xA9)    IE_1;
__sbit __at (0xA8)    IE_0;

#define  EA     IE_7
#define  EC     IE_6
#define  ET2    IE_5
#define  ES     IE_4
#define  ET1    IE_3
#define  EX1    IE_2
#define  ET0    IE_1
#define  EX0    IE_0

/*  IP   */
__sbit __at (0xBE)    IP_6;
__sbit __at (0xBD)    IP_5;
__sbit __at (0xBC)    IP_4;
__sbit __at (0xBB)    IP_3;
__sbit __at (0xBA)    IP_2;
__sbit __at (0xB9)    IP_1;
__sbit __at (0xB8)    IP_0;

#define  PPC    IP_6
#define  PT2    IP_5
#define  PS     IP_4
#define  PT1    IP_3
#define  PX1    IP_2
#define  PT0    IP_1
#define  PX0    IP_0

/*  P3  */
__sbit __at (0xB7)    P3_7;
__sbit __at (0xB6)    P3_6;
__sbit __at (0xB5)    P3_5;
__sbit __at (0xB4)    P3_4;
__sbit __at (0xB3)    P3_3;
__sbit __at (0xB2)    P3_2;
__sbit __at (0xB1)    P3_1;
__sbit __at (0xB0)    P3_0;

#define  RD     P3_7
#define  WR     P3_6
#define  T1     P3_5
#define  T0     P3_4
#define  INT1   P3_3
#define  INT0   P3_2
#define  TXD    P3_1
#define  RXD    P3_0

/*  SCON  */
__sbit __at (0x9F)    SCON_7; // alternatively "FE"
__sbit __at (0x9E)    SCON_6;
__sbit __at (0x9D)    SCON_5;
__sbit __at (0x9C)    SCON_4;
__sbit __at (0x9B)    SCON_3;
__sbit __at (0x9A)    SCON_2;
__sbit __at (0x99)    SCON_1;
__sbit __at (0x98)    SCON_0;

#define  SM0    SCON_7  // alternatively "FE"
#define  FE     SCON_7
#define  SM1    SCON_6
#define  SM2    SCON_5
#define  REN    SCON_4
#define  TB8    SCON_3
#define  RB8    SCON_2
#define  TI     SCON_1
#define  RI     SCON_0

/*  P1  */
__sbit __at (0x97)    P1_7;
__sbit __at (0x96)    P1_6;
__sbit __at (0x95)    P1_5;
__sbit __at (0x94)    P1_4;
__sbit __at (0x93)    P1_3;
__sbit __at (0x92)    P1_2;
__sbit __at (0x91)    P1_1;
__sbit __at (0x90)    P1_0;

#define  CEX4   P1_7
#define  CEX3   P1_6
#define  CEX2   P1_5
#define  CEX1   P1_4
#define  CEX0   P1_3
#define  ECI    P1_2
#define  T2EX   P1_1
#define  T2     P1_0

/*  T2CON  */
__sbit __at (0xCF)    T2CON_7;
__sbit __at (0xCE)    T2CON_6;
__sbit __at (0xCD)    T2CON_5;
__sbit __at (0xCC)    T2CON_4;
__sbit __at (0xCB)    T2CON_3;
__sbit __at (0xCA)    T2CON_2;
__sbit __at (0xC9)    T2CON_1;
__sbit __at (0xC8)    T2CON_0;

#define  TF2     T2CON_7
#define  EXF2    T2CON_6
#define  RCLK    T2CON_5
#define  TCLK    T2CON_4
#define  EXEN2   T2CON_3
#define  TR2     T2CON_2
#define  C_T2    T2CON_1
#define  CP_RL2  T2CON_0

/*  CCON  */
__sbit __at (0xDF)    CCON_7;
__sbit __at (0xDE)    CCON_6;
__sbit __at (0xDC)    CCON_4;
__sbit __at (0xDB)    CCON_3;
__sbit __at (0xDA)    CCON_2;
__sbit __at (0xD9)    CCON_1;
__sbit __at (0xD8)    CCON_0;

#define  CF      CCON_7
#define  CR      CCON_6
#define  CCF4    CCON_4
#define  CCF3    CCON_3
#define  CCF2    CCON_2
#define  CCF1    CCON_1
#define  CCF0    CCON_0

#endif
/*-------------------------------------------------------------------------
   at89x51.h - register declarations for ATMEL 89x51 processors

   Copyright (C) 1999, Bernd Bartmann <bernd.bartmann AT gmail.com>

   Based on reg51.h by Sandeep Dutta sandeep.dutta AT usa.net
   KEIL C compatible definitions are included

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef AT89x51_H
#define AT89x51_H

/* BYTE addressable registers */
__sfr __at 0x80 P0          ;
__sfr __at 0x81 SP          ;
__sfr __at 0x82 DPL         ;
__sfr __at 0x83 DPH         ;
__sfr __at 0x87 PCON        ;
__sfr __at 0x88 TCON        ;
__sfr __at 0x89 TMOD        ;
__sfr __at 0x8A TL0         ;
__sfr __at 0x8B TL1         ;
__sfr __at 0x8C TH0         ;
__sfr __at 0x8D TH1         ;
__sfr __at 0x90 P1          ;
__sfr __at 0x98 SCON        ;
__sfr __at 0x99 SBUF        ;
__sfr __at 0xA0 P2          ;
__sfr __at 0xA8 IE          ;
__sfr __at 0xB0 P3          ;
__sfr __at 0xB8 IP          ;
__sfr __at 0xD0 PSW         ;
__sfr __at 0xE0 ACC         ;
__sfr __at 0xE0 A           ;
__sfr __at 0xF0 B           ;


/* BIT addressable registers */
/* P0 */
__sbit __at 0x80 P0_0       ;
__sbit __at 0x81 P0_1       ;
__sbit __at 0x82 P0_2       ;
__sbit __at 0x83 P0_3       ;
__sbit __at 0x84 P0_4       ;
__sbit __at 0x85 P0_5       ;
__sbit __at 0x86 P0_6       ;
__sbit __at 0x87 P0_7       ;

/* TCON */
__sbit __at 0x88 IT0        ;
__sbit __at 0x89 IE0        ;
__sbit __at 0x8A IT1        ;
__sbit __at 0x8B IE1        ;
__sbit __at 0x8C TR0        ;
__sbit __at 0x8D TF0        ;
__sbit __at 0x8E TR1        ;
__sbit __at 0x8F TF1        ;

/* P1 */
__sbit __at 0x90 P1_0       ;
__sbit __at 0x91 P1_1       ;
__sbit __at 0x92 P1_2       ;
__sbit __at 0x93 P1_3       ;
__sbit __at 0x94 P1_4       ;
__sbit __at 0x95 P1_5       ;
__sbit __at 0x96 P1_6       ;
__sbit __at 0x97 P1_7       ;

/* SCON */
__sbit __at 0x98 RI         ;
__sbit __at 0x99 TI         ;
__sbit __at 0x9A RB8        ;
__sbit __at 0x9B TB8        ;
__sbit __at 0x9C REN        ;
__sbit __at 0x9D SM2        ;
__sbit __at 0x9E SM1        ;
__sbit __at 0x9F SM0        ;

/* P2 */
__sbit __at 0xA0 P2_0       ;
__sbit __at 0xA1 P2_1       ;
__sbit __at 0xA2 P2_2       ;
__sbit __at 0xA3 P2_3       ;
__sbit __at 0xA4 P2_4       ;
__sbit __at 0xA5 P2_5       ;
__sbit __at 0xA6 P2_6       ;
__sbit __at 0xA7 P2_7       ;

/* IE */
__sbit __at 0xA8 EX0        ;
__sbit __at 0xA9 ET0        ;
__sbit __at 0xAA EX1        ;
__sbit __at 0xAB ET1        ;
__sbit __at 0xAC ES         ;
__sbit __at 0xAF EA         ;

/* P3 */
__sbit __at 0xB0 P3_0       ;
__sbit __at 0xB1 P3_1       ;
__sbit __at 0xB2 P3_2       ;
__sbit __at 0xB3 P3_3       ;
__sbit __at 0xB4 P3_4       ;
__sbit __at 0xB5 P3_5       ;
__sbit __at 0xB6 P3_6       ;
__sbit __at 0xB7 P3_7       ;

__sbit __at 0xB0 RXD        ;
__sbit __at 0xB1 TXD        ;
__sbit __at 0xB2 INT0       ;
__sbit __at 0xB3 INT1       ;
__sbit __at 0xB4 T0         ;
__sbit __at 0xB5 T1         ;
__sbit __at 0xB6 WR         ;
__sbit __at 0xB7 RD         ;

/* IP */ 
__sbit __at 0xB8 PX0        ;
__sbit __at 0xB9 PT0        ;
__sbit __at 0xBA PX1        ;
__sbit __at 0xBB PT1        ;
__sbit __at 0xBC PS         ;

/* PSW */
__sbit __at 0xD0 P          ;
__sbit __at 0xD1 FL         ;
__sbit __at 0xD2 OV         ;
__sbit __at 0xD3 RS0        ;
__sbit __at 0xD4 RS1        ;
__sbit __at 0xD5 F0         ;
__sbit __at 0xD6 AC         ;
__sbit __at 0xD7 CY         ;


/* BIT definitions for bits that are not directly accessible */
/* PCON bits */
#define IDL             0x01
#define PD              0x02
#define GF0             0x04
#define GF1             0x08
#define SMOD            0x80

#define IDL_            0x01
#define PD_             0x02
#define GF0_            0x04
#define GF1_            0x08
#define SMOD_           0x80

/* TMOD bits */
#define M0_0            0x01
#define M1_0            0x02
#define C_T0            0x04
#define GATE0           0x08
#define M0_1            0x10
#define M1_1            0x20
#define C_T1            0x40
#define GATE1           0x80

#define M0_0_           0x01
#define M1_0_           0x02
#define C_T0_           0x04
#define GATE0_          0x08
#define M0_1_           0x10
#define M1_1_           0x20
#define C_T1_           0x40
#define GATE1_          0x80

#define T0_M0           0x01
#define T0_M1           0x02
#define T0_CT           0x04
#define T0_GATE         0x08
#define T1_M0           0x10
#define T1_M1           0x20
#define T1_CT           0x40
#define T1_GATE         0x80

#define T0_M0_          0x01
#define T0_M1_          0x02
#define T0_CT_          0x04
#define T0_GATE_        0x08
#define T1_M0_          0x10
#define T1_M1_          0x20
#define T1_CT_          0x40
#define T1_GATE_        0x80

#define T0_MASK         0x0F
#define T1_MASK         0xF0

#define T0_MASK_        0x0F
#define T1_MASK_        0xF0


/* Interrupt numbers: address = (number * 8) + 3 */
#define IE0_VECTOR      0       /* 0x03 external interrupt 0 */
#define TF0_VECTOR      1       /* 0x0b timer 0 */
#define IE1_VECTOR      2       /* 0x13 external interrupt 1 */
#define TF1_VECTOR      3       /* 0x1b timer 1 */
#define SI0_VECTOR      4       /* 0x23 serial port 0 */
 
#endif
/*-------------------------------------------------------------------------
   cc2510fx.h - Register Declarations for Chipcon CC2510Fx/CC2511Fx
   (Based on CC2510Fx/CC2511Fx PRELIMINARY Data Sheet (Rev. 1.2) SWRS055A)

   Copyright (C) 2006, Jesus Calvino-Fraga / jesusc at ece.ubc.ca

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef REG_CC2510FX_H
#define REG_CC2510FX_H

#include <compiler.h>

// Interrupt Vectors
#define RFTXRX_VECTOR   0 // RF TX done / RX ready  
#define ADC_VECTOR      1 // ADC end of conversion  
#define URX0_VECTOR     2 // USART0 RX complete  
#define URX1_VECTOR     3 // USART1 RX complete (I2S RX complete)  
#define ENC_VECTOR      4 // AES encryption/decryption complete  
#define ST_VECTOR       5 // Sleep Timer compare 
#define P2INT_VECTOR    6 // Port 2 inputs (Also used for USB on CC2511Fx) 
#define UTX0_VECTOR     7 // USART0 TX complete 
#define DMA_VECTOR      8 // DMA transfer complete 
#define T1_VECTOR       9 // Timer 1 (16-bit) capture/Compare/overflow 
#define T2_VECTOR      10 // Timer 2 (MAC Timer) overflow 
#define T3_VECTOR      11 // Timer 3 (8-bit) capture/compare/overflow 
#define T4_VECTOR      12 // Timer 4 (8-bit) capture/compare/overflow 
#define P0INT_VECTOR   13 // Port 0 inputs (Note: USB Resume from suspend interrupt on P0_7 on CC2511Fx ) 
#define UTX1_VECTOR    14 // USART1 TX complete (I2S TX complete) 
#define P1INT_VECTOR   15 // Port 1 inputs 
#define RF_VECTOR      16 // RF general interrupts 
#define WDT_VECTOR     17 // Watchdog overflow in timer mode 

//Shared Interrupt Vectors (I2S and USB)
#define I2SRX_VECTOR    3 //I2S RX complete 
#define I2STX_VECTOR   14 //I2S TX complete 
#define USB_VECTOR      6 //USB Interrupt pending ( CC2511Fx ) 

// SFR Registers and BITs

SFR(P0,       0x80); // Port 0 
   SBIT(P0_0,     0x80, 0); // Port 0 bit 0
   SBIT(P0_1,     0x80, 1); // Port 0 bit 1
   SBIT(P0_2,     0x80, 2); // Port 0 bit 2
   SBIT(P0_3,     0x80, 3); // Port 0 bit 3
   SBIT(P0_4,     0x80, 4); // Port 0 bit 4
   SBIT(P0_5,     0x80, 5); // Port 0 bit 5
   SBIT(P0_6,     0x80, 6); // Port 0 bit 6
   SBIT(P0_7,     0x80, 7); // Port 0 bit 7
SFR(SP,       0x81); // Stack Pointer 
SFR(DPL0,     0x82); // Data Pointer 0 Low Byte
SFR(DPH0,     0x83); // Data Pointer 0 High Byte
SFR(DPL1,     0x84); // Data Pointer 1 Low Byte
SFR(DPH1,     0x85); // Data Pointer 1 High Byte
SFR(U0CSR,    0x86); // USART 0 Control and Status 
SFR(PCON,     0x87); // Power Mode Control 
SFR(TCON,     0x88); // Interrupt Flag 
   SBIT(IT0,      0x88, 0); // reserved (must always be set to 1) 
   SBIT(RFTXRXIF, 0x88, 1); // RF TX/RX FIFO Interrupt Flag 
   SBIT(IT1,      0x88, 2); // reserved (must always be set to 1) 
   SBIT(URX0IF,   0x88, 3); // USART0 RX Interrupt Flag 
   SBIT(ADCIF,    0x88, 5); // ADC Interrupt Flag 
   SBIT(URX1IF,   0x88, 7); // USART1 RX Interrupt Flag 
   SBIT(I2SRXIF,  0x88, 7); // I2S RX interrupt flag (same loc as URX1IF) 
SFR(P0IFG,    0x89); // Port 0 Interrupt Status Flag 
SFR(P1IFG,    0x8A); // Port 1 Interrupt Status Flag 
SFR(P2IFG,    0x8B); // Port 2 Interrupt Status Flag
SFR(PICTL,    0x8C); // Port Interrupt Control
SFR(P1IEN,    0x8D); // Port 1 Interrupt Mask 
SFR(P0INP,    0x8F); // Port 0 Input Mode 
SFR(P1,       0x90); // Port 1 
   SBIT(P1_0,     0x90, 0); // Port 1 bit 0
   SBIT(P1_1,     0x90, 1); // Port 1 bit 1
   SBIT(P1_2,     0x90, 2); // Port 1 bit 2
   SBIT(P1_3,     0x90, 3); // Port 1 bit 3
   SBIT(P1_4,     0x90, 4); // Port 1 bit 4
   SBIT(P1_5,     0x90, 5); // Port 1 bit 5
   SBIT(P1_6,     0x90, 6); // Port 1 bit 6
   SBIT(P1_7,     0x90, 7); // Port 1 bit 7
SFR(RFIM,     0x91); // RF Interrupt Mask
SFR(DPS,      0x92); // Data Pointer Select 
SFR(MPAGE,    0x93); // Memory Page Select 
SFR(_XPAGE,   0x93); // Memory Page Select under the name SDCC needs it
SFR(ENDIAN,   0x95); // USB Endianess Control (CC2511Fx) 
SFR(S0CON,    0x98); // Interrupt Flag 2
   SBIT(ENCIF_0,  0x98, 0); // AES Interrupt Flag 0 
   SBIT(ENCIF_1,  0x98, 1); // AES Interrupt Flag 1 
SFR(IEN2,     0x9A); // Interrupt Enable 2 Register
SFR(S1CON,    0x9B); // Interrupt Flag 3 
SFR(T2CT,     0x9C); // Timer 2 Count
SFR(T2PR,     0x9D); // Timer 2 Prescaler
SFR(T2CTL,    0x9E); // Timer 2 Control 
SFR(P2,       0xA0); // Port 2
   SBIT(P2_0,     0xA0, 0); // Port 2 bit 0
   SBIT(P2_1,     0xA0, 1); // Port 2 bit 1
   SBIT(P2_2,     0xA0, 2); // Port 2 bit 2
   SBIT(P2_3,     0xA0, 3); // Port 2 bit 3
   SBIT(P2_4,     0xA0, 4); // Port 2 bit 4
   SBIT(P2_5,     0xA0, 5); // Port 2 bit 5
   SBIT(P2_6,     0xA0, 6); // Port 2 bit 6
   SBIT(P2_7,     0xA0, 7); // Port 2 bit 7
SFR(WORIRQ,   0xA1); // Sleep Timer Interrupt Control
SFR(WORCTL,   0xA2); // Sleep Timer Control
SFR(WORCTRL,  0xA2); // Sleep Timer Control (typo in datasheet?)
SFR(WOREVT0,  0xA3); // Sleep Timer Event0 Timeout Low
SFR(WOREVT1,  0xA4); // Sleep Timer Event0 Timeout High 
SFR(WORTIME0, 0xA5); // Sleep Timer Low Byte 
SFR(WORTIME1, 0xA6); // Sleep Timer High Byte 
SFR(IEN0,     0xA8); // Interrupt Enable 0 Register
   SBIT(RFTXRXIE, 0xA8, 0); // RF TX/RX done interrupt enable 
   SBIT(ADCIE,    0xA8, 1); // ADC Interrupt Enable 
   SBIT(URX0IE,   0xA8, 2); // USART0 RX Interrupt Enable 
   SBIT(URX1IE,   0xA8, 3); // USART1 RX Interrupt Enable
   SBIT(I2SRXIE,  0xA8, 3); // I2S RX interrupt enable (Same loc as URX1IE)
   SBIT(ENCIE,    0xA8, 4); // AES Encryption/Decryption Interrupt Enable 
   SBIT(STIE,     0xA8, 5); // Sleep Timer Interrupt Enable 
   SBIT(EA,       0xA8, 7); // Global Interrupt Enable 
SFR(IP0,      0xA9); // Interrupt Priority 0
SFR(FWT,      0xAB); // Flash Write Timing
SFR(FADDRL,   0xAC); // Flash Address Low Byte 
SFR(FADDRH,   0xAD); // Flash Address High Byte 
SFR(FCTL,     0xAE); // Flash Control 
SFR(FWDATA,   0xAF); // Flash Write Data
SFR(ENCDI,    0xB1); // Encryption Input Data
SFR(ENCDO,    0xB2); // Encryption Output Data
SFR(ENCCS,    0xB3); // Encryption Control and Status 
SFR(ADCCON1,  0xB4); // ADC Control 1 
SFR(ADCCON2,  0xB5); // ADC Control 2 
SFR(ADCCON3,  0xB6); // ADC Control 3 
SFR(IEN1,     0xB8); // Interrupt Enable 1 Register
   SBIT(DMAIE,    0xB8, 0); // DMA Transfer Interrupt Enable 
   SBIT(T1IE,     0xB8, 1); // Timer 1 Interrupt Enable 
   SBIT(T2IE,     0xB8, 2); // Timer 2 Interrupt Enable 
   SBIT(T3IE,     0xB8, 3); // Timer 3 Interrupt Enable 
   SBIT(T4IE,     0xB8, 4); // Timer 4 Interrupt Enable 
   SBIT(P0IE,     0xB8, 5); // Port 0 Interrupt Enable 
SFR(IP1,      0xB9); // Interrupt Priority 1 
SFR(ADCL,     0xBA); // ADC Data Low
SFR(ADCH,     0xBB); // ADC Data High
SFR(RNDL,     0xBC); // Random Number Generator Data Low Byte 
SFR(RNDH,     0xBD); // Random Number Generator Data High Byte
SFR(SLEEP,    0xBE); // Sleep Mode Control 
SFR(IRCON,    0xC0); // Interrupt Flag 4 
   SBIT(DMAIF,    0xC0, 0); // DMA Complete Interrupt Flag 
   SBIT(T1IF,     0xC0, 1); // Timer 1 Interrupt Flag 
   SBIT(T2IF,     0xC0, 2); // Timer 2 Interrupt Flag 
   SBIT(T3IF,     0xC0, 3); // Timer 3 Interrupt Flag 
   SBIT(T4IF,     0xC0, 4); // Timer 4 Interrupt Flag 
   SBIT(P0IF,     0xC0, 5); // Port 0 Interrupt Flag 
   SBIT(STIF,     0xC0, 7); // Sleep Timer Interrupt Flag 
SFR(U0DBUF,   0xC1); // USART 0 Receive/Transmit Data Buffer
SFR(U0BAUD,   0xC2); // USART 0 Baud Rate Control
SFR(U0UCR,    0xC4); // USART 0 UART Control 
SFR(U0GCR,    0xC5); // USART 0 Generic Control
SFR(CLKCON,   0xC6); // Clock Control
SFR(MEMCTR,   0xC7); // Memory Arbiter Control
SFR(WDCTL,    0xC9); // Watchdog Timer Control 
SFR(T3CNT,    0xCA); // Timer 3 Counter
SFR(T3CTL,    0xCB); // Timer 3 Control 
SFR(T3CCTL0,  0xCC); // Timer 3 Channel 0 Capture/Compare Control
SFR(T3CC0,    0xCD); // Timer 3 Channel 0 Capture/Compare Value 
SFR(T3CCTL1,  0xCE); // Timer 3 Channel 1 Capture/Compare Control 
SFR(T3CC1,    0xCF); // Timer 3 Channel 1 Capture/Compare Value
SFR(PSW,      0xD0); // Program Status Word
   SBIT(P,        0xD0, 0); // Parity Flag 
   SBIT(F1,       0xD0, 1); // User-Defined Flag
   SBIT(OV,       0xD0, 2); // Overflow Flag 
   SBIT(RS0,      0xD0, 3); // Register Bank Select 0 
   SBIT(RS1,      0xD0, 4); // Register Bank Select 1 
   SBIT(F0,       0xD0, 5); // User-Defined Flag
   SBIT(AC,       0xD0, 6); // Auxiliary Carry Flag 
   SBIT(CY,       0xD0, 7); // Carry Flag 
SFR(DMAIRQ,   0xD1); // DMA Interrupt Flag
SFR(DMA1CFGL, 0xD2); // DMA Channel 1-4 Configuration Address Low Byte
SFR(DMA1CFGH, 0xD3); // DMA Channel 1-4 Configuration Address High Byte
SFR(DMA0CFGL, 0xD4); // DMA Channel 0 Configuration Address Low Byte 
SFR(DMA0CFGH, 0xD5); // DMA Channel 0 Configuration Address High Byte 
SFR(DMAARM,   0xD6); // DMA Channel Arm 
SFR(DMAREQ,   0xD7); // DMA Channel Start Request and Status
SFR(TIMIF,    0xD8); // Timers 1/3/4 Interrupt Mask/Flag 
   SBIT(T3OVFIF,  0xD8, 0); // Timer 3 overflow interrupt flag 0:no pending 1:pending
   SBIT(T3CH0IF,  0xD8, 1); // Timer 3 channel 0 interrupt flag 0:no pending 1:pending
   SBIT(T3CH1IF,  0xD8, 2); // Timer 3 channel 1 interrupt flag 0:no pending 1:pending
   SBIT(T4OVFIF,  0xD8, 3); // Timer 4 overflow interrupt flag 0:no pending 1:pending
   SBIT(T4CH0IF,  0xD8, 4); // Timer 4 channel 0 interrupt flag 0:no pending 1:pending
   SBIT(T4CH1IF,  0xD8, 5); // Timer 4 channel 1 interrupt flag 0:no pending 1:pending
   SBIT(OVFIM,    0xD8, 6); // Timer 1 overflow interrupt mask
SFR(RFD,      0xD9); // RF Data
SFR(T1CC0L,   0xDA); // Timer 1 Channel 0 Capture/Compare Value Low
SFR(T1CC0H,   0xDB); // Timer 1 Channel 0 Capture/Compare Value High 
SFR(T1CC1L,   0xDC); // Timer 1 Channel 1 Capture/Compare Value Low 
SFR(T1CC1H,   0xDD); // Timer 1 Channel 1 Capture/Compare Value High 
SFR(T1CC2L,   0xDE); // Timer 1 Channel 2 Capture/Compare Value Low
SFR(T1CC2H,   0xDF); // Timer 1 Channel 2 Capture/Compare Value High
SFR(ACC,      0xE0); // Accumulator
   SBIT(ACC_0,    0xE0, 0); // Accumulator bit 0
   SBIT(ACC_1,    0xE0, 1); // Accumulator bit 1
   SBIT(ACC_2,    0xE0, 2); // Accumulator bit 2
   SBIT(ACC_3,    0xE0, 3); // Accumulator bit 3
   SBIT(ACC_4,    0xE0, 4); // Accumulator bit 4
   SBIT(ACC_5,    0xE0, 5); // Accumulator bit 5
   SBIT(ACC_6,    0xE0, 6); // Accumulator bit 6
   SBIT(ACC_7,    0xE0, 7); // Accumulator bit 7
SFR(RFST,     0xE1); // RF Strobe Commands
SFR(T1CNTL,   0xE2); // Timer 1 Counter Low 
SFR(T1CNTH,   0xE3); // Timer 1 Counter High 
SFR(T1CTL,    0xE4); // Timer 1 Control and Status
SFR(T1CCTL0,  0xE5); // Timer 1 Channel 0 Capture/Compare Control
SFR(T1CCTL1,  0xE6); // Timer 1 Channel 1 Capture/Compare Control
SFR(T1CCTL2,  0xE7); // Timer 1 Channel 2 Capture/Compare Control
SFR(IRCON2,   0xE8); // Interrupt Flag 5 
   SBIT(P2IF,     0xE8, 0); // Port 2 Interrupt Flag 
   SBIT(USBIF,    0xE8, 0); // USB Interrupt Flag (same bit as P2IF)
   SBIT(UTX0IF,   0xE8, 1); // USART0 TX Interrupt Flag 
   SBIT(UTX1IF,   0xE8, 2); // USART1 TX Interrupt Flag 
   SBIT(I2STXIF,  0xE8, 2); // I2S TX Interrupt Flag (same bit as UTX1FIF)
   SBIT(P1IF,     0xE8, 3); // Port 1 Interrupt Flag 
   SBIT(WDTIF,    0xE8, 4); // Watchdog Timer Interrupt Flag 
SFR(RFIF,     0xE9); // RF Interrupt Flags 
SFR(T4CNT,    0xEA); // Timer 4 Counter 
SFR(T4CTL,    0xEB); // Timer 4 Control 
SFR(T4CCTL0,  0xEC); // Timer 4 Channel 0 Capture/Compare Control 
SFR(T4CC0,    0xED); // Timer 4 Channel 0 Capture/Compare Value 
SFR(T4CCTL1,  0xEE); // Timer 4 Channel 1 Capture/Compare Control 
SFR(T4CC1,    0xEF); // Timer 4 Channel 1 Capture/Compare Value 
SFR(B,        0xF0); // B Register 
   SBIT(B_0,      0xF0, 0); // Register B bit 0
   SBIT(B_1,      0xF0, 1); // Register B bit 1
   SBIT(B_2,      0xF0, 2); // Register B bit 2
   SBIT(B_3,      0xF0, 3); // Register B bit 3
   SBIT(B_4,      0xF0, 4); // Register B bit 4
   SBIT(B_5,      0xF0, 5); // Register B bit 5
   SBIT(B_6,      0xF0, 6); // Register B bit 6
   SBIT(B_7,      0xF0, 7); // Register B bit 7
SFR(PERCFG,   0xF1); // Peripheral Control 
SFR(ADCCFG,   0xF2); // ADC Input Configuration
SFR(P0SEL,    0xF3); // Port 0 Function Select 
SFR(P1SEL,    0xF4); // Port 1 Function Select 
SFR(P2SEL,    0xF5); // Port 2 Function Select 
SFR(P1INP,    0xF6); // Port 1 Input Mode 
SFR(P2INP,    0xF7); // Port 2 Input Mode 
SFR(U1CSR,    0xF8); // USART 1 Control and Status
   SBIT(ACTIVE,   0xF8, 0); // USART transmit/receive active status 0:idle 1:busy
   SBIT(TX_BYTE,  0xF8, 1); // Transmit byte status 0:Byte not transmitted 1:Last byte transmitted
   SBIT(RX_BYTE,  0xF8, 2); // Receive byte status 0:No byte received 1:Received byte ready
   SBIT(ERR,      0xF8, 3); // UART parity error status 0:No error 1:parity error
   SBIT(FE,       0xF8, 4); // UART framing error status 0:No error 1:incorrect stop bit level
   SBIT(SLAVE,    0xF8, 5); // SPI master or slave mode select 0:master 1:slave
   SBIT(RE,       0xF8, 6); // UART receiver enable 0:disabled 1:enabled
   SBIT(MODE,     0xF8, 7); // USART mode select 0:SPI 1:UART
SFR(U1DBUF,   0xF9); // USART 1 Receive/Transmit Data Buffer 
SFR(U1BAUD,   0xFA); // USART 1 Baud Rate Control 
SFR(U1UCR,    0xFB); // USART 1 UART Control 
SFR(U1GCR,    0xFC); // USART 1 Generic Control
SFR(P0DIR,    0xFD); // Port 0 Direction 
SFR(P1DIR,    0xFE); // Port 1 Direction
SFR(P2DIR,    0xFF); // Port 2 Direction 

// From table 68: xdata RF registers

SFRX(SYNC1,      0xDF00); // Sync word, high byte 
SFRX(SYNC0,      0xDF01); // Sync word, low byte 
SFRX(PKTLEN,     0xDF02); // Packet length 
SFRX(PKTCTRL1,   0xDF03); // Packet automation control 
SFRX(PKTCTRL0,   0xDF04); // Packet automation control 
SFRX(ADDR,       0xDF05); // Device address 
SFRX(CHANNR,     0xDF06); // Channel number 
SFRX(FSCTRL1,    0xDF07); // Frequency synthesizer control 
SFRX(FSCTRL0,    0xDF08); // Frequency synthesizer control 
SFRX(FREQ2,      0xDF09); // Frequency control word, high byte 
SFRX(FREQ1,      0xDF0A); // Frequency control word, middle byte 
SFRX(FREQ0,      0xDF0B); // Frequency control word, low byte 
SFRX(MDMCFG4,    0xDF0C); // Modem configuration 
SFRX(MDMCFG3,    0xDF0D); // Modem configuration 
SFRX(MDMCFG2,    0xDF0E); // Modem configuration 
SFRX(MDMCFG1,    0xDF0F); // Modem configuration 
SFRX(MDMCFG0,    0xDF10); // Modem configuration 
SFRX(DEVIATN,    0xDF11); // Modem deviation setting 
SFRX(MCSM2,      0xDF12); // Main Radio Control State Machine configuration 
SFRX(MCSM1,      0xDF13); // Main Radio Control State Machine configuration 
SFRX(MCSM0,      0xDF14); // Main Radio Control State Machine configuration 
SFRX(FOCCFG,     0xDF15); // Frequency Offset Compensation configuration 
SFRX(BSCFG,      0xDF16); // Bit Synchronization configuration 
SFRX(AGCCTRL2,   0xDF17); // AGC control 
SFRX(AGCCTRL1,   0xDF18); // AGC control 
SFRX(AGCCTRL0,   0xDF19); // AGC control 
SFRX(FREND1,     0xDF1A); // Front end RX configuration 
SFRX(FREND0,     0xDF1B); // Front end TX configuration 
SFRX(FSCAL3,     0xDF1C); // Frequency synthesizer calibration 
SFRX(FSCAL2,     0xDF1D); // Frequency synthesizer calibration 
SFRX(FSCAL1,     0xDF1E); // Frequency synthesizer calibration 
SFRX(FSCAL0,     0xDF1F); // Frequency synthesizer calibration 
SFRX(PA_TABLE7,  0xDF27); // PA output power setting 
SFRX(PA_TABLE6,  0xDF28); // PA output power setting 
SFRX(PA_TABLE5,  0xDF29); // PA output power setting 
SFRX(PA_TABLE4,  0xDF2A); // PA output power setting 
SFRX(PA_TABLE3,  0xDF2B); // PA output power setting 
SFRX(PA_TABLE2,  0xDF2C); // PA output power setting 
SFRX(PA_TABLE1,  0xDF2D); // PA output power setting 
SFRX(PA_TABLE0,  0xDF2E); // PA output power setting 
SFRX(IOCFG2,     0xDF2F); // GDO2 output pin configuration 
SFRX(IOCFG1,     0xDF30); // GDO1 output pin configuration 
SFRX(IOCFG0,     0xDF31); // GDO0 output pin configuration 
SFRX(PARTNUM,    0xDF36); // Chip Identifier 
SFRX(VERSION,    0xDF37); // Configuration 
SFRX(FREQEST,    0xDF38); // Frequency Offset Estimate 
SFRX(LQI,        0xDF39); // Link Quality Indicator 
SFRX(RSSI,       0xDF3A); // Received Signal Strength Indication 
SFRX(MARCSTATE,  0xDF3B); // Main Radio Control State 
SFRX(PKTSTATUS,  0xDF3C); // Packet status 
SFRX(VCO_VC_DAC, 0xDF3D); // PLL calibration current 

// I2S Registers

SFRX(I2SCFG0,  0xDF40); // I2S Configuration Register 0 
SFRX(I2SCFG1,  0xDF41); // I2S Configuration Register 1 
SFRX(I2SDATL,  0xDF42); // I2S Data Low Byte 
SFRX(I2SDATH,  0xDF43); // I2S Data High Byte 
SFRX(I2SWCNT,  0xDF44); // I2S Word Count Register 
SFRX(I2SSTAT,  0xDF45); // I2S Status Register 
SFRX(I2SCLKF0, 0xDF46); // I2S Clock Configuration Register 0 
SFRX(I2SCLKF1, 0xDF47); // I2S Clock Configuration Register 1 
SFRX(I2SCLKF2, 0xDF48); // I2S Clock Configuration Register 2

// Common USB Registers

SFRX(USBADDR,  0xDE00); // Function Address
SFRX(USBPOW,   0xDE01); // Power/Control Register
SFRX(USBIIF,   0xDE02); // IN Endpoints and EP0 Interrupt Flags
SFRX(USBOIF,   0xDE04); // OUT Endpoints Interrupt Flags
SFRX(USBCIF,   0xDE06); // Common USB Interrupt Flags
SFRX(USBIIE,   0xDE07); // IN Endpoints and EP0 Interrupt Enable Mask
SFRX(USBOIE,   0xDE09); // Out Endpoints Interrupt Enable Mask
SFRX(USBCIE,   0xDE0B); // Common USB Interrupt Enable Mask
SFRX(USBFRML,  0xDE0C); // Current Frame Number (Low byte)
SFRX(USBFRMH,  0xDE0D); // Current Frame Number (High byte)
SFRX(USBINDEX, 0xDE0E); // Selects current endpoint.

// Indexed Endpoint Registers

SFRX(USBMAXI, 0xDE10); // Max. packet size for IN endpoint
SFRX(USBCS0,  0xDE11); // EP0 Control and Status (USBINDEX = 0)
SFRX(USBCSIL, 0xDE11); // IN EP{1-5} Control and Status Low
SFRX(USBCSIH, 0xDE12); // IN EP{1-5} Control and Status High
SFRX(USBMAXO, 0xDE13); // Max. packet size for OUT endpoint
SFRX(USBCSOL, 0xDE14); // OUT EP{1-5} Control and Status Low
SFRX(USBCSOH, 0xDE15); // OUT EP{1-5} Control and Status High
SFRX(USBCNT0, 0xDE16); // Number of received bytes in EP0 FIFO (USBINDEX = 0)
SFRX(USBCNTL, 0xDE16); // Number of bytes in OUT FIFO Low
SFRX(USBCNTH, 0xDE17); // Number of bytes in OUT FIFO High

// Endpoint FIFO Registers

SFRX(USBF0, 0xDE20); //  Endpoint 0 FIFO
SFRX(USBF1, 0xDE22); //  Endpoint 1 FIFO
SFRX(USBF2, 0xDE24); //  Endpoint 2 FIFO
SFRX(USBF3, 0xDE26); //  Endpoint 3 FIFO
SFRX(USBF4, 0xDE28); //  Endpoint 4 FIFO
SFRX(USBF5, 0xDE2A); //  Endpoint 5 FIFO

// SFRs also accesible through XDATA space

SFRX(X_U0CSR,    0xDF86); // USART 0 Control and Status
SFRX(X_P0IFG,    0xDF89); // Port 0 Interrupt Status Flag
SFRX(X_P1IFG,    0xDF8A); // Port 1 Interrupt Status Flag
SFRX(X_P2IFG,    0xDF8B); // Port 2 Interrupt Status Flag
SFRX(X_PICTL,    0xDF8C); // Port Pins Interrupt Mask and Edge
SFRX(X_P1IEN,    0xDF8D); // Port 1 Interrupt Mask
SFRX(X_P0INP,    0xDF8F); // Port 0 Input Mode
SFRX(X_RFIM,     0xDF91); // RF Interrupt Mask
SFRX(X_MPAGE,    0xDF93); // Memory Page Select 
SFRX(X_T2CT,     0xDF9C); // Timer 2 Control
SFRX(X_T2PR,     0xDF9D); // Timer 2 Prescaler
SFRX(X_T2CTL,    0xDF9E); // Timer 2 Control
SFRX(X_WORIRQ,   0xDFA1); // Timer Sleep Timer Interrupts
SFRX(X_WORCTL,   0xDFA2); // Sleep Timer Control 
SFRX(X_WOREVT0,  0xDFA3); // Timer Sleep Timer Event 0 Timeout Low Byte
SFRX(X_WOREVT1,  0xDFA4); // Timer Sleep Timer Event 0 Timeout High Byte
SFRX(X_WORTIME0, 0xDFA5); // Sleep Timer Value 0 
SFRX(X_WORTIME1, 0xDFA6); // Sleep Timer Value 1 
SFRX(X_FWT,      0xDFAB); // Flash Write Timing
SFRX(X_FADDRL,   0xDFAC); // Flash Address Low
SFRX(X_FADDRH,   0xDFAD); // Flash Address High
SFRX(X_FCTL,     0xDFAE); // Flash Control
SFRX(X_FWDATA,   0xDFAF); // Flash Write Data
SFRX(X_ENCDI,    0xDFB1); // Encryption/Decryption Input Data
SFRX(X_ENCDO,    0xDFB2); // Encryption/Decryption Output Data
SFRX(X_ENCCS,    0xDFB3); // Encryption/Decryption Control and Status
SFRX(X_ADCCON1,  0xDFB4); // ADC Control 1
SFRX(X_ADCCON2,  0xDFB5); // ADC Control 2
SFRX(X_ADCCON3,  0xDFB6); // ADC Control 3
SFRX(X_ADCL,     0xDFBA); // ADC Data Low
SFRX(X_ADCH,     0xDFBB); // ADC Data High
SFRX(X_RNDL,     0xDFBC); // Random Number Generator Data Low
SFRX(X_RNDH,     0xDFBD); // Random Number Generator Data High
SFRX(X_SLEEP,    0xDFBE); // Flash Write Timing
SFRX(X_U0DBUF,   0xDFC1); // USART 0 Receive/Transmit Data Buffer
SFRX(X_U0BAUD,   0xDFC2); // USART 0 Baud Rate Control
SFRX(X_U0UCR,    0xDFC4); // USART 0 UART Control
SFRX(X_U0GCR,    0xDFC5); // USART 0 Generic Control
SFRX(X_CLKCON,   0xDFC6); // Clock Control
SFRX(X_MEMCTR,   0xDFC7); // Memory System Control
SFRX(X_WDCTL,    0xDFC9); // Watchdog Timer Control
SFRX(X_T3CNT,    0xDFCA); // Timer 3 Counter
SFRX(X_T3CTL,    0xDFCB); // Timer 3 Control
SFRX(X_T3CCTL0,  0xDFCC); // Timer 3 Channel 0 Capture/Compare Control
SFRX(X_T3CC0,    0xDFCD); // Timer 3 Channel 0 Capture/Compare Value
SFRX(X_T3CCTL1,  0xDFCE); // Timer 3 Channel 1 Capture/Compare Control
SFRX(X_T3CC1,    0xDFCF); // Timer 3 Channel 1 Capture/Compare Value
SFRX(X_DMAIRQ,   0xDFD1); // DMA Interrupt Flag
SFRX(X_DMA1CFGL, 0xDFD2); // DMA Channel 1-4 Configuration Address Low Byte
SFRX(X_DMA1CFGH, 0xDFD3); // DMA Channel 1-4 Configuration Address High Byte
SFRX(X_DMA0CFGL, 0xDFD4); // DMA Channel 0 Configuration Address Low Byte
SFRX(X_DMA0CFGH, 0xDFD5); // DMA Channel 0 Configuration Address High Byte
SFRX(X_DMAARM,   0xDFD6); // DMA Channel Arm
SFRX(X_DMAREQ,   0xDFD7); // DMA Channel Start Request and Status
SFRX(X_TIMIF,    0xDFD8); // Timers 1/3/4 Joint Interrupt Mask/Flags
SFRX(X_RFD,      0xDFD9); // RF Data
SFRX(X_T1CC0L,   0xDFDA); // Timer 1 Channel 0 Capture/Compare Value Low
SFRX(X_T1CC0H,   0xDFDB); // Timer 1 Channel 0 Capture/Compare Value High
SFRX(X_T1CC1L,   0xDFDC); // Timer 1 Channel 1 Capture/Compare Value Low
SFRX(X_T1CC1H,   0xDFDD); // Timer 1 Channel 1 Capture/Compare Value High
SFRX(X_T1CC2L,   0xDFDE); // Timer 1 Channel 2 Capture/Compare Value Low
SFRX(X_T1CC2H,   0xDFDF); // Timer 1 Channel 2 Capture/Compare Value High
SFRX(X_RFST,     0xDFE1); // RF Strobe Commands
SFRX(X_T1CNTL,   0xDFE2); // Timer 1 Counter Low
SFRX(X_T1CNTH,   0xDFE3); // Timer 1 Counter High
SFRX(X_T1CTL,    0xDFE4); // Timer 1 Control and Status
SFRX(X_T1CCTL0,  0xDFE5); // Timer 1 Channel 0 Capture/Compare Control
SFRX(X_T1CCTL1,  0xDFE6); // Timer 1 Channel 1 Capture/Compare Control
SFRX(X_T1CCTL2,  0xDFE7); // Timer 1 Channel 2 Capture/Compare Control
SFRX(X_RFIF,     0xDFE9); // RF Interrupt flags
SFRX(X_T4CNT,    0xDFEA); // Timer 4 Counter
SFRX(X_T4CTL,    0xDFEB); // Timer 4 Control
SFRX(X_T4CCTL0,  0xDFEC); // Timer 4 Channel 0 Capture/Compare Control
SFRX(X_T4CC0,    0xDFED); // Timer 4 Channel 0 Capture/Compare Value
SFRX(X_T4CCTL1,  0xDFEE); // Timer 4 Channel 1 Capture/Compare Control
SFRX(X_T4CC1,    0xDFEF); // Timer 4 Channel 1 Capture/Compare Value
SFRX(X_PERCFG,   0xDFF1); // Peripheral I/O Control
SFRX(X_ADCCFG,   0xDFF2); // ADC Input Configuration
SFRX(X_P0SEL,    0xDFF3); // Port 0 Function Select
SFRX(X_P1SEL,    0xDFF4); // Port 1 Function Select
SFRX(X_P2SEL,    0xDFF5); // Port 2 Function Select
SFRX(X_P1INP,    0xDFF6); // Port 1 Input Mode
SFRX(X_P2INP,    0xDFF7); // Port 2 Input Mode
SFRX(X_U1CSR,    0xDFF8); // USART 1 Control and Status
SFRX(X_U1DBUF,   0xDFF9); // USART 1 Receive/Transmit Data Buffer
SFRX(X_U1BAUD,   0xDFFA); // USART 1 Baud Rate Control
SFRX(X_U1UCR,    0xDFFB); // USART 1 UART Control
SFRX(X_U1GCR,    0xDFFC); // USART 1 Generic Control
SFRX(X_P0DIR,    0xDFFD); // Port 0 Direction
SFRX(X_P1DIR,    0xDFFE); // Port 1 Direction
SFRX(X_P2DIR,    0xDFFF); // Port 2 Direction

#endif //REG_CC2510FX_H

/*-------------------------------------------------------------------------
   C8051F320.h - Register Declarations for the Cygnal/SiLabs C8051F32x
   Processor Range

   Copyright (C) 2004, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef C8051F320_H
#define C8051F320_H


/*  BYTE Registers  */
__sfr __at (0x80) P0           ;  /* PORT 0                                        */
__sfr __at (0x81) SP           ;  /* STACK POINTER                                 */
__sfr __at (0x82) DPL          ;  /* DATA POINTER - LOW BYTE                       */
__sfr __at (0x83) DPH          ;  /* DATA POINTER - HIGH BYTE                      */
__sfr __at (0x87) PCON         ;  /* POWER CONTROL                                 */
__sfr __at (0x88) TCON         ;  /* TIMER CONTROL                                 */
__sfr __at (0x89) TMOD         ;  /* TIMER MODE                                    */
__sfr __at (0x8A) TL0          ;  /* TIMER 0 - LOW BYTE                            */
__sfr __at (0x8B) TL1          ;  /* TIMER 1 - LOW BYTE                            */
__sfr __at (0x8C) TH0          ;  /* TIMER 0 - HIGH BYTE                           */
__sfr __at (0x8D) TH1          ;  /* TIMER 1 - HIGH BYTE                           */
__sfr __at (0x8E) CKCON        ;  /* CLOCK CONTROL                                 */
__sfr __at (0x8F) PSCTL        ;  /* PROGRAM STORE R/W CONTROL                     */
__sfr __at (0x90) P1           ;  /* PORT 1                                        */
__sfr __at (0x91) TMR3CN       ;  /* TIMER 3 CONTROL                               */
__sfr __at (0x92) TMR3RLL      ;  /* TIMER 3 CAPTURE REGISTER - LOW BYTE           */
__sfr __at (0x93) TMR3RLH      ;  /* TIMER 3 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at (0x94) TMR3L        ;  /* TIMER 3 - LOW BYTE                            */
__sfr __at (0x95) TMR3H        ;  /* TIMER 3 - HIGH BYTE                           */
__sfr __at (0x96) USB0ADR      ;  /* USB0 INDIRECT ADDRESS REGISTER                */
__sfr __at (0x97) USB0DAT      ;  /* USB0 DATA REGISTER                            */
__sfr __at (0x98) SCON         ;  /* SERIAL PORT CONTROL                           */
__sfr __at (0x98) SCON0        ;  /* SERIAL PORT CONTROL                           */
__sfr __at (0x99) SBUF         ;  /* SERIAL PORT BUFFER                            */
__sfr __at (0x99) SBUF0        ;  /* SERIAL PORT BUFFER                            */
__sfr __at (0x9A) CPT1CN       ;  /* COMPARATOR 1 CONTROL                          */
__sfr __at (0x9B) CPT0CN       ;  /* COMPARATOR 0 CONTROL                          */
__sfr __at (0x9C) CPT1MD       ;  /* COMPARATOR 1 MODE SELECTION                   */
__sfr __at (0x9D) CPT0MD       ;  /* COMPARATOR 0 MODE SELECTION                   */
__sfr __at (0x9E) CPT1MX       ;  /* COMPARATOR 1 MUX SELECTION                    */
__sfr __at (0x9F) CPT0MX       ;  /* COMPARATOR 0 MUX SELECTION                    */
__sfr __at (0xA0) P2           ;  /* PORT 2                                        */
__sfr __at (0xA1) SPI0CFG      ;  /* SPI0 CONFIGURATION                            */
__sfr __at (0xA2) SPI0CKR      ;  /* SPI0 CLOCK RATE CONTROL                       */
__sfr __at (0xA3) SPI0DAT      ;  /* SPI0 DATA                                     */
__sfr __at (0xA4) P0MDOUT      ;  /* PORT 0 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA5) P1MDOUT      ;  /* PORT 1 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA6) P2MDOUT      ;  /* PORT 2 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA7) P3MDOUT      ;  /* PORT 3 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA8) IE           ;  /* INTERRUPT ENABLE                              */
__sfr __at (0xA9) CLKSEL       ;  /* SYSTEM CLOCK SELECT                           */
__sfr __at (0xAA) EMI0CN       ;  /* EXTERNAL MEMORY INTERFACE CONTROL             */
__sfr __at (0xAA) _XPAGE       ;  /* XDATA/PDATA PAGE                              */
__sfr __at (0xB0) P3           ;  /* PORT 3                                        */
__sfr __at (0xB1) OSCXCN       ;  /* EXTERNAL OSCILLATOR CONTROL                   */
__sfr __at (0xB2) OSCICN       ;  /* INTERNAL OSCILLATOR CONTROL                   */
__sfr __at (0xB3) OSCICL       ;  /* INTERNAL OSCILLATOR CALIBRATION               */
__sfr __at (0xB6) FLSCL        ;  /* FLASH MEMORY TIMING PRESCALER                 */
__sfr __at (0xB7) FLKEY        ;  /* FLASH ACESS LIMIT                             */
__sfr __at (0xB8) IP           ;  /* INTERRUPT PRIORITY                            */
__sfr __at (0xB9) CLKMUL       ;  /* CLOCK MULTIPLIER CONTROL REGISTER             */
__sfr __at (0xBA) AMX0N        ;  /* ADC 0 MUX NEGATIVE CHANNEL SELECTION          */
__sfr __at (0xBB) AMX0P        ;  /* ADC 0 MUX POSITIVE CHANNEL SELECTION          */
__sfr __at (0xBC) ADC0CF       ;  /* ADC 0 CONFIGURATION                           */
__sfr __at (0xBD) ADC0L        ;  /* ADC 0 DATA WORD LSB                           */
__sfr __at (0xBE) ADC0H        ;  /* ADC 0 DATA WORD MSB                           */
__sfr __at (0xC0) SMB0CN       ;  /* SMBUS CONTROL                                 */
__sfr __at (0xC1) SMB0CF       ;  /* SMBUS CONFIGURATION                           */
__sfr __at (0xC2) SMB0DAT      ;  /* SMBUS DATA                                    */
__sfr __at (0xC3) ADC0GTL      ;  /* ADC 0 GREATER-THAN LOW BYTE                   */
__sfr __at (0xC4) ADC0GTH      ;  /* ADC 0 GREATER-THAN HIGH BYTE                  */
__sfr __at (0xC5) ADC0LTL      ;  /* ADC 0 LESS-THAN LOW BYTE                      */
__sfr __at (0xC6) ADC0LTH      ;  /* ADC 0 LESS-THAN HIGH BYTE                     */
__sfr __at (0xC8) T2CON        ;  /* TIMER 2 CONTROL                               */
__sfr __at (0xC8) TMR2CN       ;  /* TIMER 2 CONTROL                               */
__sfr __at (0xC9) REG0CN       ;  /* VOLTAGE REGULATOR CONTROL                     */
__sfr __at (0xCA) RCAP2L       ;  /* TIMER 2 CAPTURE REGISTER - LOW BYTE           */
__sfr __at (0xCA) TMR2RLL      ;  /* TIMER 2 CAPTURE REGISTER - LOW BYTE           */
__sfr __at (0xCB) RCAP2H       ;  /* TIMER 2 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at (0xCB) TMR2RLH      ;  /* TIMER 2 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at (0xCC) TL2          ;  /* TIMER 2 - LOW BYTE                            */
__sfr __at (0xCC) TMR2L        ;  /* TIMER 2 - LOW BYTE                            */
__sfr __at (0xCD) TH2          ;  /* TIMER 2 - HIGH BYTE                           */
__sfr __at (0xCD) TMR2H        ;  /* TIMER 2 - HIGH BYTE                           */
__sfr __at (0xD0) PSW          ;  /* PROGRAM STATUS WORD                           */
__sfr __at (0xD1) REF0CN       ;  /* VOLTAGE REFERENCE 0 CONTROL                   */
__sfr __at (0xD4) P0SKIP       ;  /* PORT 0 SKIP                                   */
__sfr __at (0xD5) P1SKIP       ;  /* PORT 1 SKIP                                   */
__sfr __at (0xD6) P2SKIP       ;  /* PORT 2 SKIP                                   */
__sfr __at (0xD7) USB0XCN      ;  /* USB0 TRANSCEIVER CONTROL                      */
__sfr __at (0xD8) PCA0CN       ;  /* PCA CONTROL                                   */
__sfr __at (0xD9) PCA0MD       ;  /* PCA MODE                                      */
__sfr __at (0xDA) PCA0CPM0     ;  /* PCA MODULE 0 MODE REGISTER                    */
__sfr __at (0xDB) PCA0CPM1     ;  /* PCA MODULE 1 MODE REGISTER                    */
__sfr __at (0xDC) PCA0CPM2     ;  /* PCA MODULE 2 MODE REGISTER                    */
__sfr __at (0xDD) PCA0CPM3     ;  /* PCA MODULE 3 MODE REGISTER                    */
__sfr __at (0xDE) PCA0CPM4     ;  /* PCA MODULE 4 MODE REGISTER                    */
__sfr __at (0xE0) ACC          ;  /* ACCUMULATOR                                   */
__sfr __at (0xE1) XBR0         ;  /* PORT MUX CONFIGURATION REGISTER 0             */
__sfr __at (0xE2) XBR1         ;  /* PORT MUX CONFIGURATION REGISTER 1             */
__sfr __at (0xE4) IT01CF       ;  /* INT0/INT1 CONFIGURATION REGISTER              */
__sfr __at (0xE4) INT01CF      ;  /* INT0/INT1 CONFIGURATION REGISTER              */
__sfr __at (0xE6) EIE1         ;  /* EXTERNAL INTERRUPT ENABLE 1                   */
__sfr __at (0xE7) EIE2         ;  /* EXTERNAL INTERRUPT ENABLE 2                   */
__sfr __at (0xE8) ADC0CN       ;  /* ADC 0 CONTROL                                 */
__sfr __at (0xE9) PCA0CPL1     ;  /* PCA CAPTURE 1 LOW                             */
__sfr __at (0xEA) PCA0CPH1     ;  /* PCA CAPTURE 1 HIGH                            */
__sfr __at (0xEB) PCA0CPL2     ;  /* PCA CAPTURE 2 LOW                             */
__sfr __at (0xEC) PCA0CPH2     ;  /* PCA CAPTURE 2 HIGH                            */
__sfr __at (0xED) PCA0CPL3     ;  /* PCA CAPTURE 3 LOW                             */
__sfr __at (0xEE) PCA0CPH3     ;  /* PCA CAPTURE 3 HIGH                            */
__sfr __at (0xEF) RSTSRC       ;  /* RESET SOURCE                                  */
__sfr __at (0xF0) B            ;  /* B REGISTER                                    */
__sfr __at (0xF1) P0MODE       ;  /* PORT 0 INPUT MODE CONFIGURATION               */
__sfr __at (0xF1) P0MDIN       ;  /* PORT 0 INPUT MODE CONFIGURATION               */
__sfr __at (0xF2) P1MODE       ;  /* PORT 1 INPUT MODE CONFIGURATION               */
__sfr __at (0xF2) P1MDIN       ;  /* PORT 1 INPUT MODE CONFIGURATION               */
__sfr __at (0xF3) P2MODE       ;  /* PORT 2 INPUT MODE CONFIGURATION               */
__sfr __at (0xF3) P2MDIN       ;  /* PORT 2 INPUT MODE CONFIGURATION               */
__sfr __at (0xF4) P3MODE       ;  /* PORT 3 INPUT MODE CONFIGURATION               */
__sfr __at (0xF4) P3MDIN       ;  /* PORT 3 INPUT MODE CONFIGURATION               */
__sfr __at (0xF6) EIP1         ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 1        */
__sfr __at (0xF7) EIP2         ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 2        */
__sfr __at (0xF8) SPI0CN       ;  /* SPI0 CONTROL                                  */
__sfr __at (0xF9) PCA0L        ;  /* PCA COUNTER LOW                               */
__sfr __at (0xFA) PCA0H        ;  /* PCA COUNTER HIGH                              */
__sfr __at (0xFB) PCA0CPL0     ;  /* PCA CAPTURE 0 LOW                             */
__sfr __at (0xFC) PCA0CPH0     ;  /* PCA CAPTURE 0 HIGH                            */
__sfr __at (0xFD) PCA0CPL4     ;  /* PCA CAPTURE 4 LOW                             */
__sfr __at (0xFE) PCA0CPH4     ;  /* PCA CAPTURE 4 HIGH                            */
__sfr __at (0xFF) VDM0CN       ;  /* VDD MONITOR CONTROL                           */


/*  WORD/DWORD Registers  */

__sfr16 __at (0x8C8A) TMR0     ;  /* TIMER 0 COUNTER                               */
__sfr16 __at (0x8D8B) TMR1     ;  /* TIMER 1 COUNTER                               */
__sfr16 __at (0xCDCC) TMR2     ;  /* TIMER 2 COUNTER                               */
__sfr16 __at (0xCBCA) RCAP2    ;  /* TIMER 2 CAPTURE REGISTER WORD                 */
__sfr16 __at (0xCBCA) TMR2RL   ;  /* TIMER 2 CAPTURE REGISTER WORD                 */
__sfr16 __at (0x9594) TMR3     ;  /* TIMER 3 COUNTER                               */
__sfr16 __at (0x9392) TMR3RL   ;  /* TIMER 3 CAPTURE REGISTER WORD                 */
__sfr16 __at (0xBEBD) ADC0     ;  /* ADC 0 DATA WORD                               */
__sfr16 __at (0xC4C3) ADC0GT   ;  /* ADC 0 GREATER-THAN REGISTER WORD              */
__sfr16 __at (0xC6C5) ADC0LT   ;  /* ADC 0 LESS-THAN REGISTER WORD                 */
__sfr16 __at (0xFAF9) PCA0     ;  /* PCA COUNTER                                   */
__sfr16 __at (0xFCFB) PCA0CP0  ;  /* PCA CAPTURE 0 WORD                            */
__sfr16 __at (0xEAE9) PCA0CP1  ;  /* PCA CAPTURE 1 WORD                            */
__sfr16 __at (0xECEB) PCA0CP2  ;  /* PCA CAPTURE 2 WORD                            */
__sfr16 __at (0xEEED) PCA0CP3  ;  /* PCA CAPTURE 3 WORD                            */
__sfr16 __at (0xFEFD) PCA0CP4  ;  /* PCA CAPTURE 4 WORD                            */


/*  BIT Registers  */

/*  P0  0x80 */
__sbit __at (0x80) P0_0        ;
__sbit __at (0x81) P0_1        ;
__sbit __at (0x82) P0_2        ;
__sbit __at (0x83) P0_3        ;
__sbit __at (0x84) P0_4        ;
__sbit __at (0x85) P0_5        ;
__sbit __at (0x86) P0_6        ;
__sbit __at (0x87) P0_7        ;
                               
/*  TCON  0x88 */              
__sbit __at (0x88) IT0         ;  /* TCON.0 - EXT. INTERRUPT 0 TYPE                */
__sbit __at (0x89) IE0         ;  /* TCON.1 - EXT. INTERRUPT 0 EDGE FLAG           */
__sbit __at (0x8A) IT1         ;  /* TCON.2 - EXT. INTERRUPT 1 TYPE                */
__sbit __at (0x8B) IE1         ;  /* TCON.3 - EXT. INTERRUPT 1 EDGE FLAG           */
__sbit __at (0x8C) TR0         ;  /* TCON.4 - TIMER 0 ON/OFF CONTROL               */
__sbit __at (0x8D) TF0         ;  /* TCON.5 - TIMER 0 OVERFLOW FLAG                */
__sbit __at (0x8E) TR1         ;  /* TCON.6 - TIMER 1 ON/OFF CONTROL               */
__sbit __at (0x8F) TF1         ;  /* TCON.7 - TIMER 1 OVERFLOW FLAG                */
                               
/*  P1  0x90 */                
__sbit __at (0x90) P1_0        ;
__sbit __at (0x91) P1_1        ;
__sbit __at (0x92) P1_2        ;
__sbit __at (0x93) P1_3        ;
__sbit __at (0x94) P1_4        ;
__sbit __at (0x95) P1_5        ;
__sbit __at (0x96) P1_6        ;
__sbit __at (0x97) P1_7        ;
                               
/*  SCON  0x98 */              
__sbit __at (0x98) RI          ;  /* SCON.0 - RECEIVE INTERRUPT FLAG               */
__sbit __at (0x98) RI0         ;  /* SCON.0 - RECEIVE INTERRUPT FLAG               */
__sbit __at (0x99) TI          ;  /* SCON.1 - TRANSMIT INTERRUPT FLAG              */
__sbit __at (0x99) TI0         ;  /* SCON.1 - TRANSMIT INTERRUPT FLAG              */
__sbit __at (0x9A) RB8         ;  /* SCON.2 - RECEIVE BIT 8                        */
__sbit __at (0x9A) RB80        ;  /* SCON.2 - RECEIVE BIT 8                        */
__sbit __at (0x9B) TB8         ;  /* SCON.3 - TRANSMIT BIT 8                       */
__sbit __at (0x9B) TB80        ;  /* SCON.3 - TRANSMIT BIT 8                       */
__sbit __at (0x9C) REN         ;  /* SCON.4 - RECEIVE ENABLE                       */
__sbit __at (0x9C) REN0        ;  /* SCON.4 - RECEIVE ENABLE                       */
__sbit __at (0x9D) SM2         ;  /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE  */
__sbit __at (0x9D) MCE0        ;  /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE  */
__sbit __at (0x9F) SM0         ;  /* SCON.7 - SERIAL MODE CONTROL BIT 0            */
__sbit __at (0x9F) S0MODE      ;  /* SCON.7 - SERIAL MODE CONTROL BIT 0            */
                               
/*  P2  0xA0 */                
__sbit __at (0xA0) P2_0        ;
__sbit __at (0xA1) P2_1        ;
__sbit __at (0xA2) P2_2        ;
__sbit __at (0xA3) P2_3        ;
__sbit __at (0xA4) P2_4        ;
__sbit __at (0xA5) P2_5        ;
__sbit __at (0xA6) P2_6        ;
__sbit __at (0xA7) P2_7        ;
                               
/*  IE  0xA8 */                
__sbit __at (0xA8) EX0         ;  /* IE.0 - EXTERNAL INTERRUPT 0 ENABLE            */
__sbit __at (0xA9) ET0         ;  /* IE.1 - TIMER 0 INTERRUPT ENABLE               */
__sbit __at (0xAA) EX1         ;  /* IE.2 - EXTERNAL INTERRUPT 1 ENABLE            */
__sbit __at (0xAB) ET1         ;  /* IE.3 - TIMER 1 INTERRUPT ENABLE               */
__sbit __at (0xAC) ES          ;  /* IE.4 - SERIAL PORT INTERRUPT ENABLE           */
__sbit __at (0xAC) ES0         ;  /* IE.4 - SERIAL PORT INTERRUPT ENABLE           */
__sbit __at (0xAD) ET2         ;  /* IE.5 - TIMER 2 INTERRUPT ENABLE               */
__sbit __at (0xAE) ESPI0       ;  /* IE.6 - SPI0 INTERRUPT ENABLE                  */
__sbit __at (0xAF) EA          ;  /* IE.7 - GLOBAL INTERRUPT ENABLE                */
                               
/*  P3  0xB0 */                
__sbit __at (0xB0) P3_0        ;
__sbit __at (0xB1) P3_1        ;
__sbit __at (0xB2) P3_2        ;
__sbit __at (0xB3) P3_3        ;
__sbit __at (0xB4) P3_4        ;
__sbit __at (0xB5) P3_5        ;
__sbit __at (0xB6) P3_6        ;
__sbit __at (0xB7) P3_7        ;
                               
/*  IP  0xB8 */                
__sbit __at (0xB8) PX0         ;  /* IP.0 - EXTERNAL INTERRUPT 0 PRIORITY          */
__sbit __at (0xB9) PT0         ;  /* IP.1 - TIMER 0 PRIORITY                       */
__sbit __at (0xBA) PX1         ;  /* IP.2 - EXTERNAL INTERRUPT 1 PRIORITY          */
__sbit __at (0xBB) PT1         ;  /* IP.3 - TIMER 1 PRIORITY                       */
__sbit __at (0xBC) PS          ;  /* IP.4 - SERIAL PORT PRIORITY                   */
__sbit __at (0xBC) PS0         ;  /* IP.4 - SERIAL PORT PRIORITY                   */
__sbit __at (0xBD) PT2         ;  /* IP.5 - TIMER 2 PRIORITY                       */
__sbit __at (0xBE) PSPI0       ;  /* IP.6 - SPI0 PRIORITY                          */
                               
/*  SMB0CN  0xC0 */            
__sbit __at (0xC0) SI          ;  /* SMB0CN.0 - SMBUS 0 INTERRUPT PENDING FLAG     */
__sbit __at (0xC1) ACK         ;  /* SMB0CN.1 - SMBUS 0 ACKNOWLEDGE FLAG           */
__sbit __at (0xC2) ARBLOST     ;  /* SMB0CN.2 - SMBUS 0 ARBITRATION LOST INDICATOR */
__sbit __at (0xC3) ACKRQ       ;  /* SMB0CN.3 - SMBUS 0 ACKNOWLEDGE REQUEST        */
__sbit __at (0xC4) STO         ;  /* SMB0CN.4 - SMBUS 0 STOP FLAG                  */
__sbit __at (0xC5) STA         ;  /* SMB0CN.5 - SMBUS 0 START FLAG                 */
__sbit __at (0xC6) TXMODE      ;  /* SMB0CN.6 - SMBUS 0 TRANSMIT MODE INDICATOR    */
__sbit __at (0xC7) MASTER      ;  /* SMB0CN.7 - SMBUS 0 MASTER/SLAVE INDICATOR     */
                               
/*  TMR2CN  0xC8 */            
__sbit __at (0xC8) T2XCLK      ;  /* TMR2CN.0 - TIMER 2 EXTERNAL CLOCK SELECT      */
__sbit __at (0xCA) TR2         ;  /* TMR2CN.2 - TIMER 2 ON/OFF CONTROL             */
__sbit __at (0xCB) T2SPLIT     ;  /* TMR2CN.3 - TIMER 2 SPLIT MODE ENABLE          */
__sbit __at (0xCC) T2SOF       ;  /* TMR2CN.4 - TIMER 2 START_OF_FRAME CAPTURE ENA */
__sbit __at (0xCD) TF2LEN      ;  /* TMR2CN.5 - TIMER 2 LOW BYTE INTERRUPT ENABLE  */
__sbit __at (0xCE) TF2L        ;  /* TMR2CN.6 - TIMER 2 LOW BYTE OVERFLOW FLAG     */
__sbit __at (0xCF) TF2         ;  /* TMR2CN.7 - TIMER 2 OVERFLOW FLAG              */
__sbit __at (0xCF) TF2H        ;  /* TMR2CN.7 - TIMER 2 HIGH BYTE OVERFLOW FLAG    */
                               
/*  PSW  0xD0 */               
__sbit __at (0xD0) PARITY      ;  /* PSW.0 - ACCUMULATOR PARITY FLAG               */
__sbit __at (0xD1) F1          ;  /* PSW.1 - FLAG 1                                */
__sbit __at (0xD2) OV          ;  /* PSW.2 - OVERFLOW FLAG                         */
__sbit __at (0xD3) RS0         ;  /* PSW.3 - REGISTER BANK SELECT 0                */
__sbit __at (0xD4) RS1         ;  /* PSW.4 - REGISTER BANK SELECT 1                */
__sbit __at (0xD5) F0          ;  /* PSW.5 - FLAG 0                                */
__sbit __at (0xD6) AC          ;  /* PSW.6 - AUXILIARY CARRY FLAG                  */
__sbit __at (0xD7) CY          ;  /* PSW.7 - CARRY FLAG                            */
                               
/*  PCA0CN  0xD8 */            
__sbit __at (0xD8) CCF0        ;  /* PCA0CN.0 - PCA MODULE 0 CAPTURE/COMPARE FLAG  */
__sbit __at (0xD9) CCF1        ;  /* PCA0CN.1 - PCA MODULE 1 CAPTURE/COMPARE FLAG  */
__sbit __at (0xDA) CCF2        ;  /* PCA0CN.2 - PCA MODULE 2 CAPTURE/COMPARE FLAG  */
__sbit __at (0xDB) CCF3        ;  /* PCA0CN.3 - PCA MODULE 3 CAPTURE/COMPARE FLAG  */
__sbit __at (0xDC) CCF4        ;  /* PCA0CN.4 - PCA MODULE 4 CAPTURE/COMPARE FLAG  */
__sbit __at (0xDE) CR          ;  /* PCA0CN.6 - PCA COUNTER/TIMER RUN CONTROL      */
__sbit __at (0xDF) CF          ;  /* PCA0CN.7 - PCA COUNTER/TIMER OVERFLOW FLAG    */
                               
/*  ADC0CN  0xE8 */            
__sbit __at (0xE8) AD0CM0      ;  /* ADC0CN.0 - ADC 0 START OF CONV. MODE BIT 0    */
__sbit __at (0xE9) AD0CM1      ;  /* ADC0CN.1 - ADC 0 START OF CONV. MODE BIT 1    */
__sbit __at (0xEA) AD0CM2      ;  /* ADC0CN.2 - ADC 0 START OF CONV. MODE BIT 2    */
__sbit __at (0xEB) AD0WINT     ;  /* ADC0CN.3 - ADC 0 WINDOW COMPARE INT. FLAG     */
__sbit __at (0xEC) AD0BUSY     ;  /* ADC0CN.4 - ADC 0 BUSY FLAG                    */
__sbit __at (0xED) AD0INT      ;  /* ADC0CN.5 - ADC 0 CONV. COMPLETE INT. FLAG     */
__sbit __at (0xEE) AD0TM       ;  /* ADC0CN.6 - ADC 0 TRACK MODE                   */
__sbit __at (0xEF) AD0EN       ;  /* ADC0CN.7 - ADC 0 ENABLE                       */
                               
/*  SPI0CN  0xF8 */            
__sbit __at (0xF8) SPIEN       ;  /* SPI0CN.0 - SPI0 ENABLE                        */
__sbit __at (0xF9) TXBMT       ;  /* SPI0CN.1 - TRANSMIT BUFFER EMPTY              */
__sbit __at (0xFA) NSSMD0      ;  /* SPI0CN.2 - SLAVE SELECT MODE BIT 0            */
__sbit __at (0xFB) NSSMD1      ;  /* SPI0CN.3 - SLAVE SELECT MODE BIT 1            */
__sbit __at (0xFC) RXOVRN      ;  /* SPI0CN.4 - RECEIVE OVERRUN FLAG               */
__sbit __at (0xFD) MODF        ;  /* SPI0CN.5 - MODE FAULT FLAG                    */
__sbit __at (0xFE) WCOL        ;  /* SPI0CN.6 - WRITE COLLISION FLAG               */
__sbit __at (0xFF) SPIF        ;  /* SPI0CN.7 - SPI0 INTERRUPT FLAG                */


/* Predefined SFR Bit Masks */

#define PCON_IDLE         0x01    /* PCON                                */
#define PCON_STOP         0x02    /* PCON                                */
#define T1M               0x08    /* CKCON                               */
#define PSWE              0x01    /* PSCTL                               */
#define PSEE              0x02    /* PSCTL                               */
#define ECP0              0x20    /* EIE1                                */
#define ECP1              0x40    /* EIE1                                */
#define PORSF             0x02    /* RSTSRC                              */
#define SWRSF             0x10    /* RSTSRC                              */
#define ECCF              0x01    /* PCA0CPMn                            */
#define PWM               0x02    /* PCA0CPMn                            */
#define TOG               0x04    /* PCA0CPMn                            */
#define MAT               0x08    /* PCA0CPMn                            */
#define CAPN              0x10    /* PCA0CPMn                            */
#define CAPP              0x20    /* PCA0CPMn                            */
#define ECOM              0x40    /* PCA0CPMn                            */
#define PWM16             0x80    /* PCA0CPMn                            */
#define CP0E              0x10    /* XBR0                                */
#define CP0OEN            0x10    /* XBR0                                */
#define CP0AE             0x20    /* XBR0                                */
#define CP0AOEN           0x20    /* XBR0                                */
#define CP1E              0x40    /* XBR0                                */
#define CP1AE             0x80    /* XBR0                                */

#endif
/*-------------------------------------------------------------------------
   serial.c - this module implements serial interrupt handler and IO
              routinwes using two 256 byte cyclic buffers. Bit variables
              can be used as flags for real-time kernel tasks

   Copyright (C) 1996, Dmitry S. Obukhov <dmitry.obukhov AT gmail.com>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

void serial_init (void);
void serial_interrupt_handler (void) __interrupt 4 __using 1;
void serial_putc (unsigned char);
unsigned char serial_getc (void);
void autobaud ();
/*-------------------------------------------------------------------------
   at89c55.h - register declarations for ATMEL 89x55 processors

   Copyright (C) 1999, Bernd Bartmann <bernd.bartmann AT gmail.com>

   Based on reg51.h by Sandeep Dutta sandeep.dutta AT usa.net
   KEIL C compatible definitions are included

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef AT89x55_H
#define AT89x55_H

/* BYTE addressable registers */
__sfr __at 0x80 P0          ;
__sfr __at 0x81 SP          ;
__sfr __at 0x82 DPL         ;
__sfr __at 0x83 DPH         ;
__sfr __at 0x87 PCON        ;
__sfr __at 0x88 TCON        ;
__sfr __at 0x89 TMOD        ;
__sfr __at 0x8A TL0         ;
__sfr __at 0x8B TL1         ;
__sfr __at 0x8C TH0         ;
__sfr __at 0x8D TH1         ;
__sfr __at 0x90 P1          ;
__sfr __at 0x98 SCON        ;
__sfr __at 0x99 SBUF        ;
__sfr __at 0xA0 P2          ;
__sfr __at 0xA8 IE          ;
__sfr __at 0xB0 P3          ;
__sfr __at 0xB8 IP          ;
__sfr __at 0xC8 T2CON       ;
__sfr __at 0xC9 T2MOD       ;
__sfr __at 0xCA RCAP2L      ;
__sfr __at 0xCB RCAP2H      ;
__sfr __at 0xCC TL2         ;
__sfr __at 0xCD TH2         ;
__sfr __at 0xD0 PSW         ;
__sfr __at 0xE0 ACC         ;
__sfr __at 0xE0 A           ;
__sfr __at 0xF0 B           ;


/* BIT addressable registers */
/* P0 */
__sbit __at 0x80 P0_0       ;
__sbit __at 0x81 P0_1       ;
__sbit __at 0x82 P0_2       ;
__sbit __at 0x83 P0_3       ;
__sbit __at 0x84 P0_4       ;
__sbit __at 0x85 P0_5       ;
__sbit __at 0x86 P0_6       ;
__sbit __at 0x87 P0_7       ;

/* TCON */
__sbit __at 0x88 IT0        ;
__sbit __at 0x89 IE0        ;
__sbit __at 0x8A IT1        ;
__sbit __at 0x8B IE1        ;
__sbit __at 0x8C TR0        ;
__sbit __at 0x8D TF0        ;
__sbit __at 0x8E TR1        ;
__sbit __at 0x8F TF1        ;

/* P1 */
__sbit __at 0x90 P1_0       ;
__sbit __at 0x91 P1_1       ;
__sbit __at 0x92 P1_2       ;
__sbit __at 0x93 P1_3       ;
__sbit __at 0x94 P1_4       ;
__sbit __at 0x95 P1_5       ;
__sbit __at 0x96 P1_6       ;
__sbit __at 0x97 P1_7       ;

__sbit __at 0x90 T2         ;
__sbit __at 0x91 T2EX       ;

/* SCON */
__sbit __at 0x98 RI         ;
__sbit __at 0x99 TI         ;
__sbit __at 0x9A RB8        ;
__sbit __at 0x9B TB8        ;
__sbit __at 0x9C REN        ;
__sbit __at 0x9D SM2        ;
__sbit __at 0x9E SM1        ;
__sbit __at 0x9F SM0        ;

/* P2 */
__sbit __at 0xA0 P2_0       ;
__sbit __at 0xA1 P2_1       ;
__sbit __at 0xA2 P2_2       ;
__sbit __at 0xA3 P2_3       ;
__sbit __at 0xA4 P2_4       ;
__sbit __at 0xA5 P2_5       ;
__sbit __at 0xA6 P2_6       ;
__sbit __at 0xA7 P2_7       ;

/* IE */
__sbit __at 0xA8 EX0        ;
__sbit __at 0xA9 ET0        ;
__sbit __at 0xAA EX1        ;
__sbit __at 0xAB ET1        ;
__sbit __at 0xAC ES         ;
__sbit __at 0xAD ET2        ;
__sbit __at 0xAF EA         ;

/* P3 */
__sbit __at 0xB0 P3_0       ;
__sbit __at 0xB1 P3_1       ;
__sbit __at 0xB2 P3_2       ;
__sbit __at 0xB3 P3_3       ;
__sbit __at 0xB4 P3_4       ;
__sbit __at 0xB5 P3_5       ;
__sbit __at 0xB6 P3_6       ;
__sbit __at 0xB7 P3_7       ;

__sbit __at 0xB0 RXD        ;
__sbit __at 0xB1 TXD        ;
__sbit __at 0xB2 INT0       ;
__sbit __at 0xB3 INT1       ;
__sbit __at 0xB4 T0         ;
__sbit __at 0xB5 T1         ;
__sbit __at 0xB6 WR         ;
__sbit __at 0xB7 RD         ;

/* IP */ 
__sbit __at 0xB8 PX0        ;
__sbit __at 0xB9 PT0        ;
__sbit __at 0xBA PX1        ;
__sbit __at 0xBB PT1        ;
__sbit __at 0xBC PS         ;
__sbit __at 0xBD PT2        ;

/* T2CON */
__sbit __at 0xC8 T2CON_0    ;
__sbit __at 0xC9 T2CON_1    ;
__sbit __at 0xCA T2CON_2    ;
__sbit __at 0xCB T2CON_3    ;
__sbit __at 0xCC T2CON_4    ;
__sbit __at 0xCD T2CON_5    ;
__sbit __at 0xCE T2CON_6    ;
__sbit __at 0xCF T2CON_7    ;

__sbit __at 0xC8 CP_RL2     ;
__sbit __at 0xC9 C_T2       ;
__sbit __at 0xCA TR2        ;
__sbit __at 0xCB EXEN2      ;
__sbit __at 0xCC TCLK       ;
__sbit __at 0xCD RCLK       ;
__sbit __at 0xCE EXF2       ;
__sbit __at 0xCF TF2        ;

/* PSW */
__sbit __at 0xD0 P          ;
__sbit __at 0xD1 FL         ;
__sbit __at 0xD2 OV         ;
__sbit __at 0xD3 RS0        ;
__sbit __at 0xD4 RS1        ;
__sbit __at 0xD5 F0         ;
__sbit __at 0xD6 AC         ;
__sbit __at 0xD7 CY         ;


/* BIT definitions for bits that are not directly accessible */
/* PCON bits */
#define IDL             0x01
#define PD              0x02
#define GF0             0x04
#define GF1             0x08
#define SMOD            0x80

#define IDL_            0x01
#define PD_             0x02
#define GF0_            0x04
#define GF1_            0x08
#define SMOD_           0x80

/* TMOD bits */
#define M0_0            0x01
#define M1_0            0x02
#define C_T0            0x04
#define GATE0           0x08
#define M0_1            0x10
#define M1_1            0x20
#define C_T1            0x40
#define GATE1           0x80

#define M0_0_           0x01
#define M1_0_           0x02
#define C_T0_           0x04
#define GATE0_          0x08
#define M0_1_           0x10
#define M1_1_           0x20
#define C_T1_           0x40
#define GATE1_          0x80

#define T0_M0           0x01
#define T0_M1           0x02
#define T0_CT           0x04
#define T0_GATE         0x08
#define T1_M0           0x10
#define T1_M1           0x20
#define T1_CT           0x40
#define T1_GATE         0x80

#define T0_M0_          0x01
#define T0_M1_          0x02
#define T0_CT_          0x04
#define T0_GATE_        0x08
#define T1_M0_          0x10
#define T1_M1_          0x20
#define T1_CT_          0x40
#define T1_GATE_        0x80

#define T0_MASK         0x0F
#define T1_MASK         0xF0

#define T0_MASK_        0x0F
#define T1_MASK_        0xF0

/* T2MOD bits */
#define DCEN            0x01
#define T2OE            0x02

#define DCEN_           0x01
#define T2OE_           0x02


/* Interrupt numbers: address = (number * 8) + 3 */
#define IE0_VECTOR      0       /* 0x03 external interrupt 0 */
#define TF0_VECTOR      1       /* 0x0b timer 0 */
#define IE1_VECTOR      2       /* 0x13 external interrupt 1 */
#define TF1_VECTOR      3       /* 0x1b timer 1 */
#define SI0_VECTOR      4       /* 0x23 serial port 0 */
#define TF2_VECTOR      5       /* 0x2B timer 2 */
#define EX2_VECTOR      5       /* 0x2B external interrupt 2 */
 
#endif
/*-------------------------------------------------------------------------
   C8051F330.h - Register Declarations for the Cygnal/SiLabs C8051F33x
   Processor Range

   Copyright (C) 2004, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef C8051F330_H
#define C8051F330_H


/*  BYTE Registers  */

__sfr __at (0x80) P0           ;  /* PORT 0                                        */
__sfr __at (0x81) SP           ;  /* STACK POINTER                                 */
__sfr __at (0x82) DPL          ;  /* DATA POINTER - LOW BYTE                       */
__sfr __at (0x83) DPH          ;  /* DATA POINTER - HIGH BYTE                      */
__sfr __at (0x87) PCON         ;  /* POWER CONTROL                                 */
__sfr __at (0x88) TCON         ;  /* TIMER CONTROL                                 */
__sfr __at (0x89) TMOD         ;  /* TIMER MODE                                    */
__sfr __at (0x8A) TL0          ;  /* TIMER 0 - LOW BYTE                            */
__sfr __at (0x8B) TL1          ;  /* TIMER 1 - LOW BYTE                            */
__sfr __at (0x8C) TH0          ;  /* TIMER 0 - HIGH BYTE                           */
__sfr __at (0x8D) TH1          ;  /* TIMER 1 - HIGH BYTE                           */
__sfr __at (0x8E) CKCON        ;  /* CLOCK CONTROL                                 */
__sfr __at (0x8F) PSCTL        ;  /* PROGRAM STORE R/W CONTROL                     */
__sfr __at (0x90) P1           ;  /* PORT 1                                        */
__sfr __at (0x91) TMR3CN       ;  /* TIMER 3 CONTROL                               */
__sfr __at (0x92) TMR3RLL      ;  /* TIMER 3 CAPTURE REGISTER - LOW BYTE           */
__sfr __at (0x93) TMR3RLH      ;  /* TIMER 3 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at (0x94) TMR3L        ;  /* TIMER 3 - LOW BYTE                            */
__sfr __at (0x95) TMR3H        ;  /* TIMER 3 - HIGH BYTE                           */
__sfr __at (0x96) IDA0L        ;  /* CURRENT MODE DAC 0 - LOW BYTE                 */
__sfr __at (0x97) IDA0H        ;  /* CURRENT MODE DAC 0 - HIGH BYTE                */
__sfr __at (0x98) SCON         ;  /* SERIAL PORT CONTROL                           */
__sfr __at (0x98) SCON0        ;  /* SERIAL PORT CONTROL                           */
__sfr __at (0x99) SBUF         ;  /* SERIAL PORT BUFFER                            */
__sfr __at (0x99) SBUF0        ;  /* SERIAL PORT BUFFER                            */
__sfr __at (0x9B) CPT0CN       ;  /* COMPARATOR 0 CONTROL                          */
__sfr __at (0x9D) CPT0MD       ;  /* COMPARATOR 0 MODE SELECTION                   */
__sfr __at (0x9F) CPT0MX       ;  /* COMPARATOR 0 MUX SELECTION                    */
__sfr __at (0xA0) P2           ;  /* PORT 2                                        */
__sfr __at (0xA1) SPI0CFG      ;  /* SPI0 CONFIGURATION                            */
__sfr __at (0xA2) SPI0CKR      ;  /* SPI0 CLOCK RATE CONTROL                       */
__sfr __at (0xA3) SPI0DAT      ;  /* SPI0 DATA                                     */
__sfr __at (0xA4) P0MDOUT      ;  /* PORT 0 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA5) P1MDOUT      ;  /* PORT 1 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA6) P2MDOUT      ;  /* PORT 2 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xA8) IE           ;  /* INTERRUPT ENABLE                              */
__sfr __at (0xA9) CLKSEL       ;  /* SYSTEM CLOCK SELECT                           */
__sfr __at (0xAA) EMI0CN       ;  /* EXTERNAL MEMORY INTERFACE CONTROL             */
__sfr __at (0xAA) _XPAGE       ;  /* XDATA/PDATA PAGE                              */
__sfr __at (0xB1) OSCXCN       ;  /* EXTERNAL OSCILLATOR CONTROL                   */
__sfr __at (0xB2) OSCICN       ;  /* INTERNAL OSCILLATOR CONTROL                   */
__sfr __at (0xB3) OSCICL       ;  /* INTERNAL OSCILLATOR CALIBRATION               */
__sfr __at (0xB6) FLSCL        ;  /* FLASH MEMORY TIMING PRESCALER                 */
__sfr __at (0xB7) FLKEY        ;  /* FLASH ACESS LIMIT                             */
__sfr __at (0xB8) IP           ;  /* INTERRUPT PRIORITY                            */
__sfr __at (0xB9) IDA0CN       ;  /* CURRENT MODE DAC 0 - CONTROL                  */
__sfr __at (0xBA) AMX0N        ;  /* ADC 0 MUX NEGATIVE CHANNEL SELECTION          */
__sfr __at (0xBB) AMX0P        ;  /* ADC 0 MUX POSITIVE CHANNEL SELECTION          */
__sfr __at (0xBC) ADC0CF       ;  /* ADC 0 CONFIGURATION                           */
__sfr __at (0xBD) ADC0L        ;  /* ADC 0 DATA WORD LSB                           */
__sfr __at (0xBE) ADC0H        ;  /* ADC 0 DATA WORD MSB                           */
__sfr __at (0xC0) SMB0CN       ;  /* SMBUS CONTROL                                 */
__sfr __at (0xC1) SMB0CF       ;  /* SMBUS CONFIGURATION                           */
__sfr __at (0xC2) SMB0DAT      ;  /* SMBUS DATA                                    */
__sfr __at (0xC3) ADC0GTL      ;  /* ADC 0 GREATER-THAN LOW BYTE                   */
__sfr __at (0xC4) ADC0GTH      ;  /* ADC 0 GREATER-THAN HIGH BYTE                  */
__sfr __at (0xC5) ADC0LTL      ;  /* ADC 0 LESS-THAN LOW BYTE                      */
__sfr __at (0xC6) ADC0LTH      ;  /* ADC 0 LESS-THAN HIGH BYTE                     */
__sfr __at (0xC8) T2CON        ;  /* TIMER 2 CONTROL                               */
__sfr __at (0xC8) TMR2CN       ;  /* TIMER 2 CONTROL                               */
__sfr __at (0xCA) RCAP2L       ;  /* TIMER 2 CAPTURE REGISTER - LOW BYTE           */
__sfr __at (0xCA) TMR2RLL      ;  /* TIMER 2 CAPTURE REGISTER - LOW BYTE           */
__sfr __at (0xCB) RCAP2H       ;  /* TIMER 2 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at (0xCB) TMR2RLH      ;  /* TIMER 2 CAPTURE REGISTER - HIGH BYTE          */
__sfr __at (0xCC) TL2          ;  /* TIMER 2 - LOW BYTE                            */
__sfr __at (0xCC) TMR2L        ;  /* TIMER 2 - LOW BYTE                            */
__sfr __at (0xCD) TH2          ;  /* TIMER 2 - HIGH BYTE                           */
__sfr __at (0xCD) TMR2H        ;  /* TIMER 2 - HIGH BYTE                           */
__sfr __at (0xD0) PSW          ;  /* PROGRAM STATUS WORD                           */
__sfr __at (0xD1) REF0CN       ;  /* VOLTAGE REFERENCE 0 CONTROL                   */
__sfr __at (0xD4) P0SKIP       ;  /* PORT 0 SKIP                                   */
__sfr __at (0xD5) P1SKIP       ;  /* PORT 1 SKIP                                   */
__sfr __at (0xD8) PCA0CN       ;  /* PCA CONTROL                                   */
__sfr __at (0xD9) PCA0MD       ;  /* PCA MODE                                      */
__sfr __at (0xDA) PCA0CPM0     ;  /* PCA MODULE 0 MODE REGISTER                    */
__sfr __at (0xDB) PCA0CPM1     ;  /* PCA MODULE 1 MODE REGISTER                    */
__sfr __at (0xDC) PCA0CPM2     ;  /* PCA MODULE 2 MODE REGISTER                    */
__sfr __at (0xE0) ACC          ;  /* ACCUMULATOR                                   */
__sfr __at (0xE1) XBR0         ;  /* PORT MUX CONFIGURATION REGISTER 0             */
__sfr __at (0xE2) XBR1         ;  /* PORT MUX CONFIGURATION REGISTER 1             */
__sfr __at (0xE3) OSCLCN       ;  /* LOW-FREQUENCY OSCILLATOR CONTROL              */
__sfr __at (0xE4) IT01CF       ;  /* INT0/INT1 CONFIGURATION REGISTER              */
__sfr __at (0xE4) INT01CF      ;  /* INT0/INT1 CONFIGURATION REGISTER              */
__sfr __at (0xE6) EIE1         ;  /* EXTERNAL INTERRUPT ENABLE 1                   */
__sfr __at (0xE8) ADC0CN       ;  /* ADC 0 CONTROL                                 */
__sfr __at (0xE9) PCA0CPL1     ;  /* PCA CAPTURE 1 LOW                             */
__sfr __at (0xEA) PCA0CPH1     ;  /* PCA CAPTURE 1 HIGH                            */
__sfr __at (0xEB) PCA0CPL2     ;  /* PCA CAPTURE 2 LOW                             */
__sfr __at (0xEC) PCA0CPH2     ;  /* PCA CAPTURE 2 HIGH                            */
__sfr __at (0xEF) RSTSRC       ;  /* RESET SOURCE                                  */
__sfr __at (0xF0) B            ;  /* B REGISTER                                    */
__sfr __at (0xF1) P0MODE       ;  /* PORT 0 INPUT MODE CONFIGURATION               */
__sfr __at (0xF1) P0MDIN       ;  /* PORT 0 INPUT MODE CONFIGURATION               */
__sfr __at (0xF2) P1MODE       ;  /* PORT 1 INPUT MODE CONFIGURATION               */
__sfr __at (0xF2) P1MDIN       ;  /* PORT 1 INPUT MODE CONFIGURATION               */
__sfr __at (0xF6) EIP1         ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 1        */
__sfr __at (0xF8) SPI0CN       ;  /* SPI0 CONTROL                                  */
__sfr __at (0xF9) PCA0L        ;  /* PCA COUNTER LOW                               */
__sfr __at (0xFA) PCA0H        ;  /* PCA COUNTER HIGH                              */
__sfr __at (0xFB) PCA0CPL0     ;  /* PCA CAPTURE 0 LOW                             */
__sfr __at (0xFC) PCA0CPH0     ;  /* PCA CAPTURE 0 HIGH                            */
__sfr __at (0xFF) VDM0CN       ;  /* VDD MONITOR CONTROL                           */


/*  WORD/DWORD Registers  */

__sfr16 __at (0x8C8A) TMR0     ;  /* TIMER 0 COUNTER                               */
__sfr16 __at (0x8D8B) TMR1     ;  /* TIMER 1 COUNTER                               */
__sfr16 __at (0xCDCC) TMR2     ;  /* TIMER 2 COUNTER                               */
__sfr16 __at (0xCBCA) RCAP2    ;  /* TIMER 2 CAPTURE REGISTER WORD                 */
__sfr16 __at (0xCBCA) TMR2RL   ;  /* TIMER 2 CAPTURE REGISTER WORD                 */
__sfr16 __at (0x9594) TMR3     ;  /* TIMER 3 COUNTER                               */
__sfr16 __at (0x9392) TMR3RL   ;  /* TIMER 3 CAPTURE REGISTER WORD                 */
__sfr16 __at (0x9796) IDA0     ;  /* CURRENT MODE DAC 0 DATA WORD                  */
__sfr16 __at (0xBEBD) ADC0     ;  /* ADC 0 DATA WORD                               */
__sfr16 __at (0xC4C3) ADC0GT   ;  /* ADC 0 GREATER-THAN REGISTER WORD              */
__sfr16 __at (0xC6C5) ADC0LT   ;  /* ADC 0 LESS-THAN REGISTER WORD                 */
__sfr16 __at (0xFAF9) PCA0     ;  /* PCA COUNTER                                   */
__sfr16 __at (0xFCFB) PCA0CP0  ;  /* PCA CAPTURE 0 WORD                            */
__sfr16 __at (0xEAE9) PCA0CP1  ;  /* PCA CAPTURE 1 WORD                            */
__sfr16 __at (0xECEB) PCA0CP2  ;  /* PCA CAPTURE 2 WORD                            */


/*  BIT Registers  */

/*  P0  0x80 */
__sbit __at (0x80) P0_0        ;
__sbit __at (0x81) P0_1        ;
__sbit __at (0x82) P0_2        ;
__sbit __at (0x83) P0_3        ;
__sbit __at (0x84) P0_4        ;
__sbit __at (0x85) P0_5        ;
__sbit __at (0x86) P0_6        ;
__sbit __at (0x87) P0_7        ;

/*  TCON  0x88 */
__sbit __at (0x88) IT0         ;  /* TCON.0 - EXT. INTERRUPT 0 TYPE                */
__sbit __at (0x89) IE0         ;  /* TCON.1 - EXT. INTERRUPT 0 EDGE FLAG           */
__sbit __at (0x8A) IT1         ;  /* TCON.2 - EXT. INTERRUPT 1 TYPE                */
__sbit __at (0x8B) IE1         ;  /* TCON.3 - EXT. INTERRUPT 1 EDGE FLAG           */
__sbit __at (0x8C) TR0         ;  /* TCON.4 - TIMER 0 ON/OFF CONTROL               */
__sbit __at (0x8D) TF0         ;  /* TCON.5 - TIMER 0 OVERFLOW FLAG                */
__sbit __at (0x8E) TR1         ;  /* TCON.6 - TIMER 1 ON/OFF CONTROL               */
__sbit __at (0x8F) TF1         ;  /* TCON.7 - TIMER 1 OVERFLOW FLAG                */

/*  P1  0x90 */
__sbit __at (0x90) P1_0        ;
__sbit __at (0x91) P1_1        ;
__sbit __at (0x92) P1_2        ;
__sbit __at (0x93) P1_3        ;
__sbit __at (0x94) P1_4        ;
__sbit __at (0x95) P1_5        ;
__sbit __at (0x96) P1_6        ;
__sbit __at (0x97) P1_7        ;

/*  SCON  0x98 */
__sbit __at (0x98) RI          ;  /* SCON.0 - RECEIVE INTERRUPT FLAG               */
__sbit __at (0x98) RI0         ;  /* SCON.0 - RECEIVE INTERRUPT FLAG               */
__sbit __at (0x99) TI          ;  /* SCON.1 - TRANSMIT INTERRUPT FLAG              */
__sbit __at (0x99) TI0         ;  /* SCON.1 - TRANSMIT INTERRUPT FLAG              */
__sbit __at (0x9A) RB8         ;  /* SCON.2 - RECEIVE BIT 8                        */
__sbit __at (0x9A) RB80        ;  /* SCON.2 - RECEIVE BIT 8                        */
__sbit __at (0x9B) TB8         ;  /* SCON.3 - TRANSMIT BIT 8                       */
__sbit __at (0x9B) TB80        ;  /* SCON.3 - TRANSMIT BIT 8                       */
__sbit __at (0x9C) REN         ;  /* SCON.4 - RECEIVE ENABLE                       */
__sbit __at (0x9C) REN0        ;  /* SCON.4 - RECEIVE ENABLE                       */
__sbit __at (0x9D) SM2         ;  /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE  */
__sbit __at (0x9D) MCE0        ;  /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE  */
__sbit __at (0x9F) SM0         ;  /* SCON.7 - SERIAL MODE CONTROL BIT 0            */
__sbit __at (0x9F) S0MODE      ;  /* SCON.7 - SERIAL MODE CONTROL BIT 0            */

/*  P2  0xA0 */
__sbit __at (0xA0) P2_0        ;
__sbit __at (0xA1) P2_1        ;
__sbit __at (0xA2) P2_2        ;
__sbit __at (0xA3) P2_3        ;
__sbit __at (0xA4) P2_4        ;
__sbit __at (0xA5) P2_5        ;
__sbit __at (0xA6) P2_6        ;
__sbit __at (0xA7) P2_7        ;

/*  IE  0xA8 */
__sbit __at (0xA8) EX0         ;  /* IE.0 - EXTERNAL INTERRUPT 0 ENABLE            */
__sbit __at (0xA9) ET0         ;  /* IE.1 - TIMER 0 INTERRUPT ENABLE               */
__sbit __at (0xAA) EX1         ;  /* IE.2 - EXTERNAL INTERRUPT 1 ENABLE            */
__sbit __at (0xAB) ET1         ;  /* IE.3 - TIMER 1 INTERRUPT ENABLE               */
__sbit __at (0xAC) ES          ;  /* IE.4 - SERIAL PORT INTERRUPT ENABLE           */
__sbit __at (0xAC) ES0         ;  /* IE.4 - SERIAL PORT INTERRUPT ENABLE           */
__sbit __at (0xAD) ET2         ;  /* IE.5 - TIMER 2 INTERRUPT ENABLE               */
__sbit __at (0xAE) ESPI0       ;  /* IE.6 - SPI0 INTERRUPT ENABLE                  */
__sbit __at (0xAF) EA          ;  /* IE.7 - GLOBAL INTERRUPT ENABLE                */

/*  IP  0xB8 */
__sbit __at (0xB8) PX0         ;  /* IP.0 - EXTERNAL INTERRUPT 0 PRIORITY          */
__sbit __at (0xB9) PT0         ;  /* IP.1 - TIMER 0 PRIORITY                       */
__sbit __at (0xBA) PX1         ;  /* IP.2 - EXTERNAL INTERRUPT 1 PRIORITY          */
__sbit __at (0xBB) PT1         ;  /* IP.3 - TIMER 1 PRIORITY                       */
__sbit __at (0xBC) PS          ;  /* IP.4 - SERIAL PORT PRIORITY                   */
__sbit __at (0xBC) PS0         ;  /* IP.4 - SERIAL PORT PRIORITY                   */
__sbit __at (0xBD) PT2         ;  /* IP.5 - TIMER 2 PRIORITY                       */
__sbit __at (0xBE) PSPI0       ;  /* IP.6 - SPI0 PRIORITY                          */

/*  SMB0CN  0xC0 */
__sbit __at (0xC0) SI          ;  /* SMB0CN.0 - SMBUS 0 INTERRUPT PENDING FLAG     */
__sbit __at (0xC1) ACK         ;  /* SMB0CN.1 - SMBUS 0 ACKNOWLEDGE FLAG           */
__sbit __at (0xC2) ARBLOST     ;  /* SMB0CN.2 - SMBUS 0 ARBITRATION LOST INDICATOR */
__sbit __at (0xC3) ACKRQ       ;  /* SMB0CN.3 - SMBUS 0 ACKNOWLEDGE REQUEST        */
__sbit __at (0xC4) STO         ;  /* SMB0CN.4 - SMBUS 0 STOP FLAG                  */
__sbit __at (0xC5) STA         ;  /* SMB0CN.5 - SMBUS 0 START FLAG                 */
__sbit __at (0xC6) TXMODE      ;  /* SMB0CN.6 - SMBUS 0 TRANSMIT MODE INDICATOR    */
__sbit __at (0xC7) MASTER      ;  /* SMB0CN.7 - SMBUS 0 MASTER/SLAVE INDICATOR     */

/*  TMR2CN  0xC8 */
__sbit __at (0xC8) T2XCLK      ;  /* TMR2CN.0 - TIMER 2 EXTERNAL CLOCK SELECT      */
__sbit __at (0xCA) TR2         ;  /* TMR2CN.2 - TIMER 2 ON/OFF CONTROL             */
__sbit __at (0xCB) T2SPLIT     ;  /* TMR2CN.3 - TIMER 2 SPLIT MODE ENABLE          */
__sbit __at (0xCC) TF2CEN      ;  /* TMR2CN.4 - TIMER 2 LOW-FREQ OSC CAPTURE ENABLE*/
__sbit __at (0xCD) TF2LEN      ;  /* TMR2CN.5 - TIMER 2 LOW BYTE INTERRUPT ENABLE  */
__sbit __at (0xCE) TF2L        ;  /* TMR2CN.6 - TIMER 2 LOW BYTE OVERFLOW FLAG     */
__sbit __at (0xCF) TF2         ;  /* TMR2CN.7 - TIMER 2 OVERFLOW FLAG              */
__sbit __at (0xCF) TF2H        ;  /* TMR2CN.7 - TIMER 2 HIGH BYTE OVERFLOW FLAG    */

/*  PSW  0xD0 */
__sbit __at (0xD0) PARITY      ;  /* PSW.0 - ACCUMULATOR PARITY FLAG               */
__sbit __at (0xD1) F1          ;  /* PSW.1 - FLAG 1                                */
__sbit __at (0xD2) OV          ;  /* PSW.2 - OVERFLOW FLAG                         */
__sbit __at (0xD3) RS0         ;  /* PSW.3 - REGISTER BANK SELECT 0                */
__sbit __at (0xD4) RS1         ;  /* PSW.4 - REGISTER BANK SELECT 1                */
__sbit __at (0xD5) F0          ;  /* PSW.5 - FLAG 0                                */
__sbit __at (0xD6) AC          ;  /* PSW.6 - AUXILIARY CARRY FLAG                  */
__sbit __at (0xD7) CY          ;  /* PSW.7 - CARRY FLAG                            */

/*  PCA0CN  0xD8 */
__sbit __at (0xD8) CCF0        ;  /* PCA0CN.0 - PCA MODULE 0 CAPTURE/COMPARE FLAG  */
__sbit __at (0xD9) CCF1        ;  /* PCA0CN.1 - PCA MODULE 1 CAPTURE/COMPARE FLAG  */
__sbit __at (0xDA) CCF2        ;  /* PCA0CN.2 - PCA MODULE 2 CAPTURE/COMPARE FLAG  */
__sbit __at (0xDE) CR          ;  /* PCA0CN.6 - PCA COUNTER/TIMER RUN CONTROL      */
__sbit __at (0xDF) CF          ;  /* PCA0CN.7 - PCA COUNTER/TIMER OVERFLOW FLAG    */

/*  ADC0CN  0xE8 */
__sbit __at (0xE8) AD0CM0      ;  /* ADC0CN.0 - ADC 0 START OF CONV. MODE BIT 0    */
__sbit __at (0xE9) AD0CM1      ;  /* ADC0CN.1 - ADC 0 START OF CONV. MODE BIT 1    */
__sbit __at (0xEA) AD0CM2      ;  /* ADC0CN.2 - ADC 0 START OF CONV. MODE BIT 2    */
__sbit __at (0xEB) AD0WINT     ;  /* ADC0CN.3 - ADC 0 WINDOW COMPARE INT. FLAG     */
__sbit __at (0xEC) AD0BUSY     ;  /* ADC0CN.4 - ADC 0 BUSY FLAG                    */
__sbit __at (0xED) AD0INT      ;  /* ADC0CN.5 - ADC 0 CONV. COMPLETE INT. FLAG     */
__sbit __at (0xEE) AD0TM       ;  /* ADC0CN.6 - ADC 0 TRACK MODE                   */
__sbit __at (0xEF) AD0EN       ;  /* ADC0CN.7 - ADC 0 ENABLE                       */

/*  SPI0CN  0xF8 */
__sbit __at (0xF8) SPIEN       ;  /* SPI0CN.0 - SPI0 ENABLE                        */
__sbit __at (0xF9) TXBMT       ;  /* SPI0CN.1 - TRANSMIT BUFFER EMPTY              */
__sbit __at (0xFA) NSSMD0      ;  /* SPI0CN.2 - SLAVE SELECT MODE BIT 0            */
__sbit __at (0xFB) NSSMD1      ;  /* SPI0CN.3 - SLAVE SELECT MODE BIT 1            */
__sbit __at (0xFC) RXOVRN      ;  /* SPI0CN.4 - RECEIVE OVERRUN FLAG               */
__sbit __at (0xFD) MODF        ;  /* SPI0CN.5 - MODE FAULT FLAG                    */
__sbit __at (0xFE) WCOL        ;  /* SPI0CN.6 - WRITE COLLISION FLAG               */
__sbit __at (0xFF) SPIF        ;  /* SPI0CN.7 - SPI0 INTERRUPT FLAG                */


/* Predefined SFR Bit Masks */

#define PCON_IDLE         0x01    /* PCON                                */
#define PCON_STOP         0x02    /* PCON                                */
#define T1M               0x08    /* CKCON                               */
#define PSWE              0x01    /* PSCTL                               */
#define PSEE              0x02    /* PSCTL                               */
#define ECP0              0x20    /* EIE1                                */
#define PORSF             0x02    /* RSTSRC                              */
#define SWRSF             0x10    /* RSTSRC                              */
#define ECCF              0x01    /* PCA0CPMn                            */
#define PWM               0x02    /* PCA0CPMn                            */
#define TOG               0x04    /* PCA0CPMn                            */
#define MAT               0x08    /* PCA0CPMn                            */
#define CAPN              0x10    /* PCA0CPMn                            */
#define CAPP              0x20    /* PCA0CPMn                            */
#define ECOM              0x40    /* PCA0CPMn                            */
#define PWM16             0x80    /* PCA0CPMn                            */
#define CP0E              0x10    /* XBR0                                */
#define CP0OEN            0x10    /* XBR0                                */
#define CP0AE             0x20    /* XBR0                                */
#define CP0AOEN           0x20    /* XBR0                                */

#endif
/*---------------------------------------------------------------------------
   C8051F000.h - Register Declarations for the Cygnal/SiLabs C8051F000-F017
   Processor Range

   Copyright (C) 2003, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef C8051F000_H
#define C8051F000_H


/*  BYTE Registers  */
__sfr __at (0x80) P0           ;  /* PORT 0                                                  */
__sfr __at (0x81) SP           ;  /* STACK POINTER                                           */
__sfr __at (0x82) DPL          ;  /* DATA POINTER - LOW BYTE                                 */
__sfr __at (0x83) DPH          ;  /* DATA POINTER - HIGH BYTE                                */
__sfr __at (0x87) PCON         ;  /* POWER CONTROL                                           */
__sfr __at (0x88) TCON         ;  /* TIMER CONTROL                                           */
__sfr __at (0x89) TMOD         ;  /* TIMER MODE                                              */
__sfr __at (0x8A) TL0          ;  /* TIMER 0 - LOW BYTE                                      */
__sfr __at (0x8B) TL1          ;  /* TIMER 1 - LOW BYTE                                      */
__sfr __at (0x8C) TH0          ;  /* TIMER 0 - HIGH BYTE                                     */
__sfr __at (0x8D) TH1          ;  /* TIMER 1 - HIGH BYTE                                     */
__sfr __at (0x8E) CKCON        ;  /* CLOCK CONTROL                                           */
__sfr __at (0x8F) PSCTL        ;  /* PROGRAM STORE R/W CONTROL                               */
__sfr __at (0x90) P1           ;  /* PORT 1                                                  */
__sfr __at (0x91) TMR3CN       ;  /* TIMER 3 CONTROL                                         */
__sfr __at (0x92) TMR3RLL      ;  /* TIMER 3 RELOAD REGISTER - LOW BYTE                      */
__sfr __at (0x93) TMR3RLH      ;  /* TIMER 3 RELOAD REGISTER - HIGH BYTE                     */
__sfr __at (0x94) TMR3L        ;  /* TIMER 3 - LOW BYTE                                      */
__sfr __at (0x95) TMR3H        ;  /* TIMER 3 - HIGH BYTE                                     */
__sfr __at (0x98) SCON         ;  /* SERIAL PORT CONTROL                                     */
__sfr __at (0x99) SBUF         ;  /* SERIAL PORT BUFFER                                      */
__sfr __at (0x9A) SPI0CFG      ;  /* SERIAL PERIPHERAL INTERFACE 0 CONFIGURATION             */
__sfr __at (0x9B) SPI0DAT      ;  /* SERIAL PERIPHERAL INTERFACE 0 DATA                      */
__sfr __at (0x9D) SPI0CKR      ;  /* SERIAL PERIPHERAL INTERFACE 0 CLOCK RATE CONTROL        */
__sfr __at (0x9E) CPT0CN       ;  /* COMPARATOR 0 CONTROL                                    */
__sfr __at (0x9F) CPT1CN       ;  /* COMPARATOR 1 CONTROL                                    */
__sfr __at (0xA0) P2           ;  /* PORT 2                                                  */
__sfr __at (0xA4) PRT0CF       ;  /* PORT 0 CONFIGURATION                                    */
__sfr __at (0xA5) PRT1CF       ;  /* PORT 1 CONFIGURATION                                    */
__sfr __at (0xA6) PRT2CF       ;  /* PORT 2 CONFIGURATION                                    */
__sfr __at (0xA7) PRT3CF       ;  /* PORT 3 CONFIGURATION                                    */
__sfr __at (0xA8) IE           ;  /* INTERRUPT ENABLE                                        */
__sfr __at (0xAD) PRT1IF       ;  /* PORT 1 EXTERNAL INTERRUPT FLAGS                         */
__sfr __at (0xAF) EMI0CN       ;  /* EXTERNAL MEMORY INTERFACE CONTROL                       */
__sfr __at (0xAF) _XPAGE       ;  /* XDATA/PDATA PAGE                                        */
__sfr __at (0xB0) P3           ;  /* PORT 3                                                  */
__sfr __at (0xB1) OSCXCN       ;  /* EXTERNAL OSCILLATOR CONTROL                             */
__sfr __at (0xB2) OSCICN       ;  /* INTERNAL OSCILLATOR CONTROL                             */
__sfr __at (0xB6) FLSCL        ;  /* FLASH MEMORY TIMING PRESCALER                           */
__sfr __at (0xB7) FLACL        ;  /* FLASH ACESS LIMIT                                       */
__sfr __at (0xB8) IP           ;  /* INTERRUPT PRIORITY                                      */
__sfr __at (0xBA) AMX0CF       ;  /* ADC 0 MUX CONFIGURATION                                 */
__sfr __at (0xBB) AMX0SL       ;  /* ADC 0 MUX CHANNEL SELECTION                             */
__sfr __at (0xBC) ADC0CF       ;  /* ADC 0 CONFIGURATION                                     */
__sfr __at (0xBE) ADC0L        ;  /* ADC 0 DATA - LOW BYTE                                   */
__sfr __at (0xBF) ADC0H        ;  /* ADC 0 DATA - HIGH BYTE                                  */
__sfr __at (0xC0) SMB0CN       ;  /* SMBUS 0 CONTROL                                         */
__sfr __at (0xC1) SMB0STA      ;  /* SMBUS 0 STATUS                                          */
__sfr __at (0xC2) SMB0DAT      ;  /* SMBUS 0 DATA                                            */
__sfr __at (0xC3) SMB0ADR      ;  /* SMBUS 0 SLAVE ADDRESS                                   */
__sfr __at (0xC4) ADC0GTL      ;  /* ADC 0 GREATER-THAN REGISTER - LOW BYTE                  */
__sfr __at (0xC5) ADC0GTH      ;  /* ADC 0 GREATER-THAN REGISTER - HIGH BYTE                 */
__sfr __at (0xC6) ADC0LTL      ;  /* ADC 0 LESS-THAN REGISTER - LOW BYTE                     */
__sfr __at (0xC7) ADC0LTH      ;  /* ADC 0 LESS-THAN REGISTER - HIGH BYTE                    */
__sfr __at (0xC8) T2CON        ;  /* TIMER 2 CONTROL                                         */
__sfr __at (0xCA) RCAP2L       ;  /* TIMER 2 CAPTURE REGISTER - LOW BYTE                     */
__sfr __at (0xCB) RCAP2H       ;  /* TIMER 2 CAPTURE REGISTER - HIGH BYTE                    */
__sfr __at (0xCC) TL2          ;  /* TIMER 2 - LOW BYTE                                      */
__sfr __at (0xCD) TH2          ;  /* TIMER 2 - HIGH BYTE                                     */
__sfr __at (0xCF) SMB0CR       ;  /* SMBUS 0 CLOCK RATE                                      */
__sfr __at (0xD0) PSW          ;  /* PROGRAM STATUS WORD                                     */
__sfr __at (0xD1) REF0CN       ;  /* VOLTAGE REFERENCE 0 CONTROL                             */
__sfr __at (0xD2) DAC0L        ;  /* DAC 0 REGISTER - LOW BYTE                               */
__sfr __at (0xD3) DAC0H        ;  /* DAC 0 REGISTER - HIGH BYTE                              */
__sfr __at (0xD4) DAC0CN       ;  /* DAC 0 CONTROL                                           */
__sfr __at (0xD5) DAC1L        ;  /* DAC 1 REGISTER - LOW BYTE                               */
__sfr __at (0xD6) DAC1H        ;  /* DAC 1 REGISTER - HIGH BYTE                              */
__sfr __at (0xD7) DAC1CN       ;  /* DAC 1 CONTROL                                           */
__sfr __at (0xD8) PCA0CN       ;  /* PCA 0 COUNTER CONTROL                                   */
__sfr __at (0xD9) PCA0MD       ;  /* PCA 0 COUNTER MODE                                      */
__sfr __at (0xDA) PCA0CPM0     ;  /* CONTROL REGISTER FOR PCA 0 MODULE 0                     */
__sfr __at (0xDB) PCA0CPM1     ;  /* CONTROL REGISTER FOR PCA 0 MODULE 1                     */
__sfr __at (0xDC) PCA0CPM2     ;  /* CONTROL REGISTER FOR PCA 0 MODULE 2                     */
__sfr __at (0xDD) PCA0CPM3     ;  /* CONTROL REGISTER FOR PCA 0 MODULE 3                     */
__sfr __at (0xDE) PCA0CPM4     ;  /* CONTROL REGISTER FOR PCA 0 MODULE 4                     */
__sfr __at (0xE0) ACC          ;  /* ACCUMULATOR                                             */
__sfr __at (0xE1) XBR0         ;  /* DIGITAL CROSSBAR CONFIGURATION REGISTER 0               */
__sfr __at (0xE2) XBR1         ;  /* DIGITAL CROSSBAR CONFIGURATION REGISTER 1               */
__sfr __at (0xE3) XBR2         ;  /* DIGITAL CROSSBAR CONFIGURATION REGISTER 2               */
__sfr __at (0xE6) EIE1         ;  /* EXTERNAL INTERRUPT ENABLE 1                             */
__sfr __at (0xE7) EIE2         ;  /* EXTERNAL INTERRUPT ENABLE 2                             */
__sfr __at (0xE8) ADC0CN       ;  /* ADC 0 CONTROL                                           */
__sfr __at (0xE9) PCA0L        ;  /* PCA 0 TIMER - LOW BYTE                                  */
__sfr __at (0xEA) PCA0CPL0     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 0 - LOW BYTE  */
__sfr __at (0xEB) PCA0CPL1     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 1 - LOW BYTE  */
__sfr __at (0xEC) PCA0CPL2     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 2 - LOW BYTE  */
__sfr __at (0xED) PCA0CPL3     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 3 - LOW BYTE  */
__sfr __at (0xEE) PCA0CPL4     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 4 - LOW BYTE  */
__sfr __at (0xEF) RSTSRC       ;  /* RESET SOURCE                                            */
__sfr __at (0xF0) B            ;  /* B REGISTER                                              */
__sfr __at (0xF6) EIP1         ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 1                  */
__sfr __at (0xF7) EIP2         ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 2                  */
__sfr __at (0xF8) SPI0CN       ;  /* SERIAL PERIPHERAL INTERFACE 0 CONTROL                   */
__sfr __at (0xF9) PCA0H        ;  /* PCA 0 TIMER - HIGH BYTE                                 */
__sfr __at (0xFA) PCA0CPH0     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 0 - HIGH BYTE */
__sfr __at (0xFB) PCA0CPH1     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 1 - HIGH BYTE */
__sfr __at (0xFC) PCA0CPH2     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 2 - HIGH BYTE */
__sfr __at (0xFD) PCA0CPH3     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 3 - HIGH BYTE */
__sfr __at (0xFE) PCA0CPH4     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 4 - HIGH BYTE */
__sfr __at (0xFF) WDTCN        ;  /* WATCHDOG TIMER CONTROL                                  */


/*  WORD/DWORD Registers  */

__sfr16 __at (0x8C8A) TMR0     ;  /* TIMER 0 COUNTER                                         */
__sfr16 __at (0x8D8B) TMR1     ;  /* TIMER 1 COUNTER                                         */
__sfr16 __at (0xCDCC) TMR2     ;  /* TIMER 2 COUNTER                                         */
__sfr16 __at (0xCBCA) RCAP2    ;  /* TIMER 2 CAPTURE REGISTER WORD                           */
__sfr16 __at (0x9594) TMR3     ;  /* TIMER 3 COUNTER                                         */
__sfr16 __at (0x9392) TMR3RL   ;  /* TIMER 3 CAPTURE REGISTER WORD                           */
__sfr16 __at (0xBFBE) ADC0     ;  /* ADC 0 DATA WORD                                         */
__sfr16 __at (0xC5C4) ADC0GT   ;  /* ADC 0 GREATER-THAN REGISTER WORD                        */
__sfr16 __at (0xC7C6) ADC0LT   ;  /* ADC 0 LESS-THAN REGISTER WORD                           */
__sfr16 __at (0xD3D2) DAC0     ;  /* DAC 0 REGISTER WORD                                     */
__sfr16 __at (0xD6D5) DAC1     ;  /* DAC 1 REGISTER WORD                                     */
__sfr16 __at (0xF9E9) PCA0     ;  /* PCA COUNTER                                             */
__sfr16 __at (0xFAEA) PCA0CP0  ;  /* PCA CAPTURE 0 WORD                                      */
__sfr16 __at (0xFBEB) PCA0CP1  ;  /* PCA CAPTURE 1 WORD                                      */
__sfr16 __at (0xFCEC) PCA0CP2  ;  /* PCA CAPTURE 2 WORD                                      */
__sfr16 __at (0xFDED) PCA0CP3  ;  /* PCA CAPTURE 3 WORD                                      */
__sfr16 __at (0xFEEE) PCA0CP4  ;  /* PCA CAPTURE 4 WORD                                      */


/*  BIT Registers  */

/*  P0  0x80 */
__sbit __at (0x87) P0_7        ;
__sbit __at (0x86) P0_6        ;
__sbit __at (0x85) P0_5        ;
__sbit __at (0x84) P0_4        ;
__sbit __at (0x83) P0_3        ;
__sbit __at (0x82) P0_2        ;
__sbit __at (0x81) P0_1        ;
__sbit __at (0x80) P0_0        ;

/*  TCON  0x88 */
__sbit __at (0x8F) TF1         ;  /* TIMER 1 OVERFLOW FLAG                                   */
__sbit __at (0x8E) TR1         ;  /* TIMER 1 ON/OFF CONTROL                                  */
__sbit __at (0x8D) TF0         ;  /* TIMER 0 OVERFLOW FLAG                                   */
__sbit __at (0x8C) TR0         ;  /* TIMER 0 ON/OFF CONTROL                                  */
__sbit __at (0x8B) IE1         ;  /* EXT. INTERRUPT 1 EDGE FLAG                              */
__sbit __at (0x8A) IT1         ;  /* EXT. INTERRUPT 1 TYPE                                   */
__sbit __at (0x89) IE0         ;  /* EXT. INTERRUPT 0 EDGE FLAG                              */
__sbit __at (0x88) IT0         ;  /* EXT. INTERRUPT 0 TYPE                                   */

/*  P1  0x90 */
__sbit __at (0x97) P1_7        ;
__sbit __at (0x96) P1_6        ;
__sbit __at (0x95) P1_5        ;
__sbit __at (0x94) P1_4        ;
__sbit __at (0x93) P1_3        ;
__sbit __at (0x92) P1_2        ;
__sbit __at (0x91) P1_1        ;
__sbit __at (0x90) P1_0        ;

/*  SCON  0x98 */
__sbit __at (0x9F) SM0         ;  /* SERIAL MODE CONTROL BIT 0                               */
__sbit __at (0x9E) SM1         ;  /* SERIAL MODE CONTROL BIT 1                               */
__sbit __at (0x9D) SM2         ;  /* MULTIPROCESSOR COMMUNICATION ENABLE                     */
__sbit __at (0x9C) REN         ;  /* RECEIVE ENABLE                                          */
__sbit __at (0x9B) TB8         ;  /* TRANSMIT BIT 8                                          */
__sbit __at (0x9A) RB8         ;  /* RECEIVE BIT 8                                           */
__sbit __at (0x99) TI          ;  /* TRANSMIT INTERRUPT FLAG                                 */
__sbit __at (0x98) RI          ;  /* RECEIVE INTERRUPT FLAG                                  */

/*  P2  0xA0 */
__sbit __at (0xA7) P2_7        ;
__sbit __at (0xA6) P2_6        ;
__sbit __at (0xA5) P2_5        ;
__sbit __at (0xA4) P2_4        ;
__sbit __at (0xA3) P2_3        ;
__sbit __at (0xA2) P2_2        ;
__sbit __at (0xA1) P2_1        ;
__sbit __at (0xA0) P2_0        ;

/*  IE  0xA8 */
__sbit __at (0xAF) EA          ;  /* GLOBAL INTERRUPT ENABLE                                 */
__sbit __at (0xAD) ET2         ;  /* TIMER 2 INTERRUPT ENABLE                                */
__sbit __at (0xAC) ES          ;  /* SERIAL PORT INTERRUPT ENABLE                            */
__sbit __at (0xAB) ET1         ;  /* TIMER 1 INTERRUPT ENABLE                                */
__sbit __at (0xAA) EX1         ;  /* EXTERNAL INTERRUPT 1 ENABLE                             */
__sbit __at (0xA9) ET0         ;  /* TIMER 0 INTERRUPT ENABLE                                */
__sbit __at (0xA8) EX0         ;  /* EXTERNAL INTERRUPT 0 ENABLE                             */

/*  P3  0xB0 */
__sbit __at (0xB7) P3_7        ;
__sbit __at (0xB6) P3_6        ;
__sbit __at (0xB5) P3_5        ;
__sbit __at (0xB4) P3_4        ;
__sbit __at (0xB3) P3_3        ;
__sbit __at (0xB2) P3_2        ;
__sbit __at (0xB1) P3_1        ;
__sbit __at (0xB0) P3_0        ;

/*  IP  0xB8 */
__sbit __at (0xBD) PT2         ;  /* TIMER 2 PRIORITY                                        */
__sbit __at (0xBC) PS          ;  /* SERIAL PORT PRIORITY                                    */
__sbit __at (0xBB) PT1         ;  /* TIMER 1 PRIORITY                                        */
__sbit __at (0xBA) PX1         ;  /* EXTERNAL INTERRUPT 1 PRIORITY                           */
__sbit __at (0xB9) PT0         ;  /* TIMER 0 PRIORITY                                        */
__sbit __at (0xB8) PX0         ;  /* EXTERNAL INTERRUPT 0 PRIORITY                           */

/*  SMB0CN  0xC0 */
__sbit __at (0xC7) BUSY        ;  /* SMBUS 0 BUSY                                            */
__sbit __at (0xC6) ENSMB       ;  /* SMBUS 0 ENABLE                                          */
__sbit __at (0xC5) STA         ;  /* SMBUS 0 START FLAG                                      */
__sbit __at (0xC4) STO         ;  /* SMBUS 0 STOP FLAG                                       */
__sbit __at (0xC3) SI          ;  /* SMBUS 0 INTERRUPT PENDING FLAG                          */
__sbit __at (0xC2) AA          ;  /* SMBUS 0 ASSERT/ACKNOWLEDGE FLAG                         */
__sbit __at (0xC1) SMBFTE      ;  /* SMBUS 0 FREE TIMER ENABLE                               */
__sbit __at (0xC0) SMBTOE      ;  /* SMBUS 0 TIMEOUT ENABLE                                  */

/*  T2CON  0xC8 */
__sbit __at (0xCF) TF2         ;  /* TIMER 2 OVERFLOW FLAG                                   */
__sbit __at (0xCE) EXF2        ;  /* EXTERNAL FLAG                                           */
__sbit __at (0xCD) RCLK        ;  /* RECEIVE CLOCK FLAG                                      */
__sbit __at (0xCC) TCLK        ;  /* TRANSMIT CLOCK FLAG                                     */
__sbit __at (0xCB) EXEN2       ;  /* TIMER 2 EXTERNAL ENABLE FLAG                            */
__sbit __at (0xCA) TR2         ;  /* TIMER 2 ON/OFF CONTROL                                  */
__sbit __at (0xC9) CT2         ;  /* TIMER OR COUNTER SELECT                                 */
__sbit __at (0xC8) CPRL2       ;  /* CAPTURE OR RELOAD SELECT                                */

/*  PSW  0xD0 */
__sbit __at (0xD7) CY          ;  /* CARRY FLAG                                              */
__sbit __at (0xD6) AC          ;  /* AUXILIARY CARRY FLAG                                    */
__sbit __at (0xD5) F0          ;  /* USER FLAG 0                                             */
__sbit __at (0xD4) RS1         ;  /* REGISTER BANK SELECT 1                                  */
__sbit __at (0xD3) RS0         ;  /* REGISTER BANK SELECT 0                                  */
__sbit __at (0xD2) OV          ;  /* OVERFLOW FLAG                                           */
__sbit __at (0xD1) F1          ;  /* USER FLAG 1                                             */
__sbit __at (0xD0) P           ;  /* ACCUMULATOR PARITY FLAG                                 */

/*  PCA0CN  0xD8H */
__sbit __at (0xDF) CF          ;  /* PCA 0 COUNTER OVERFLOW FLAG                             */
__sbit __at (0xDE) CR          ;  /* PCA 0 COUNTER RUN CONTROL BIT                           */
__sbit __at (0xDC) CCF4        ;  /* PCA 0 MODULE 4 INTERRUPT FLAG                           */
__sbit __at (0xDB) CCF3        ;  /* PCA 0 MODULE 3 INTERRUPT FLAG                           */
__sbit __at (0xDA) CCF2        ;  /* PCA 0 MODULE 2 INTERRUPT FLAG                           */
__sbit __at (0xD9) CCF1        ;  /* PCA 0 MODULE 1 INTERRUPT FLAG                           */
__sbit __at (0xD8) CCF0        ;  /* PCA 0 MODULE 0 INTERRUPT FLAG                           */

/*  ADC0CN  0xE8H */
__sbit __at (0xEF) AD0EN       ;  /* ADC 0 ENABLE                                            */
__sbit __at (0xEE) AD0TM       ;  /* ADC 0 TRACK MODE                                        */
__sbit __at (0xED) AD0INT      ;  /* ADC 0 CONVERISION COMPLETE INTERRUPT FLAG               */
__sbit __at (0xEC) AD0BUSY     ;  /* ADC 0 BUSY FLAG                                         */
__sbit __at (0xEB) ADSTM1      ;  /* ADC 0 START OF CONVERSION MODE BIT 1                    */
__sbit __at (0xEA) ADSTM0      ;  /* ADC 0 START OF CONVERSION MODE BIT 0                    */
__sbit __at (0xE9) AD0WINT     ;  /* ADC 0 WINDOW COMPARE INTERRUPT FLAG                     */
__sbit __at (0xE8) ADLJST      ;  /* ADC 0 RIGHT JUSTIFY DATA BIT                            */

/*  SPI0CN  0xF8H */
__sbit __at (0xFF) SPIF        ;  /* SPI 0 INTERRUPT FLAG                                    */
__sbit __at (0xFE) WCOL        ;  /* SPI 0 WRITE COLLISION FLAG                              */
__sbit __at (0xFD) MODF        ;  /* SPI 0 MODE FAULT FLAG                                   */
__sbit __at (0xFC) RXOVRN      ;  /* SPI 0 RX OVERRUN FLAG                                   */
__sbit __at (0xFB) TXBSY       ;  /* SPI 0 TX BUSY FLAG                                      */
__sbit __at (0xFA) SLVSEL      ;  /* SPI 0 SLAVE SELECT                                      */
__sbit __at (0xF9) MSTEN       ;  /* SPI 0 MASTER ENABLE                                     */
__sbit __at (0xF8) SPIEN       ;  /* SPI 0 SPI ENABLE                                        */


/* Predefined SFR Bit Masks */

#define PCON_IDLE         0x01    /* PCON                                */
#define PCON_STOP         0x02    /* PCON                                */
#define TF3               0x80    /* TMR3CN                              */
#define CPFIF             0x10    /* CPTnCN                              */
#define CPRIF             0x20    /* CPTnCN                              */
#define CPOUT             0x40    /* CPTnCN                              */
#define ECCF              0x01    /* PCA0CPMn                            */
#define PWM               0x02    /* PCA0CPMn                            */
#define TOG               0x04    /* PCA0CPMn                            */
#define MAT               0x08    /* PCA0CPMn                            */
#define CAPN              0x10    /* PCA0CPMn                            */
#define CAPP              0x20    /* PCA0CPMn                            */
#define ECOM              0x40    /* PCA0CPMn                            */

#endif
/*---------------------------------------------------------------------------
   C8051F200.h - Register Declarations for the Cygnal/SiLabs C8051F2xx
   Processor Range

   Copyright (C) 2006, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef C8051F200_H
#define C8051F200_H


/*  BYTE Registers  */
__sfr __at (0x80) P0           ;  /* PORT 0                                            */
__sfr __at (0x81) SP           ;  /* STACK POINTER                                     */
__sfr __at (0x82) DPL          ;  /* DATA POINTER - LOW BYTE                           */
__sfr __at (0x83) DPH          ;  /* DATA POINTER - HIGH BYTE                          */
__sfr __at (0x87) PCON         ;  /* POWER Control                                     */
__sfr __at (0x88) TCON         ;  /* TIMER Control                                     */
__sfr __at (0x89) TMOD         ;  /* TIMER MODE                                        */
__sfr __at (0x8A) TL0          ;  /* TIMER 0 - LOW BYTE                                */
__sfr __at (0x8B) TL1          ;  /* TIMER 1 - LOW BYTE                                */
__sfr __at (0x8C) TH0          ;  /* TIMER 0 - HIGH BYTE                               */
__sfr __at (0x8D) TH1          ;  /* TIMER 1 - HIGH BYTE                               */
__sfr __at (0x8E) CKCON        ;  /* CLOCK Control                                     */
__sfr __at (0x8F) PSCTL        ;  /* PROGRAM STORE R/W Control                         */
__sfr __at (0x90) P1           ;  /* PORT 1                                            */
__sfr __at (0x98) SCON         ;  /* SERIAL PORT Control                               */
__sfr __at (0x99) SBUF         ;  /* SERIAL PORT BUFFER                                */
__sfr __at (0x9A) SPI0CFG      ;  /* SERIAL PERIPHERAL INTERFACE 0 Configuration       */
__sfr __at (0x9B) SPI0DAT      ;  /* SERIAL PERIPHERAL INTERFACE 0 DATA                */
__sfr __at (0x9D) SPI0CKR      ;  /* SERIAL PERIPHERAL INTERFACE 0 CLOCK RATE Control  */
__sfr __at (0x9E) CPT0CN       ;  /* COMPARATOR 0 Control                              */
__sfr __at (0x9F) CPT1CN       ;  /* COMPARATOR 1 Control                              */
__sfr __at (0xA0) P2           ;  /* PORT 2                                            */
__sfr __at (0xA4) PRT0CF       ;  /* PORT 0 OUTPUT MODE Configuration                  */
__sfr __at (0xA5) PRT1CF       ;  /* PORT 1 OUTPUT MODE Configuration                  */
__sfr __at (0xA6) PRT2CF       ;  /* PORT 2 OUTPUT MODE Configuration                  */
__sfr __at (0xA7) PRT3CF       ;  /* PORT 3 OUTPUT MODE Configuration                  */
__sfr __at (0xA8) IE           ;  /* Interrupt Enable                                  */
__sfr __at (0xAD) SWCINT       ;  /* SOFTWARE-Controlled Interrupt FLAGS               */
__sfr __at (0xAD) PRT1IF       ;  /* SOFTWARE-Controlled Interrupt FLAGS (LEGACY NAME) */
__sfr __at (0xAF) EMI0CN       ;  /* EXTERNAL MEMORY INTERFACE Control (F206/F226/F236)*/
__sfr __at (0xAF) _XPAGE       ;  /* XDATA/PDATA PAGE                                  */
__sfr __at (0xB0) P3           ;  /* PORT 3                                            */
__sfr __at (0xB1) OSCXCN       ;  /* EXTERNAL OSCILLATOR Control                       */
__sfr __at (0xB2) OSCICN       ;  /* INTERNAL OSCILLATOR Control                       */
__sfr __at (0xB6) FLSCL        ;  /* FLASH MEMORY TIMING PRESCALER                     */
__sfr __at (0xB7) FLACL        ;  /* FLASH ACESS LIMIT                                 */
__sfr __at (0xB8) IP           ;  /* Interrupt Priority                                */
__sfr __at (0xBB) AMX0SL       ;  /* ADC 0 MUX CHANNEL SELECTION    (Not on F230/1/6)  */
__sfr __at (0xBC) ADC0CF       ;  /* ADC 0 Configuration            (Not on F230/1/6)  */
__sfr __at (0xBE) ADC0L        ;  /* ADC 0 Data LOW                 ( F206 only )      */
__sfr __at (0xBF) ADC0H        ;  /* ADC 0 Data High                                   */
__sfr __at (0xC4) ADC0GTL      ;  /* ADC 0 GREATER-THAN Register LOW( F206 only )      */
__sfr __at (0xC5) ADC0GTH      ;  /* ADC 0 GREATER-THAN Register    (Not on F230/1/6)  */
__sfr __at (0xC6) ADC0LTL      ;  /* ADC 0 LESS-THAN Register LOW   ( F206 only )      */
__sfr __at (0xC7) ADC0LTH      ;  /* ADC 0 LESS-THAN Register       (Not on F230/1/6)  */
__sfr __at (0xC8) T2CON        ;  /* TIMER 2 Control                                   */
__sfr __at (0xCA) RCAP2L       ;  /* TIMER 2 CAPTURE Register - LOW BYTE               */
__sfr __at (0xCB) RCAP2H       ;  /* TIMER 2 CAPTURE Register - HIGH BYTE              */
__sfr __at (0xCC) TL2          ;  /* TIMER 2 - LOW BYTE                                */
__sfr __at (0xCD) TH2          ;  /* TIMER 2 - HIGH BYTE                               */
__sfr __at (0xD0) PSW          ;  /* PROGRAM STATUS WORD                               */
__sfr __at (0xD1) REF0CN       ;  /* VOLTAGE REFERENCE 0 Control                       */
__sfr __at (0xE0) ACC          ;  /* ACCUMULATOR                                       */
__sfr __at (0xE1) PRT0MX       ;  /* PORT MUX Configuration Register 0                 */
__sfr __at (0xE2) PRT1MX       ;  /* PORT MUX Configuration Register 1                 */
__sfr __at (0xE3) PRT2MX       ;  /* PORT MUX Configuration Register 2                 */
__sfr __at (0xE6) EIE1         ;  /* EXTERNAL Interrupt Enable 1                       */
__sfr __at (0xE7) EIE2         ;  /* EXTERNAL Interrupt Enable 2                       */
__sfr __at (0xE8) ADC0CN       ;  /* ADC 0 Control                   (Not on F230/1/6) */
__sfr __at (0xEF) RSTSRC       ;  /* RESET SOURCE                                      */
__sfr __at (0xF0) B            ;  /* B Register                                        */
__sfr __at (0xF1) P0MODE       ;  /* PORT 0 INPUT MODE Configuration                   */
__sfr __at (0xF2) P1MODE       ;  /* PORT 1 INPUT MODE Configuration                   */
__sfr __at (0xF3) P2MODE       ;  /* PORT 2 INPUT MODE Configuration                   */
__sfr __at (0xF4) P3MODE       ;  /* PORT 3 INPUT MODE Configuration (Not on F221/F231)*/
__sfr __at (0xF6) EIP1         ;  /* EXTERNAL Interrupt Priority Register 1            */
__sfr __at (0xF7) EIP2         ;  /* EXTERNAL Interrupt Priority Register 2            */
__sfr __at (0xF8) SPI0CN       ;  /* SERIAL PERIPHERAL INTERFACE 0 Control             */
__sfr __at (0xFF) WDTCN        ;  /* WATCHDOG TIMER Control                            */


/*  WORD/DWORD Registers  */

__sfr16 __at (0x8C8A) TMR0     ;  /* TIMER 0 COUNTER                                   */
__sfr16 __at (0x8D8B) TMR1     ;  /* TIMER 1 COUNTER                                   */
__sfr16 __at (0xCDCC) TMR2     ;  /* TIMER 2 COUNTER                                   */
__sfr16 __at (0xCBCA) RCAP2    ;  /* TIMER 2 CAPTURE REGISTER WORD                     */
__sfr16 __at (0xBFBE) ADC0     ;  /* ADC 0 DATA WORD                                   */
__sfr16 __at (0xC5C4) ADC0GT   ;  /* ADC 0 GREATER-THAN REGISTER WORD                  */
__sfr16 __at (0xC7C6) ADC0LT   ;  /* ADC 0 LESS-THAN REGISTER WORD                     */


/*  BIT Registers  */

/*  P0  0x80 */
__sbit __at (0x80) P0_0        ;
__sbit __at (0x81) P0_1        ;
__sbit __at (0x82) P0_2        ;
__sbit __at (0x83) P0_3        ;
__sbit __at (0x84) P0_4        ; /* Port0 I/O Bits */
__sbit __at (0x85) P0_5        ;
__sbit __at (0x86) P0_6        ;
__sbit __at (0x87) P0_7        ;

/*  TCON  0x88 */
__sbit __at (0x88) IT0         ; /* EXT. Interrupt 0 TYPE                              */
__sbit __at (0x89) IE0         ; /* EXT. Interrupt 0 EDGE FLAG                         */
__sbit __at (0x8A) IT1         ; /* EXT. Interrupt 1 TYPE                              */
__sbit __at (0x8B) IE1         ; /* EXT. Interrupt 1 EDGE FLAG                         */
__sbit __at (0x8C) TR0         ; /* TIMER 0 ON/OFF Control                             */
__sbit __at (0x8D) TF0         ; /* TIMER 0 Overflow FLAG                              */
__sbit __at (0x8E) TR1         ; /* TIMER 1 ON/OFF Control                             */
__sbit __at (0x8F) TF1         ; /* TIMER 1 Overflow FLAG                              */

/*  P1  0x90 */
__sbit __at (0x90) P1_0        ;
__sbit __at (0x91) P1_1        ;
__sbit __at (0x92) P1_2        ;
__sbit __at (0x93) P1_3        ;
__sbit __at (0x94) P1_4        ; /* Port1 I/O Bits */
__sbit __at (0x95) P1_5        ;
__sbit __at (0x96) P1_6        ;
__sbit __at (0x97) P1_7        ;

/*  SCON  0x98 */
__sbit __at (0x98) RI          ; /* RECEIVE Interrupt FLAG                             */
__sbit __at (0x99) TI          ; /* TRANSMIT Interrupt FLAG                            */
__sbit __at (0x9A) RB8         ; /* RECEIVE BIT 8                                      */
__sbit __at (0x9B) TB8         ; /* TRANSMIT BIT 8                                     */
__sbit __at (0x9C) REN         ; /* RECEIVE Enable                                     */
__sbit __at (0x9D) SM2         ; /* MULTIPROCESSOR COMMUNICATION Enable                */
__sbit __at (0x9E) SM1         ; /* SERIAL MODE Control BIT 1                          */
__sbit __at (0x9F) SM0         ; /* SERIAL MODE Control BIT 0                          */

/*  P2  0xA0 */
__sbit __at (0xA0) P2_0        ;
__sbit __at (0xA1) P2_1        ;
__sbit __at (0xA2) P2_2        ;
__sbit __at (0xA3) P2_3        ;
__sbit __at (0xA4) P2_4        ; /* Port2 I/O Bits */
__sbit __at (0xA5) P2_5        ;
__sbit __at (0xA6) P2_6        ;
__sbit __at (0xA7) P2_7        ;

/*  IE  0xA8 */
__sbit __at (0xA8) EX0         ; /* EXTERNAL Interrupt 0 Enable                        */
__sbit __at (0xA9) ET0         ; /* TIMER 0 Interrupt Enable                           */
__sbit __at (0xAA) EX1         ; /* EXTERNAL Interrupt 1 Enable                        */
__sbit __at (0xAB) ET1         ; /* TIMER 1 Interrupt Enable                           */
__sbit __at (0xAC) ES          ; /* SERIAL PORT Interrupt Enable                       */
__sbit __at (0xAD) ET2         ; /* TIMER 2 Interrupt Enable                           */
//-------------                  /* Bit 6 not used                                     */
__sbit __at (0xAF) EA          ; /* GLOBAL Interrupt Enable                            */

/*  P2  0xB0 */
__sbit __at (0xB0) P3_0        ;
__sbit __at (0xB1) P3_1        ;
__sbit __at (0xB2) P3_2        ;
__sbit __at (0xB3) P3_3        ;
__sbit __at (0xB4) P3_4        ; /* Port3 I/O Bits */
__sbit __at (0xB5) P3_5        ;
__sbit __at (0xB6) P3_6        ;
__sbit __at (0xB7) P3_7        ;

/*  IP  0xB8 */
__sbit __at (0xB8) PX0         ; /* EXTERNAL Interrupt 0 Priority                      */
__sbit __at (0xB9) PT0         ; /* TIMER 0 Priority                                   */
__sbit __at (0xBA) PX1         ; /* EXTERNAL Interrupt 1 Priority                      */
__sbit __at (0xBB) PT1         ; /* TIMER 1 Priority                                   */
__sbit __at (0xBC) PS          ; /* SERIAL PORT Priority                               */
__sbit __at (0xBD) PT2         ; /* TIMER 2 Priority                                   */
//-------------                  /* Bit 6 not used                                     */
//-------------                  /* Bit 7 not used                                     */

/*  T2CON  0xC8 */
__sbit __at (0xC8) CPRL2       ; /* CAPTURE OR RELOAD SELECT                           */
__sbit __at (0xC9) CT2         ; /* TIMER OR COUNTER SELECT                            */
__sbit __at (0xCA) TR2         ; /* TIMER 2 ON/OFF Control                             */
__sbit __at (0xCB) EXEN2       ; /* TIMER 2 EXTERNAL Enable FLAG                       */
__sbit __at (0xCC) TCLK        ; /* TRANSMIT CLOCK FLAG                                */
__sbit __at (0xCD) RCLK        ; /* RECEIVE CLOCK FLAG                                 */
__sbit __at (0xCE) EXF2        ; /* EXTERNAL FLAG                                      */
__sbit __at (0xCF) TF2         ; /* TIMER 2 Overflow FLAG                              */

/*  PSW  0xD0 */
__sbit __at (0xD0) P           ; /* ACCUMULATOR PARITY FLAG                            */
__sbit __at (0xD1) F1          ; /* USER FLAG 1                                        */
__sbit __at (0xD2) OV          ; /* Overflow FLAG                                      */
__sbit __at (0xD3) RS0         ; /* Register BANK SELECT 0                             */
__sbit __at (0xD4) RS1         ; /* Register BANK SELECT 1                             */
__sbit __at (0xD5) F0          ; /* USER FLAG 0                                        */
__sbit __at (0xD6) AC          ; /* AUXILIARY CARRY FLAG                               */
__sbit __at (0xD7) CY          ; /* CARRY FLAG                                         */

/* ADC0CN 0xE8 */
__sbit __at (0xE8) ADLJST      ; /* Left Justify Data (F206 only)                      */
__sbit __at (0xE9) ADWINT      ; /* WINDOW COMPARE Interrupt FLAG                      */
__sbit __at (0xEA) ADSTM0      ; /* START OF CONVERSION MODE BIT 0                     */
__sbit __at (0xEB) ADSTM1      ; /* START OF CONVERSION MODE BIT 1                     */
__sbit __at (0xEC) ADBUSY      ; /* BUSY FLAG                                          */
__sbit __at (0xED) ADCINT      ; /* CONVERISION COMPLETE Interrupt FLAG                */
__sbit __at (0xEE) ADCTM       ; /* TRACK MODE                                         */
__sbit __at (0xEF) ADCEN       ; /* Enable                                             */

/* SPI0CN 0xF8 */
__sbit __at (0xF8) SPIEN       ; /* SPI Enable                                         */
__sbit __at (0xF9) MSTEN       ; /* MASTER Enable                                      */
__sbit __at (0xFA) SLVSEL      ; /* SLAVE SELECT                                       */
__sbit __at (0xFB) TXBSY       ; /* TX BUSY FLAG                                       */
__sbit __at (0xFC) RXOVRN      ; /* RX OVERRUN FLAG                                    */
__sbit __at (0xFD) MODF        ; /* MODE FAULT FLAG                                    */
__sbit __at (0xFE) WCOL        ; /* WRITE COLLISION FLAG                               */
__sbit __at (0xFF) SPIF        ; /* Interrupt FLAG                                     */

#endif
/*-------------------------------------------------------------------------
   C8051F020.h - Register Declarations for the Cygnal/SiLabs C8051F02x
   Processor Range

   Copyright (C) 2004, Maarten Brock, sourceforge.brock@dse.nl

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef C8051F020_H
#define C8051F020_H


/*  BYTE Registers  */
__sfr __at (0x80) P0           ;  /* PORT 0                                                  */
__sfr __at (0x81) SP           ;  /* STACK POINTER                                           */
__sfr __at (0x82) DPL          ;  /* DATA POINTER - LOW BYTE                                 */
__sfr __at (0x83) DPH          ;  /* DATA POINTER - HIGH BYTE                                */
__sfr __at (0x84) P4           ;  /* PORT 4                                                  */
__sfr __at (0x85) P5           ;  /* PORT 5                                                  */
__sfr __at (0x86) P6           ;  /* PORT 6                                                  */
__sfr __at (0x87) PCON         ;  /* POWER CONTROL                                           */
__sfr __at (0x88) TCON         ;  /* TIMER CONTROL                                           */
__sfr __at (0x89) TMOD         ;  /* TIMER MODE                                              */
__sfr __at (0x8A) TL0          ;  /* TIMER 0 - LOW BYTE                                      */
__sfr __at (0x8B) TL1          ;  /* TIMER 1 - LOW BYTE                                      */
__sfr __at (0x8C) TH0          ;  /* TIMER 0 - HIGH BYTE                                     */
__sfr __at (0x8D) TH1          ;  /* TIMER 1 - HIGH BYTE                                     */
__sfr __at (0x8E) CKCON        ;  /* CLOCK CONTROL                                           */
__sfr __at (0x8F) PSCTL        ;  /* PROGRAM STORE R/W CONTROL                               */
__sfr __at (0x90) P1           ;  /* PORT 1                                                  */
__sfr __at (0x91) TMR3CN       ;  /* TIMER 3 CONTROL                                         */
__sfr __at (0x92) TMR3RLL      ;  /* TIMER 3 RELOAD REGISTER - LOW BYTE                      */
__sfr __at (0x93) TMR3RLH      ;  /* TIMER 3 RELOAD REGISTER - HIGH BYTE                     */
__sfr __at (0x94) TMR3L        ;  /* TIMER 3 - LOW BYTE                                      */
__sfr __at (0x95) TMR3H        ;  /* TIMER 3 - HIGH BYTE                                     */
__sfr __at (0x96) P7           ;  /* PORT 7                                                  */
__sfr __at (0x98) SCON         ;  /* UART0 CONTROL                                           */
__sfr __at (0x98) SCON0        ;  /* UART0 CONTROL                                           */
__sfr __at (0x99) SBUF         ;  /* UART0 BUFFER                                            */
__sfr __at (0x99) SBUF0        ;  /* UART0 BUFFER                                            */
__sfr __at (0x9A) SPI0CFG      ;  /* SERIAL PERIPHERAL INTERFACE 0 CONFIGURATION             */
__sfr __at (0x9B) SPI0DAT      ;  /* SERIAL PERIPHERAL INTERFACE 0 DATA                      */
__sfr __at (0x9C) ADC1         ;  /* ADC 1 DATA                                              */
__sfr __at (0x9D) SPI0CKR      ;  /* SERIAL PERIPHERAL INTERFACE 0 CLOCK RATE CONTROL        */
__sfr __at (0x9E) CPT0CN       ;  /* COMPARATOR 0 CONTROL                                    */
__sfr __at (0x9F) CPT1CN       ;  /* COMPARATOR 1 CONTROL                                    */
__sfr __at (0xA0) P2           ;  /* PORT 2                                                  */
__sfr __at (0xA1) EMI0TC       ;  /* External Memory Timing Control                          */
__sfr __at (0xA3) EMI0CF       ;  /* EMIF CONFIGURATION                                      */
__sfr __at (0xA4) PRT0CF       ;  /* PORT 0 CONFIGURATION                                    */
__sfr __at (0xA4) P0MDOUT      ;  /* PORT 0 OUTPUT MODE CONFIGURATION                        */
__sfr __at (0xA5) PRT1CF       ;  /* PORT 1 CONFIGURATION                                    */
__sfr __at (0xA5) P1MDOUT      ;  /* PORT 1 OUTPUT MODE CONFIGURATION                        */
__sfr __at (0xA6) PRT2CF       ;  /* PORT 2 CONFIGURATION                                    */
__sfr __at (0xA6) P2MDOUT      ;  /* PORT 2 OUTPUT MODE CONFIGURATION                        */
__sfr __at (0xA7) PRT3CF       ;  /* PORT 3 CONFIGURATION                                    */
__sfr __at (0xA7) P3MDOUT      ;  /* PORT 3 OUTPUT MODE CONFIGURATION                        */
__sfr __at (0xA8) IE           ;  /* INTERRUPT ENABLE                                        */
__sfr __at (0xA9) SADDR0       ;  /* UART0 Slave Address                                     */
__sfr __at (0xAA) ADC1CN       ;  /* ADC 1 CONTROL                                           */
__sfr __at (0xAB) ADC1CF       ;  /* ADC 1 CONFIGURATION                                     */
__sfr __at (0xAC) AMX1SL       ;  /* ADC 1 MUX CHANNEL SELECTION                             */
__sfr __at (0xAD) P3IF         ;  /* PORT 3 EXTERNAL INTERRUPT FLAGS                         */
__sfr __at (0xAE) SADEN1       ;  /* UART1 Slave Address Enable                              */
__sfr __at (0xAF) EMI0CN       ;  /* EXTERNAL MEMORY INTERFACE CONTROL                       */
__sfr __at (0xAF) _XPAGE       ;  /* XDATA/PDATA PAGE                                        */
__sfr __at (0xB0) P3           ;  /* PORT 3                                                  */
__sfr __at (0xB1) OSCXCN       ;  /* EXTERNAL OSCILLATOR CONTROL                             */
__sfr __at (0xB2) OSCICN       ;  /* INTERNAL OSCILLATOR CONTROL                             */
__sfr __at (0xB5) P74OUT       ;  /* PORT 4 THROUGH 7 OUTPUT MODE CONFIGURATION              */
__sfr __at (0xB6) FLSCL        ;  /* FLASH MEMORY TIMING PRESCALER                           */
__sfr __at (0xB7) FLACL        ;  /* FLASH ACESS LIMIT                                       */
__sfr __at (0xB8) IP           ;  /* INTERRUPT PRIORITY                                      */
__sfr __at (0xB9) SADEN0       ;  /* UART0 Slave Address Enable                              */
__sfr __at (0xBA) AMX0CF       ;  /* ADC 0 MUX CONFIGURATION                                 */
__sfr __at (0xBB) AMX0SL       ;  /* ADC 0 MUX CHANNEL SELECTION                             */
__sfr __at (0xBC) ADC0CF       ;  /* ADC 0 CONFIGURATION                                     */
__sfr __at (0xBD) P1MDIN       ;  /* PORT 1 Input Mode                                       */
__sfr __at (0xBE) ADC0L        ;  /* ADC 0 DATA - LOW BYTE                                   */
__sfr __at (0xBF) ADC0H        ;  /* ADC 0 DATA - HIGH BYTE                                  */
__sfr __at (0xC0) SMB0CN       ;  /* SMBUS 0 CONTROL                                         */
__sfr __at (0xC1) SMB0STA      ;  /* SMBUS 0 STATUS                                          */
__sfr __at (0xC2) SMB0DAT      ;  /* SMBUS 0 DATA                                            */
__sfr __at (0xC3) SMB0ADR      ;  /* SMBUS 0 SLAVE ADDRESS                                   */
__sfr __at (0xC4) ADC0GTL      ;  /* ADC 0 GREATER-THAN REGISTER - LOW BYTE                  */
__sfr __at (0xC5) ADC0GTH      ;  /* ADC 0 GREATER-THAN REGISTER - HIGH BYTE                 */
__sfr __at (0xC6) ADC0LTL      ;  /* ADC 0 LESS-THAN REGISTER - LOW BYTE                     */
__sfr __at (0xC7) ADC0LTH      ;  /* ADC 0 LESS-THAN REGISTER - HIGH BYTE                    */
__sfr __at (0xC8) T2CON        ;  /* TIMER 2 CONTROL                                         */
__sfr __at (0xC9) T4CON        ;  /* TIMER 4 CONTROL                                         */
__sfr __at (0xCA) RCAP2L       ;  /* TIMER 2 CAPTURE REGISTER - LOW BYTE                     */
__sfr __at (0xCB) RCAP2H       ;  /* TIMER 2 CAPTURE REGISTER - HIGH BYTE                    */
__sfr __at (0xCC) TL2          ;  /* TIMER 2 - LOW BYTE                                      */
__sfr __at (0xCD) TH2          ;  /* TIMER 2 - HIGH BYTE                                     */
__sfr __at (0xCF) SMB0CR       ;  /* SMBUS 0 CLOCK RATE                                      */
__sfr __at (0xD0) PSW          ;  /* PROGRAM STATUS WORD                                     */
__sfr __at (0xD1) REF0CN       ;  /* VOLTAGE REFERENCE 0 CONTROL                             */
__sfr __at (0xD2) DAC0L        ;  /* DAC 0 REGISTER - LOW BYTE                               */
__sfr __at (0xD3) DAC0H        ;  /* DAC 0 REGISTER - HIGH BYTE                              */
__sfr __at (0xD4) DAC0CN       ;  /* DAC 0 CONTROL                                           */
__sfr __at (0xD5) DAC1L        ;  /* DAC 1 REGISTER - LOW BYTE                               */
__sfr __at (0xD6) DAC1H        ;  /* DAC 1 REGISTER - HIGH BYTE                              */
__sfr __at (0xD7) DAC1CN       ;  /* DAC 1 CONTROL                                           */
__sfr __at (0xD8) PCA0CN       ;  /* PCA 0 COUNTER CONTROL                                   */
__sfr __at (0xD9) PCA0MD       ;  /* PCA 0 COUNTER MODE                                      */
__sfr __at (0xDA) PCA0CPM0     ;  /* CONTROL REGISTER FOR PCA 0 MODULE 0                     */
__sfr __at (0xDB) PCA0CPM1     ;  /* CONTROL REGISTER FOR PCA 0 MODULE 1                     */
__sfr __at (0xDC) PCA0CPM2     ;  /* CONTROL REGISTER FOR PCA 0 MODULE 2                     */
__sfr __at (0xDD) PCA0CPM3     ;  /* CONTROL REGISTER FOR PCA 0 MODULE 3                     */
__sfr __at (0xDE) PCA0CPM4     ;  /* CONTROL REGISTER FOR PCA 0 MODULE 4                     */
__sfr __at (0xE0) ACC          ;  /* ACCUMULATOR                                             */
__sfr __at (0xE1) XBR0         ;  /* DIGITAL CROSSBAR CONFIGURATION REGISTER 0               */
__sfr __at (0xE2) XBR1         ;  /* DIGITAL CROSSBAR CONFIGURATION REGISTER 1               */
__sfr __at (0xE3) XBR2         ;  /* DIGITAL CROSSBAR CONFIGURATION REGISTER 2               */
__sfr __at (0xE4) RCAP4L       ;  /* TIMER 4 CAPTURE REGISTER - LOW BYTE                     */
__sfr __at (0xE5) RCAP4H       ;  /* TIMER 4 CAPTURE REGISTER - HIGH BYTE                    */
__sfr __at (0xE6) EIE1         ;  /* EXTERNAL INTERRUPT ENABLE 1                             */
__sfr __at (0xE7) EIE2         ;  /* EXTERNAL INTERRUPT ENABLE 2                             */
__sfr __at (0xE8) ADC0CN       ;  /* ADC 0 CONTROL                                           */
__sfr __at (0xE9) PCA0L        ;  /* PCA 0 TIMER - LOW BYTE                                  */
__sfr __at (0xEA) PCA0CPL0     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 0 - LOW BYTE  */
__sfr __at (0xEB) PCA0CPL1     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 1 - LOW BYTE  */
__sfr __at (0xEC) PCA0CPL2     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 2 - LOW BYTE  */
__sfr __at (0xED) PCA0CPL3     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 3 - LOW BYTE  */
__sfr __at (0xEE) PCA0CPL4     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 4 - LOW BYTE  */
__sfr __at (0xEF) RSTSRC       ;  /* RESET SOURCE                                            */
__sfr __at (0xF0) B            ;  /* B REGISTER                                              */
__sfr __at (0xF1) SCON1        ;  /* UART1 CONTROL                                           */
__sfr __at (0xF2) SBUF1        ;  /* UART1 DATA                                              */
__sfr __at (0xF3) SADDR1       ;  /* UART1 Slave Address                                     */
__sfr __at (0xF4) TL4          ;  /* TIMER 4 DATA - LOW BYTE                                 */
__sfr __at (0xF5) TH4          ;  /* TIMER 4 DATA - HIGH BYTE                                */
__sfr __at (0xF6) EIP1         ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 1                  */
__sfr __at (0xF7) EIP2         ;  /* EXTERNAL INTERRUPT PRIORITY REGISTER 2                  */
__sfr __at (0xF8) SPI0CN       ;  /* SERIAL PERIPHERAL INTERFACE 0 CONTROL                   */
__sfr __at (0xF9) PCA0H        ;  /* PCA 0 TIMER - HIGH BYTE                                 */
__sfr __at (0xFA) PCA0CPH0     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 0 - HIGH BYTE */
__sfr __at (0xFB) PCA0CPH1     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 1 - HIGH BYTE */
__sfr __at (0xFC) PCA0CPH2     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 2 - HIGH BYTE */
__sfr __at (0xFD) PCA0CPH3     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 3 - HIGH BYTE */
__sfr __at (0xFE) PCA0CPH4     ;  /* CAPTURE/COMPARE REGISTER FOR PCA 0 MODULE 4 - HIGH BYTE */
__sfr __at (0xFF) WDTCN        ;  /* WATCHDOG TIMER CONTROL                                  */


/*  WORD/DWORD Registers  */

__sfr16 __at (0x8C8A) TMR0     ;  /* TIMER 0 COUNTER                                         */
__sfr16 __at (0x8D8B) TMR1     ;  /* TIMER 1 COUNTER                                         */
__sfr16 __at (0xCDCC) TMR2     ;  /* TIMER 2 COUNTER                                         */
__sfr16 __at (0xCBCA) RCAP2    ;  /* TIMER 2 CAPTURE REGISTER WORD                           */
__sfr16 __at (0x9594) TMR3     ;  /* TIMER 3 COUNTER                                         */
__sfr16 __at (0x9392) TMR3RL   ;  /* TIMER 3 CAPTURE REGISTER WORD                           */
__sfr16 __at (0xF5F4) TMR4     ;  /* TIMER 4 COUNTER                                         */
__sfr16 __at (0xE5E4) RCAP4    ;  /* TIMER 4 CAPTURE REGISTER WORD                           */
__sfr16 __at (0xBFBE) ADC0     ;  /* ADC 0 DATA WORD                                         */
__sfr16 __at (0xC5C4) ADC0GT   ;  /* ADC 0 GREATER-THAN REGISTER WORD                        */
__sfr16 __at (0xC7C6) ADC0LT   ;  /* ADC 0 LESS-THAN REGISTER WORD                           */
__sfr16 __at (0xD3D2) DAC0     ;  /* DAC 0 REGISTER WORD                                     */
__sfr16 __at (0xD6D5) DAC1     ;  /* DAC 1 REGISTER WORD                                     */
__sfr16 __at (0xF9E9) PCA0     ;  /* PCA COUNTER                                             */
__sfr16 __at (0xFAEA) PCA0CP0  ;  /* PCA CAPTURE 0 WORD                                      */
__sfr16 __at (0xFBEB) PCA0CP1  ;  /* PCA CAPTURE 1 WORD                                      */
__sfr16 __at (0xFCEC) PCA0CP2  ;  /* PCA CAPTURE 2 WORD                                      */
__sfr16 __at (0xFDED) PCA0CP3  ;  /* PCA CAPTURE 3 WORD                                      */
__sfr16 __at (0xFEEE) PCA0CP4  ;  /* PCA CAPTURE 4 WORD                                      */


/*  BIT Registers  */

/*  P0  0x80 */
__sbit __at (0x80) P0_0        ;
__sbit __at (0x81) P0_1        ;
__sbit __at (0x82) P0_2        ;
__sbit __at (0x83) P0_3        ;
__sbit __at (0x84) P0_4        ;
__sbit __at (0x85) P0_5        ;
__sbit __at (0x86) P0_6        ;
__sbit __at (0x87) P0_7        ;

/*  TCON  0x88 */
__sbit __at (0x88) IT0         ;  /* EXT. INTERRUPT 0 TYPE                                   */
__sbit __at (0x89) IE0         ;  /* EXT. INTERRUPT 0 EDGE FLAG                              */
__sbit __at (0x8A) IT1         ;  /* EXT. INTERRUPT 1 TYPE                                   */
__sbit __at (0x8B) IE1         ;  /* EXT. INTERRUPT 1 EDGE FLAG                              */
__sbit __at (0x8C) TR0         ;  /* TIMER 0 ON/OFF CONTROL                                  */
__sbit __at (0x8D) TF0         ;  /* TIMER 0 OVERFLOW FLAG                                   */
__sbit __at (0x8E) TR1         ;  /* TIMER 1 ON/OFF CONTROL                                  */
__sbit __at (0x8F) TF1         ;  /* TIMER 1 OVERFLOW FLAG                                   */

/*  P1  0x90 */
__sbit __at (0x90) P1_0        ;
__sbit __at (0x91) P1_1        ;
__sbit __at (0x92) P1_2        ;
__sbit __at (0x93) P1_3        ;
__sbit __at (0x94) P1_4        ;
__sbit __at (0x95) P1_5        ;
__sbit __at (0x96) P1_6        ;
__sbit __at (0x97) P1_7        ;

/*  SCON  0x98 */
__sbit __at (0x98) RI          ;  /* SCON.0 - RECEIVE INTERRUPT FLAG                         */
__sbit __at (0x98) RI0         ;  /* SCON.0 - RECEIVE INTERRUPT FLAG                         */
__sbit __at (0x99) TI          ;  /* SCON.1 - TRANSMIT INTERRUPT FLAG                        */
__sbit __at (0x99) TI0         ;  /* SCON.1 - TRANSMIT INTERRUPT FLAG                        */
__sbit __at (0x9A) RB8         ;  /* SCON.2 - RECEIVE BIT 8                                  */
__sbit __at (0x9A) RB80        ;  /* SCON.2 - RECEIVE BIT 8                                  */
__sbit __at (0x9B) TB8         ;  /* SCON.3 - TRANSMIT BIT 8                                 */
__sbit __at (0x9B) TB80        ;  /* SCON.3 - TRANSMIT BIT 8                                 */
__sbit __at (0x9C) REN         ;  /* SCON.4 - RECEIVE ENABLE                                 */
__sbit __at (0x9C) REN0        ;  /* SCON.4 - RECEIVE ENABLE                                 */
__sbit __at (0x9D) SM2         ;  /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE            */
__sbit __at (0x9D) SM20        ;  /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE            */
__sbit __at (0x9D) MCE0        ;  /* SCON.5 - MULTIPROCESSOR COMMUNICATION ENABLE            */
__sbit __at (0x9E) SM1         ;  /* SCON.6 - SERIAL MODE CONTROL BIT 1                      */
__sbit __at (0x9E) SM10        ;  /* SCON.6 - SERIAL MODE CONTROL BIT 1                      */
__sbit __at (0x9F) SM0         ;  /* SCON.7 - SERIAL MODE CONTROL BIT 0                      */
__sbit __at (0x9F) SM00        ;  /* SCON.7 - SERIAL MODE CONTROL BIT 0                      */
__sbit __at (0x9F) S0MODE      ;  /* SCON.7 - SERIAL MODE CONTROL BIT 0                      */

/*  P2  0xA0 */
__sbit __at (0xA0) P2_0        ;
__sbit __at (0xA1) P2_1        ;
__sbit __at (0xA2) P2_2        ;
__sbit __at (0xA3) P2_3        ;
__sbit __at (0xA4) P2_4        ;
__sbit __at (0xA5) P2_5        ;
__sbit __at (0xA6) P2_6        ;
__sbit __at (0xA7) P2_7        ;

/*  IE  0xA8 */
__sbit __at (0xA8) EX0         ;  /* EXTERNAL INTERRUPT 0 ENABLE                             */
__sbit __at (0xA9) ET0         ;  /* TIMER 0 INTERRUPT ENABLE                                */
__sbit __at (0xAA) EX1         ;  /* EXTERNAL INTERRUPT 1 ENABLE                             */
__sbit __at (0xAB) ET1         ;  /* TIMER 1 INTERRUPT ENABLE                                */
__sbit __at (0xAC) ES0         ;  /* SERIAL PORT 0 INTERRUPT ENABLE                          */
__sbit __at (0xAC) ES          ;  /* SERIAL PORT 0 INTERRUPT ENABLE                          */
__sbit __at (0xAD) ET2         ;  /* TIMER 2 INTERRUPT ENABLE                                */
__sbit __at (0xAF) EA          ;  /* GLOBAL INTERRUPT ENABLE                                 */

/*  P3  0xB0 */
__sbit __at (0xB0) P3_0        ;
__sbit __at (0xB1) P3_1        ;
__sbit __at (0xB2) P3_2        ;
__sbit __at (0xB3) P3_3        ;
__sbit __at (0xB4) P3_4        ;
__sbit __at (0xB5) P3_5        ;
__sbit __at (0xB6) P3_6        ;
__sbit __at (0xB7) P3_7        ;

/*  IP  0xB8 */
__sbit __at (0xB8) PX0         ;  /* EXTERNAL INTERRUPT 0 PRIORITY                           */
__sbit __at (0xB9) PT0         ;  /* TIMER 0 PRIORITY                                        */
__sbit __at (0xBA) PX1         ;  /* EXTERNAL INTERRUPT 1 PRIORITY                           */
__sbit __at (0xBB) PT1         ;  /* TIMER 1 PRIORITY                                        */
__sbit __at (0xBC) PS0         ;  /* SERIAL PORT PRIORITY                                    */
__sbit __at (0xBC) PS          ;  /* SERIAL PORT PRIORITY                                    */
__sbit __at (0xBD) PT2         ;  /* TIMER 2 PRIORITY                                        */

/*  SMB0CN  0xC0 */
__sbit __at (0xC0) SMBTOE      ;  /* SMBUS 0 TIMEOUT ENABLE                                  */
__sbit __at (0xC1) SMBFTE      ;  /* SMBUS 0 FREE TIMER ENABLE                               */
__sbit __at (0xC2) AA          ;  /* SMBUS 0 ASSERT/ACKNOWLEDGE FLAG                         */
__sbit __at (0xC3) SI          ;  /* SMBUS 0 INTERRUPT PENDING FLAG                          */
__sbit __at (0xC4) STO         ;  /* SMBUS 0 STOP FLAG                                       */
__sbit __at (0xC5) STA         ;  /* SMBUS 0 START FLAG                                      */
__sbit __at (0xC6) ENSMB       ;  /* SMBUS 0 ENABLE                                          */
__sbit __at (0xC7) BUSY        ;  /* SMBUS 0 BUSY                                            */

/*  T2CON  0xC8 */
__sbit __at (0xC8) CPRL2       ;  /* CAPTURE OR RELOAD SELECT                                */
__sbit __at (0xC9) CT2         ;  /* TIMER OR COUNTER SELECT                                 */
__sbit __at (0xCA) TR2         ;  /* TIMER 2 ON/OFF CONTROL                                  */
__sbit __at (0xCB) EXEN2       ;  /* TIMER 2 EXTERNAL ENABLE FLAG                            */
__sbit __at (0xCC) TCLK        ;  /* TRANSMIT CLOCK FLAG                                     */
__sbit __at (0xCD) RCLK        ;  /* RECEIVE CLOCK FLAG                                      */
__sbit __at (0xCE) EXF2        ;  /* EXTERNAL FLAG                                           */
__sbit __at (0xCF) TF2         ;  /* TIMER 2 OVERFLOW FLAG                                   */

/*  PSW  0xD0 */
__sbit __at (0xD0) P           ;  /* ACCUMULATOR PARITY FLAG                                 */
__sbit __at (0xD1) F1          ;  /* USER FLAG 1                                             */
__sbit __at (0xD2) OV          ;  /* OVERFLOW FLAG                                           */
__sbit __at (0xD3) RS0         ;  /* REGISTER BANK SELECT 0                                  */
__sbit __at (0xD4) RS1         ;  /* REGISTER BANK SELECT 1                                  */
__sbit __at (0xD5) F0          ;  /* USER FLAG 0                                             */
__sbit __at (0xD6) AC          ;  /* AUXILIARY CARRY FLAG                                    */
__sbit __at (0xD7) CY          ;  /* CARRY FLAG                                              */

/*  PCA0CN  0xD8H */
__sbit __at (0xD8) CCF0        ;  /* PCA 0 MODULE 0 INTERRUPT FLAG                           */
__sbit __at (0xD9) CCF1        ;  /* PCA 0 MODULE 1 INTERRUPT FLAG                           */
__sbit __at (0xDA) CCF2        ;  /* PCA 0 MODULE 2 INTERRUPT FLAG                           */
__sbit __at (0xDB) CCF3        ;  /* PCA 0 MODULE 3 INTERRUPT FLAG                           */
__sbit __at (0xDC) CCF4        ;  /* PCA 0 MODULE 4 INTERRUPT FLAG                           */
__sbit __at (0xDE) CR          ;  /* PCA 0 COUNTER RUN CONTROL BIT                           */
__sbit __at (0xDF) CF          ;  /* PCA 0 COUNTER OVERFLOW FLAG                             */

/*  ADC0CN  0xE8H */
__sbit __at (0xE8) ADLJST      ;  /* ADC 0 RIGHT JUSTIFY DATA BIT                            */
__sbit __at (0xE8) AD0LJST     ;  /* ADC 0 RIGHT JUSTIFY DATA BIT                            */
__sbit __at (0xE9) ADWINT      ;  /* ADC 0 WINDOW COMPARE INTERRUPT FLAG                     */
__sbit __at (0xE9) AD0WINT     ;  /* ADC 0 WINDOW COMPARE INTERRUPT FLAG                     */
__sbit __at (0xEA) ADSTM0      ;  /* ADC 0 START OF CONVERSION MODE BIT 0                    */
__sbit __at (0xEA) AD0CM0      ;  /* ADC 0 START OF CONVERSION MODE BIT 0                    */
__sbit __at (0xEB) ADSTM1      ;  /* ADC 0 START OF CONVERSION MODE BIT 1                    */
__sbit __at (0xEB) AD0CM1      ;  /* ADC 0 START OF CONVERSION MODE BIT 1                    */
__sbit __at (0xEC) ADBUSY      ;  /* ADC 0 BUSY FLAG                                         */
__sbit __at (0xEC) AD0BUSY     ;  /* ADC 0 BUSY FLAG                                         */
__sbit __at (0xED) ADCINT      ;  /* ADC 0 CONVERISION COMPLETE INTERRUPT FLAG               */
__sbit __at (0xED) AD0INT      ;  /* ADC 0 CONVERISION COMPLETE INTERRUPT FLAG               */
__sbit __at (0xEE) ADCTM       ;  /* ADC 0 TRACK MODE                                        */
__sbit __at (0xEE) AD0TM       ;  /* ADC 0 TRACK MODE                                        */
__sbit __at (0xEF) ADCEN       ;  /* ADC 0 ENABLE                                            */
__sbit __at (0xEF) AD0EN       ;  /* ADC 0 ENABLE                                            */

/*  SPI0CN  0xF8H */
__sbit __at (0xF8) SPIEN       ;  /* SPI 0 SPI ENABLE                                        */
__sbit __at (0xF9) MSTEN       ;  /* SPI 0 MASTER ENABLE                                     */
__sbit __at (0xFA) SLVSEL      ;  /* SPI 0 SLAVE SELECT                                      */
__sbit __at (0xFB) TXBSY       ;  /* SPI 0 TX BUSY FLAG                                      */
__sbit __at (0xFC) RXOVRN      ;  /* SPI 0 RX OVERRUN FLAG                                   */
__sbit __at (0xFD) MODF        ;  /* SPI 0 MODE FAULT FLAG                                   */
__sbit __at (0xFE) WCOL        ;  /* SPI 0 WRITE COLLISION FLAG                              */
__sbit __at (0xFF) SPIF        ;  /* SPI 0 INTERRUPT FLAG                                    */


/* Predefined SFR Bit Masks */

#define PCON_IDLE         0x01    /* PCON                                */
#define PCON_STOP         0x02    /* PCON                                */
#define PCON_SMOD0        0x80    /* PCON                                */
#define TF3               0x80    /* TMR3CN                              */
#define CPFIF             0x10    /* CPTnCN                              */
#define CPRIF             0x20    /* CPTnCN                              */
#define CPOUT             0x40    /* CPTnCN                              */
#define TR4               0x04    /* T4CON                               */
#define TF4               0x80    /* T4CON                               */
#define ECCF              0x01    /* PCA0CPMn                            */
#define PWM               0x02    /* PCA0CPMn                            */
#define TOG               0x04    /* PCA0CPMn                            */
#define MAT               0x08    /* PCA0CPMn                            */
#define CAPN              0x10    /* PCA0CPMn                            */
#define CAPP              0x20    /* PCA0CPMn                            */
#define ECOM              0x40    /* PCA0CPMn                            */
#define PWM16             0x80    /* PCA0CPMn                            */
#define PORSF             0x02    /* RSTSRC                              */
#define SWRSF             0x10    /* RSTSRC                              */
#define RI1               0x01    /* SCON1                               */
#define TI1               0x02    /* SCON1                               */
#define RB81              0x04    /* SCON1                               */
#define TB81              0x08    /* SCON1                               */
#define REN1              0x10    /* SCON1                               */
#define SM21              0x20    /* SCON1                               */
#define SM11              0x40    /* SCON1                               */
#define SM01              0x80    /* SCON1                               */

#endif
/*-------------------------------------------------------------------------
   mc68hc908apxx.h - register declarations for Motorola MC68HC908AP16/32/64

   Copyright (C) 2004, Lucas Loizaga <lucas.loizaga AT ingenieria-inversa.com.ar>

   Based on mc68hc908gp32.h,
   Written By - Juan Gonzalez <juan AT iearobotics.com>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef MC68HC908APXX_H
#define MC68HC908APXX_H

#ifndef _UINT8
 #define _UINT8 unsigned char
#endif
#ifndef _UINT16
 #define _UINT16 unsigned int
#endif
#ifndef _VOLDATA
 #define _VOLDATA volatile __data
#endif
#ifndef _VOLXDATA
 #define _VOLXDATA volatile __xdata
#endif

struct __hc08_bits
{
  unsigned int bit0:1;
  unsigned int bit1:1;
  unsigned int bit2:1;
  unsigned int bit3:1;
  unsigned int bit4:1;
  unsigned int bit5:1;
  unsigned int bit6:1;
  unsigned int bit7:1;
};
  

_VOLDATA _UINT8 __at 0x00 PTA;     /* Port A Data Register */
#define PORTA PTA		 /* Alias for PTA        */
  #define PTA0 ((struct __hc08_bits *)(&PTA))->bit0
  #define PTA1 ((struct __hc08_bits *)(&PTA))->bit1
  #define PTA2 ((struct __hc08_bits *)(&PTA))->bit2
  #define PTA3 ((struct __hc08_bits *)(&PTA))->bit3
  #define PTA4 ((struct __hc08_bits *)(&PTA))->bit4
  #define PTA5 ((struct __hc08_bits *)(&PTA))->bit5
  #define PTA6 ((struct __hc08_bits *)(&PTA))->bit6
  #define PTA7 ((struct __hc08_bits *)(&PTA))->bit7
    
_VOLDATA _UINT8 __at 0x01 PTB;     /* Port B Data Register */
#define PORTB PTB              /* Alias for PTB        */	
  #define PTB0 ((struct __hc08_bits *)(&PTB))->bit0
  #define PTB1 ((struct __hc08_bits *)(&PTB))->bit1
  #define PTB2 ((struct __hc08_bits *)(&PTB))->bit2
  #define PTB3 ((struct __hc08_bits *)(&PTB))->bit3
  #define PTB4 ((struct __hc08_bits *)(&PTB))->bit4
  #define PTB5 ((struct __hc08_bits *)(&PTB))->bit5
  #define PTB6 ((struct __hc08_bits *)(&PTB))->bit6
  #define PTB7 ((struct __hc08_bits *)(&PTB))->bit7

_VOLDATA _UINT8 __at 0x02 PTC;     /* Port C Data Register */
#define PORTC PTC              /* Alias for PTC        */
  #define PTC0 ((struct __hc08_bits *)(&PTC))->bit0
  #define PTC1 ((struct __hc08_bits *)(&PTC))->bit1
  #define PTC2 ((struct __hc08_bits *)(&PTC))->bit2
  #define PTC3 ((struct __hc08_bits *)(&PTC))->bit3
  #define PTC4 ((struct __hc08_bits *)(&PTC))->bit4
  #define PTC5 ((struct __hc08_bits *)(&PTC))->bit5
  #define PTC6 ((struct __hc08_bits *)(&PTC))->bit6
  #define PTC7 ((struct __hc08_bits *)(&PTC))->bit7

_VOLDATA _UINT8 __at 0x03 PTD;     /* Port D Data Register */
#define PORTD PTD              /* Alias for PTD        */
  #define PTD0 ((struct __hc08_bits *)(&PTD))->bit0
  #define PTD1 ((struct __hc08_bits *)(&PTD))->bit1
  #define PTD2 ((struct __hc08_bits *)(&PTD))->bit2
  #define PTD3 ((struct __hc08_bits *)(&PTD))->bit3
  #define PTD4 ((struct __hc08_bits *)(&PTD))->bit4
  #define PTD5 ((struct __hc08_bits *)(&PTD))->bit5
  #define PTD6 ((struct __hc08_bits *)(&PTD))->bit6
  #define PTD7 ((struct __hc08_bits *)(&PTD))->bit7

_VOLDATA _UINT8 __at 0x04 DDRA;    /* Data Direction Register A */
  #define DDRA0 ((struct __hc08_bits *)(&DDRA))->bit0
  #define DDRA1 ((struct __hc08_bits *)(&DDRA))->bit1
  #define DDRA2 ((struct __hc08_bits *)(&DDRA))->bit2
  #define DDRA3 ((struct __hc08_bits *)(&DDRA))->bit3
  #define DDRA4 ((struct __hc08_bits *)(&DDRA))->bit4
  #define DDRA5 ((struct __hc08_bits *)(&DDRA))->bit5
  #define DDRA6 ((struct __hc08_bits *)(&DDRA))->bit6
  #define DDRA7 ((struct __hc08_bits *)(&DDRA))->bit7

_VOLDATA _UINT8 __at 0x05 DDRB;    /* Data Direction Register B */
  #define DDRB0 ((struct __hc08_bits *)(&DDRB))->bit0
  #define DDRB1 ((struct __hc08_bits *)(&DDRB))->bit1
  #define DDRB2 ((struct __hc08_bits *)(&DDRB))->bit2
  #define DDRB3 ((struct __hc08_bits *)(&DDRB))->bit3
  #define DDRB4 ((struct __hc08_bits *)(&DDRB))->bit4
  #define DDRB5 ((struct __hc08_bits *)(&DDRB))->bit5
  #define DDRB6 ((struct __hc08_bits *)(&DDRB))->bit6
  #define DDRB7 ((struct __hc08_bits *)(&DDRB))->bit7

_VOLDATA _UINT8 __at 0x06 DDRC;    /* Data Direction Register C */
  #define DDRC0 ((struct __hc08_bits *)(&DDRC))->bit0
  #define DDRC1 ((struct __hc08_bits *)(&DDRC))->bit1
  #define DDRC2 ((struct __hc08_bits *)(&DDRC))->bit2
  #define DDRC3 ((struct __hc08_bits *)(&DDRC))->bit3
  #define DDRC4 ((struct __hc08_bits *)(&DDRC))->bit4
  #define DDRC5 ((struct __hc08_bits *)(&DDRC))->bit5
  #define DDRC6 ((struct __hc08_bits *)(&DDRC))->bit6
  #define DDRC7 ((struct __hc08_bits *)(&DDRC))->bit7

_VOLDATA _UINT8 __at 0x07 DDRD;    /* Data Direction Register D */
  #define DDRD0 ((struct __hc08_bits *)(&DDRD))->bit0
  #define DDRD1 ((struct __hc08_bits *)(&DDRD))->bit1
  #define DDRD2 ((struct __hc08_bits *)(&DDRD))->bit2
  #define DDRD3 ((struct __hc08_bits *)(&DDRD))->bit3
  #define DDRD4 ((struct __hc08_bits *)(&DDRD))->bit4
  #define DDRD5 ((struct __hc08_bits *)(&DDRD))->bit5
  #define DDRD6 ((struct __hc08_bits *)(&DDRD))->bit6
  #define DDRD7 ((struct __hc08_bits *)(&DDRD))->bit7

_VOLDATA _UINT8 __at 0x0C LEDA;    /* PORTA Led Control Register */
  #define LEDA0 ((struct __hc08_bits *)(&LEDA))->bit0
  #define LEDA1 ((struct __hc08_bits *)(&LEDA))->bit1
  #define LEDA2 ((struct __hc08_bits *)(&LEDA))->bit2
  #define LEDA3 ((struct __hc08_bits *)(&LEDA))->bit3
  #define LEDA4 ((struct __hc08_bits *)(&LEDA))->bit4
  #define LEDA5 ((struct __hc08_bits *)(&LEDA))->bit5
  #define LEDA6 ((struct __hc08_bits *)(&LEDA))->bit6
  #define LEDA7 ((struct __hc08_bits *)(&LEDA))->bit7
		
_VOLDATA _UINT8 __at 0x10 SPCR;   /* SPI Control Register */
	#define SPRIE  ((struct __hc08_bits *)(&SPCR))->bit7
	#define DMAS   ((struct __hc08_bits *)(&SPCR))->bit6
	#define SPMSTR ((struct __hc08_bits *)(&SPCR))->bit5	
	#define CPOL   ((struct __hc08_bits *)(&SPCR))->bit4
	#define CPHA   ((struct __hc08_bits *)(&SPCR))->bit3	
        #define SPWOM  ((struct __hc08_bits *)(&SPCR))->bit2
	#define SPE    ((struct __hc08_bits *)(&SPCR))->bit1	
        #define SPTIE  ((struct __hc08_bits *)(&SPCR))->bit0	
	
_VOLDATA _UINT8 __at 0x11 SPSCR;  /* SPI Status and Control Register */
	#define SPRF   ((struct __hc08_bits *)(&SPSCR))->bit7
	#define ERRIE  ((struct __hc08_bits *)(&SPSCR))->bit6
	#define OVRF   ((struct __hc08_bits *)(&SPSCR))->bit5
	#define MODF   ((struct __hc08_bits *)(&SPSCR))->bit4
	#define SPTE   ((struct __hc08_bits *)(&SPSCR))->bit3
	#define MODFEN ((struct __hc08_bits *)(&SPSCR))->bit2
	#define SPR1   ((struct __hc08_bits *)(&SPSCR))->bit1
	#define SPR0   ((struct __hc08_bits *)(&SPSCR))->bit0	
		
_VOLDATA _UINT8 __at 0x12 SPDR;   /* SPI Data Register */


_VOLDATA _UINT8 __at 0x13 SCC1;  /* SCI Control Register 1 */ 
	#define LOOPS  ((struct __hc08_bits *)(&SCC1))->bit7
 	#define ENSCI  ((struct __hc08_bits *)(&SCC1))->bit6	
	#define TXINV  ((struct __hc08_bits *)(&SCC1))->bit5
  	#define M      ((struct __hc08_bits *)(&SCC1))->bit4		
	#define WAKE   ((struct __hc08_bits *)(&SCC1))->bit3
  	#define ILTY   ((struct __hc08_bits *)(&SCC1))->bit2
	#define PEN    ((struct __hc08_bits *)(&SCC1))->bit1
  	#define PTY    ((struct __hc08_bits *)(&SCC1))->bit0
	
		
_VOLDATA _UINT8 __at 0x14 SCC2;  /* SCI Control Register 2 */ 
	#define SCTIE  ((struct __hc08_bits *)(&SCC2))->bit7
	#define TCIE   ((struct __hc08_bits *)(&SCC2))->bit6
	#define SCRIE  ((struct __hc08_bits *)(&SCC2))->bit5
	#define ILIE   ((struct __hc08_bits *)(&SCC2))->bit4
	#define TE     ((struct __hc08_bits *)(&SCC2))->bit3
	#define RE     ((struct __hc08_bits *)(&SCC2))->bit2
	#define WRU    ((struct __hc08_bits *)(&SCC2))->bit1
	#define SBK    ((struct __hc08_bits *)(&SCC2))->bit0
	
_VOLDATA _UINT8 __at 0x15 SCC3;  /* SCI Control Register 3 */ 
	#define SCC3_R8 ((struct __hc08_bits *)(&SCC3))->bit7
	#define SCC3_T8 ((struct __hc08_bits *)(&SCC3))->bit6
  	#define DMARE   ((struct __hc08_bits *)(&SCC3))->bit5
	#define DMATE   ((struct __hc08_bits *)(&SCC3))->bit4
	#define ORIE    ((struct __hc08_bits *)(&SCC3))->bit3
	#define NEIE    ((struct __hc08_bits *)(&SCC3))->bit2
  	#define FEIE    ((struct __hc08_bits *)(&SCC3))->bit1
	#define PEIE    ((struct __hc08_bits *)(&SCC3))->bit0
	
_VOLDATA _UINT8 __at 0x16 SCS1;  /* SCI Status Register 1 */
	#define SCTE  ((struct __hc08_bits *)(&SCS1))->bit7
	#define TC    ((struct __hc08_bits *)(&SCS1))->bit6
	#define SCRF  ((struct __hc08_bits *)(&SCS1))->bit5
	#define IDLE  ((struct __hc08_bits *)(&SCS1))->bit4
	#define OR    ((struct __hc08_bits *)(&SCS1))->bit3
	#define NF    ((struct __hc08_bits *)(&SCS1))->bit2
	#define FE    ((struct __hc08_bits *)(&SCS1))->bit1
	#define PE    ((struct __hc08_bits *)(&SCS1))->bit0	
		
_VOLDATA _UINT8 __at 0x17 SCS2;  /* SCI Status Register 2 */
	#define RPF  ((struct __hc08_bits *)(&SCS2))->bit0
	#define BKF  ((struct __hc08_bits *)(&SCS2))->bit1
  /*  Bits 2-7 not implemented	*/
	
_VOLDATA _UINT8 __at 0x18 SCDR;  /* SCI Data Register */
	
_VOLDATA _UINT8 __at 0x19 SCBR;  /* SCI Baud Rate Register */
	#define SCP1  ((struct __hc08_bits *)(&SCBR))->bit5
	#define SCP0  ((struct __hc08_bits *)(&SCBR))->bit4
  	#define R     ((struct __hc08_bits *)(&SCBR))->bit3
  	#define SCR2  ((struct __hc08_bits *)(&SCBR))->bit2
  	#define SCR1  ((struct __hc08_bits *)(&SCBR))->bit1
  	#define SCR0  ((struct __hc08_bits *)(&SCBR))->bit0
	/*-- Bits 6 and 7 do not exist */
		
_VOLDATA _UINT8 __at 0x1a INTKBSCR; /* Keyboard Status and Control Register */
	#define KEYF   ((struct __hc08_bits *)(&INTKBSCR))->bit3
	#define ACKK   ((struct __hc08_bits *)(&INTKBSCR))->bit2
	#define IMASKK ((struct __hc08_bits *)(&INTKBSCR))->bit1
	#define MODEK  ((struct __hc08_bits *)(&INTKBSCR))->bit0
	/*-- Bits 4-7 do not exist  */
		
_VOLDATA _UINT8 __at 0x1b INTKBIER; /* Keyboard Interrupt Enable Register */
  #define KBIE7  ((struct __hc08_bits *)(&INTKBIER))->bit7	
	#define KBIE6  ((struct __hc08_bits *)(&INTKBIER))->bit6
	#define KBIE5  ((struct __hc08_bits *)(&INTKBIER))->bit5
	#define KBIE4  ((struct __hc08_bits *)(&INTKBIER))->bit4
	#define KBIE3  ((struct __hc08_bits *)(&INTKBIER))->bit3
	#define KBIE2  ((struct __hc08_bits *)(&INTKBIER))->bit2
	#define KBIE1  ((struct __hc08_bits *)(&INTKBIER))->bit1
	#define KBIE0  ((struct __hc08_bits *)(&INTKBIER))->bit0

_VOLDATA _UINT8 __at 0x1C INTSCR2; /* Keyboard Status and Control Register */
	#define PUC0ENB ((struct __hc08_bits *)(&INTSCR2))->bit6
	#define IRQF2   ((struct __hc08_bits *)(&INTSCR2))->bit3
	#define ACK2    ((struct __hc08_bits *)(&INTSCR2))->bit2
	#define IMASK2  ((struct __hc08_bits *)(&INTSCR2))->bit1
	#define MODE2   ((struct __hc08_bits *)(&INTSCR2))->bit0
	
_VOLDATA _UINT8 __at 0x1D CONFIG2; /* Configuration Register 2 */
/* CONFIG2 is one-time writeble, so can't use bitfields  */	
		
		
_VOLDATA _UINT8 __at 0x1E INTSCR1;	/* IRQ status/control       */
	#define IRQF1  ((struct __hc08_bits *)(&INTSCR1))->bit3
	#define ACK1   ((struct __hc08_bits *)(&INTSCR1))->bit2
	#define IMASK1 ((struct __hc08_bits *)(&INTSCR1))->bit1
	#define MODE1  ((struct __hc08_bits *)(&INTSCR1))->bit0
	/* Bits 4-7 unimplemented */
	
_VOLDATA _UINT8 __at 0x1f CONFIG1; /* Configuration Register 1 */
/* CONFIG1 is one-time writeable, so can't use bitfields */	
	
_VOLDATA _UINT8 __at 0x20 T1SC;     /* TIM 1 Status and Control */
  #define PS0   ((struct __hc08_bits *)(&T1SC))->bit0
  #define PS1   ((struct __hc08_bits *)(&T1SC))->bit1
  #define PS2   ((struct __hc08_bits *)(&T1SC))->bit2
  #define TRST  ((struct __hc08_bits *)(&T1SC))->bit4
  #define TSTOP ((struct __hc08_bits *)(&T1SC))->bit5
  #define TOIE  ((struct __hc08_bits *)(&T1SC))->bit6
  #define TOF   ((struct __hc08_bits *)(&T1SC))->bit7	

_VOLDATA _UINT16 __at 0x21 T1CNT;    /* TIM1 Counter High & Low Registers */
_VOLDATA _UINT8  __at 0x21  T1CNTH;  /* TIM1 Counter Register High */
_VOLDATA _UINT8  __at 0x22  T1CNTL;  /* TIM1 Counter Register Low */

_VOLDATA _UINT16 __at 0x23 T1MOD;    /* TIM1 Counter Modulo High & Low Registers */
_VOLDATA _UINT8  __at 0x23 T1MODH;   /* TIM1 Counter Modulo Register High */
_VOLDATA _UINT8  __at 0x24 T1MODL;   /* TIM1 Counter Modulo Register Low */

_VOLDATA _UINT8 __at 0x25 T1SC0;    /* TIM1 Channel 0 Status and Control Register */
  #define CH0MAX ((struct __hc08_bits *)(&T1SC0))->bit0
  #define TOV0   ((struct __hc08_bits *)(&T1SC0))->bit1
  #define ELS0A  ((struct __hc08_bits *)(&T1SC0))->bit2
  #define ELS0B  ((struct __hc08_bits *)(&T1SC0))->bit3
  #define MS0A   ((struct __hc08_bits *)(&T1SC0))->bit4
  #define MS0B   ((struct __hc08_bits *)(&T1SC0))->bit5
  #define CH0IE  ((struct __hc08_bits *)(&T1SC0))->bit6
  #define CH0F   ((struct __hc08_bits *)(&T1SC0))->bit7
		
_VOLDATA _UINT16 __at 0x26 T1CH0;   /* TIM1 Channel 0 High & Low Registers */
_VOLDATA _UINT8 __at 0x26 T1CH0H;   /* TIM1 Channel 0 Register High */
_VOLDATA _UINT8 __at 0x27 T1CH0L;   /* TIM1 Channel 0 Register Low */

_VOLDATA _UINT8 __at 0x28 T1SC1;    /* TIM1 Channel 1 Status and Control Register */
  #define CH1MAX ((struct __hc08_bits *)(&T1SC1))->bit0
  #define TOV1   ((struct __hc08_bits *)(&T1SC1))->bit1
  #define ELS1A  ((struct __hc08_bits *)(&T1SC1))->bit2
  #define ELS1B  ((struct __hc08_bits *)(&T1SC1))->bit3
  #define MS1A   ((struct __hc08_bits *)(&T1SC1))->bit4
  #define CH1IE  ((struct __hc08_bits *)(&T1SC1))->bit6
  #define CH1F   ((struct __hc08_bits *)(&T1SC1))->bit7

_VOLDATA _UINT16 __at 0x29 T1CH1;    /* TIM1 Channel 1 High & Low Registers */
_VOLDATA _UINT8  __at 0x29  T1CH1H;  /* TIM1 Channel 1 Register High */
_VOLDATA _UINT8  __at 0x2A  T1CH1L;  /* TIM1 Channel 1 Register Low */
	
/*------------------*/
/* TIM 2 REGISTERS  */
/*------------------*/
	
_VOLDATA _UINT8 __at 0x2B T2SC;     /* TIM 2 Status and Control */
  #define PS0_2   ((struct __hc08_bits *)(&T2SC))->bit0
  #define PS1_2   ((struct __hc08_bits *)(&T2SC))->bit1
  #define PS2_2   ((struct __hc08_bits *)(&T2SC))->bit2
  #define TRST_2  ((struct __hc08_bits *)(&T2SC))->bit4
  #define TSTOP_2 ((struct __hc08_bits *)(&T2SC))->bit5
  #define TOIE_2  ((struct __hc08_bits *)(&T2SC))->bit6
  #define TOF_2   ((struct __hc08_bits *)(&T2SC))->bit7	
		
_VOLDATA _UINT16 __at 0x2C T2CNT;   /* TIM2 Counter High & Low Registers */
_VOLDATA _UINT8  __at 0x2C T2CNTH;  /* TIM2 Counter Register High */
_VOLDATA _UINT8  __at 0x2D T2CNTL;  /* TIM2 Counter Register Low */
	
_VOLDATA _UINT16 __at 0x2E T2MOD;    /* TIM2 Counter Modulo High & Low Registers */
_VOLDATA _UINT8  __at 0x2E T2MODH;   /* TIM2 Counter Modulo Register High */
_VOLDATA _UINT8  __at 0x2F T2MODL;   /* TIM2 Counter Modulo Register Low */	
	
_VOLDATA _UINT8 __at 0x30 T2SC0;    /* TIM2 Channel 0 Status and Control Register */
  #define CH0MAX_2 ((struct __hc08_bits *)(&T2SC0))->bit0
  #define TOV0_2   ((struct __hc08_bits *)(&T2SC0))->bit1
  #define ELS0A_2  ((struct __hc08_bits *)(&T2SC0))->bit2
  #define ELS0B_2  ((struct __hc08_bits *)(&T2SC0))->bit3
  #define MS0A_2   ((struct __hc08_bits *)(&T2SC0))->bit4
  #define MS0B_2   ((struct __hc08_bits *)(&T2SC0))->bit5
  #define CH0IE_2  ((struct __hc08_bits *)(&T2SC0))->bit6
  #define CH0F_2   ((struct __hc08_bits *)(&T2SC0))->bit7	
	
_VOLDATA _UINT16 __at 0x31 T2CH0;    /* TIM2 Channel 0 High & Low Registers */
_VOLDATA _UINT8  __at 0x31 T2CH0H;   /* TIM2 Channel 0 Register High */
_VOLDATA _UINT8  __at 0x32 T2CH0L;   /* TIM2 Channel 0 Register Low */	
	
_VOLDATA _UINT8 __at 0x33 T2SC1;    /* TIM2 Channel 1 Status and Control Register */
  #define CH1MAX_2 ((struct __hc08_bits *)(&T2SC1))->bit0
  #define TOV1_2   ((struct __hc08_bits *)(&T2SC1))->bit1
  #define ELS1A_2  ((struct __hc08_bits *)(&T2SC1))->bit2
  #define ELS1B_2  ((struct __hc08_bits *)(&T2SC1))->bit3
  #define MS1A_2   ((struct __hc08_bits *)(&T2SC1))->bit4
  #define CH1IE_2  ((struct __hc08_bits *)(&T2SC1))->bit6
  #define CH1F_2   ((struct __hc08_bits *)(&T2SC1))->bit7

_VOLDATA _UINT16 __at 0x34  T2CH1;   /* TIM2 Channel 1 High & Low Registers */
_VOLDATA _UINT8  __at 0x34  T2CH1H;  /* TIM2 Channel 1 Register High */
_VOLDATA _UINT8  __at 0x35  T2CH1L;  /* TIM2 Channel 1 Register Low */	
	
_VOLDATA _UINT8 __at 0x36 PCTL;  /* PLL Control Register */
	#define PLLIE ((struct __hc08_bits *)(&PCTL))->bit7
	#define PLLF  ((struct __hc08_bits *)(&PCTL))->bit6
	#define PLLON ((struct __hc08_bits *)(&PCTL))->bit5
	#define BCS   ((struct __hc08_bits *)(&PCTL))->bit4
	#define PRE1  ((struct __hc08_bits *)(&PCTL))->bit3
	#define PRE0  ((struct __hc08_bits *)(&PCTL))->bit2
	#define VPR1  ((struct __hc08_bits *)(&PCTL))->bit1
	#define VPR0  ((struct __hc08_bits *)(&PCTL))->bit0
		
_VOLDATA	_UINT8 __at 0x37 PBWC;  /* PLL Bandwidth Control Register */
	#define AUTO ((struct __hc08_bits *)(&PBWC))->bit7
	#define LOCK ((struct __hc08_bits *)(&PBWC))->bit6
	#define ACQ  ((struct __hc08_bits *)(&PBWC))->bit5
	/* Bits 1-4, Unimplemented */
	/* Bit 0, Reserved         */
	
_VOLDATA _UINT8 __at 0x38 PMSH;  /* PLL Multiplier Select High */
	#define MUL11 ((struct __hc08_bits *)(&PMSH))->bit3
	#define MUL10 ((struct __hc08_bits *)(&PMSH))->bit2
	#define MUL9  ((struct __hc08_bits *)(&PMSH))->bit1
	#define MUL8  ((struct __hc08_bits *)(&PMSH))->bit0
	/* Bits 4-7 unimplemented */
	
_VOLDATA _UINT8 __at 0x39 PMSL;  /* PLL Multiplir Select Low */
	#define MUL7 ((struct __hc08_bits *)(&PMSL))->bit7
	#define MUL6 ((struct __hc08_bits *)(&PMSL))->bit6
	#define MUL5 ((struct __hc08_bits *)(&PMSL))->bit5
	#define MUL4 ((struct __hc08_bits *)(&PMSL))->bit4
	#define MUL3 ((struct __hc08_bits *)(&PMSL))->bit3
	#define MUL2 ((struct __hc08_bits *)(&PMSL))->bit2
	#define MUL1 ((struct __hc08_bits *)(&PMSL))->bit1
	#define MUL0 ((struct __hc08_bits *)(&PMSL))->bit0
	
_VOLDATA _UINT8 __at 0x3a PMRS;  /* PLL VCO Select Range  */
	#define VRS7 ((struct __hc08_bits *)(&PMRS))->bit7
	#define VRS6 ((struct __hc08_bits *)(&PMRS))->bit6
	#define VRS5 ((struct __hc08_bits *)(&PMRS))->bit5
	#define VRS4 ((struct __hc08_bits *)(&PMRS))->bit4
	#define VRS3 ((struct __hc08_bits *)(&PMRS))->bit3
	#define VRS2 ((struct __hc08_bits *)(&PMRS))->bit2
	#define VRS1 ((struct __hc08_bits *)(&PMRS))->bit1
	#define VRS0 ((struct __hc08_bits *)(&PMRS))->bit0
		
_VOLDATA _UINT8 __at 0x3b PMDS;  /* PLL Reference Divider Select Register */	
	#define RDS3 ((struct __hc08_bits *)(&PMDS))->bit3
	#define RDS2 ((struct __hc08_bits *)(&PMDS))->bit2
	#define RDS1 ((struct __hc08_bits *)(&PMDS))->bit1
	#define RDS0 ((struct __hc08_bits *)(&PMDS))->bit0
	/* Bits 4-7 unimplemented */



_VOLDATA _UINT8 __at 0x40 IRSCC1;  /* SCI Control Register 1 */ 
	#define LOOPS_IR  ((struct __hc08_bits *)(&IRSCC1))->bit7
 	#define ENSCI_IR  ((struct __hc08_bits *)(&IRSCC1))->bit6	
	#define TXINV_IR  ((struct __hc08_bits *)(&IRSCC1))->bit5
  	#define M_IR      ((struct __hc08_bits *)(&IRSCC1))->bit4		
	#define WAKE_IR   ((struct __hc08_bits *)(&IRSCC1))->bit3
  	#define ILTY_IR   ((struct __hc08_bits *)(&IRSCC1))->bit2
	#define PEN_IR    ((struct __hc08_bits *)(&IRSCC1))->bit1
  	#define PTY_IR    ((struct __hc08_bits *)(&IRSCC1))->bit0
	
		
_VOLDATA _UINT8 __at 0x41 IRSCC2;  /* SCI Control Register 2 */ 
	#define SCTIE_IR  ((struct __hc08_bits *)(&IRSCC2))->bit7
	#define TCIE_IR   ((struct __hc08_bits *)(&IRSCC2))->bit6
	#define SCRIE_IR  ((struct __hc08_bits *)(&IRSCC2))->bit5
	#define ILIE_IR   ((struct __hc08_bits *)(&IRSCC2))->bit4
	#define TE_IR     ((struct __hc08_bits *)(&IRSCC2))->bit3
	#define RE_IR     ((struct __hc08_bits *)(&IRSCC2))->bit2
	#define WRU_IR    ((struct __hc08_bits *)(&IRSCC2))->bit1
	#define SBK_IR    ((struct __hc08_bits *)(&IRSCC2))->bit0
	
_VOLDATA _UINT8 __at 0x42 IRSCC3;  /* SCI Control Register 3 */ 
	#define SCC3_R8_IR ((struct __hc08_bits *)(&IRSCC3))->bit7
	#define SCC3_T8_IR ((struct __hc08_bits *)(&IRSCC3))->bit6
  	#define DMARE_IR   ((struct __hc08_bits *)(&IRSCC3))->bit5
	#define DMATE_IR   ((struct __hc08_bits *)(&IRSCC3))->bit4
	#define ORIE_IR    ((struct __hc08_bits *)(&IRSCC3))->bit3
	#define NEIE_IR    ((struct __hc08_bits *)(&IRSCC3))->bit2
  	#define FEIE_IR    ((struct __hc08_bits *)(&IRSCC3))->bit1
	#define PEIE_IR    ((struct __hc08_bits *)(&IRSCC3))->bit0
	
_VOLDATA _UINT8 __at 0x43 IRSCS1;  /* SCI Status Register 1 */
	#define SCTE_IR  ((struct __hc08_bits *)(&IRSCS1))->bit7
	#define TC_IR    ((struct __hc08_bits *)(&IRSCS1))->bit6
	#define SCRF_IR  ((struct __hc08_bits *)(&IRSCS1))->bit5
	#define IDLE_IR  ((struct __hc08_bits *)(&IRSCS1))->bit4
	#define OR_IR    ((struct __hc08_bits *)(&IRSCS1))->bit3
	#define NF_IR    ((struct __hc08_bits *)(&IRSCS1))->bit2
	#define FE_IR    ((struct __hc08_bits *)(&IRSCS1))->bit1
	#define PE_IR    ((struct __hc08_bits *)(&IRSCS1))->bit0	
		
_VOLDATA _UINT8 __at 0x44 IRSCS2;  /* SCI Status Register 2 */
	#define RPF_IR  ((struct __hc08_bits *)(&IRSCS2))->bit0
	#define BKF_IR  ((struct __hc08_bits *)(&IRSCS2))->bit1
  /*  Bits 2-7 not implemented	*/
	
_VOLDATA _UINT8 __at 0x45 IRSCDR;  /* SCI Data Register */
	
_VOLDATA _UINT8 __at 0x46 IRSCBR;  /* SCI Baud Rate Register */
	#define CKS_IR   ((struct __hc08_bits *)(&IRSCBR))->bit7
	#define SCP1_IR  ((struct __hc08_bits *)(&IRSCBR))->bit5
	#define SCP0_IR  ((struct __hc08_bits *)(&IRSCBR))->bit4
  	#define SCR2_IR  ((struct __hc08_bits *)(&IRSCBR))->bit2
  	#define SCR1_IR  ((struct __hc08_bits *)(&IRSCBR))->bit1
  	#define SCR0_IR  ((struct __hc08_bits *)(&IRSCBR))->bit0

_VOLDATA _UINT8 __at 0x47 IRSCIRCR;  /* SCI Baud Rate Register */
  	#define TNP1_IR  ((struct __hc08_bits *)(&IRSCIRCR))->bit2
  	#define TNP0_IR  ((struct __hc08_bits *)(&IRSCIRCR))->bit1
  	#define IREN_IR  ((struct __hc08_bits *)(&IRSCIRCR))->bit0



_VOLDATA _UINT8 __at 0x48 MMADR; /* MMIIC Address Register. */
	#define MMAD7   ((struct __hc08_bits *)(&MMADR))->bit7
	#define MMAD6   ((struct __hc08_bits *)(&MMADR))->bit6
	#define MMAD5   ((struct __hc08_bits *)(&MMADR))->bit5
	#define MMAD4   ((struct __hc08_bits *)(&MMADR))->bit4
	#define MMAD3   ((struct __hc08_bits *)(&MMADR))->bit3
	#define MMAD2   ((struct __hc08_bits *)(&MMADR))->bit2
	#define MMAD1   ((struct __hc08_bits *)(&MMADR))->bit1
	#define MMEXTAD ((struct __hc08_bits *)(&MMADR))->bit0
	

_VOLDATA _UINT8 __at 0x49 MMCR1; /* MMIIC Control Register 1. */
	#define MMEN      ((struct __hc08_bits *)(&MMCR1))->bit7
	#define MMIEN     ((struct __hc08_bits *)(&MMCR1))->bit6
	#define MMCLRBB   ((struct __hc08_bits *)(&MMCR1))->bit5
	#define MMTXAK    ((struct __hc08_bits *)(&MMCR1))->bit3
	#define REPSEN    ((struct __hc08_bits *)(&MMCR1))->bit2
	#define MMCRCBYTE ((struct __hc08_bits *)(&MMCR1))->bit1
	

_VOLDATA _UINT8 __at 0x4a MMCR2; /* MMIIC Control Register 2. */
	#define MMALIF      ((struct __hc08_bits *)(&MMCR2))->bit7
	#define MMNAKIF     ((struct __hc08_bits *)(&MMCR2))->bit6
	#define MMBB        ((struct __hc08_bits *)(&MMCR2))->bit5
	#define MMAST       ((struct __hc08_bits *)(&MMCR2))->bit4
	#define MMRW        ((struct __hc08_bits *)(&MMCR2))->bit3
	#define MMCRCEF     ((struct __hc08_bits *)(&MMCR2))->bit0
	

_VOLDATA _UINT8 __at 0x4B MMSR; /* MMIIC Status Register. */
	#define MMRXIF  ((struct __hc08_bits *)(&MMSR))->bit7
	#define MMTXIF  ((struct __hc08_bits *)(&MMSR))->bit6
	#define MMATCH  ((struct __hc08_bits *)(&MMSR))->bit5
	#define MMSRW   ((struct __hc08_bits *)(&MMSR))->bit4
	#define MMRXAK  ((struct __hc08_bits *)(&MMSR))->bit3
	#define MMCRCBF ((struct __hc08_bits *)(&MMSR))->bit2
	#define MMTXBE  ((struct __hc08_bits *)(&MMSR))->bit1
	#define MMRXBF  ((struct __hc08_bits *)(&MMSR))->bit0
	
_VOLDATA _UINT8 __at 0x4C MMDTR;  /* MMIIC Data Transmit Register */
_VOLDATA _UINT8 __at 0x4D MMDRR;  /* MMIIC Data Receive Register  */
_VOLDATA _UINT8 __at 0x4E MMCRDR; /* MMIIC CRC Data Register  */


_VOLDATA _UINT8 __at 0x4F MMFDR;  /* MMIIC Frecuency Divider Register */
  	#define MMBR2  ((struct __hc08_bits *)(&MMFDR))->bit2
  	#define MMBR1  ((struct __hc08_bits *)(&MMFDR))->bit1
  	#define MMBR0  ((struct __hc08_bits *)(&MMFDR))->bit0


_VOLDATA _UINT8 __at 0x51 TBCR;    /* Time Base Module Control */
	#define TBIF   ((struct __hc08_bits *)(&TBCR))->bit7
	#define TBR2   ((struct __hc08_bits *)(&TBCR))->bit6
	#define TBR1   ((struct __hc08_bits *)(&TBCR))->bit5
	#define TBR0   ((struct __hc08_bits *)(&TBCR))->bit4
	#define TACK   ((struct __hc08_bits *)(&TBCR))->bit3
	#define TBIE   ((struct __hc08_bits *)(&TBCR))->bit2
	#define TBON   ((struct __hc08_bits *)(&TBCR))->bit1
	/* Bit 0 Reserved */	



_VOLDATA _UINT8 __at 0x57 ADSCR; /* Analog-to-Digital Status and Control Reg. */
	#define COCO  ((struct __hc08_bits *)(&ADSCR))->bit7
	#define AIEN  ((struct __hc08_bits *)(&ADSCR))->bit6
	#define ADCO  ((struct __hc08_bits *)(&ADSCR))->bit5
	#define ADCH4 ((struct __hc08_bits *)(&ADSCR))->bit4
	#define ADCH3 ((struct __hc08_bits *)(&ADSCR))->bit3
	#define ADCH2 ((struct __hc08_bits *)(&ADSCR))->bit2
	#define ADCH1 ((struct __hc08_bits *)(&ADSCR))->bit1
	#define ADCH0 ((struct __hc08_bits *)(&ADSCR))->bit0
	
_VOLDATA _UINT8 __at 0x58 ADCLK; /* Analog-to-Digital Clock */
	#define ADIV2  ((struct __hc08_bits *)(&ADCLK))->bit7
	#define ADIV1  ((struct __hc08_bits *)(&ADCLK))->bit6
	#define ADIV0  ((struct __hc08_bits *)(&ADCLK))->bit5
	#define ADICLK ((struct __hc08_bits *)(&ADCLK))->bit4
	#define ADMODE1  ((struct __hc08_bits *)(&ADCLK))->bit3
	#define ADMODE0  ((struct __hc08_bits *)(&ADCLK))->bit2
	
_VOLDATA _UINT8 __at 0x59 ADRH0;   /* Analog-to-Digital Data Register  */
_VOLDATA _UINT8 __at 0x5a ADRL0;   /* Analog-to-Digital Data Register  */
_VOLDATA _UINT8 __at 0x5b ADRL1;   /* Analog-to-Digital Data Register  */
_VOLDATA _UINT8 __at 0x5c ADRL2;   /* Analog-to-Digital Data Register  */
_VOLDATA _UINT8 __at 0x5d ADRL3;   /* Analog-to-Digital Data Register  */

_VOLDATA _UINT8 __at 0x5e ADASCR; /* ADC Auto Scan Control */
	#define ASCAN  ((struct __hc08_bits *)(&ADCLK))->bit0
	#define AUTO0  ((struct __hc08_bits *)(&ADCLK))->bit1
	#define AUTO1  ((struct __hc08_bits *)(&ADCLK))->bit2


_VOLXDATA _UINT8 __at 0xfe00 SBSR;     /* SIM Break Status Register */
  #define SBSW ((struct __hc08_bits *)(&SBSR))->bit1

_VOLXDATA _UINT8 __at 0xfe01 SRSR;    /* SIM Reset Status Register */
  #define LVI    ((struct __hc08_bits *)(&SRSR))->bit1
  #define MODRST ((struct __hc08_bits *)(&SRSR))->bit2
  #define ILAD   ((struct __hc08_bits *)(&SRSR))->bit3
  #define ILOP   ((struct __hc08_bits *)(&SRSR))->bit4
  #define COP    ((struct __hc08_bits *)(&SRSR))->bit5
  #define PIN    ((struct __hc08_bits *)(&SRSR))->bit6
  #define POR    ((struct __hc08_bits *)(&SRSR))->bit7
  /* Bit 0 unimplemented */

	
_VOLXDATA _UINT8 __at 0xfe03 SBFCR;    /* SIM Break Flag Control Register */
  #define BFCE ((struct __hc08_bits *)(&BFCR))->bit7

_VOLXDATA _UINT8 __at 0xfe04 INT1;    /* Interrupt Status Register 1 */
  #define IF1 ((struct __hc08_bits *)(&INT1))->bit2
  #define IF2 ((struct __hc08_bits *)(&INT1))->bit3
  #define IF3 ((struct __hc08_bits *)(&INT1))->bit4
  #define IF4 ((struct __hc08_bits *)(&INT1))->bit5
  #define IF5 ((struct __hc08_bits *)(&INT1))->bit6
  #define IF6 ((struct __hc08_bits *)(&INT1))->bit7
	/* Bits 0-1 Reserved */
	
_VOLXDATA _UINT8 __at 0xfe05 INT2;  /* Interrupt Status Register 2 */
        #define IF14 ((struct __hc08_bits *)(&INT2))->bit7
	#define IF13 ((struct __hc08_bits *)(&INT2))->bit6	
	#define IF12 ((struct __hc08_bits *)(&INT2))->bit5
	#define IF11 ((struct __hc08_bits *)(&INT2))->bit4	
	#define IF10 ((struct __hc08_bits *)(&INT2))->bit3
	#define IF9 ((struct __hc08_bits *)(&INT2))->bit2
	#define IF8 ((struct __hc08_bits *)(&INT2))->bit1
	#define IF7 ((struct __hc08_bits *)(&INT2))->bit0	
		
_VOLXDATA _UINT8 __at 0xfe06 INT3;  /* Interrupt Status Register 3 */
	#define IF21 ((struct __hc08_bits *)(&INT3))->bit6	
        #define IF20 ((struct __hc08_bits *)(&INT3))->bit5	
	#define IF19 ((struct __hc08_bits *)(&INT3))->bit4	
        #define IF18 ((struct __hc08_bits *)(&INT3))->bit3	
	#define IF17 ((struct __hc08_bits *)(&INT3))->bit2	
        #define IF16 ((struct __hc08_bits *)(&INT3))->bit1	
	#define IF15 ((struct __hc08_bits *)(&INT3))->bit0	
	
_VOLXDATA _UINT8 __at 0xfe08 FLCR;    /* FLASH Control Register */
  #define PGM   ((struct __hc08_bits *)(&FLCR))->bit0
  #define ERASE ((struct __hc08_bits *)(&FLCR))->bit1
  #define MASS  ((struct __hc08_bits *)(&FLCR))->bit2
  #define HVEN  ((struct __hc08_bits *)(&FLCR))->bit3

	
_VOLXDATA _UINT8 __at 0xfe09 FLBPR;    /* FLASH Block Protect Register */
  #define BPR0 ((struct __hc08_bits *)(&FLBPR))->bit0
  #define BPR1 ((struct __hc08_bits *)(&FLBPR))->bit1
  #define BPR2 ((struct __hc08_bits *)(&FLBPR))->bit2
  #define BPR3 ((struct __hc08_bits *)(&FLBPR))->bit3
  #define BPR4 ((struct __hc08_bits *)(&FLBPR))->bit4
  #define BPR5 ((struct __hc08_bits *)(&FLBPR))->bit5
  #define BPR6 ((struct __hc08_bits *)(&FLBPR))->bit6
  #define BPR7 ((struct __hc08_bits *)(&FLBPR))->bit7

		
_VOLXDATA _UINT16 __at 0xfe0C BRK;    /* Break Address High & Low Registers */
_VOLXDATA _UINT8 __at 0xfe0C BRKH;    /* Break Address High Register */
_VOLXDATA _UINT8 __at 0xfe0D BRKL;    /* Break Address Low Register */	
	
_VOLXDATA _UINT8 __at 0xfe0b BRKSCR;  /* Break Status and Control Register */
  #define BRKA ((struct __hc08_bits *)(&BRKSCR))->bit6
  #define BRKE ((struct __hc08_bits *)(&BRKSCR))->bit7	

_VOLXDATA _UINT8 __at 0xfe0c LVISR;   /* Low voltage detect */
	#define LVIOUT ((struct __hc08_bits *)(&LVISR))->bit7
	

_VOLXDATA _UINT8 __at 0xffff COPCTL;  /* COP Control Register */

#endif
/*-------------------------------------------------------------------------
   mc68hc908jb8.h - Register Declarations for Motorola MC68HC908JB8

   Copyright (C) 2004, Bjorn Bringert <bjorn@bringert.net>
   Based on mc68hc908qy.h,
     written By - Erik Petrich epetrich@users.sourceforge.net (2003)

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/


#ifndef _MC68HC908JB8_H
#define _MC68HC908JB8_H

#ifndef _UINT8
 #define _UINT8 unsigned char
#endif
#ifndef _UINT16
 #define _UINT16 unsigned int
#endif
#ifndef _VOLDATA
 #define _VOLDATA volatile __data
#endif
#ifndef _VOLXDATA
 #define _VOLXDATA volatile __xdata
#endif

struct __hc08_bits
{
  unsigned int bit0:1;
  unsigned int bit1:1;
  unsigned int bit2:1;
  unsigned int bit3:1;
  unsigned int bit4:1;
  unsigned int bit5:1;
  unsigned int bit6:1;
  unsigned int bit7:1;
};


_VOLDATA _UINT8 __at 0x00 PTA;     /* Port A Data Register */
  #define PTA0 ((struct __hc08_bits *)(&PTA))->bit0
  #define PTA1 ((struct __hc08_bits *)(&PTA))->bit1
  #define PTA2 ((struct __hc08_bits *)(&PTA))->bit2
  #define PTA3 ((struct __hc08_bits *)(&PTA))->bit3
  #define PTA4 ((struct __hc08_bits *)(&PTA))->bit4
  #define PTA5 ((struct __hc08_bits *)(&PTA))->bit5
  #define PTA6 ((struct __hc08_bits *)(&PTA))->bit6
  #define PTA7 ((struct __hc08_bits *)(&PTA))->bit7

_VOLDATA _UINT8 __at 0x01 PTB;     /* Port B Data Register */
  #define PTB0 ((struct __hc08_bits *)(&PTB))->bit0
  #define PTB1 ((struct __hc08_bits *)(&PTB))->bit1
  #define PTB2 ((struct __hc08_bits *)(&PTB))->bit2
  #define PTB3 ((struct __hc08_bits *)(&PTB))->bit3
  #define PTB4 ((struct __hc08_bits *)(&PTB))->bit4
  #define PTB5 ((struct __hc08_bits *)(&PTB))->bit5
  #define PTB6 ((struct __hc08_bits *)(&PTB))->bit6
  #define PTB7 ((struct __hc08_bits *)(&PTB))->bit7

_VOLDATA _UINT8 __at 0x02 PTC;     /* Port C Data Register */
  #define PTC0 ((struct __hc08_bits *)(&PTC))->bit0
  #define PTC1 ((struct __hc08_bits *)(&PTC))->bit1
  #define PTC2 ((struct __hc08_bits *)(&PTC))->bit2
  #define PTC3 ((struct __hc08_bits *)(&PTC))->bit3
  #define PTC4 ((struct __hc08_bits *)(&PTC))->bit4
  #define PTC5 ((struct __hc08_bits *)(&PTC))->bit5
  #define PTC6 ((struct __hc08_bits *)(&PTC))->bit6
  #define PTC7 ((struct __hc08_bits *)(&PTC))->bit7

_VOLDATA _UINT8 __at 0x03 PTD;     /* Port D Data Register */
  #define PTD0 ((struct __hc08_bits *)(&PTD))->bit0
  #define PTD1 ((struct __hc08_bits *)(&PTD))->bit1
  #define PTD2 ((struct __hc08_bits *)(&PTD))->bit2
  #define PTD3 ((struct __hc08_bits *)(&PTD))->bit3
  #define PTD4 ((struct __hc08_bits *)(&PTD))->bit4
  #define PTD5 ((struct __hc08_bits *)(&PTD))->bit5
  #define PTD6 ((struct __hc08_bits *)(&PTD))->bit6
  #define PTD7 ((struct __hc08_bits *)(&PTD))->bit7

_VOLDATA _UINT8 __at 0x04 DDRA;    /* Data Direction Register A */
  #define DDRA0 ((struct __hc08_bits *)(&DDRA))->bit0
  #define DDRA1 ((struct __hc08_bits *)(&DDRA))->bit1
  #define DDRA2 ((struct __hc08_bits *)(&DDRA))->bit2
  #define DDRA3 ((struct __hc08_bits *)(&DDRA))->bit3
  #define DDRA4 ((struct __hc08_bits *)(&DDRA))->bit4
  #define DDRA5 ((struct __hc08_bits *)(&DDRA))->bit5
  #define DDRA6 ((struct __hc08_bits *)(&DDRA))->bit6
  #define DDRA7 ((struct __hc08_bits *)(&DDRA))->bit7

_VOLDATA _UINT8 __at 0x05 DDRB;    /* Data Direction Register B */
  #define DDRB0 ((struct __hc08_bits *)(&DDRB))->bit0
  #define DDRB1 ((struct __hc08_bits *)(&DDRB))->bit1
  #define DDRB2 ((struct __hc08_bits *)(&DDRB))->bit2
  #define DDRB3 ((struct __hc08_bits *)(&DDRB))->bit3
  #define DDRB4 ((struct __hc08_bits *)(&DDRB))->bit4
  #define DDRB5 ((struct __hc08_bits *)(&DDRB))->bit5
  #define DDRB6 ((struct __hc08_bits *)(&DDRB))->bit6
  #define DDRB7 ((struct __hc08_bits *)(&DDRB))->bit7

_VOLDATA _UINT8 __at 0x06 DDRC;    /* Data Direction Register C */
  #define DDRC0 ((struct __hc08_bits *)(&DDRC))->bit0
  #define DDRC1 ((struct __hc08_bits *)(&DDRC))->bit1
  #define DDRC2 ((struct __hc08_bits *)(&DDRC))->bit2
  #define DDRC3 ((struct __hc08_bits *)(&DDRC))->bit3
  #define DDRC4 ((struct __hc08_bits *)(&DDRC))->bit4
  #define DDRC5 ((struct __hc08_bits *)(&DDRC))->bit5
  #define DDRC6 ((struct __hc08_bits *)(&DDRC))->bit6
  #define DDRC7 ((struct __hc08_bits *)(&DDRC))->bit7

_VOLDATA _UINT8 __at 0x07 DDRD;    /* Data Direction Register D */
  #define DDRD0 ((struct __hc08_bits *)(&DDRD))->bit0
  #define DDRD1 ((struct __hc08_bits *)(&DDRD))->bit1
  #define DDRD2 ((struct __hc08_bits *)(&DDRD))->bit2
  #define DDRD3 ((struct __hc08_bits *)(&DDRD))->bit3
  #define DDRD4 ((struct __hc08_bits *)(&DDRD))->bit4
  #define DDRD5 ((struct __hc08_bits *)(&DDRD))->bit5
  #define DDRD6 ((struct __hc08_bits *)(&DDRD))->bit6
  #define DDRD7 ((struct __hc08_bits *)(&DDRD))->bit7

_VOLDATA _UINT8 __at 0x08 PTE;     /* Port E Data Register */
  #define PTE0 ((struct __hc08_bits *)(&PTE))->bit0
  #define PTE1 ((struct __hc08_bits *)(&PTE))->bit1
  #define PTE2 ((struct __hc08_bits *)(&PTE))->bit2
  #define PTE3 ((struct __hc08_bits *)(&PTE))->bit3
  #define PTE4 ((struct __hc08_bits *)(&PTE))->bit4
  #define PTE5 ((struct __hc08_bits *)(&PTE))->bit5
  #define PTE6 ((struct __hc08_bits *)(&PTE))->bit6
  #define PTE7 ((struct __hc08_bits *)(&PTE))->bit7

_VOLDATA _UINT8 __at 0x09 DDRE;    /* Data Direction Register E */
  #define DDRE0 ((struct __hc08_bits *)(&DDRE))->bit0
  #define DDRE1 ((struct __hc08_bits *)(&DDRE))->bit1
  #define DDRE2 ((struct __hc08_bits *)(&DDRE))->bit2
  #define DDRE3 ((struct __hc08_bits *)(&DDRE))->bit3
  #define DDRE4 ((struct __hc08_bits *)(&DDRE))->bit4
  #define DDRE5 ((struct __hc08_bits *)(&DDRE))->bit5
  #define DDRE6 ((struct __hc08_bits *)(&DDRE))->bit6
  #define DDRE7 ((struct __hc08_bits *)(&DDRE))->bit7

_VOLDATA _UINT8 __at 0x0a TSC;     /* TIM Status and Control */
  #define PS0   ((struct __hc08_bits *)(&TSC))->bit0
  #define PS1   ((struct __hc08_bits *)(&TSC))->bit1
  #define PS2   ((struct __hc08_bits *)(&TSC))->bit2
  #define TRST  ((struct __hc08_bits *)(&TSC))->bit4
  #define TSTOP ((struct __hc08_bits *)(&TSC))->bit5
  #define TOIE  ((struct __hc08_bits *)(&TSC))->bit6
  #define TOF   ((struct __hc08_bits *)(&TSC))->bit7

_VOLDATA _UINT16 __at 0x0c TCNT;   /* TIM Counter High & Low Registers */
_VOLDATA _UINT8 __at 0x0c TCNTH;   /* TIM Counter Register High */
_VOLDATA _UINT8 __at 0x0d TCNTL;   /* TIM Counter Register Low */

_VOLDATA _UINT16 __at 0x0e TMOD;   /* TIM Counter Modulo High & Low Registers */
_VOLDATA _UINT8 __at 0x0e TMODH;   /* TIM Counter Modulo Register High */
_VOLDATA _UINT8 __at 0x0f TMODL;   /* TIM Counter Modulo Register Low */

_VOLDATA _UINT8 __at 0x10 TSC0;    /* TIM Channel 0 Status and Control Register */
  #define CH0MAX ((struct __hc08_bits *)(&TSC0))->bit0
  #define TOV0   ((struct __hc08_bits *)(&TSC0))->bit1
  #define ELS0A  ((struct __hc08_bits *)(&TSC0))->bit2
  #define ELS0B  ((struct __hc08_bits *)(&TSC0))->bit3
  #define MS0A   ((struct __hc08_bits *)(&TSC0))->bit4
  #define MS0B   ((struct __hc08_bits *)(&TSC0))->bit5
  #define CH0IE  ((struct __hc08_bits *)(&TSC0))->bit6
  #define CH0F   ((struct __hc08_bits *)(&TSC0))->bit7

_VOLDATA _UINT16 __at 0x11 TCH0;   /* TIM Channel 0 High & Low Registers */
_VOLDATA _UINT8 __at 0x11 TCH0H;   /* TIM Channel 0 Register High */
_VOLDATA _UINT8 __at 0x12 TCH0L;   /* TIM Channel 0 Register Low */

_VOLDATA _UINT8 __at 0x13 TSC1;    /* TIM Channel 1 Status and Control Register */
  #define CH1MAX ((struct __hc08_bits *)(&TSC1))->bit0
  #define TOV1   ((struct __hc08_bits *)(&TSC1))->bit1
  #define ELS1A  ((struct __hc08_bits *)(&TSC1))->bit2
  #define ELS1B  ((struct __hc08_bits *)(&TSC1))->bit3
  #define MS1A   ((struct __hc08_bits *)(&TSC1))->bit4
  #define CH1IE  ((struct __hc08_bits *)(&TSC1))->bit6
  #define CH1F   ((struct __hc08_bits *)(&TSC1))->bit7

_VOLDATA _UINT16 __at 0x14 TCH1;   /* TIM Channel 1 High & Low Registers */
_VOLDATA _UINT8 __at 0x14 TCH1H;   /* TIM Channel 1 Register High */
_VOLDATA _UINT8 __at 0x15 TCH1L;   /* TIM Channel 1 Register Low */

_VOLDATA _UINT8 __at 0x16 KBSCR;   /* Keyboard Status and Control Register */
  #define MODEK  ((struct __hc08_bits *)(&KBSCR))->bit0
  #define IMASKK ((struct __hc08_bits *)(&KBSCR))->bit1
  #define ACKK   ((struct __hc08_bits *)(&KBSCR))->bit2
  #define KEYF   ((struct __hc08_bits *)(&KBSCR))->bit3

_VOLDATA _UINT8 __at 0x17 KBIER;   /* Keyboard Interrupt Enable Register */
  #define KBIE0 ((struct __hc08_bits *)(&KBIER))->bit0
  #define KBIE1 ((struct __hc08_bits *)(&KBIER))->bit1
  #define KBIE2 ((struct __hc08_bits *)(&KBIER))->bit2
  #define KBIE3 ((struct __hc08_bits *)(&KBIER))->bit3
  #define KBIE4 ((struct __hc08_bits *)(&KBIER))->bit4
  #define KBIE5 ((struct __hc08_bits *)(&KBIER))->bit5
  #define KBIE6 ((struct __hc08_bits *)(&KBIER))->bit6
  #define KBIE7 ((struct __hc08_bits *)(&KBIER))->bit7

_VOLDATA _UINT8 __at 0x18 UIR2;   /* USB Interrupt Register 2 */
  #define RXD0FR  ((struct __hc08_bits *)(&UIR2))->bit0
  #define TXD0FR  ((struct __hc08_bits *)(&UIR2))->bit1
  #define RESUMFR ((struct __hc08_bits *)(&UIR2))->bit2
  #define TXD1FR  ((struct __hc08_bits *)(&UIR2))->bit3
  #define RXD2FR  ((struct __hc08_bits *)(&UIR2))->bit4
  #define TXD2FR  ((struct __hc08_bits *)(&UIR2))->bit5
  #define RSTFR   ((struct __hc08_bits *)(&UIR2))->bit6
  #define EOPFR   ((struct __hc08_bits *)(&UIR2))->bit7

_VOLDATA _UINT8 __at 0x19 UCR2;   /* USB Control Register 2 */
  #define TP2SIZ0 ((struct __hc08_bits *)(&UCR2))->bit0
  #define TP2SIZ1 ((struct __hc08_bits *)(&UCR2))->bit1
  #define TP2SIZ2 ((struct __hc08_bits *)(&UCR2))->bit2
  #define TP2SIZ3 ((struct __hc08_bits *)(&UCR2))->bit3
  #define RX2E    ((struct __hc08_bits *)(&UCR2))->bit4
  #define TX2E    ((struct __hc08_bits *)(&UCR2))->bit5
  #define STALL2  ((struct __hc08_bits *)(&UCR2))->bit6
  #define T2SEQ   ((struct __hc08_bits *)(&UCR2))->bit7

_VOLDATA _UINT8 __at 0x1a UCR3;   /* USB Control Register 3 */
  #define ENABLE1 ((struct __hc08_bits *)(&UCR3))->bit0
  #define ENABLE2 ((struct __hc08_bits *)(&UCR3))->bit1
  #define PULLEN  ((struct __hc08_bits *)(&UCR3))->bit2
  #define ISTALL0 ((struct __hc08_bits *)(&UCR3))->bit4
  #define OSTALL0 ((struct __hc08_bits *)(&UCR3))->bit5
  #define TX1STR  ((struct __hc08_bits *)(&UCR3))->bit6
  #define TX1ST   ((struct __hc08_bits *)(&UCR3))->bit7

_VOLDATA _UINT8 __at 0x1b UCR4;   /* USB Control Register 4 */
  #define FDM   ((struct __hc08_bits *)(&UCR4))->bit0
  #define FDP   ((struct __hc08_bits *)(&UCR4))->bit1
  #define FUSB0 ((struct __hc08_bits *)(&UCR4))->bit2

_VOLDATA _UINT8 __at 0x1c IOCR;   /* IRQ Option Control Register */
  #define IRQPD  ((struct __hc08_bits *)(&IOCR))->bit0
  #define PTE4IE ((struct __hc08_bits *)(&IOCR))->bit1
  #define PTE4IF ((struct __hc08_bits *)(&IOCR))->bit2

_VOLDATA _UINT8 __at 0x1d POCR;   /* Port Option Control Register */
 #define PAP     ((struct __hc08_bits *)(&POCR))->bit0
 #define PBP     ((struct __hc08_bits *)(&POCR))->bit1
 #define PCP     ((struct __hc08_bits *)(&POCR))->bit2
 #define PTE3P   ((struct __hc08_bits *)(&POCR))->bit3
 #define PTE4P   ((struct __hc08_bits *)(&POCR))->bit4
 #define PTDILDD ((struct __hc08_bits *)(&POCR))->bit5
 #define PTDLDD  ((struct __hc08_bits *)(&POCR))->bit6
 #define PTE20P  ((struct __hc08_bits *)(&POCR))->bit7

_VOLDATA _UINT8 __at 0x1e ISCR;   /* IRQ Status and Control Register */
  #define MODE  ((struct __hc08_bits *)(&ISCR))->bit0
  #define IMASK ((struct __hc08_bits *)(&ISCR))->bit1
  #define ACK   ((struct __hc08_bits *)(&ISCR))->bit2
  #define IRQF  ((struct __hc08_bits *)(&ISCR))->bit3

_VOLDATA _UINT8 __at 0x1f CONFIG; /* Configuration Register 1 */
/* CONFIG1 is one-time writeable, so can't use bitfields */

_VOLDATA _UINT8 __at 0x20 UE0D0;  /* USB Endpoint 0 Data Register 0 */
_VOLDATA _UINT8 __at 0x21 UE0D1;  /* USB Endpoint 0 Data Register 1 */
_VOLDATA _UINT8 __at 0x22 UE0D2;  /* USB Endpoint 0 Data Register 2 */
_VOLDATA _UINT8 __at 0x23 UE0D3;  /* USB Endpoint 0 Data Register 3 */
_VOLDATA _UINT8 __at 0x24 UE0D4;  /* USB Endpoint 0 Data Register 4 */
_VOLDATA _UINT8 __at 0x25 UE0D5;  /* USB Endpoint 0 Data Register 5 */
_VOLDATA _UINT8 __at 0x26 UE0D6;  /* USB Endpoint 0 Data Register 6 */
_VOLDATA _UINT8 __at 0x27 UE0D7;  /* USB Endpoint 0 Data Register 7 */

_VOLDATA _UINT8 __at 0x28 UE1D0;  /* USB Endpoint 1 Data Register 0 */
_VOLDATA _UINT8 __at 0x29 UE1D1;  /* USB Endpoint 1 Data Register 1 */
_VOLDATA _UINT8 __at 0x2a UE1D2;  /* USB Endpoint 1 Data Register 2 */
_VOLDATA _UINT8 __at 0x2b UE1D3;  /* USB Endpoint 1 Data Register 3 */
_VOLDATA _UINT8 __at 0x2c UE1D4;  /* USB Endpoint 1 Data Register 4 */
_VOLDATA _UINT8 __at 0x2d UE1D5;  /* USB Endpoint 1 Data Register 5 */
_VOLDATA _UINT8 __at 0x2e UE1D6;  /* USB Endpoint 1 Data Register 6 */
_VOLDATA _UINT8 __at 0x2f UE1D7;  /* USB Endpoint 1 Data Register 7 */

_VOLDATA _UINT8 __at 0x30 UE2D0;  /* USB Endpoint 2 Data Register 0 */
_VOLDATA _UINT8 __at 0x31 UE2D1;  /* USB Endpoint 2 Data Register 1 */
_VOLDATA _UINT8 __at 0x32 UE2D2;  /* USB Endpoint 2 Data Register 2 */
_VOLDATA _UINT8 __at 0x33 UE2D3;  /* USB Endpoint 2 Data Register 3 */
_VOLDATA _UINT8 __at 0x34 UE2D4;  /* USB Endpoint 2 Data Register 4 */
_VOLDATA _UINT8 __at 0x35 UE2D5;  /* USB Endpoint 2 Data Register 5 */
_VOLDATA _UINT8 __at 0x36 UE2D6;  /* USB Endpoint 2 Data Register 6 */
_VOLDATA _UINT8 __at 0x37 UE2D7;  /* USB Endpoint 2 Data Register 7 */

_VOLDATA _UINT8 __at 0x38 UADDR;  /* USB Address Register */
 #define USBEN ((struct __hc08_bits *)(&UADDR))->bit7

_VOLDATA _UINT8 __at 0x39 UIR0;   /* USB Interrupt Register 0 */
  #define RXD0IE  ((struct __hc08_bits *)(&UIR0))->bit0
  #define TXD0IE  ((struct __hc08_bits *)(&UIR0))->bit1
  #define TXD1IE  ((struct __hc08_bits *)(&UIR0))->bit3
  #define RXD2IE  ((struct __hc08_bits *)(&UIR0))->bit4
  #define TXD2IE  ((struct __hc08_bits *)(&UIR0))->bit5
  #define SUSPND  ((struct __hc08_bits *)(&UIR0))->bit6
  #define EOPIE   ((struct __hc08_bits *)(&UIR0))->bit7

_VOLDATA _UINT8 __at 0x3a UIR1;   /* USB Interrupt Register 1 */
  #define RXD0F   ((struct __hc08_bits *)(&UIR1))->bit0
  #define TXD0F   ((struct __hc08_bits *)(&UIR1))->bit1
  #define RESUMF  ((struct __hc08_bits *)(&UIR1))->bit2
  #define TXD1F   ((struct __hc08_bits *)(&UIR1))->bit3
  #define RXD2F   ((struct __hc08_bits *)(&UIR1))->bit4
  #define TXD2F   ((struct __hc08_bits *)(&UIR1))->bit5
  #define RSTF    ((struct __hc08_bits *)(&UIR1))->bit6
  #define EOPF    ((struct __hc08_bits *)(&UIR1))->bit7

_VOLDATA _UINT8 __at 0x3b UCR0;   /* USB Control Register 0 */
  #define TP0SIZ0 ((struct __hc08_bits *)(&UCR0))->bit0
  #define TP0SIZ1 ((struct __hc08_bits *)(&UCR0))->bit1
  #define TP0SIZ2 ((struct __hc08_bits *)(&UCR0))->bit2
  #define TP0SIZ3 ((struct __hc08_bits *)(&UCR0))->bit3
  #define RX0E    ((struct __hc08_bits *)(&UCR0))->bit4
  #define TX0E    ((struct __hc08_bits *)(&UCR0))->bit5
  #define T0SEQ   ((struct __hc08_bits *)(&UCR0))->bit7

_VOLDATA _UINT8 __at 0x3c UCR1;   /* USB Control Register 1 */
  #define TP1SIZ0 ((struct __hc08_bits *)(&UCR1))->bit0
  #define TP1SIZ1 ((struct __hc08_bits *)(&UCR1))->bit1
  #define TP1SIZ2 ((struct __hc08_bits *)(&UCR1))->bit2
  #define TP1SIZ3 ((struct __hc08_bits *)(&UCR1))->bit3
  #define FRESUM  ((struct __hc08_bits *)(&UCR1))->bit4
  #define TX1E    ((struct __hc08_bits *)(&UCR1))->bit5
  #define STALL1  ((struct __hc08_bits *)(&UCR1))->bit6
  #define T1SEQ   ((struct __hc08_bits *)(&UCR1))->bit7

_VOLDATA _UINT8 __at 0x3d USR0;   /* USB Status Register 0 */
  #define RP0SIZ0 ((struct __hc08_bits *)(&USR0))->bit0
  #define RP0SIZ1 ((struct __hc08_bits *)(&USR0))->bit1
  #define RP0SIZ2 ((struct __hc08_bits *)(&USR0))->bit2
  #define RP0SIZ3 ((struct __hc08_bits *)(&USR0))->bit3
  #define SETUP   ((struct __hc08_bits *)(&USR0))->bit6
  #define R0SEQ   ((struct __hc08_bits *)(&USR0))->bit7

_VOLDATA _UINT8 __at 0x3e USR1;   /* USB Status Register 1 */
  #define RP2SIZ0 ((struct __hc08_bits *)(&USR1))->bit0
  #define RP2SIZ1 ((struct __hc08_bits *)(&USR1))->bit1
  #define RP2SIZ2 ((struct __hc08_bits *)(&USR1))->bit2
  #define RP2SIZ3 ((struct __hc08_bits *)(&USR1))->bit3
  #define TXSTL   ((struct __hc08_bits *)(&USR1))->bit4
  #define TXNAK   ((struct __hc08_bits *)(&USR1))->bit5
  #define TXACK   ((struct __hc08_bits *)(&USR1))->bit6
  #define R2SEQ   ((struct __hc08_bits *)(&USR1))->bit7

_VOLXDATA _UINT8 __at 0xfe00 BSR;     /* Break Status Register */
  #define SBSW ((struct __hc08_bits *)(&BSR))->bit1

_VOLXDATA _UINT8 __at 0xfe01 RSR;    /* Reset Status Register */
  #define LVI  ((struct __hc08_bits *)(&RSR))->bit1
  #define USB  ((struct __hc08_bits *)(&RSR))->bit2
  #define ILAD ((struct __hc08_bits *)(&RSR))->bit3
  #define ILOP ((struct __hc08_bits *)(&RSR))->bit4
  #define COP  ((struct __hc08_bits *)(&RSR))->bit5
  #define PIN  ((struct __hc08_bits *)(&RSR))->bit6
  #define POR  ((struct __hc08_bits *)(&RSR))->bit7

_VOLXDATA _UINT8 __at 0xfe03 BFCR;    /* Break Flag Control Register */
  #define BFCE ((struct __hc08_bits *)(&BFCR))->bit7

_VOLXDATA _UINT8 __at 0xfe04 INT1;    /* Interrupt Status Register 1 */
  #define IF1 ((struct __hc08_bits *)(&INT1))->bit2
  #define IF2 ((struct __hc08_bits *)(&INT1))->bit3
  #define IF3 ((struct __hc08_bits *)(&INT1))->bit4
  #define IF4 ((struct __hc08_bits *)(&INT1))->bit5
  #define IF5 ((struct __hc08_bits *)(&INT1))->bit6
  #define IF6 ((struct __hc08_bits *)(&INT1))->bit7

_VOLXDATA _UINT8 __at 0xfe08 FLCR;    /* FLASH Control Register */
  #define PGM   ((struct __hc08_bits *)(&FLCR))->bit0
  #define ERASE ((struct __hc08_bits *)(&FLCR))->bit1
  #define MASS  ((struct __hc08_bits *)(&FLCR))->bit2
  #define HVEN  ((struct __hc08_bits *)(&FLCR))->bit3

_VOLXDATA _UINT8 __at 0xfe09 FLBPR;    /* FLASH Block Protect Register */
  #define BPR0 ((struct __hc08_bits *)(&FLBPR))->bit0
  #define BPR1 ((struct __hc08_bits *)(&FLBPR))->bit1
  #define BPR2 ((struct __hc08_bits *)(&FLBPR))->bit2
  #define BPR3 ((struct __hc08_bits *)(&FLBPR))->bit3
  #define BPR4 ((struct __hc08_bits *)(&FLBPR))->bit4
  #define BPR5 ((struct __hc08_bits *)(&FLBPR))->bit5
  #define BPR6 ((struct __hc08_bits *)(&FLBPR))->bit6
  #define BPR7 ((struct __hc08_bits *)(&FLBPR))->bit7

_VOLXDATA _UINT16 __at 0xfe0c BRK;    /* Break Address High & Low Registers */
_VOLXDATA _UINT8 __at 0xfe0c BRKH;    /* Break Address High Register */
_VOLXDATA _UINT8 __at 0xfe0d BRKL;    /* Break Address Low Register */

_VOLXDATA _UINT8 __at 0xfe0e BRKSCR;  /* Break Status and Control Register */
  #define BRKA ((struct __hc08_bits *)(&BRKSCR))->bit6
  #define BRKE ((struct __hc08_bits *)(&BRKSCR))->bit7

_VOLXDATA _UINT8 __at 0xffff COPCTL;  /* COP Control Register */

#endif
/*-------------------------------------------------------------------------
   mc68hc908qy.h - Register Declarations for Motorola MC68HC908QY & MC68HC908QT
  
   Copyright (C) 2003, Erik Petrich epetrich@users.sourceforge.net

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef _MC68HC908QY_H
#define _MC68HC908QY_H

#ifndef _UINT8
 #define _UINT8 unsigned char
#endif
#ifndef _UINT16
 #define _UINT16 unsigned int
#endif
#ifndef _VOLDATA
 #define _VOLDATA volatile __data
#endif
#ifndef _VOLXDATA
 #define _VOLXDATA volatile __xdata
#endif

struct __hc08_bits
{
  unsigned int bit0:1;
  unsigned int bit1:1;
  unsigned int bit2:1;
  unsigned int bit3:1;
  unsigned int bit4:1;
  unsigned int bit5:1;
  unsigned int bit6:1;
  unsigned int bit7:1;
};
  

_VOLDATA _UINT8 __at 0x00 PTA;     /* Port A Data Register */
  #define PTA0 ((struct __hc08_bits *)(&PTA))->bit0
  #define PTA1 ((struct __hc08_bits *)(&PTA))->bit1
  #define PTA2 ((struct __hc08_bits *)(&PTA))->bit2
  #define PTA3 ((struct __hc08_bits *)(&PTA))->bit3
  #define PTA4 ((struct __hc08_bits *)(&PTA))->bit4
  #define PTA5 ((struct __hc08_bits *)(&PTA))->bit5
  #define AWUL ((struct __hc08_bits *)(&PTA))->bit6
  
_VOLDATA _UINT8 __at 0x01 PTB;     /* Port B Data Register */
  #define PTB0 ((struct __hc08_bits *)(&PTB))->bit0
  #define PTB1 ((struct __hc08_bits *)(&PTB))->bit1
  #define PTB2 ((struct __hc08_bits *)(&PTB))->bit2
  #define PTB3 ((struct __hc08_bits *)(&PTB))->bit3
  #define PTB4 ((struct __hc08_bits *)(&PTB))->bit4
  #define PTB5 ((struct __hc08_bits *)(&PTB))->bit5
  #define PTB6 ((struct __hc08_bits *)(&PTB))->bit6
  #define PTB7 ((struct __hc08_bits *)(&PTB))->bit7

_VOLDATA _UINT8 __at 0x04 DDRA;    /* Data Direction Register A */
  #define DDRA0 ((struct __hc08_bits *)(&DDRA))->bit0
  #define DDRA1 ((struct __hc08_bits *)(&DDRA))->bit1
  #define DDRA3 ((struct __hc08_bits *)(&DDRA))->bit3
  #define DDRA4 ((struct __hc08_bits *)(&DDRA))->bit4
  #define DDRA5 ((struct __hc08_bits *)(&DDRA))->bit5

_VOLDATA _UINT8 __at 0x05 DDRB;    /* Data Direction Register B */
  #define DDRB0 ((struct __hc08_bits *)(&DDRB))->bit0
  #define DDRB1 ((struct __hc08_bits *)(&DDRB))->bit1
  #define DDRB2 ((struct __hc08_bits *)(&DDRB))->bit2
  #define DDRB3 ((struct __hc08_bits *)(&DDRB))->bit3
  #define DDRB4 ((struct __hc08_bits *)(&DDRB))->bit4
  #define DDRB5 ((struct __hc08_bits *)(&DDRB))->bit5
  #define DDRB6 ((struct __hc08_bits *)(&DDRB))->bit6
  #define DDRB7 ((struct __hc08_bits *)(&DDRB))->bit7

_VOLDATA _UINT8 __at 0x0b PTAPUE;  /* Port A Input Pullup Enable Register */
  #define PTAPUE0 ((struct __hc08_bits *)(&PTAPUE))->bit0
  #define PTAPUE1 ((struct __hc08_bits *)(&PTAPUE))->bit1
  #define PTAPUE2 ((struct __hc08_bits *)(&PTAPUE))->bit2
  #define PTAPUE3 ((struct __hc08_bits *)(&PTAPUE))->bit3
  #define PTAPUE4 ((struct __hc08_bits *)(&PTAPUE))->bit4
  #define PTAPUE5 ((struct __hc08_bits *)(&PTAPUE))->bit5
  #define OSC2EN ((struct __hc08_bits *)(&PTAPUE))->bit7

_VOLDATA _UINT8 __at 0x0c PTBPUE;  /* Port B Input Pullup Enable Register */
  #define PTBPUE0 ((struct __hc08_bits *)(&PTBPUE))->bit0
  #define PTBPUE1 ((struct __hc08_bits *)(&PTBPUE))->bit1
  #define PTBPUE2 ((struct __hc08_bits *)(&PTBPUE))->bit2
  #define PTBPUE3 ((struct __hc08_bits *)(&PTBPUE))->bit3
  #define PTBPUE4 ((struct __hc08_bits *)(&PTBPUE))->bit4
  #define PTBPUE5 ((struct __hc08_bits *)(&PTBPUE))->bit5
  #define PTBPUE6 ((struct __hc08_bits *)(&PTBPUE))->bit6
  #define PTBPUE7 ((struct __hc08_bits *)(&PTBPUE))->bit7

_VOLDATA _UINT8 __at 0x1a KBSCR;   /* Keyboard Status and Control Register */
  #define MODEK ((struct __hc08_bits *)(&KBSCR))->bit0
  #define IMASKK ((struct __hc08_bits *)(&KBSCR))->bit1
  #define ACKK ((struct __hc08_bits *)(&KBSCR))->bit2
  #define KEYF ((struct __hc08_bits *)(&KBSCR))->bit3

_VOLDATA _UINT8 __at 0x1b KBIER;   /* Keyboard Interrupt Enable Register */
  #define KBIE0 ((struct __hc08_bits *)(&KBIER))->bit0
  #define KBIE1 ((struct __hc08_bits *)(&KBIER))->bit1
  #define KBIE2 ((struct __hc08_bits *)(&KBIER))->bit2
  #define KBIE3 ((struct __hc08_bits *)(&KBIER))->bit3
  #define KBIE4 ((struct __hc08_bits *)(&KBIER))->bit4
  #define KBIE5 ((struct __hc08_bits *)(&KBIER))->bit5
  #define AWUIE ((struct __hc08_bits *)(&KBIER))->bit6

_VOLDATA _UINT8 __at 0x1d INTSCR;  /* IRQ Status and Control Register */
  #define MODE1 ((struct __hc08_bits *)(&INTSCR))->bit0
  #define IMASK1 ((struct __hc08_bits *)(&INTSCR))->bit1
  #define ACK1 ((struct __hc08_bits *)(&INTSCR))->bit2
  #define IRQF1 ((struct __hc08_bits *)(&INTSCR))->bit3

_VOLDATA _UINT8 __at 0x1e CONFIG2; /* Configuration Register 2 */
/* CONFIG2 is one-time writeable, so can't use bitfields */

_VOLDATA _UINT8 __at 0x1f CONFIG1; /* Configuration Register 1 */
/* CONFIG1 is one-time writeable, so can't use bitfields */

_VOLDATA _UINT8 __at 0x20 TSC;     /* TIM Status and Control */
  #define PS0 ((struct __hc08_bits *)(&TSC))->bit0
  #define PS1 ((struct __hc08_bits *)(&TSC))->bit1
  #define PS2 ((struct __hc08_bits *)(&TSC))->bit2
  #define TRST ((struct __hc08_bits *)(&TSC))->bit4
  #define TSTOP ((struct __hc08_bits *)(&TSC))->bit5
  #define TOIE ((struct __hc08_bits *)(&TSC))->bit6
  #define TOF ((struct __hc08_bits *)(&TSC))->bit7

_VOLDATA _UINT8 __at 0x21 TCNTH;   /* TIM Counter Register High */
_VOLDATA _UINT8 __at 0x22 TCNTL;   /* TIM Counter Register Low */
_VOLDATA _UINT16 __at 0x21 TCNT;   /* TIM Counter High & Low Registers */

_VOLDATA _UINT8 __at 0x23 TMODH;   /* TIM Counter Modulo Register High */
_VOLDATA _UINT8 __at 0x24 TMODL;   /* TIM Counter Modulo Register Low */
_VOLDATA _UINT16 __at 0x23 TMOD;   /* TIM Counter Modulo High & Low Registers */

_VOLDATA _UINT8 __at 0x25 TSC0;    /* TIM Channel 0 Status and Control Register */
  #define CH0MAX ((struct __hc08_bits *)(&TSC0))->bit0
  #define TOV0 ((struct __hc08_bits *)(&TSC0))->bit1
  #define ELS0A ((struct __hc08_bits *)(&TSC0))->bit2
  #define ELS0B ((struct __hc08_bits *)(&TSC0))->bit3
  #define MS0A ((struct __hc08_bits *)(&TSC0))->bit4
  #define MS0B ((struct __hc08_bits *)(&TSC0))->bit5
  #define CH0IE ((struct __hc08_bits *)(&TSC0))->bit6
  #define CH0F ((struct __hc08_bits *)(&TSC0))->bit7

_VOLDATA _UINT8 __at 0x26 TCH0H;   /* TIM Channel 0 Register High */
_VOLDATA _UINT8 __at 0x27 TCH0L;   /* TIM Channel 0 Register Low */
_VOLDATA _UINT16 __at 0x26 TCH0;   /* TIM Channel 0 High & Low Registers */

_VOLDATA _UINT8 __at 0x28 TSC1;    /* TIM Channel 1 Status and Control Register */
  #define CH1MAX ((struct __hc08_bits *)(&TSC1))->bit0
  #define TOV1 ((struct __hc08_bits *)(&TSC1))->bit1
  #define ELS1A ((struct __hc08_bits *)(&TSC1))->bit2
  #define ELS1B ((struct __hc08_bits *)(&TSC1))->bit3
  #define MS1A ((struct __hc08_bits *)(&TSC1))->bit4
  #define MS1B ((struct __hc08_bits *)(&TSC1))->bit5
  #define CH1IE ((struct __hc08_bits *)(&TSC1))->bit6
  #define CH1F ((struct __hc08_bits *)(&TSC1))->bit7

_VOLDATA _UINT8 __at 0x29 TCH1H;   /* TIM Channel 1 Register High */
_VOLDATA _UINT8 __at 0x2a TCH1L;   /* TIM Channel 1 Register Low */
_VOLDATA _UINT16 __at 0x29 TCH1;   /* TIM Channel 1 High & Low Registers */

_VOLDATA _UINT8 __at 0x36 OSCSTAT; /* Oscillator Status Register */
  #define ECGST ((struct __hc08_bits *)(&OSCSTAT))->bit0
  #define ECGON ((struct __hc08_bits *)(&OSCSTAT))->bit1

_VOLDATA _UINT8 __at 0x38 OSCTRIM; /* Oscillator Trim Register */

_VOLDATA _UINT8 __at 0x3c ADSCR;   /* ADC Status and Control Register */
  #define CH0 ((struct __hc08_bits *)(&ADSCR))->bit0
  #define CH1 ((struct __hc08_bits *)(&ADSCR))->bit1
  #define CH2 ((struct __hc08_bits *)(&ADSCR))->bit2
  #define CH3 ((struct __hc08_bits *)(&ADSCR))->bit3
  #define CH4 ((struct __hc08_bits *)(&ADSCR))->bit4
  #define ADC0 ((struct __hc08_bits *)(&ADSCR))->bit5
  #define AIEN ((struct __hc08_bits *)(&ADSCR))->bit6
  #define COCO ((struct __hc08_bits *)(&ADSCR))->bit7

_VOLDATA _UINT8 __at 0x3e ADR;     /* ADC Data Register */

_VOLDATA _UINT8 __at 0x3f ADICLK;  /* ADS Input Clock Register */
  #define ADIV0 ((struct __hc08_bits *)(&ADICLK))->bit5
  #define ADIV1 ((struct __hc08_bits *)(&ADICLK))->bit6
  #define ADIV2 ((struct __hc08_bits *)(&ADICLK))->bit7

_VOLXDATA _UINT8 __at 0xfe00 BSR;     /* Break Status Register */
  #define SBSW ((struct __hc08_bits *)(&BSR))->bit1
  
_VOLXDATA _UINT8 __at 0xfe01 SRSR;    /* SIM Reset Status Register */
  #define LVI ((struct __hc08_bits *)(&SRSR))->bit1
  #define MODRST ((struct __hc08_bits *)(&SRSR))->bit2
  #define ILAD ((struct __hc08_bits *)(&SRSR))->bit3
  #define ILOP ((struct __hc08_bits *)(&SRSR))->bit4
  #define COP ((struct __hc08_bits *)(&SRSR))->bit5
  #define PIN ((struct __hc08_bits *)(&SRSR))->bit6
  #define POR ((struct __hc08_bits *)(&SRSR))->bit7
  
_VOLXDATA _UINT8 __at 0xfe02 BRKAR;   /* Break Auxilliary Register */
  #define BDCOP ((struct __hc08_bits *)(&BRKAR))->bit0

_VOLXDATA _UINT8 __at 0xfe03 BFCF;    /* Break Flag Control Register */
  #define BFCF ((struct __hc08_bits *)(&BFCF))->bit7

_VOLXDATA _UINT8 __at 0xfe04 INT1;    /* Interrupt Status Register 1 */
  #define IF1 ((struct __hc08_bits *)(&INT1))->bit2
  #define IF3 ((struct __hc08_bits *)(&INT1))->bit4
  #define IF4 ((struct __hc08_bits *)(&INT1))->bit5
  #define IF5 ((struct __hc08_bits *)(&INT1))->bit6

_VOLXDATA _UINT8 __at 0xfe05 INT2;    /* Interrupt Status Register 2 */
  #define IF14 ((struct __hc08_bits *)(&INT2))->bit7

_VOLXDATA _UINT8 __at 0xfe06 INT3;    /* Interrupt Status Register 3 */
  #define IF15 ((struct __hc08_bits *)(&INT3))->bit0

_VOLXDATA _UINT8 __at 0xfe08 FLCR;    /* FLASH Control Register */
  #define PGM ((struct __hc08_bits *)(&FLCR))->bit0
  #define ERASE ((struct __hc08_bits *)(&FLCR))->bit1
  #define MASS ((struct __hc08_bits *)(&FLCR))->bit2
  #define HVEN ((struct __hc08_bits *)(&FLCR))->bit3

_VOLXDATA _UINT8 __at 0xfe09 BRKH;    /* Break Address High Register */
_VOLXDATA _UINT8 __at 0xfe0a BRKL;    /* Break Address Low Register */
_VOLXDATA _UINT16 __at 0xfe09 BRK;    /* Break Address High & Low Registers */

_VOLXDATA _UINT8 __at 0xfe0b BRKSCR;  /* Break Status and Control Register */
  #define BRKA ((struct __hc08_bits *)(&BRKSCR))->bit6
  #define BRKE ((struct __hc08_bits *)(&BRKSCR))->bit7

_VOLXDATA _UINT8 __at 0xfe0c LVISR;   /* LVI Status Register */
  #define LVIOUT ((struct __hc08_bits *)(&LVISR))->bit7

_VOLXDATA _UINT8 __at 0xffbe FLBPR;   /* FLASH Block Protect Register */
_VOLXDATA _UINT8 __at 0xffc0 OSCTRIMVAL; /* Oscillator Trim Value */
_VOLXDATA _UINT8 __at 0xffff COPCTL;  /* COP Control Register */


#endif

/*-------------------------------------------------------------------------
   mc68hc908gp.h - Register Declarations for Motorola MC68HC908GP32

   Copyright (C) 2004, Juan Gonzalez <juan@iearobotics.com>

   Based on mc68hc908qy.h,
     Written By - Erik Petrich epetrich@users.sourceforge.net (2003)

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef _MC68HC908GP32_H
#define _MC68HC908GP32_H

#ifndef _UINT8
 #define _UINT8 unsigned char
#endif
#ifndef _UINT16
 #define _UINT16 unsigned int
#endif
#ifndef _VOLDATA
 #define _VOLDATA volatile __data
#endif
#ifndef _VOLXDATA
 #define _VOLXDATA volatile __xdata
#endif

struct __hc08_bits
{
  unsigned int bit0:1;
  unsigned int bit1:1;
  unsigned int bit2:1;
  unsigned int bit3:1;
  unsigned int bit4:1;
  unsigned int bit5:1;
  unsigned int bit6:1;
  unsigned int bit7:1;
};


_VOLDATA _UINT8 __at 0x00 PTA;     /* Port A Data Register */
#define PORTA PTA		 /* Alias for PTA        */
  #define PTA0 ((struct __hc08_bits *)(&PTA))->bit0
  #define PTA1 ((struct __hc08_bits *)(&PTA))->bit1
  #define PTA2 ((struct __hc08_bits *)(&PTA))->bit2
  #define PTA3 ((struct __hc08_bits *)(&PTA))->bit3
  #define PTA4 ((struct __hc08_bits *)(&PTA))->bit4
  #define PTA5 ((struct __hc08_bits *)(&PTA))->bit5
  #define PTA6 ((struct __hc08_bits *)(&PTA))->bit6
  #define PTA7 ((struct __hc08_bits *)(&PTA))->bit7

_VOLDATA _UINT8 __at 0x01 PTB;     /* Port B Data Register */
#define PORTB PTB              /* Alias for PTB        */
  #define PTB0 ((struct __hc08_bits *)(&PTB))->bit0
  #define PTB1 ((struct __hc08_bits *)(&PTB))->bit1
  #define PTB2 ((struct __hc08_bits *)(&PTB))->bit2
  #define PTB3 ((struct __hc08_bits *)(&PTB))->bit3
  #define PTB4 ((struct __hc08_bits *)(&PTB))->bit4
  #define PTB5 ((struct __hc08_bits *)(&PTB))->bit5
  #define PTB6 ((struct __hc08_bits *)(&PTB))->bit6
  #define PTB7 ((struct __hc08_bits *)(&PTB))->bit7

_VOLDATA _UINT8 __at 0x02 PTC;     /* Port C Data Register */
#define PORTC PTC              /* Alias for PTC        */
  #define PTC0 ((struct __hc08_bits *)(&PTC))->bit0
  #define PTC1 ((struct __hc08_bits *)(&PTC))->bit1
  #define PTC2 ((struct __hc08_bits *)(&PTC))->bit2
  #define PTC3 ((struct __hc08_bits *)(&PTC))->bit3
  #define PTC4 ((struct __hc08_bits *)(&PTC))->bit4
  #define PTC5 ((struct __hc08_bits *)(&PTC))->bit5
  #define PTC6 ((struct __hc08_bits *)(&PTC))->bit6
  #define PTC7 ((struct __hc08_bits *)(&PTC))->bit7

_VOLDATA _UINT8 __at 0x03 PTD;     /* Port D Data Register */
#define PORTD PTD              /* Alias for PTD        */
  #define PTD0 ((struct __hc08_bits *)(&PTD))->bit0
  #define PTD1 ((struct __hc08_bits *)(&PTD))->bit1
  #define PTD2 ((struct __hc08_bits *)(&PTD))->bit2
  #define PTD3 ((struct __hc08_bits *)(&PTD))->bit3
  #define PTD4 ((struct __hc08_bits *)(&PTD))->bit4
  #define PTD5 ((struct __hc08_bits *)(&PTD))->bit5
  #define PTD6 ((struct __hc08_bits *)(&PTD))->bit6
  #define PTD7 ((struct __hc08_bits *)(&PTD))->bit7

_VOLDATA _UINT8 __at 0x04 DDRA;    /* Data Direction Register A */
  #define DDRA0 ((struct __hc08_bits *)(&DDRA))->bit0
  #define DDRA1 ((struct __hc08_bits *)(&DDRA))->bit1
  #define DDRA2 ((struct __hc08_bits *)(&DDRA))->bit2
  #define DDRA3 ((struct __hc08_bits *)(&DDRA))->bit3
  #define DDRA4 ((struct __hc08_bits *)(&DDRA))->bit4
  #define DDRA5 ((struct __hc08_bits *)(&DDRA))->bit5
  #define DDRA6 ((struct __hc08_bits *)(&DDRA))->bit6
  #define DDRA7 ((struct __hc08_bits *)(&DDRA))->bit7

_VOLDATA _UINT8 __at 0x05 DDRB;    /* Data Direction Register B */
  #define DDRB0 ((struct __hc08_bits *)(&DDRB))->bit0
  #define DDRB1 ((struct __hc08_bits *)(&DDRB))->bit1
  #define DDRB2 ((struct __hc08_bits *)(&DDRB))->bit2
  #define DDRB3 ((struct __hc08_bits *)(&DDRB))->bit3
  #define DDRB4 ((struct __hc08_bits *)(&DDRB))->bit4
  #define DDRB5 ((struct __hc08_bits *)(&DDRB))->bit5
  #define DDRB6 ((struct __hc08_bits *)(&DDRB))->bit6
  #define DDRB7 ((struct __hc08_bits *)(&DDRB))->bit7

_VOLDATA _UINT8 __at 0x06 DDRC;    /* Data Direction Register C */
  #define DDRC0 ((struct __hc08_bits *)(&DDRC))->bit0
  #define DDRC1 ((struct __hc08_bits *)(&DDRC))->bit1
  #define DDRC2 ((struct __hc08_bits *)(&DDRC))->bit2
  #define DDRC3 ((struct __hc08_bits *)(&DDRC))->bit3
  #define DDRC4 ((struct __hc08_bits *)(&DDRC))->bit4
  #define DDRC5 ((struct __hc08_bits *)(&DDRC))->bit5
  #define DDRC6 ((struct __hc08_bits *)(&DDRC))->bit6
  #define DDRC7 ((struct __hc08_bits *)(&DDRC))->bit7

_VOLDATA _UINT8 __at 0x07 DDRD;    /* Data Direction Register D */
  #define DDRD0 ((struct __hc08_bits *)(&DDRD))->bit0
  #define DDRD1 ((struct __hc08_bits *)(&DDRD))->bit1
  #define DDRD2 ((struct __hc08_bits *)(&DDRD))->bit2
  #define DDRD3 ((struct __hc08_bits *)(&DDRD))->bit3
  #define DDRD4 ((struct __hc08_bits *)(&DDRD))->bit4
  #define DDRD5 ((struct __hc08_bits *)(&DDRD))->bit5
  #define DDRD6 ((struct __hc08_bits *)(&DDRD))->bit6
  #define DDRD7 ((struct __hc08_bits *)(&DDRD))->bit7

_VOLDATA _UINT8 __at 0x08 PTE;     /* Port E Data Register */
#define PORTE PTE              /* Alias for PTE        */
  #define PTE0 ((struct __hc08_bits *)(&PTE))->bit0
  #define PTE1 ((struct __hc08_bits *)(&PTE))->bit1
  #define PTE2 ((struct __hc08_bits *)(&PTE))->bit2
  #define PTE3 ((struct __hc08_bits *)(&PTE))->bit3
  #define PTE4 ((struct __hc08_bits *)(&PTE))->bit4
  #define PTE5 ((struct __hc08_bits *)(&PTE))->bit5
  #define PTE6 ((struct __hc08_bits *)(&PTE))->bit6
  #define PTE7 ((struct __hc08_bits *)(&PTE))->bit7

_VOLDATA _UINT8 __at 0x0C DDRE;    /* Data Direction Register E */
  #define DDRE0 ((struct __hc08_bits *)(&DDRE))->bit0
  #define DDRE1 ((struct __hc08_bits *)(&DDRE))->bit1
  #define DDRE2 ((struct __hc08_bits *)(&DDRE))->bit2
  #define DDRE3 ((struct __hc08_bits *)(&DDRE))->bit3
  #define DDRE4 ((struct __hc08_bits *)(&DDRE))->bit4
  #define DDRE5 ((struct __hc08_bits *)(&DDRE))->bit5
  #define DDRE6 ((struct __hc08_bits *)(&DDRE))->bit6
  #define DDRE7 ((struct __hc08_bits *)(&DDRE))->bit7

_VOLDATA _UINT8 __at 0x0D PTAPUE;  /* Port A pull-up enables */
	#define PTAPUE0 ((struct __hc08_bits *)(&PTAPUE))->bit0
	#define PTAPUE1 ((struct __hc08_bits *)(&PTAPUE))->bit1
	#define PTAPUE2 ((struct __hc08_bits *)(&PTAPUE))->bit2
	#define PTAPUE3 ((struct __hc08_bits *)(&PTAPUE))->bit3
  #define PTAPUE4 ((struct __hc08_bits *)(&PTAPUE))->bit4
	#define PTAPUE5 ((struct __hc08_bits *)(&PTAPUE))->bit5
	#define PTAPUE6 ((struct __hc08_bits *)(&PTAPUE))->bit6
	#define PTAPUE7 ((struct __hc08_bits *)(&PTAPUE))->bit7

_VOLDATA _UINT8 __at 0x0E PTCPUE;	 /* Port C pull-up enables */
	#define PTCPUE0 ((struct __hc08_bits *)(&PTCPUE))->bit0
	#define PTCPUE1 ((struct __hc08_bits *)(&PTCPUE))->bit1
	#define PTCPUE2 ((struct __hc08_bits *)(&PTCPUE))->bit2
	#define PTCPUE3 ((struct __hc08_bits *)(&PTCPUE))->bit3
	#define PTCPUE4 ((struct __hc08_bits *)(&PTCPUE))->bit4
	#define PTCPUE5 ((struct __hc08_bits *)(&PTCPUE))->bit5
	#define PTCPUE6 ((struct __hc08_bits *)(&PTCPUE))->bit6
	/* PTCPUE7 does not exit! */

_VOLDATA _UINT8 __at 0x0F PTDPUE;  /* port D pull-up enables */
	#define PTDPUE0 ((struct __hc08_bits *)(&PTDPUE))->bit0
	#define PTDPUE1 ((struct __hc08_bits *)(&PTDPUE))->bit1
  #define PTDPUE2 ((struct __hc08_bits *)(&PTDPUE))->bit2
	#define PTDPUE3 ((struct __hc08_bits *)(&PTDPUE))->bit3
	#define PTDPUE4 ((struct __hc08_bits *)(&PTDPUE))->bit4
	#define PTDPUE5 ((struct __hc08_bits *)(&PTDPUE))->bit5
  #define PTDPUE6 ((struct __hc08_bits *)(&PTDPUE))->bit6
	#define PTDPUE7 ((struct __hc08_bits *)(&PTDPUE))->bit7

_VOLDATA _UINT8 __at 0x10 SPCR;   /* SPI Control Register */
	#define SPRIE  ((struct __hc08_bits *)(&SPCR))->bit7
	#define DMAS   ((struct __hc08_bits *)(&SPCR))->bit6
	#define SPMSTR ((struct __hc08_bits *)(&SPCR))->bit5
	#define CPOL   ((struct __hc08_bits *)(&SPCR))->bit4
	#define CPHA   ((struct __hc08_bits *)(&SPCR))->bit3
  #define SPWOM  ((struct __hc08_bits *)(&SPCR))->bit2
	#define SPE    ((struct __hc08_bits *)(&SPCR))->bit1
  #define SPTIE  ((struct __hc08_bits *)(&SPCR))->bit0

_VOLDATA _UINT8 __at 0x11 SPSCR;  /* SPI Status and Control Register */
	#define SPRF   ((struct __hc08_bits *)(&SPSCR))->bit7
	#define ERRIE  ((struct __hc08_bits *)(&SPSCR))->bit6
	#define OVRF   ((struct __hc08_bits *)(&SPSCR))->bit5
	#define MODF   ((struct __hc08_bits *)(&SPSCR))->bit4
	#define SPTE   ((struct __hc08_bits *)(&SPSCR))->bit3
	#define MODFEN ((struct __hc08_bits *)(&SPSCR))->bit2
	#define SPR1   ((struct __hc08_bits *)(&SPSCR))->bit1
	#define SPR0   ((struct __hc08_bits *)(&SPSCR))->bit0

_VOLDATA _UINT8 __at 0x12 SPDR;   /* SPI Data Register */

_VOLDATA _UINT8 __at 0x13 SCC1;  /* SCI Control Register 1 */
	#define LOOPS  ((struct __hc08_bits *)(&SCC1))->bit7
  #define ENSCI  ((struct __hc08_bits *)(&SCC1))->bit6
	#define TXINV  ((struct __hc08_bits *)(&SCC1))->bit5
  #define M      ((struct __hc08_bits *)(&SCC1))->bit4
	#define WAKE   ((struct __hc08_bits *)(&SCC1))->bit3
  #define ILTY   ((struct __hc08_bits *)(&SCC1))->bit2
	#define PEN    ((struct __hc08_bits *)(&SCC1))->bit1
  #define PTY    ((struct __hc08_bits *)(&SCC1))->bit0


_VOLDATA _UINT8 __at 0x14 SCC2;  /* SCI Control Register 2 */
	#define SCTIE  ((struct __hc08_bits *)(&SCC2))->bit7
	#define TCIE   ((struct __hc08_bits *)(&SCC2))->bit6
	#define SCRIE  ((struct __hc08_bits *)(&SCC2))->bit5
	#define ILIE   ((struct __hc08_bits *)(&SCC2))->bit4
	#define TE     ((struct __hc08_bits *)(&SCC2))->bit3
	#define RE     ((struct __hc08_bits *)(&SCC2))->bit2
	#define WRU    ((struct __hc08_bits *)(&SCC2))->bit1
	#define SBK    ((struct __hc08_bits *)(&SCC2))->bit0

_VOLDATA _UINT8 __at 0x15 SCC3;  /* SCI Control Register 3 */
	#define SCC3_R8 ((struct __hc08_bits *)(&SCC3))->bit7
	#define SCC3_TB ((struct __hc08_bits *)(&SCC3))->bit6
  #define DMARE   ((struct __hc08_bits *)(&SCC3))->bit5
	#define DMATE   ((struct __hc08_bits *)(&SCC3))->bit4
	#define ORIE    ((struct __hc08_bits *)(&SCC3))->bit3
	#define NEIE    ((struct __hc08_bits *)(&SCC3))->bit2
  #define FEIE    ((struct __hc08_bits *)(&SCC3))->bit1
	#define PEIE    ((struct __hc08_bits *)(&SCC3))->bit0

_VOLDATA _UINT8 __at 0x16 SCS1;  /* SCI Status Register 1 */
	#define SCTE  ((struct __hc08_bits *)(&SCS1))->bit7
	#define TC    ((struct __hc08_bits *)(&SCS1))->bit6
	#define SCRF  ((struct __hc08_bits *)(&SCS1))->bit5
	#define IDLE  ((struct __hc08_bits *)(&SCS1))->bit4
	#define OR    ((struct __hc08_bits *)(&SCS1))->bit3
	#define NF    ((struct __hc08_bits *)(&SCS1))->bit2
	#define FE    ((struct __hc08_bits *)(&SCS1))->bit1
	#define PE    ((struct __hc08_bits *)(&SCS1))->bit0

_VOLDATA _UINT8 __at 0x17 SCS2;  /* SCI Status Register 2 */
	#define RPF  ((struct __hc08_bits *)(&SCS2))->bit0
	#define BKF  ((struct __hc08_bits *)(&SCS2))->bit1
  /*  Bits 2-7 not implemented	*/

_VOLDATA _UINT8 __at 0x18 SCDR;  /* SCI Data Register */

_VOLDATA _UINT8 __at 0x19 SCBR;  /* SCI Baud Rate Register */
	#define SCP1  ((struct __hc08_bits *)(&SCBR))->bit5
	#define SCP0  ((struct __hc08_bits *)(&SCBR))->bit4
  #define R     ((struct __hc08_bits *)(&SCBR))->bit3
  #define SCR2  ((struct __hc08_bits *)(&SCBR))->bit2
  #define SCR1  ((struct __hc08_bits *)(&SCBR))->bit1
  #define SCR0  ((struct __hc08_bits *)(&SCBR))->bit0
	/*-- Bits 6 and 7 do not exist */

_VOLDATA _UINT8 __at 0x1a INTKBSCR; /* Keyboard Status and Control Register */
	#define KEYF   ((struct __hc08_bits *)(&INTKBSCR))->bit3
	#define ACKK   ((struct __hc08_bits *)(&INTKBSCR))->bit2
	#define IMASKK ((struct __hc08_bits *)(&INTKBSCR))->bit1
	#define MODEK  ((struct __hc08_bits *)(&INTKBSCR))->bit0
	/*-- Bits 4-7 do not exist  */

_VOLDATA _UINT8 __at 0x1b INTKBIER; /* Keyboard Interrupt Enable Register */
  #define KBIE7  ((struct __hc08_bits *)(&INTKBIER))->bit7
	#define KBIE6  ((struct __hc08_bits *)(&INTKBIER))->bit6
	#define KBIE5  ((struct __hc08_bits *)(&INTKBIER))->bit5
	#define KBIE4  ((struct __hc08_bits *)(&INTKBIER))->bit4
	#define KBIE3  ((struct __hc08_bits *)(&INTKBIER))->bit3
	#define KBIE2  ((struct __hc08_bits *)(&INTKBIER))->bit2
	#define KBIE1  ((struct __hc08_bits *)(&INTKBIER))->bit1
	#define KBIE0  ((struct __hc08_bits *)(&INTKBIER))->bit0

_VOLDATA _UINT8 __at 0x1C TBCR;    /* Time Base Module Control */
	#define TBIF   ((struct __hc08_bits *)(&TBCR))->bit7
	#define TBR2   ((struct __hc08_bits *)(&TBCR))->bit6
	#define TBR1   ((struct __hc08_bits *)(&TBCR))->bit5
	#define TBR0   ((struct __hc08_bits *)(&TBCR))->bit4
	#define TACK   ((struct __hc08_bits *)(&TBCR))->bit3
	#define TBIE   ((struct __hc08_bits *)(&TBCR))->bit2
	#define TBON   ((struct __hc08_bits *)(&TBCR))->bit1
	/* Bit 0 Reserved */

_VOLDATA _UINT8 __at 0x1D INTSCR;	/* IRQ status/control       */
	#define IRQF1  ((struct __hc08_bits *)(&INTSCR))->bit3
	#define ACK1   ((struct __hc08_bits *)(&INTSCR))->bit2
	#define IMASK1 ((struct __hc08_bits *)(&INTSCR))->bit1
	#define MODE1  ((struct __hc08_bits *)(&INTSCR))->bit0
	/* Bits 4-7 unimplemented */

_VOLDATA _UINT8 __at 0x1e CONFIG2; /* Configuration Register 2 */
/* CONFIG2 is one-time writeble, so can't use bitfields  */

_VOLDATA _UINT8 __at 0x1f CONFIG1; /* Configuration Register 1 */
/* CONFIG1 is one-time writeable, so can't use bitfields */

_VOLDATA _UINT8 __at 0x20 T1SC;     /* TIM 1 Status and Control */
  #define PS0   ((struct __hc08_bits *)(&T1SC))->bit0
  #define PS1   ((struct __hc08_bits *)(&T1SC))->bit1
  #define PS2   ((struct __hc08_bits *)(&T1SC))->bit2
  #define TRST  ((struct __hc08_bits *)(&T1SC))->bit4
  #define TSTOP ((struct __hc08_bits *)(&T1SC))->bit5
  #define TOIE  ((struct __hc08_bits *)(&T1SC))->bit6
  #define TOF   ((struct __hc08_bits *)(&T1SC))->bit7

_VOLDATA _UINT16 __at 0x21 T1CNT;    /* TIM1 Counter High & Low Registers */
_VOLDATA _UINT8  __at 0x21  T1CNTH;  /* TIM1 Counter Register High */
_VOLDATA _UINT8  __at 0x22  T1CNTL;  /* TIM1 Counter Register Low */

_VOLDATA _UINT16 __at 0x23 T1MOD;    /* TIM1 Counter Modulo High & Low Registers */
_VOLDATA _UINT8  __at 0x23 T1MODH;   /* TIM1 Counter Modulo Register High */
_VOLDATA _UINT8  __at 0x24 T1MODL;   /* TIM1 Counter Modulo Register Low */

_VOLDATA _UINT8 __at 0x25 T1SC0;    /* TIM1 Channel 0 Status and Control Register */
  #define CH0MAX ((struct __hc08_bits *)(&T1SC0))->bit0
  #define TOV0   ((struct __hc08_bits *)(&T1SC0))->bit1
  #define ELS0A  ((struct __hc08_bits *)(&T1SC0))->bit2
  #define ELS0B  ((struct __hc08_bits *)(&T1SC0))->bit3
  #define MS0A   ((struct __hc08_bits *)(&T1SC0))->bit4
  #define MS0B   ((struct __hc08_bits *)(&T1SC0))->bit5
  #define CH0IE  ((struct __hc08_bits *)(&T1SC0))->bit6
  #define CH0F   ((struct __hc08_bits *)(&T1SC0))->bit7

_VOLDATA _UINT16 __at 0x26 T1CH0;   /* TIM1 Channel 0 High & Low Registers */
_VOLDATA _UINT8 __at 0x26 T1CH0H;   /* TIM1 Channel 0 Register High */
_VOLDATA _UINT8 __at 0x27 T1CH0L;   /* TIM1 Channel 0 Register Low */

_VOLDATA _UINT8 __at 0x28 T1SC1;    /* TIM1 Channel 1 Status and Control Register */
  #define CH1MAX ((struct __hc08_bits *)(&T1SC1))->bit0
  #define TOV1   ((struct __hc08_bits *)(&T1SC1))->bit1
  #define ELS1A  ((struct __hc08_bits *)(&T1SC1))->bit2
  #define ELS1B  ((struct __hc08_bits *)(&T1SC1))->bit3
  #define MS1A   ((struct __hc08_bits *)(&T1SC1))->bit4
  #define CH1IE  ((struct __hc08_bits *)(&T1SC1))->bit6
  #define CH1F   ((struct __hc08_bits *)(&T1SC1))->bit7

_VOLDATA _UINT16 __at 0x29 T1CH1;    /* TIM1 Channel 1 High & Low Registers */
_VOLDATA _UINT8  __at 0x29  T1CH1H;  /* TIM1 Channel 1 Register High */
_VOLDATA _UINT8  __at 0x2A  T1CH1L;  /* TIM1 Channel 1 Register Low */

/*------------------*/
/* TIM 2 REGISTERS  */
/*------------------*/

_VOLDATA _UINT8 __at 0x2B T2SC;     /* TIM 2 Status and Control */
  #define PS0_2   ((struct __hc08_bits *)(&T2SC))->bit0
  #define PS1_2   ((struct __hc08_bits *)(&T2SC))->bit1
  #define PS2_2   ((struct __hc08_bits *)(&T2SC))->bit2
  #define TRST_2  ((struct __hc08_bits *)(&T2SC))->bit4
  #define TSTOP_2 ((struct __hc08_bits *)(&T2SC))->bit5
  #define TOIE_2  ((struct __hc08_bits *)(&T2SC))->bit6
  #define TOF_2   ((struct __hc08_bits *)(&T2SC))->bit7

_VOLDATA _UINT16 __at 0x2C T2CNT;   /* TIM2 Counter High & Low Registers */
_VOLDATA _UINT8  __at 0x2C T2CNTH;  /* TIM2 Counter Register High */
_VOLDATA _UINT8  __at 0x2D T2CNTL;  /* TIM2 Counter Register Low */

_VOLDATA _UINT16 __at 0x2E T2MOD;    /* TIM2 Counter Modulo High & Low Registers */
_VOLDATA _UINT8  __at 0x2E T2MODH;   /* TIM2 Counter Modulo Register High */
_VOLDATA _UINT8  __at 0x2F T2MODL;   /* TIM2 Counter Modulo Register Low */

_VOLDATA _UINT8 __at 0x30 T2SC0;    /* TIM2 Channel 0 Status and Control Register */
  #define CH0MAX_2 ((struct __hc08_bits *)(&T2SC0))->bit0
  #define TOV0_2   ((struct __hc08_bits *)(&T2SC0))->bit1
  #define ELS0A_2  ((struct __hc08_bits *)(&T2SC0))->bit2
  #define ELS0B_2  ((struct __hc08_bits *)(&T2SC0))->bit3
  #define MS0A_2   ((struct __hc08_bits *)(&T2SC0))->bit4
  #define MS0B_2   ((struct __hc08_bits *)(&T2SC0))->bit5
  #define CH0IE_2  ((struct __hc08_bits *)(&T2SC0))->bit6
  #define CH0F_2   ((struct __hc08_bits *)(&T2SC0))->bit7

_VOLDATA _UINT16 __at 0x31 T2CH0;    /* TIM2 Channel 0 High & Low Registers */
_VOLDATA _UINT8  __at 0x31 T2CH0H;   /* TIM2 Channel 0 Register High */
_VOLDATA _UINT8  __at 0x32 T2CH0L;   /* TIM2 Channel 0 Register Low */

_VOLDATA _UINT8 __at 0x33 T2SC1;    /* TIM2 Channel 1 Status and Control Register */
  #define CH1MAX_2 ((struct __hc08_bits *)(&T2SC1))->bit0
  #define TOV1_2   ((struct __hc08_bits *)(&T2SC1))->bit1
  #define ELS1A_2  ((struct __hc08_bits *)(&T2SC1))->bit2
  #define ELS1B_2  ((struct __hc08_bits *)(&T2SC1))->bit3
  #define MS1A_2   ((struct __hc08_bits *)(&T2SC1))->bit4
  #define CH1IE_2  ((struct __hc08_bits *)(&T2SC1))->bit6
  #define CH1F_2   ((struct __hc08_bits *)(&T2SC1))->bit7

_VOLDATA _UINT16 __at 0x34  T2CH1;   /* TIM2 Channel 1 High & Low Registers */
_VOLDATA _UINT8  __at 0x34  T2CH1H;  /* TIM2 Channel 1 Register High */
_VOLDATA _UINT8  __at 0x35  T2CH1L;  /* TIM2 Channel 1 Register Low */

_VOLDATA _UINT8 __at 0x36 PCTL;  /* PLL Control Register */
	#define PLLIE ((struct __hc08_bits *)(&PCTL))->bit7
	#define PLLF  ((struct __hc08_bits *)(&PCTL))->bit6
	#define PLLON ((struct __hc08_bits *)(&PCTL))->bit5
	#define BCS   ((struct __hc08_bits *)(&PCTL))->bit4
	#define PRE1  ((struct __hc08_bits *)(&PCTL))->bit3
	#define PRE0  ((struct __hc08_bits *)(&PCTL))->bit2
	#define VPR1  ((struct __hc08_bits *)(&PCTL))->bit1
	#define VPR0  ((struct __hc08_bits *)(&PCTL))->bit0

_VOLDATA	_UINT8 __at 0x37 PBWC;  /* PLL Bandwidth Control Register */
	#define AUTO ((struct __hc08_bits *)(&PBWC))->bit7
	#define LOCK ((struct __hc08_bits *)(&PBWC))->bit6
	#define ACQ  ((struct __hc08_bits *)(&PBWC))->bit5
	/* Bits 1-4, Unimplemented */
	/* Bit 0, Reserved         */

_VOLDATA _UINT8 __at 0x38 PMSH;  /* PLL Multiplier Select High */
	#define MUL11 ((struct __hc08_bits *)(&PMSH))->bit3
	#define MUL10 ((struct __hc08_bits *)(&PMSH))->bit2
	#define MUL9  ((struct __hc08_bits *)(&PMSH))->bit1
	#define MUL8  ((struct __hc08_bits *)(&PMSH))->bit0
	/* Bits 4-7 unimplemented */

_VOLDATA _UINT8 __at 0x39 PMSL;  /* PLL Multiplir Select Low */
	#define MUL7 ((struct __hc08_bits *)(&PMSL))->bit7
	#define MUL6 ((struct __hc08_bits *)(&PMSL))->bit6
	#define MUL5 ((struct __hc08_bits *)(&PMSL))->bit5
	#define MUL4 ((struct __hc08_bits *)(&PMSL))->bit4
	#define MUL3 ((struct __hc08_bits *)(&PMSL))->bit3
	#define MUL2 ((struct __hc08_bits *)(&PMSL))->bit2
	#define MUL1 ((struct __hc08_bits *)(&PMSL))->bit1
	#define MUL0 ((struct __hc08_bits *)(&PMSL))->bit0

_VOLDATA _UINT8 __at 0x3a PMRS;  /* PLL VCO Select Range  */
	#define VRS7 ((struct __hc08_bits *)(&PMRS))->bit7
	#define VRS6 ((struct __hc08_bits *)(&PMRS))->bit6
	#define VRS5 ((struct __hc08_bits *)(&PMRS))->bit5
	#define VRS4 ((struct __hc08_bits *)(&PMRS))->bit4
	#define VRS3 ((struct __hc08_bits *)(&PMRS))->bit3
	#define VRS2 ((struct __hc08_bits *)(&PMRS))->bit2
	#define VRS1 ((struct __hc08_bits *)(&PMRS))->bit1
	#define VRS0 ((struct __hc08_bits *)(&PMRS))->bit0

_VOLDATA _UINT8 __at 0x3b PMDS;  /* PLL Reference Divider Select Register */
	#define RDS3 ((struct __hc08_bits *)(&PMDS))->bit3
	#define RDS2 ((struct __hc08_bits *)(&PMDS))->bit2
	#define RDS1 ((struct __hc08_bits *)(&PMDS))->bit1
	#define RDS0 ((struct __hc08_bits *)(&PMDS))->bit0
	/* Bits 4-7 unimplemented */

_VOLDATA _UINT8 __at 0x3c ADSCR; /* Analog-to-Digital Status and Control Reg. */
	#define COCO  ((struct __hc08_bits *)(&ADSCR))->bit7
	#define AIEN  ((struct __hc08_bits *)(&ADSCR))->bit6
	#define ADCO  ((struct __hc08_bits *)(&ADSCR))->bit5
	#define ADCH4 ((struct __hc08_bits *)(&ADSCR))->bit4
	#define ADCH3 ((struct __hc08_bits *)(&ADSCR))->bit3
	#define ADCH2 ((struct __hc08_bits *)(&ADSCR))->bit2
	#define ADCH1 ((struct __hc08_bits *)(&ADSCR))->bit1
	#define ADCH0 ((struct __hc08_bits *)(&ADSCR))->bit0

_VOLDATA _UINT8 __at 0x3d ADR;   /* Analog-to-Digital Data Register  */

_VOLDATA _UINT8 __at 0x3e ADCLK; /* Analog-to-Digital Clock */
	#define ADIV2  ((struct __hc08_bits *)(&ADCLK))->bit7
	#define ADIV1  ((struct __hc08_bits *)(&ADCLK))->bit6
	#define ADIV0  ((struct __hc08_bits *)(&ADCLK))->bit5
	#define ADICLK ((struct __hc08_bits *)(&ADCLK))->bit4
	/* Bits 0-3 unimplemented */

_VOLXDATA _UINT8 __at 0xfe00 SBSR;     /* SIM Break Status Register */
  #define SBSW ((struct __hc08_bits *)(&SBSR))->bit1

_VOLXDATA _UINT8 __at 0xfe01 SRSR;    /* SIM Reset Status Register */
  #define LVI    ((struct __hc08_bits *)(&SRSR))->bit1
  #define MODRST ((struct __hc08_bits *)(&SRSR))->bit2
  #define ILAD   ((struct __hc08_bits *)(&SRSR))->bit3
  #define ILOP   ((struct __hc08_bits *)(&SRSR))->bit4
  #define COP    ((struct __hc08_bits *)(&SRSR))->bit5
  #define PIN    ((struct __hc08_bits *)(&SRSR))->bit6
  #define POR    ((struct __hc08_bits *)(&SRSR))->bit7
  /* Bit 0 unimplemented */

_VOLXDATA _UINT8 __at 0xfe02 SUBAR;  /* SIM Upper Byte Address */

_VOLXDATA _UINT8 __at 0xfe03 SBFCR;    /* SIM Break Flag Control Register */
  #define BFCE ((struct __hc08_bits *)(&BFCR))->bit7

_VOLXDATA _UINT8 __at 0xfe04 INT1;    /* Interrupt Status Register 1 */
  #define IF1 ((struct __hc08_bits *)(&INT1))->bit2
  #define IF2 ((struct __hc08_bits *)(&INT1))->bit3
  #define IF3 ((struct __hc08_bits *)(&INT1))->bit4
  #define IF4 ((struct __hc08_bits *)(&INT1))->bit5
  #define IF5 ((struct __hc08_bits *)(&INT1))->bit6
  #define IF6 ((struct __hc08_bits *)(&INT1))->bit7
	/* Bits 0-1 Reserved */

_VOLXDATA _UINT8 __at 0xfe05 INT2;  /* Interrupt Status Register 2 */
  #define IF14 ((struct __hc08_bits *)(&INT2))->bit7
	#define IF13 ((struct __hc08_bits *)(&INT2))->bit6
	#define IF12 ((struct __hc08_bits *)(&INT2))->bit5
	#define IF11 ((struct __hc08_bits *)(&INT2))->bit4
	#define IF10 ((struct __hc08_bits *)(&INT2))->bit3
	#define IF9 ((struct __hc08_bits *)(&INT2))->bit2
	#define IF8 ((struct __hc08_bits *)(&INT2))->bit1
	#define IF7 ((struct __hc08_bits *)(&INT2))->bit0

_VOLXDATA _UINT8 __at 0xfe06 INT3;  /* Interrupt Status Register 3 */
  #define IF16 ((struct __hc08_bits *)(&INT3))->bit1
	#define IF15 ((struct __hc08_bits *)(&INT3))->bit0

_VOLXDATA _UINT8 __at 0xfe07 FLCTR;  /* Flash test/programming */

_VOLXDATA _UINT8 __at 0xfe08 FLCR;    /* FLASH Control Register */
  #define PGM   ((struct __hc08_bits *)(&FLCR))->bit0
  #define ERASE ((struct __hc08_bits *)(&FLCR))->bit1
  #define MASS  ((struct __hc08_bits *)(&FLCR))->bit2
  #define HVEN  ((struct __hc08_bits *)(&FLCR))->bit3

_VOLXDATA _UINT16 __at 0xfe09 BRK;    /* Break Address High & Low Registers */
_VOLXDATA _UINT8 __at 0xfe09 BRKH;    /* Break Address High Register */
_VOLXDATA _UINT8 __at 0xfe0a BRKL;    /* Break Address Low Register */

_VOLXDATA _UINT8 __at 0xfe0b BRKSCR;  /* Break Status and Control Register */
  #define BRKA ((struct __hc08_bits *)(&BRKSCR))->bit6
  #define BRKE ((struct __hc08_bits *)(&BRKSCR))->bit7

_VOLXDATA _UINT8 __at 0xfe0c LVISR;   /* Low voltage detect */
	#define LVIOUT ((struct __hc08_bits *)(&LVISR))->bit7


_VOLXDATA _UINT8 __at 0xfe7e FLBPR;    /* FLASH Block Protect Register */
  #define BPR0 ((struct __hc08_bits *)(&FLBPR))->bit0
  #define BPR1 ((struct __hc08_bits *)(&FLBPR))->bit1
  #define BPR2 ((struct __hc08_bits *)(&FLBPR))->bit2
  #define BPR3 ((struct __hc08_bits *)(&FLBPR))->bit3
  #define BPR4 ((struct __hc08_bits *)(&FLBPR))->bit4
  #define BPR5 ((struct __hc08_bits *)(&FLBPR))->bit5
  #define BPR6 ((struct __hc08_bits *)(&FLBPR))->bit6
  #define BPR7 ((struct __hc08_bits *)(&FLBPR))->bit7

_VOLXDATA _UINT8 __at 0xffff COPCTL;  /* COP Control Register */

#endif
/*-------------------------------------------------------------------------
   mc68hc908jkjl.h - register declarations for Motorola MC68HC908JK1/JK3/JL3/JK8/JL8

   Copyright (C) 2004, Lucas Loizaga <lucas.loizaga AT ingenieria-inversa.com.ar>

   Based on mc68hc908qy.h,
   Written By - Erik Petrich <epetrich AT users.sourceforge.net> (2003)

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef _MC68HC908JKJL_H
#define _MC68HC908JKJL_H

#ifndef _UINT8
 #define _UINT8 unsigned char
#endif
#ifndef _UINT16
 #define _UINT16 unsigned int
#endif
#ifndef _VOLDATA
 #define _VOLDATA volatile __data
#endif
#ifndef _VOLXDATA
 #define _VOLXDATA volatile __xdata
#endif

struct __hc08_bits
{
  unsigned int bit0:1;
  unsigned int bit1:1;
  unsigned int bit2:1;
  unsigned int bit3:1;
  unsigned int bit4:1;
  unsigned int bit5:1;
  unsigned int bit6:1;
  unsigned int bit7:1;
};
  

_VOLDATA _UINT8 __at 0x00 PTA;     /* Port A Data Register */
#define PORTA PTA							 /* Alias for PTA        */
  #define PTA0 ((struct __hc08_bits *)(&PTA))->bit0
  #define PTA1 ((struct __hc08_bits *)(&PTA))->bit1
  #define PTA2 ((struct __hc08_bits *)(&PTA))->bit2
  #define PTA3 ((struct __hc08_bits *)(&PTA))->bit3
  #define PTA4 ((struct __hc08_bits *)(&PTA))->bit4
  #define PTA5 ((struct __hc08_bits *)(&PTA))->bit5
  #define PTA6 ((struct __hc08_bits *)(&PTA))->bit6
  #define PTA7 ((struct __hc08_bits *)(&PTA))->bit7
    
_VOLDATA _UINT8 __at 0x01 PTB;     /* Port B Data Register */
#define PORTB PTB              /* Alias for PTB        */	
  #define PTB0 ((struct __hc08_bits *)(&PTB))->bit0
  #define PTB1 ((struct __hc08_bits *)(&PTB))->bit1
  #define PTB2 ((struct __hc08_bits *)(&PTB))->bit2
  #define PTB3 ((struct __hc08_bits *)(&PTB))->bit3
  #define PTB4 ((struct __hc08_bits *)(&PTB))->bit4
  #define PTB5 ((struct __hc08_bits *)(&PTB))->bit5
  #define PTB6 ((struct __hc08_bits *)(&PTB))->bit6
  #define PTB7 ((struct __hc08_bits *)(&PTB))->bit7

_VOLDATA _UINT8 __at 0x03 PTD;     /* Port D Data Register */
#define PORTD PTD              /* Alias for PTD        */
  #define PTD0 ((struct __hc08_bits *)(&PTD))->bit0
  #define PTD1 ((struct __hc08_bits *)(&PTD))->bit1
  #define PTD2 ((struct __hc08_bits *)(&PTD))->bit2
  #define PTD3 ((struct __hc08_bits *)(&PTD))->bit3
  #define PTD4 ((struct __hc08_bits *)(&PTD))->bit4
  #define PTD5 ((struct __hc08_bits *)(&PTD))->bit5
  #define PTD6 ((struct __hc08_bits *)(&PTD))->bit6
  #define PTD7 ((struct __hc08_bits *)(&PTD))->bit7

_VOLDATA _UINT8 __at 0x04 DDRA;    /* Data Direction Register A */
  #define DDRA0 ((struct __hc08_bits *)(&DDRA))->bit0
  #define DDRA1 ((struct __hc08_bits *)(&DDRA))->bit1
  #define DDRA2 ((struct __hc08_bits *)(&DDRA))->bit2
  #define DDRA3 ((struct __hc08_bits *)(&DDRA))->bit3
  #define DDRA4 ((struct __hc08_bits *)(&DDRA))->bit4
  #define DDRA5 ((struct __hc08_bits *)(&DDRA))->bit5
  #define DDRA6 ((struct __hc08_bits *)(&DDRA))->bit6
  #define DDRA7 ((struct __hc08_bits *)(&DDRA))->bit7

_VOLDATA _UINT8 __at 0x05 DDRB;    /* Data Direction Register B */
  #define DDRB0 ((struct __hc08_bits *)(&DDRB))->bit0
  #define DDRB1 ((struct __hc08_bits *)(&DDRB))->bit1
  #define DDRB2 ((struct __hc08_bits *)(&DDRB))->bit2
  #define DDRB3 ((struct __hc08_bits *)(&DDRB))->bit3
  #define DDRB4 ((struct __hc08_bits *)(&DDRB))->bit4
  #define DDRB5 ((struct __hc08_bits *)(&DDRB))->bit5
  #define DDRB6 ((struct __hc08_bits *)(&DDRB))->bit6
  #define DDRB7 ((struct __hc08_bits *)(&DDRB))->bit7

_VOLDATA _UINT8 __at 0x07 DDRD;    /* Data Direction Register D */
  #define DDRD0 ((struct __hc08_bits *)(&DDRD))->bit0
  #define DDRD1 ((struct __hc08_bits *)(&DDRD))->bit1
  #define DDRD2 ((struct __hc08_bits *)(&DDRD))->bit2
  #define DDRD3 ((struct __hc08_bits *)(&DDRD))->bit3
  #define DDRD4 ((struct __hc08_bits *)(&DDRD))->bit4
  #define DDRD5 ((struct __hc08_bits *)(&DDRD))->bit5
  #define DDRD6 ((struct __hc08_bits *)(&DDRD))->bit6
  #define DDRD7 ((struct __hc08_bits *)(&DDRD))->bit7

_VOLDATA _UINT8 __at 0x08 PTE;     /* Port E Data Register */
#define PORTE PTE              /* Alias for PTE        */
  #define PTE0 ((struct __hc08_bits *)(&PTE))->bit0
  #define PTE1 ((struct __hc08_bits *)(&PTE))->bit1

_VOLDATA _UINT8 __at 0x0A PDCR;     /* Port D Control Register */

  #define PTDPU6 ((struct __hc08_bits *)(&PDCR))->bit0
  #define PTDPU7 ((struct __hc08_bits *)(&PDCR))->bit1
  #define SLOWD6 ((struct __hc08_bits *)(&PDCR))->bit2
  #define SLOWD7 ((struct __hc08_bits *)(&PDCR))->bit3

_VOLDATA _UINT8 __at 0x0C DDRE;    /* Data Direction Register E */
  #define DDRE0 ((struct __hc08_bits *)(&DDRE))->bit0
  #define DDRE1 ((struct __hc08_bits *)(&DDRE))->bit1
		

_VOLDATA _UINT8 __at 0x0D PTAPUE;  /* Port A pull-up enables */
	#define PTAPUE0 ((struct __hc08_bits *)(&PTAPUE))->bit0
	#define PTAPUE1 ((struct __hc08_bits *)(&PTAPUE))->bit1	
	#define PTAPUE2 ((struct __hc08_bits *)(&PTAPUE))->bit2
	#define PTAPUE3 ((struct __hc08_bits *)(&PTAPUE))->bit3	
        #define PTAPUE4 ((struct __hc08_bits *)(&PTAPUE))->bit4
	#define PTAPUE5 ((struct __hc08_bits *)(&PTAPUE))->bit5	
	#define PTAPUE6 ((struct __hc08_bits *)(&PTAPUE))->bit6
	#define PTA6EN  ((struct __hc08_bits *)(&PTAPUE))->bit7		
		
_VOLDATA _UINT8 __at 0x0E PTA7PUE;  /* Port A pull-up enables */
	#define PTAPUE7 ((struct __hc08_bits *)(&PTA7PUE))->bit7

_VOLDATA _UINT8 __at 0x13 SCC1;  /* SCI Control Register 1 */ 
	#define LOOPS  ((struct __hc08_bits *)(&SCC1))->bit7
        #define ENSCI  ((struct __hc08_bits *)(&SCC1))->bit6	
	#define TXINV  ((struct __hc08_bits *)(&SCC1))->bit5
        #define M      ((struct __hc08_bits *)(&SCC1))->bit4		
	#define WAKE   ((struct __hc08_bits *)(&SCC1))->bit3
        #define ILTY   ((struct __hc08_bits *)(&SCC1))->bit2
	#define PEN    ((struct __hc08_bits *)(&SCC1))->bit1
        #define PTY    ((struct __hc08_bits *)(&SCC1))->bit0
	
		
_VOLDATA _UINT8 __at 0x14 SCC2;  /* SCI Control Register 2 */ 
	#define SCTIE  ((struct __hc08_bits *)(&SCC2))->bit7
	#define TCIE   ((struct __hc08_bits *)(&SCC2))->bit6
	#define SCRIE  ((struct __hc08_bits *)(&SCC2))->bit5
	#define ILIE   ((struct __hc08_bits *)(&SCC2))->bit4
	#define TE     ((struct __hc08_bits *)(&SCC2))->bit3
	#define RE     ((struct __hc08_bits *)(&SCC2))->bit2
	#define WRU    ((struct __hc08_bits *)(&SCC2))->bit1
	#define SBK    ((struct __hc08_bits *)(&SCC2))->bit0
	
_VOLDATA _UINT8 __at 0x15 SCC3;  /* SCI Control Register 3 */ 
	#define SCC3_R8 ((struct __hc08_bits *)(&SCC3))->bit7
	#define SCC3_TB ((struct __hc08_bits *)(&SCC3))->bit6
  	#define DMARE   ((struct __hc08_bits *)(&SCC3))->bit5
	#define DMATE   ((struct __hc08_bits *)(&SCC3))->bit4
	#define ORIE    ((struct __hc08_bits *)(&SCC3))->bit3
	#define NEIE    ((struct __hc08_bits *)(&SCC3))->bit2
  	#define FEIE    ((struct __hc08_bits *)(&SCC3))->bit1
	#define PEIE    ((struct __hc08_bits *)(&SCC3))->bit0
	
_VOLDATA _UINT8 __at 0x16 SCS1;  /* SCI Status Register 1 */
	#define SCTE  ((struct __hc08_bits *)(&SCS1))->bit7
	#define TC    ((struct __hc08_bits *)(&SCS1))->bit6
	#define SCRF  ((struct __hc08_bits *)(&SCS1))->bit5
	#define IDLE  ((struct __hc08_bits *)(&SCS1))->bit4
	#define OR    ((struct __hc08_bits *)(&SCS1))->bit3
	#define NF    ((struct __hc08_bits *)(&SCS1))->bit2
	#define FE    ((struct __hc08_bits *)(&SCS1))->bit1
	#define PE    ((struct __hc08_bits *)(&SCS1))->bit0	
		
_VOLDATA _UINT8 __at 0x17 SCS2;  /* SCI Status Register 2 */
	#define RPF  ((struct __hc08_bits *)(&SCS2))->bit0
	#define BKF  ((struct __hc08_bits *)(&SCS2))->bit1
  /*  Bits 2-7 not implemented	*/
	
_VOLDATA _UINT8 __at 0x18 SCDR;  /* SCI Data Register */
	
_VOLDATA _UINT8 __at 0x19 SCBR;  /* SCI Baud Rate Register */
	#define SCP1  ((struct __hc08_bits *)(&SCBR))->bit5
	#define SCP0  ((struct __hc08_bits *)(&SCBR))->bit4
 	#define R     ((struct __hc08_bits *)(&SCBR))->bit3
        #define SCR2  ((struct __hc08_bits *)(&SCBR))->bit2
        #define SCR1  ((struct __hc08_bits *)(&SCBR))->bit1
        #define SCR0  ((struct __hc08_bits *)(&SCBR))->bit0
	/*-- Bits 6 and 7 do not exist */

		
_VOLDATA _UINT8 __at 0x1a KBSCR; /* Keyboard Status and Control Register */
	#define MODEK  ((struct __hc08_bits *)(&KBSCR))->bit0
	#define IMASKK ((struct __hc08_bits *)(&KBSCR))->bit1
	#define ACKK   ((struct __hc08_bits *)(&KBSCR))->bit2
	#define KEYF   ((struct __hc08_bits *)(&KBSCR))->bit3
	/*-- Bits 4-7 do not exist  */
		
_VOLDATA _UINT8 __at 0x1b KBIER; /* Keyboard Interrupt Enable Register */
	#define KBIE0  ((struct __hc08_bits *)(&KBIER))->bit0
	#define KBIE1  ((struct __hc08_bits *)(&KBIER))->bit1
	#define KBIE3  ((struct __hc08_bits *)(&KBIER))->bit3
	#define KBIE2  ((struct __hc08_bits *)(&KBIER))->bit2
	#define KBIE4  ((struct __hc08_bits *)(&KBIER))->bit4
	#define KBIE5  ((struct __hc08_bits *)(&KBIER))->bit5
	#define KBIE6  ((struct __hc08_bits *)(&KBIER))->bit6
	#define KBIE7  ((struct __hc08_bits *)(&KBIER))->bit7
		
_VOLDATA _UINT8 __at 0x1D INTSCR;	/* IRQ status/control       */
	#define IRQF1  ((struct __hc08_bits *)(&INTSCR))->bit3
	#define ACK1   ((struct __hc08_bits *)(&INTSCR))->bit2
	#define IMASK1 ((struct __hc08_bits *)(&INTSCR))->bit1
	#define MODE1  ((struct __hc08_bits *)(&INTSCR))->bit0
	/* Bits 4-7 unimplemented */
	
_VOLDATA _UINT8 __at 0x1e CONFIG2; /* Configuration Register 2 */
/* CONFIG2 is one-time writeble, so can't use bitfields  */	
	
_VOLDATA _UINT8 __at 0x1f CONFIG1; /* Configuration Register 1 */
/* CONFIG1 is one-time writeable, so can't use bitfields */	
	
_VOLDATA _UINT8 __at 0x20 T1SC;     /* TIM 1 Status and Control */
  #define PS0   ((struct __hc08_bits *)(&T1SC))->bit0
  #define PS1   ((struct __hc08_bits *)(&T1SC))->bit1
  #define PS2   ((struct __hc08_bits *)(&T1SC))->bit2
  #define TRST  ((struct __hc08_bits *)(&T1SC))->bit4
  #define TSTOP ((struct __hc08_bits *)(&T1SC))->bit5
  #define TOIE  ((struct __hc08_bits *)(&T1SC))->bit6
  #define TOF   ((struct __hc08_bits *)(&T1SC))->bit7	

_VOLDATA _UINT16 __at 0x21 T1CNT;    /* TIM1 Counter High & Low Registers */
_VOLDATA _UINT8  __at 0x21  T1CNTH;  /* TIM1 Counter Register High */
_VOLDATA _UINT8  __at 0x22  T1CNTL;  /* TIM1 Counter Register Low */

_VOLDATA _UINT16 __at 0x23 T1MOD;    /* TIM1 Counter Modulo High & Low Registers */
_VOLDATA _UINT8  __at 0x23 T1MODH;   /* TIM1 Counter Modulo Register High */
_VOLDATA _UINT8  __at 0x24 T1MODL;   /* TIM1 Counter Modulo Register Low */

_VOLDATA _UINT8 __at 0x25 T1SC0;    /* TIM1 Channel 0 Status and Control Register */
  #define CH0MAX ((struct __hc08_bits *)(&T1SC0))->bit0
  #define TOV0   ((struct __hc08_bits *)(&T1SC0))->bit1
  #define ELS0A  ((struct __hc08_bits *)(&T1SC0))->bit2
  #define ELS0B  ((struct __hc08_bits *)(&T1SC0))->bit3
  #define MS0A   ((struct __hc08_bits *)(&T1SC0))->bit4
  #define MS0B   ((struct __hc08_bits *)(&T1SC0))->bit5
  #define CH0IE  ((struct __hc08_bits *)(&T1SC0))->bit6
  #define CH0F   ((struct __hc08_bits *)(&T1SC0))->bit7
		
_VOLDATA _UINT16 __at 0x26 T1CH0;   /* TIM1 Channel 0 High & Low Registers */
_VOLDATA _UINT8 __at 0x26 T1CH0H;   /* TIM1 Channel 0 Register High */
_VOLDATA _UINT8 __at 0x27 T1CH0L;   /* TIM1 Channel 0 Register Low */

_VOLDATA _UINT8 __at 0x28 T1SC1;    /* TIM1 Channel 1 Status and Control Register */
  #define CH1MAX ((struct __hc08_bits *)(&T1SC1))->bit0
  #define TOV1   ((struct __hc08_bits *)(&T1SC1))->bit1
  #define ELS1A  ((struct __hc08_bits *)(&T1SC1))->bit2
  #define ELS1B  ((struct __hc08_bits *)(&T1SC1))->bit3
  #define MS1A   ((struct __hc08_bits *)(&T1SC1))->bit4
  #define CH1IE  ((struct __hc08_bits *)(&T1SC1))->bit6
  #define CH1F   ((struct __hc08_bits *)(&T1SC1))->bit7

_VOLDATA _UINT16 __at 0x29 T1CH1;    /* TIM1 Channel 1 High & Low Registers */
_VOLDATA _UINT8  __at 0x29  T1CH1H;  /* TIM1 Channel 1 Register High */
_VOLDATA _UINT8  __at 0x2A  T1CH1L;  /* TIM1 Channel 1 Register Low */

_VOLDATA _UINT8 __at 0x30 T2SC;    /* TIM2 Status and Control Register */
  #define PS0_2 	((struct __hc08_bits *)(&T2SC))->bit0
  #define PS1_2 	((struct __hc08_bits *)(&T2SC0))->bit1
  #define PS2_2 	((struct __hc08_bits *)(&T2SC0))->bit2
  #define TRST_2 	((struct __hc08_bits *)(&T2SC0))->bit4
  #define TSTOP_2    ((struct __hc08_bits *)(&T2SC0))->bit5
  #define TOIE_2     ((struct __hc08_bits *)(&T2SC0))->bit6
  #define TOF_2		((struct __hc08_bits *)(&T2SC0))->bit7	
	
_VOLDATA _UINT16 __at 0x31 T2CNT;    /* TIM2 Counter Registers */
_VOLDATA _UINT8  __at 0x31 T2CNTH;   /* TIM2 Counter Register High */
_VOLDATA _UINT8  __at 0x32 T2CNTL;   /* TIM2 Counter Register Low */	

	
_VOLDATA _UINT16 __at 0x33 T2MOD;    /* TIM2 Counter Modulo Registers */
_VOLDATA _UINT8  __at 0x33 T2MODH;   /* TIM2 Counter Modulo Register High */
_VOLDATA _UINT8  __at 0x34 T2MODL;   /* TIM2 Counter Modulo Register Low */	

	
_VOLDATA _UINT8 __at 0x35 T2SC0;    /* TIM2 Channel 0 Status and Control Register */
  #define CH0MAX_2 ((struct __hc08_bits *)(&T2SC0))->bit0
  #define TOV0_2   ((struct __hc08_bits *)(&T2SC0))->bit1
  #define ELS0A_2  ((struct __hc08_bits *)(&T2SC0))->bit2
  #define ELS0B_2  ((struct __hc08_bits *)(&T2SC0))->bit3
  #define MS0A_2   ((struct __hc08_bits *)(&T2SC0))->bit4
  #define CH0IE_2  ((struct __hc08_bits *)(&T2SC0))->bit6
  #define CH0F_2   ((struct __hc08_bits *)(&T2SC0))->bit7

_VOLDATA _UINT16 __at 0x36 T2CH0;    /* TIM2 Channel 0 High & Low Registers */
_VOLDATA _UINT8  __at 0x36 T2CH0H;   /* TIM2 Channel 0 Register High */
_VOLDATA _UINT8  __at 0x37 T2CH0L;   /* TIM2 Channel 0 Register Low */	

_VOLDATA _UINT8 __at 0x38 T2SC1;    /* TIM2 Channel 1 Status and Control Register */
  #define CH1MAX_2 ((struct __hc08_bits *)(&T2SC1))->bit0
  #define TOV1_2   ((struct __hc08_bits *)(&T2SC1))->bit1
  #define ELS1A_2  ((struct __hc08_bits *)(&T2SC1))->bit2
  #define ELS1B_2  ((struct __hc08_bits *)(&T2SC1))->bit3
  #define MS1A_2   ((struct __hc08_bits *)(&T2SC1))->bit4
  #define CH1IE_2  ((struct __hc08_bits *)(&T2SC1))->bit6
  #define CH1F_2   ((struct __hc08_bits *)(&T2SC1))->bit7

_VOLDATA _UINT16 __at 0x39  T2CH1;   /* TIM2 Channel 1 High & Low Registers */
_VOLDATA _UINT8  __at 0x39  T2CH1H;  /* TIM2 Channel 1 Register High */
_VOLDATA _UINT8  __at 0x3a  T2CH1L;  /* TIM2 Channel 1 Register Low */	


_VOLDATA _UINT8 __at 0x3c ADSCR; /* Analog-to-Digital Status and Control Reg. */
	#define COCO  ((struct __hc08_bits *)(&ADSCR))->bit7
	#define AIEN  ((struct __hc08_bits *)(&ADSCR))->bit6
	#define ADCO  ((struct __hc08_bits *)(&ADSCR))->bit5
	#define ADCH4 ((struct __hc08_bits *)(&ADSCR))->bit4
	#define ADCH3 ((struct __hc08_bits *)(&ADSCR))->bit3
	#define ADCH2 ((struct __hc08_bits *)(&ADSCR))->bit2
	#define ADCH1 ((struct __hc08_bits *)(&ADSCR))->bit1
	#define ADCH0 ((struct __hc08_bits *)(&ADSCR))->bit0
	
_VOLDATA _UINT8 __at 0x3d ADR;   /* Analog-to-Digital Data Register  */
	
_VOLDATA _UINT8 __at 0x3e ADCLK; /* Analog-to-Digital Clock */
	#define ADIV2  ((struct __hc08_bits *)(&ADCLK))->bit7
	#define ADIV1  ((struct __hc08_bits *)(&ADCLK))->bit6
	#define ADIV0  ((struct __hc08_bits *)(&ADCLK))->bit5
	/* Bits 0-4 unimplemented */

_VOLXDATA _UINT8 __at 0xfe00 BSR;     /* SIM Break Status Register */
  #define SBSW ((struct __hc08_bits *)(&BSR))->bit1

_VOLXDATA _UINT8 __at 0xfe01 RSR;    /* SIM Reset Status Register */
  #define LVI    ((struct __hc08_bits *)(&RSR))->bit1
  #define MODRST ((struct __hc08_bits *)(&RSR))->bit2
  #define ILAD   ((struct __hc08_bits *)(&RSR))->bit3
  #define ILOP   ((struct __hc08_bits *)(&RSR))->bit4
  #define COP    ((struct __hc08_bits *)(&RSR))->bit5
  #define PIN    ((struct __hc08_bits *)(&RSR))->bit6
  #define POR    ((struct __hc08_bits *)(&RSR))->bit7
  /* Bit 0 unimplemented */

_VOLXDATA _UINT8 __at 0xfe02 SUBAR;  /* SIM Upper Byte Address */
	
_VOLXDATA _UINT8 __at 0xfe03 BFCR;    /* SIM Break Flag Control Register */
  #define BFCE ((struct __hc08_bits *)(&BFCR))->bit7

_VOLXDATA _UINT8 __at 0xfe04 INT1;    /* Interrupt Status Register 1 */
  #define IF1 ((struct __hc08_bits *)(&INT1))->bit2
  #define IF3 ((struct __hc08_bits *)(&INT1))->bit4
  #define IF4 ((struct __hc08_bits *)(&INT1))->bit5
  #define IF5 ((struct __hc08_bits *)(&INT1))->bit6
	
	
_VOLXDATA _UINT8 __at 0xfe05 INT2;  /* Interrupt Status Register 2 */
  	#define IF14 ((struct __hc08_bits *)(&INT2))->bit7
		
_VOLXDATA _UINT8 __at 0xfe06 INT3;  /* Interrupt Status Register 3 */
  #define IF16 ((struct __hc08_bits *)(&INT3))->bit1	
	#define IF15 ((struct __hc08_bits *)(&INT3))->bit0	
		
_VOLXDATA _UINT8 __at 0xfe08 FLCR;    /* FLASH Control Register */
  #define PGM   ((struct __hc08_bits *)(&FLCR))->bit0
  #define ERASE ((struct __hc08_bits *)(&FLCR))->bit1
  #define MASS  ((struct __hc08_bits *)(&FLCR))->bit2
  #define HVEN  ((struct __hc08_bits *)(&FLCR))->bit3
		
_VOLXDATA _UINT8 __at 0xfe09 FLBPR;    /* Flash Block Protect Register */
  #define BPR0 ((struct __hc08_bits *)(&FLBPR))->bit0
  #define BPR1 ((struct __hc08_bits *)(&FLBPR))->bit1
  #define BPR2 ((struct __hc08_bits *)(&FLBPR))->bit2
  #define BPR3 ((struct __hc08_bits *)(&FLBPR))->bit3
  #define BPR4 ((struct __hc08_bits *)(&FLBPR))->bit4
  #define BPR5 ((struct __hc08_bits *)(&FLBPR))->bit5
  #define BPR6 ((struct __hc08_bits *)(&FLBPR))->bit6
  #define BPR7 ((struct __hc08_bits *)(&FLBPR))->bit7

_VOLXDATA _UINT16 __at 0xfe0C BRK;    /* Break Address High & Low Registers */
_VOLXDATA _UINT8 __at 0xfe0C BRKH;    /* Break Address High Register */
_VOLXDATA _UINT8 __at 0xfe0D BRKL;    /* Break Address Low Register */	

_VOLXDATA _UINT8 __at 0xfe0e BRKSCR;  /* Break Status and Control Register */
  #define BRKA ((struct __hc08_bits *)(&BRKSCR))->bit6
  #define BRKE ((struct __hc08_bits *)(&BRKSCR))->bit7	
	
_VOLXDATA _UINT8 __at 0xffff COPCTL;  /* COP Control Register */

#endif
/*-------------------------------------------------------------------------
   z180.h - definitions on the built in I/O ports for the Z180/HD64180
            for use with SDCC

   Copyright (C) 2003, Peter Townson <Peter.Townson AT tattsgroup.com>

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#if !defined( __Z180_H__ )
    #define   __Z180_H__ 

#if !defined( Z180_IO_BASE )
    #define   Z180_IO_BASE  0  /* zero is the Reset default */
#endif

/* will want this to be the case by default (I think) */
#pragma portmode z180

static void _ENABLE_Z180_ASSEMBLER_(void) __naked { __asm .hd64 __endasm; }

/*
 *---------------------------------------------------------------------------
 *      Z180/HD64180 internal port addresses
 */
__sfr __at (Z180_IO_BASE+0x00) CNTLA0;  /* ASCI control register A channel 0 */
__sfr __at (Z180_IO_BASE+0x01) CNTLA1;  /* ASCI control register A channel 1 */
__sfr __at (Z180_IO_BASE+0x02) CNTLB0;  /* ASCI control register B channel 0 */
__sfr __at (Z180_IO_BASE+0x03) CNTLB1;  /* ASCI control register B channel 0 */
__sfr __at (Z180_IO_BASE+0x04) STAT0 ;  /* ASCI status register    channel 0 */
__sfr __at (Z180_IO_BASE+0x05) STAT1 ;  /* ASCI status register    channel 1 */
__sfr __at (Z180_IO_BASE+0x06) TDR0  ;  /* ASCI transmit data reg, channel 0 */
__sfr __at (Z180_IO_BASE+0x07) TDR1  ;  /* ASCI transmit data reg, channel 1 */
__sfr __at (Z180_IO_BASE+0x08) RDR0  ;  /* ASCI receive data reg,  channel 0 */
__sfr __at (Z180_IO_BASE+0x09) RDR1  ;  /* ASCI receive data reg,  channel 0 */
__sfr __at (Z180_IO_BASE+0x0A) CNTR  ;  /* CSI/0 control register */
__sfr __at (Z180_IO_BASE+0x0B) TRDR  ;  /* CSI/0 transmit/receive data reg */

__sfr __at (Z180_IO_BASE+0x0C) TMDR0L;  /* Timer data register,    channel 0L */
__sfr __at (Z180_IO_BASE+0x0D) TMDR0H;  /* Timer data register,    channel 0H */
__sfr __at (Z180_IO_BASE+0x0E) RLDR0L;  /* Timer reload register,  channel 0L */
__sfr __at (Z180_IO_BASE+0x0F) RLDR0H;  /* Timer reload register,  channel 0H */
__sfr __at (Z180_IO_BASE+0x10) TCR   ;  /* Timer control register */
__sfr __at (Z180_IO_BASE+0x14) TMDR1L;  /* Timer data register,    channel 1L */
__sfr __at (Z180_IO_BASE+0x15) TMDR1H;  /* Timer data register,    channel 1H */
__sfr __at (Z180_IO_BASE+0x16) RLDR1L;  /* Timer reload register,  channel 1L */
__sfr __at (Z180_IO_BASE+0x17) RLDR1H;  /* Timer reload register,  channel 1H */
__sfr __at (Z180_IO_BASE+0x18) FRC   ;  /* Timer Free running counter */

__sfr __at (Z180_IO_BASE+0x20) SAR0L ;  /* DMA source address reg, channel 0L */
__sfr __at (Z180_IO_BASE+0x21) SAR0H ;  /* DMA source address reg, channel 0H */
__sfr __at (Z180_IO_BASE+0x22) SAR0B ;  /* DMA source address reg, channel 0B */
__sfr __at (Z180_IO_BASE+0x23) DAR0L ;  /* DMA dest address reg,   channel 0L */
__sfr __at (Z180_IO_BASE+0x24) DAR0H ;  /* DMA dest address reg,   channel 0H */
__sfr __at (Z180_IO_BASE+0x25) DAR0B ;  /* DMA dest address reg,   channel 0B */
__sfr __at (Z180_IO_BASE+0x26) BCR0L ;  /* DMA byte count reg,     channel 0L */
__sfr __at (Z180_IO_BASE+0x27) BCR0H ;  /* DMA byte count reg,     channel 0H */
__sfr __at (Z180_IO_BASE+0x28) MAR1L ;  /* DMA memory address reg, channel 1L */
__sfr __at (Z180_IO_BASE+0x29) MAR1H ;  /* DMA memory address reg, channel 1H */
__sfr __at (Z180_IO_BASE+0x2A) MAR1B ;  /* DMA memory address reg, channel 1B */
__sfr __at (Z180_IO_BASE+0x2B) IAR1L ;  /* DMA I/O address reg,    channel 1L */
__sfr __at (Z180_IO_BASE+0x2C) IAR1H ;  /* DMA I/O address reg,    channel 1H */
__sfr __at (Z180_IO_BASE+0x2E) BCR1L ;  /* DMA byte count reg,     channel 1L */
__sfr __at (Z180_IO_BASE+0x2F) BCR1H ;  /* DMA byte count reg,     channel 1H */
__sfr __at (Z180_IO_BASE+0x30) DSTAT ;  /* DMA status register */
__sfr __at (Z180_IO_BASE+0x31) DMODE ;  /* DMA mode register */
__sfr __at (Z180_IO_BASE+0x32) DCNTL ;  /* DMA/WAIT control register */

__sfr __at (Z180_IO_BASE+0x33) IL    ;  /* Interrupt vector low register */
__sfr __at (Z180_IO_BASE+0x34) ITC   ;  /* INT/TRAP control register */

__sfr __at (Z180_IO_BASE+0x36) RCR   ;  /* Refresh control register */

__sfr __at (Z180_IO_BASE+0x38) CBR   ;  /* MMU common base register */
__sfr __at (Z180_IO_BASE+0x39) BBR   ;  /* MMU bank base register */
__sfr __at (Z180_IO_BASE+0x3A) CBAR  ;  /* MMU common/bank area register */

__sfr __at (Z180_IO_BASE+0x3E) OMCR  ;  /* Operation mode control register */

__sfr __at               0x3F  ICR   ;  /* I/O base control register - does not move */

/*
 *---------------------------------------------------------------------------
 *      Interrupt vectors (offsets) for Z180/HD64180 internal interrupts
 */
#define INT1_VECTOR     0x00    /* external /INT1 */
#define INT2_VECTOR     0x02    /* external /INT2 */
#define PRT0_VECTOR     0x04    /* PRT channel 0 */
#define PRT1_VECTOR     0x06    /* PRT channel 1 */
#define DMA0_VECTOR     0x08    /* DMA channel 0 */ /* ???? */
#define DMA1_VECTOR     0x0A    /* DMA Channel 1 */
#define CSIO_VECTOR     0x0C    /* Clocked serial I/O */
#define ASCI0_VECTOR    0x0E    /* Async channel 0 */
#define ASCI1_VECTOR    0x10    /* Async channel 1 */
#define INCAP_VECTOR    0x12    /* input capture */
#define OUTCMP_VECTOR   0x14    /* output compare */
#define TIMOV_VECTOR    0x16    /* timer overflow */
/*
 *---------------------------------------------------------------------------
 */
#endif  /* __Z180_H__ */
/*-------------------------------------------------------------------------
   ds400rom.h - Interface to DS80C400 ROM functions

   Copyright (C) 2000, Kevin Vigor

   This library is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License 
   along with this library; see the file COPYING. If not, write to the
   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.

   As a special exception, if you link this library with other files,
   some of which are compiled with SDCC, to produce an executable,
   this library does not by itself cause the resulting executable to
   be covered by the GNU General Public License. This exception does
   not however invalidate any other reasons why the executable file
   might be covered by the GNU General Public License.
-------------------------------------------------------------------------*/

#ifndef DS400ROM_H_
#define DS400ROM_H_

extern unsigned char init_rom(void __xdata *loMem,
			      void __xdata *hiMem) __naked;

extern unsigned long task_gettimemillis_long(void) __naked;

extern unsigned char task_getthreadID(void) __naked;

/** Timer reload value for 14.746 MHz crystal. */
#define RELOAD_14_746 0xfb33

/** Timer reload value for 18.432 MHz crystal. */
#define RELOAD_18_432 0xfa00

/** Timer reload value for 29.491 MHz crystal. */
#define RELOAD_29_491 0xfd99

/** Timer reload value for 36.864 MHz crystal. */
#define RELOAD_36_864 0xfd00

/** Timer reload value for 58.982 MHz crystal. */
#define RELOAD_58_982 0xfecc

/** Timer reload value for 73.728 MHz crystal. */
#define RELOAD_73_728 0xfe80

extern unsigned int task_gettickreload(void);

extern void task_settickreload(unsigned);

#endif
!<arch>
/               1458795436  0     0     0       3024      `
   à  è  è  è  è  è  >  >  >  >  >  >  >  Ú  Ú  Ú        &  &  &  ì  ì  ì        ä  ä  ä  ä  ö  ö  ö  ö   `   `   `  ""  ""  #º  #º  $Þ  $Þ  %ì  %ì  &Ø  &Ø  '®  '®  (  (  )x  )x  )x  +¾  +¾  <|  <|  >æ  >æ  AT  AT  Dð  Dð  GP  GP  I¦  P  P  T®  T®  XÄ  XÄ  ]¢  ]¢  `¢  `¢  c¤  iÊ    ¬  °ð  ³Ð  ¸ú  À  È  ÍD  Ð:  ÔÊ  Û&  Û&  ôd  ôd  út  út     Ê Ê ( ( +b +b 6Æ 6Æ P P S  S  X X q q v6 v6 { { J J Â Â ­æ °j ²ð ²ð Àä Àä Ç Ç Í® Í® ÑD Ó  Ù  Þ äh èÖ èÖ òÌ þ þ ¨ â â ø  v  v #¶ &Ü )t , /h 38 6 9 9 =
 A Df Iä LV NÈ U ^ ^ _v bd bd g j n qÂ u& zP *  ¶ ´   Ö " £V §Ò «P ®  ®  ±x ±x ºÎ ºÎ Ål Ål Ål Ë â â      ü ü ü ü ü ü ü ü ü IÎ IÎ IÎ R R Z< \6 \6 \6 a  a  a .__.ABS. __divuint __divuchar __divu16 __divu8 .__.ABS. __div_signexte __divschar __get_remainder __div16 __div8 __divsint .__.ABS. __divuschar __divsuchar .__.ABS. __moduchar __moduint .__.ABS. __modschar __modsint .__.ABS. __moduschar __modsuchar .__.ABS. __mulint __mul16 .__.ABS. __muluschar __mulsuchar __mulschar .__.ABS. _putchar _putchar_rr_s _putchar_rr_dbs .__.ABS. __sdcc_heap_start __sdcc_heap_end .__.ABS. _memmove .__.ABS. _strcpy .__.ABS. _strlen .__.ABS. _abs .__.ABS. ___sdcc_call_hl .__.ABS. ___sdcc_call_iy .__.ABS. ___sdcc_enter_ix .__.ABS. _longjmp ___setjmp .__.ABS. _atof .__.ABS. ___schar2fs .__.ABS. ___sint2fs .__.ABS. ___slong2fs .__.ABS. ___uchar2fs .__.ABS. ___uint2fs ___ulong2fs .__.ABS. ___fs2schar .__.ABS. ___fs2sint .__.ABS. ___fs2slong .__.ABS. ___fs2uchar .__.ABS. ___fs2uint ___fs2ulong ___fsadd ___fsdiv ___fsmul ___fssub ___fseq ___fsgt ___fslt ___fsneq _fabsf _frexpf _ldexpf .__.ABS. _expf .__.ABS. _powf .__.ABS. _sincosf .__.ABS. _sinf .__.ABS. _cosf .__.ABS. _logf .__.ABS. _log10f .__.ABS. _sqrtf .__.ABS. _tancotf .__.ABS. _tanf .__.ABS. _cotf .__.ABS. _asincosf .__.ABS. _asinf .__.ABS. _acosf .__.ABS. _atanf .__.ABS. _atan2f .__.ABS. _sincoshf _sinhf _coshf .__.ABS. _tanhf .__.ABS. _floorf .__.ABS. _ceilf .__.ABS. _modff _errno __divslong __modslong __modulong __divulong .__.ABS. __mullong __mullonglong .__.ABS. __divslonglong __divulonglong .__.ABS. __modslonglong __modulonglong .__.ABS. _isalnum _isalpha _isblank _iscntrl _isdigit _isgraph _islower _isprint .__.ABS. _ispunct _isspace _isupper _isxdigit _tolower _toupper _atoi _atol .__.ABS. _abs _labs _rand _srand _strcat _strchr _strcmp _strcspn _strncat _strncmp _strxfrm _strncpy _strpbrk _strrchr _strspn _strstr _strtok _memchr _memcmp _memcpy _memset .__.ABS. _calloc _malloc __sdcc_heap_init .__.ABS. _realloc _free __sdcc_find_memheader __sdcc_prev_memheader __print_format .__.ABS. _puts .__.ABS. _gets __assert _RtcRead _asctime _time _localtime _gmtime _mktime _ctime ___month ___day .__.ABS. __uitoa __itoa __ultoa __ltoa __sdcc_external_startup .__.ABS. _vsprintf _sprintf .__.ABS. _vprintf _printf  //                                              152       `
__sdcc_call_hl.rel/
__sdcc_call_iy.rel/
_mullonglong.rel/
_divslonglong.rel/
_divulonglong.rel/
_modslonglong.rel/
_modulonglong.rel/
printf_large.rel/
divunsigned.rel/1458795406  2001  2501  100664  794       `
XL2
H 1 areas 5 global symbols
S .__.ABS. Def0000
A _CODE size 41 flags 0 addr 0
S __divuint Def0000
S __divuchar Def0008
S __divu16 Def0012
S __divu8 Def000F
T 00 00
R 00 00 00 00
T 00 00 F1 E1 D1 D5 E5 F5 18 0A
R 00 00 00 00
T 08 00
R 00 00 00 00
T 08 00 21 03 00 39 5E 2B 6E
R 00 00 00 00
T 0F 00
R 00 00 00 00
T 0F 00 26 00 54
R 00 00 00 00
T 12 00
R 00 00 00 00
T 12 00 7B E6 80 B2 20 10
R 00 00 00 00
T 18 00
R 00 00 00 00
T 18 00 06 10 ED 6A
R 00 00 00 00
T 1C 00
R 00 00 00 00
T 1C 00 17 93 30 01 83
R 00 00 00 00
T 21 00
R 00 00 00 00
T 21 00 3F ED 6A 10 F6 5F C9
R 00 00 00 00
T 28 00
R 00 00 00 00
T 28 00 06 09 7D 6C 26 00 CB 1D
R 00 00 00 00
T 30 00
R 00 00 00 00
T 30 00 ED 6A ED 52 30 01 19
R 00 00 00 00
T 37 00
R 00 00 00 00
T 37 00 3F 17 10 F5 CB 10 50 5F EB C9
R 00 00 00 00
divsigned.rel/  1458795406  2001  2501  100664  863       `
XL2
H 1 areas 8 global symbols
S __divu16 Ref0000
S .__.ABS. Def0000
A _CODE size 48 flags 0 addr 0
S __div_signexte Def0014
S __divschar Def0009
S __get_remainder Def003E
S __div16 Def0018
S __div8 Def0010
S __divsint Def0000
T 00 00
R 00 00 00 00
T 00 00 F1 E1 D1 D5 E5 F5 C3 18 00
R 00 00 00 00 00 09 00 00
T 09 00
R 00 00 00 00
T 09 00 21 03 00 39 5E 2B 6E
R 00 00 00 00
T 10 00
R 00 00 00 00
T 10 00 7D 07 9F 67
R 00 00 00 00
T 14 00
R 00 00 00 00
T 14 00 7B 07 9F 57
R 00 00 00 00
T 18 00
R 00 00 00 00
T 18 00 7C AA 17 7C F5 17 30 06 97 95 6F 9F 94 67
R 00 00 00 00
T 26 00
R 00 00 00 00
T 26 00 CB 7A 28 06 97 93 5F 9F 92 57
R 00 00 00 00
T 30 00
R 00 00 00 00
T 30 00 CD 00 00
R 00 00 00 00 02 03 00 00
T 33 00
R 00 00 00 00
T 33 00 F1 D0 47 97 95 6F 9F 94 67 78 C9
R 00 00 00 00
T 3E 00
R 00 00 00 00
T 3E 00 17 EB D0 97 95 6F 9F 94 67 C9
R 00 00 00 00

divmixed.rel/   1458795406  2001  2501  100664  383       `
XL2
H 1 areas 5 global symbols
S __div_signexte Ref0000
S .__.ABS. Def0000
S __div16 Ref0000
A _CODE size 1B flags 0 addr 0
S __divuschar Def000C
S __divsuchar Def0000
T 00 00
R 00 00 00 00
T 00 00 21 03 00 39 5E 2B 6E 26 00 C3 00 00
R 00 00 00 00 02 0C 00 00
T 0C 00
R 00 00 00 00
T 0C 00 21 03 00 54 39 5E 2B 6E 7D 07 9F 67 C3
R 00 00 00 00
T 19 00 00 00
R 00 00 00 00 02 02 02 00

modunsigned.rel/1458795406  2001  2501  100664  340       `
XL2
H 1 areas 5 global symbols
S __divu16 Ref0000
S .__.ABS. Def0000
S __divu8 Ref0000
A _CODE size 17 flags 0 addr 0
S __moduchar Def0000
S __moduint Def000C
T 00 00
R 00 00 00 00
T 00 00 21 03 00 39 5E 2B 6E CD 00 00 EB C9
R 00 00 00 00 02 0A 02 00
T 0C 00
R 00 00 00 00
T 0C 00 F1 E1 D1 D5 E5 F5 CD 00 00 EB C9
R 00 00 00 00 02 09 00 00
modsigned.rel/  1458795406  2001  2501  100664  394       `
XL2
H 1 areas 6 global symbols
S __get_remainder Ref0000
S .__.ABS. Def0000
S __div16 Ref0000
S __div8 Ref0000
A _CODE size 19 flags 0 addr 0
S __modschar Def0000
S __modsint Def000D
T 00 00
R 00 00 00 00
T 00 00 21 03 00 39 5E 2B 6E CD 00 00 C3 00 00
R 00 00 00 00 02 0A 03 00 02 0D 00 00
T 0D 00
R 00 00 00 00
T 0D 00 F1 E1 D1 D5 E5 F5 CD 00 00 C3 00 00
R 00 00 00 00 02 09 02 00 02 0C 00 00
modmixed.rel/   1458795406  2001  2501  100664  473       `
XL2
H 1 areas 6 global symbols
S __div_signexte Ref0000
S __get_remainder Ref0000
S .__.ABS. Def0000
S __div16 Ref0000
A _CODE size 21 flags 0 addr 0
S __moduschar Def000F
S __modsuchar Def0000
T 00 00
R 00 00 00 00
T 00 00 21 03 00 39 5E 2B 6E 26 00 CD 00 00 C3
R 00 00 00 00 02 0C 00 00
T 0D 00 00 00
R 00 00 00 00 02 02 01 00
T 0F 00
R 00 00 00 00
T 0F 00 21 03 00 54 39 5E 2B 6E 7D 07 9F 67 CD
R 00 00 00 00
T 1C 00 00 00 C3 00 00
R 00 00 00 00 02 02 03 00 02 05 01 00

mul.rel/        1458795406  2001  2501  100664  422       `
XL2
H 1 areas 3 global symbols
S .__.ABS. Def0000
A _CODE size 1C flags 0 addr 0
S __mulint Def0000
S __mul16 Def0008
T 00 00
R 00 00 00 00
T 00 00 F1 E1 D1 D5 E5 F5 44 4D
R 00 00 00 00
T 08 00
R 00 00 00 00
T 08 00 AF 6F B0 06 10 20 04 06 08 79
R 00 00 00 00
T 12 00
R 00 00 00 00
T 12 00 29
R 00 00 00 00
T 13 00
R 00 00 00 00
T 13 00 CB 11 17 30 01 19
R 00 00 00 00
T 19 00
R 00 00 00 00
T 19 00 10 F7 C9
R 00 00 00 00
mulchar.rel/    1458795406  2001  2501  100664  469       `
XL2
H 1 areas 5 global symbols
S .__.ABS. Def0000
S __mul16 Ref0000
A _CODE size 27 flags 0 addr 0
S __muluschar Def000A
S __mulsuchar Def0000
S __mulschar Def0014
T 00 00
R 00 00 00 00
T 00 00 21 03 00 44 39 5E 2B 4E 18 16
R 00 00 00 00
T 0A 00
R 00 00 00 00
T 0A 00 21 02 00 44 39 5E 23 4E 18 0C
R 00 00 00 00
T 14 00
R 00 00 00 00
T 14 00 21 03 00 39 5E 2B 6E 4D 7D 17 9F 47
R 00 00 00 00
T 20 00
R 00 00 00 00
T 20 00 7B 17 9F 57 C3 00 00
R 00 00 00 00 02 07 01 00

putchar.rel/    1458795406  2001  2501  100664  301       `
XL2
H 1 areas 4 global symbols
S .__.ABS. Def0000
A _CODE size E flags 0 addr 0
S _putchar Def0000
S _putchar_rr_s Def0000
S _putchar_rr_dbs Def0009
T 00 00
R 00 00 00 00
T 00 00
R 00 00 00 00
T 00 00 21 02 00 39 6E 3E 01 CF C9
R 00 00 00 00
T 09 00
R 00 00 00 00
T 09 00 6B 3E 01 CF C9
R 00 00 00 00

heap.rel/       1458795406  2001  2501  100664  390       `
XL2
H 4 areas 4 global symbols
S .__.ABS. Def0000
S __sdcc_heap_init Ref0000
A _CODE size 0 flags 0 addr 0
A _GSINIT size 3 flags 0 addr 0
A _HEAP size 3FF flags 0 addr 0
S __sdcc_heap_start Def0000
A _HEAP_END size 1 flags 0 addr 0
S __sdcc_heap_end Def0000
T 00 00 CD 00 00
R 00 00 01 00 02 03 01 00
T 00 00
R 00 00 02 00
T 00 00
R 00 00 02 00
T 00 00
R 00 00 03 00
T 00 00
R 00 00 03 00
memmove.rel/    1458795406  2001  2501  100664  347       `
XL2
H 1 areas 2 global symbols
S .__.ABS. Def0000
A _CODE size 1F flags 0 addr 0
S _memmove Def0000
T 00 00
R 00 00 00 00
T 00 00 F1 E1 D1 C1 C5 D5 E5 F5 79 B0 C8 E5 ED 52
R 00 00 00 00
T 0E 00 19 38 09
R 00 00 00 00
T 11 00
R 00 00 00 00
T 11 00 0B 09 EB 09 03 ED B8 E1 C9
R 00 00 00 00
T 1A 00
R 00 00 00 00
T 1A 00 EB ED B0 E1 C9
R 00 00 00 00

strcpy.rel/     1458795406  2001  2501  100664  231       `
XL2
H 1 areas 2 global symbols
S .__.ABS. Def0000
A _CODE size F flags 0 addr 0
S _strcpy Def0000
T 00 00
R 00 00 00 00
T 00 00 C1 D1 E1 E5 D5 C5 D5 AF
R 00 00 00 00
T 08 00
R 00 00 00 00
T 08 00 BE ED A0 20 FB E1 C9
R 00 00 00 00

strlen.rel/     1458795406  2001  2501  100664  209       `
XL2
H 1 areas 2 global symbols
S .__.ABS. Def0000
A _CODE size F flags 0 addr 0
S _strlen Def0000
T 00 00
R 00 00 00 00
T 00 00 C1 E1 E5 C5 AF 47 4F ED B1 21 FF FF ED 42
R 00 00 00 00
T 0E 00 C9
R 00 00 00 00

abs.rel/        1458795406  2001  2501  100664  175       `
XL2
H 1 areas 2 global symbols
S .__.ABS. Def0000
A _CODE size C flags 0 addr 0
S _abs Def0000
T 00 00
R 00 00 00 00
T 00 00 E1 D1 D5 E5 AF 6F 67 ED 52 F0 EB C9
R 00 00 00 00

/0              1458795406  2001  2501  100664  153       `
XL2
H 1 areas 2 global symbols
S .__.ABS. Def0000
A _CODE size 1 flags 0 addr 0
S ___sdcc_call_hl Def0000
T 00 00
R 00 00 00 00
T 00 00 E9
R 00 00 00 00

/20             1458795406  2001  2501  100664  156       `
XL2
H 1 areas 2 global symbols
S .__.ABS. Def0000
A _CODE size 2 flags 0 addr 0
S ___sdcc_call_iy Def0000
T 00 00
R 00 00 00 00
T 00 00 FD E9
R 00 00 00 00
crtenter.rel/   1458795406  2001  2501  100664  181       `
XL2
H 1 areas 2 global symbols
S .__.ABS. Def0000
A _CODE size A flags 0 addr 0
S ___sdcc_enter_ix Def0000
T 00 00
R 00 00 00 00
T 00 00 E1 DD E5 DD 21 00 00 DD 39 E9
R 00 00 00 00

setjmp.rel/     1458795406  2001  2501  100664  522       `
XL2
H 1 areas 3 global symbols
S .__.ABS. Def0000
A _CODE size 44 flags 0 addr 0
S _longjmp Def0021
S ___setjmp Def0000
T 00 00
R 00 00 00 00
T 00 00 E1 FD E1 F5 E5 FD 75 00 FD 74 01 AF 6F 67
R 00 00 00 00
T 0E 00 39 FD 75 02 FD 74 03 DD E5 E1 FD 75 04 FD
R 00 00 00 00
T 1C 00 74 05 6F 67 C9
R 00 00 00 00
T 21 00
R 00 00 00 00
T 21 00 F1 FD E1 D1 7B B2 20 01 13
R 00 00 00 00
T 2A 00
R 00 00 00 00
T 2A 00 FD 6E 04 FD 66 05 E5 DD E1 FD 6E 02 FD 66
R 00 00 00 00
T 38 00 03 F9 E1 EB FD 4E 00 FD 46 01 C5 C9
R 00 00 00 00
_atof.rel/      1458795407  2001  2501  100664  4226      `
XL2
H 9 areas 9 global symbols
M _atof
O -mz80
S ___fsmul Ref0000
S _isspace Ref0000
S _isdigit Ref0000
S _atoi Ref0000
S .__.ABS. Def0000
S ___fsadd Ref0000
S ___sint2fs Ref0000
S _toupper Ref0000
A _CODE size 299 flags 0 addr 0
S _atof Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 F0 FF 39 F9 DD
R 00 00 00 00
T 0E 00 4E 04 DD 46 05
R 00 00 00 00
T 13 00
R 00 00 00 00
T 13 00 0A 6F 17 9F 67 C5 E5 CD 00 00 F1 C1 59 50
R 00 00 00 00 02 0A 01 00
T 21 00 13 7C B5 28 04 4B 42 18 E9
R 00 00 00 00
T 2A 00
R 00 00 00 00
T 2A 00 DD 71 04 DD 70 05 0A 67 D6 2D 20 0C DD 36
R 00 00 00 00
T 38 00 F0 01 DD 73 04 DD 72 05 18 0F
R 00 00 00 00
T 42 00
R 00 00 00 00
T 42 00 DD 36 F0 00 7C D6 2B 20 06 DD 73 04 DD 72
R 00 00 00 00
T 50 00 05
R 00 00 00 00
T 51 00
R 00 00 00 00
T 51 00 DD 36 F5 00 DD 36 F6 00 DD 36 F7 00 DD 36
R 00 00 00 00
T 5F 00 F8 00 DD 4E 04 DD 46 05
R 00 00 00 00
T 67 00
R 00 00 00 00
T 67 00 0A 6F 17 9F 67 C5 E5 CD 00 00 F1 EB C1 0A
R 00 00 00 00 02 0A 02 00
T 75 00 DD 77 FF 21 01 00 09 DD 75 FD DD 74 FE 7A
R 00 00 00 00
T 83 00 B3 28 6C DD 6E F7 DD 66 F8 E5 DD 6E F5 DD
R 00 00 00 00
T 91 00 66 F6 E5 21 20 41 E5 21 00 00 E5 CD 00 00
R 00 00 00 00 02 0E 00 00
T 9F 00 F1 F1 F1 F1 DD 72 FC DD 73 FB DD 74 FA DD
R 00 00 00 00
T AD 00 75 F9 DD 66 FF DD 7E FF 17 9F 57 7C C6 D0
R 00 00 00 00
T BB 00 6F 7A CE FF 67 E5 CD 00 00 F1 EB E5 D5 DD
R 00 00 00 00 02 09 06 00
T C9 00 6E FB DD 66 FC E5 DD 6E F9 DD 66 FA E5 CD
R 00 00 00 00
T D7 00 00 00 F1 F1 F1 F1 DD 75 F5 DD 74 F6 DD 73
R 00 00 00 00 02 02 05 00
T E5 00 F7 DD 72 F8 DD 4E FD DD 46 FE C3 67 00
R 00 00 00 00 00 0D 00 00
T F2 00
R 00 00 00 00
T F2 00 DD 71 04 DD 70 05 DD 7E FF D6 2E C2 D4 01
R 00 00 00 00 00 0E 00 00
T 00 01 DD 36 F1 CD DD 36 F2 CC DD 36 F3 CC DD 36
R 00 00 00 00
T 0E 01 F4 3D DD 7E FD DD 77 F9 DD 7E FE DD 77 FA
R 00 00 00 00
T 1C 01
R 00 00 00 00
T 1C 01 DD 6E F9 DD 66 FA 7E DD 77 FD DD 77 FD 17
R 00 00 00 00
T 2A 01 9F DD 77 FE DD 6E FD DD 66 FE E5 CD 00 00
R 00 00 00 00 02 0E 02 00
T 38 01 F1 7C B5 CA C8 01 DD 6E F9 DD 66 FA 7E 67
R 00 00 00 00 00 06 00 00
T 46 01 17 9F 6F 7C C6 D0 5F 7D CE FF 57 D5 CD
R 00 00 00 00
T 53 01 00 00 F1 4D 44 DD 6E F3 DD 66 F4 E5 DD 6E
R 00 00 00 00 02 02 06 00
T 61 01 F1 DD 66 F2 E5 D5 C5 CD 00 00 F1 F1 F1 F1
R 00 00 00 00 02 0A 00 00
T 6F 01 EB E5 D5 DD 6E F7 DD 66 F8 E5 DD 6E F5 DD
R 00 00 00 00
T 7D 01 66 F6 E5 CD 00 00 F1 F1 F1 F1 DD 75 F5 DD
R 00 00 00 00 02 06 05 00
T 8B 01 74 F6 DD 73 F7 DD 72 F8 DD 6E F3 DD 66 F4
R 00 00 00 00
T 99 01 E5 DD 6E F1 DD 66 F2 E5 21 CC 3D E5 21
R 00 00 00 00
T A6 01 CD CC E5 CD 00 00 F1 F1 F1 F1 DD 75 F1 DD
R 00 00 00 00 02 06 00 00
T B4 01 74 F2 DD 73 F3 DD 72 F4 DD 34 F9 C2 1C 01
R 00 00 00 00 00 0E 00 00
T C2 01 DD 34 FA C3 1C 01
R 00 00 00 00 00 06 00 00
T C8 01
R 00 00 00 00
T C8 01 DD 7E F9 DD 77 04 DD 7E FA DD 77 05
R 00 00 00 00
T D4 01
R 00 00 00 00
T D4 01 DD 7E 04 DD 77 F9 DD 7E 05 DD 77 FA DD 6E
R 00 00 00 00
T E2 01 F9 DD 66 FA 7E 6F 17 9F 67 E5 CD 00 00 F1
R 00 00 00 00 02 0D 07 00
T F0 01 7D D6 45 C2 7A 02 B4 C2 7A 02 DD 7E F9 C6
R 00 00 00 00 00 06 00 00 00 0A 00 00
T FE 01 01 DD 77 04 DD 7E FA CE 00 DD 77 05 DD 6E
R 00 00 00 00
T 0C 02 04 DD 66 05 E5 CD 00 00 F1 45
R 00 00 00 00 02 08 03 00
T 16 02
R 00 00 00 00
T 16 02 78 B7 28 60 CB 78 28 2E C5 DD 6E F7 DD 66
R 00 00 00 00
T 24 02 F8 E5 DD 6E F5 DD 66 F6 E5 21 CC 3D E5 21
R 00 00 00 00
T 32 02 CD CC E5 CD 00 00 F1 F1 F1 F1 C1 DD 75 F5
R 00 00 00 00 02 06 00 00
T 40 02 DD 74 F6 DD 73 F7 DD 72 F8 04 18 CA
R 00 00 00 00
T 4C 02
R 00 00 00 00
T 4C 02 C5 DD 6E F7 DD 66 F8 E5 DD 6E F5 DD 66 F6
R 00 00 00 00
T 5A 02 E5 21 20 41 E5 21 00 00 E5 CD 00 00 F1 F1
R 00 00 00 00 02 0C 00 00
T 68 02 F1 F1 C1 DD 75 F5 DD 74 F6 DD 73 F7 DD 72
R 00 00 00 00
T 76 02 F8 05 18 9C
R 00 00 00 00
T 7A 02
R 00 00 00 00
T 7A 02 DD CB F0 46 28 08 DD 7E F8 EE 80 DD 77 F8
R 00 00 00 00
T 88 02
R 00 00 00 00
T 88 02 DD 6E F5 DD 66 F6 DD 5E F7 DD 56 F8 DD F9
R 00 00 00 00
T 96 02 DD E1 C9
R 00 00 00 00
_schar2fs.rel/  1458795407  2001  2501  100664  557       `
XL2
H 9 areas 3 global symbols
M _schar2fs
O -mz80
S ___slong2fs Ref0000
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 19 flags 0 addr 0
S ___schar2fs Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 FD 21 02 00 FD 39 FD 6E 00 FD 7E 00 17 9F
R 00 00 04 00
T 0E 00 67 5F 57 D5 E5 CD 00 00 F1 F1 C9
R 00 00 04 00 02 08 00 00

_sint2fs.rel/   1458795407  2001  2501  100664  561       `
XL2
H 9 areas 3 global symbols
M _sint2fs
O -mz80
S ___slong2fs Ref0000
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 1B flags 0 addr 0
S ___sint2fs Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 FD 21 02 00 FD 39 FD 6E 00 FD 66 01 FD 7E
R 00 00 04 00
T 0E 00 01 17 9F 5F 57 D5 E5 CD 00 00 F1 F1 C9
R 00 00 04 00 02 0A 00 00

_slong2fs.rel/  1458795407  2001  2501  100664  864       `
XL2
H 9 areas 3 global symbols
M _slong2fs
O -mz80
S ___ulong2fs Ref0000
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 48 flags 0 addr 0
S ___slong2fs Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 DD CB 07 7E 28 24
R 00 00 04 00
T 0E 00 AF DD 96 04 6F 3E 00 DD 9E 05 67 3E 00 DD
R 00 00 04 00
T 1C 00 9E 06 5F 3E 00 DD 9E 07 57 D5 E5 CD 00 00
R 00 00 04 00 02 0E 00 00
T 2A 00 F1 F1 7A EE 80 57 18 13
R 00 00 04 00
T 32 00
R 00 00 04 00
T 32 00 DD 6E 06 DD 66 07 E5 DD 6E 04 DD 66 05 E5
R 00 00 04 00
T 40 00 CD 00 00 F1 F1
R 00 00 04 00 02 03 00 00
T 45 00
R 00 00 04 00
T 45 00 DD E1 C9
R 00 00 04 00
_uchar2fs.rel/  1458795407  2001  2501  100664  548       `
XL2
H 9 areas 3 global symbols
M _uchar2fs
O -mz80
S ___ulong2fs Ref0000
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 16 flags 0 addr 0
S ___uchar2fs Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 FD 21 02 00 FD 39 FD 6E 00 26 00 11 00 00
R 00 00 04 00
T 0E 00 D5 E5 CD 00 00 F1 F1 C9
R 00 00 04 00 02 05 00 00
_uint2fs.rel/   1458795407  2001  2501  100664  537       `
XL2
H 9 areas 3 global symbols
M _uint2fs
O -mz80
S ___ulong2fs Ref0000
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 13 flags 0 addr 0
S ___uint2fs Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 21 02 00 39 7E 23 66 6F 11 00 00 D5 E5 CD
R 00 00 04 00
T 0E 00 00 00 F1 F1 C9
R 00 00 04 00 02 02 00 00

_ulong2fs.rel/  1458795408  2001  2501  100664  1722      `
XL2
H 9 areas 2 global symbols
M _ulong2fs
O -mz80
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size E6 flags 0 addr 0
S ___ulong2fs Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 FA FF 39 F9 DD
R 00 00 04 00
T 0E 00 7E 07 DD B6 06 DD B6 05 DD B6 04 20 08 21
R 00 00 04 00
T 1C 00 00 00 5D 54 C3 E1 00
R 00 00 04 00 00 07 04 00
T 23 00
R 00 00 04 00
T 23 00 21 96 00
R 00 00 04 00
T 26 00
R 00 00 04 00
T 26 00 DD 7E 07 B7 28 15 F5 F1 DD CB 07 3E DD CB
R 00 00 04 00
T 34 00 06 1E DD CB 05 1E DD CB 04 1E 23 18 E5
R 00 00 04 00
T 41 00
R 00 00 04 00
T 41 00
R 00 00 04 00
T 41 00 DD 7E 06 D6 80 DD 7E 07 DE 00 30 15 F5 F1
R 00 00 04 00
T 4F 00 DD CB 04 26 DD CB 05 16 DD CB 06 16 DD CB
R 00 00 04 00
T 5D 00 07 16 2B 18 DF
R 00 00 04 00
T 62 00
R 00 00 04 00
T 62 00 DD 75 FE DD 74 FF DD 56 04 DD 5E 05 DD 4E
R 00 00 04 00
T 70 00 06 CB B9 06 00 14 20 1F 1C 20 1C 79 D6 7F
R 00 00 04 00
T 7E 00 20 17 B0 20 14 AF DD 77 04 DD 77 05 DD 77
R 00 00 04 00
T 8C 00 06 DD 77 07 23 DD 75 FE DD 74 FF
R 00 00 04 00
T 97 00
R 00 00 04 00
T 97 00 DD CB 06 BE 21 00 00 39 DD 5E FE DD 56 FF
R 00 00 04 00
T A5 00 DD 7E FF 17 9F 4F 47 3E 17
R 00 00 04 00
T AE 00
R 00 00 04 00
T AE 00 CB 23 CB 12 CB 11 CB 10 3D 20 F5 7B DD B6
R 00 00 04 00
T BC 00 04 5F 7A DD B6 05 57 79 DD B6 06 4F 78 DD
R 00 00 04 00
T CA 00 B6 07 47 73 23 72 23 71 23 70 21 00 00 39
R 00 00 04 00
T D8 00 46 23 4E 23 5E 23 56 68 61
R 00 00 04 00
T E1 00
R 00 00 04 00
T E1 00 DD F9 DD E1 C9
R 00 00 04 00
_fs2schar.rel/  1458795408  2001  2501  100664  982       `
XL2
H 9 areas 3 global symbols
M _fs2schar
O -mz80
S ___fs2slong Ref0000
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 4E flags 0 addr 0
S ___fs2schar Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 DD 6E 06 DD 66 07
R 00 00 04 00
T 0E 00 E5 DD 6E 04 DD 66 05 E5 CD 00 00 F1 F1 4D
R 00 00 04 00 02 0B 00 00
T 1C 00 44 79 D6 7F 78 DE 00 7B DE 00 7A 17 3F 1F
R 00 00 04 00
T 2A 00 DE 80 38 04 2E 7F 18 19
R 00 00 04 00
T 32 00
R 00 00 04 00
T 32 00 3E 80 B9 3E FF 98 3E FF 9B 3E FF 9A E2
R 00 00 04 00
T 3F 00 43 00 EE 80
R 00 00 04 00 00 02 04 00
T 43 00
R 00 00 04 00
T 43 00 FA 4A 00 2E 80 18 01
R 00 00 04 00 00 03 04 00
T 4A 00
R 00 00 04 00
T 4A 00 69
R 00 00 04 00
T 4B 00
R 00 00 04 00
T 4B 00 DD E1 C9
R 00 00 04 00
_fs2sint.rel/   1458795408  2001  2501  100664  986       `
XL2
H 9 areas 3 global symbols
M _fs2sint
O -mz80
S ___fs2slong Ref0000
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 50 flags 0 addr 0
S ___fs2sint Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 DD 6E 06 DD 66 07
R 00 00 04 00
T 0E 00 E5 DD 6E 04 DD 66 05 E5 CD 00 00 F1 F1 4D
R 00 00 04 00 02 0B 00 00
T 1C 00 44 79 D6 FF 78 DE 7F 7B DE 00 7A 17 3F 1F
R 00 00 04 00
T 2A 00 DE 80 38 05 21 FF 7F 18 1A
R 00 00 04 00
T 33 00
R 00 00 04 00
T 33 00 AF B9 3E 80 98 3E FF 9B 3E FF 9A E2 43 00
R 00 00 04 00 00 0E 04 00
T 41 00 EE 80
R 00 00 04 00
T 43 00
R 00 00 04 00
T 43 00 FA 4B 00 21 00 80 18 02
R 00 00 04 00 00 03 04 00
T 4B 00
R 00 00 04 00
T 4B 00 69 60
R 00 00 04 00
T 4D 00
R 00 00 04 00
T 4D 00 DD E1 C9
R 00 00 04 00
_fs2slong.rel/  1458795408  2001  2501  100664  1185      `
XL2
H 9 areas 4 global symbols
M _fs2slong
O -mz80
S ___fs2ulong Ref0000
S ___fslt Ref0000
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 7D flags 0 addr 0
S ___fs2slong Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 DD 7E 07 CB BF DD
R 00 00 04 00
T 0E 00 B6 06 DD B6 05 DD B6 04 20 07 21 00 00 5D
R 00 00 04 00
T 1C 00 54 18 5B
R 00 00 04 00
T 1F 00
R 00 00 04 00
T 1F 00 21 00 00 E5 21 00 00 E5 DD 6E 06 DD 66 07
R 00 00 04 00
T 2D 00 E5 DD 6E 04 DD 66 05 E5 CD 00 00 F1 F1 F1
R 00 00 04 00 02 0B 01 00
T 3B 00 F1 7D B7 28 27 DD 7E 07 EE 80 57 DD 6E 04
R 00 00 04 00
T 49 00 DD 66 05 DD 5E 06 D5 E5 CD 00 00 F1 F1 AF
R 00 00 04 00 02 0B 00 00
T 57 00 95 6F 3E 00 9C 67 3E 00 9B 5F 3E 00 9A 57
R 00 00 04 00
T 65 00 18 13
R 00 00 04 00
T 67 00
R 00 00 04 00
T 67 00 DD 6E 06 DD 66 07 E5 DD 6E 04 DD 66 05 E5
R 00 00 04 00
T 75 00 CD 00 00 F1 F1
R 00 00 04 00 02 03 00 00
T 7A 00
R 00 00 04 00
T 7A 00 DD E1 C9
R 00 00 04 00

_fs2uchar.rel/  1458795408  2001  2501  100664  708       `
XL2
H 9 areas 3 global symbols
M _fs2uchar
O -mz80
S ___fs2ulong Ref0000
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 2E flags 0 addr 0
S ___fs2uchar Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 DD 6E 06 DD 66 07
R 00 00 04 00
T 0E 00 E5 DD 6E 04 DD 66 05 E5 CD 00 00 F1 F1 7D
R 00 00 04 00 02 0B 00 00
T 1C 00 D6 FF 7C DE 00 7B DE 00 7A DE 00 38 02 2E
R 00 00 04 00
T 2A 00 FF
R 00 00 04 00
T 2B 00
R 00 00 04 00
T 2B 00 DD E1 C9
R 00 00 04 00
_fs2uint.rel/   1458795408  2001  2501  100664  709       `
XL2
H 9 areas 3 global symbols
M _fs2uint
O -mz80
S ___fs2ulong Ref0000
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 2F flags 0 addr 0
S ___fs2uint Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 DD 6E 06 DD 66 07
R 00 00 04 00
T 0E 00 E5 DD 6E 04 DD 66 05 E5 CD 00 00 F1 F1 7D
R 00 00 04 00 02 0B 00 00
T 1C 00 D6 FF 7C DE FF 7B DE 00 7A DE 00 38 03 21
R 00 00 04 00
T 2A 00 FF FF
R 00 00 04 00
T 2C 00
R 00 00 04 00
T 2C 00 DD E1 C9
R 00 00 04 00

_fs2ulong.rel/  1458795408  2001  2501  100664  1513      `
XL2
H 9 areas 2 global symbols
M _fs2ulong
O -mz80
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size C5 flags 0 addr 0
S ___fs2ulong Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 F6 FF 39 F9 21
R 00 00 04 00
T 0E 00 06 00 39 EB 21 0E 00 39 01 04 00 ED B0 21
R 00 00 04 00
T 1C 00 06 00 39 5E 23 56 23 4E 23 7E B1 B2 B3 28
R 00 00 04 00
T 2A 00 11 21 06 00 39 5E 23 56 23 4E 23 7E CB 07
R 00 00 04 00
T 38 00 E6 01 28 08
R 00 00 04 00
T 3C 00
R 00 00 04 00
T 3C 00 21 00 00 5D 54 C3 C0 00
R 00 00 04 00 00 08 04 00
T 44 00
R 00 00 04 00
T 44 00 21 06 00 39 5E 23 56 23 4E 23 46 3E 17
R 00 00 04 00
T 51 00
R 00 00 04 00
T 51 00 CB 38 CB 19 CB 1A CB 1B 3D 20 F5 16 00 01
R 00 00 04 00
T 5F 00 00 00 7B C6 6A 6F 7A CE FF 67 79 CE FF 78
R 00 00 04 00
T 6D 00 CE FF DD 75 FA DD 74 FB 21 06 00 39 5E 23
R 00 00 04 00
T 7B 00 56 23 4E 23 46 CB B9 06 00 DD 73 F6 DD 72
R 00 00 04 00
T 89 00 F7 79 CB FF DD 77 F8 DD 70 F9 AF DD 96 FA
R 00 00 04 00
T 97 00 47 3E 00 DD 9E FB F5 F1 04 18 10
R 00 00 04 00
T A2 00
R 00 00 04 00
T A2 00 DD CB F9 2E DD CB F8 1E DD CB F7 1E DD CB
R 00 00 04 00
T B0 00 F6 1E
R 00 00 04 00
T B2 00
R 00 00 04 00
T B2 00 10 EE DD 6E F6 DD 66 F7 DD 5E F8 DD 56 F9
R 00 00 04 00
T C0 00
R 00 00 04 00
T C0 00 DD F9 DD E1 C9
R 00 00 04 00

_fsadd.rel/     1458795409  2001  2501  100664  6804      `
XL2
H 9 areas 2 global symbols
M _fsadd
O -mz80
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 455 flags 0 addr 0
S ___fsadd Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 E1 FF 39 F9 21
R 00 00 04 00
T 0E 00 27 00 39 EB 21 11 00 39 EB 01 04 00 ED B0
R 00 00 04 00
T 1C 00 21 17 00 39 EB 21 11 00 39 01 04 00 ED B0
R 00 00 04 00
T 2A 00 F5 DD 6E F8 DD 66 F9 DD 56 FA DD 4E FB F1
R 00 00 04 00
T 38 00 06 17
R 00 00 04 00
T 3A 00
R 00 00 04 00
T 3A 00 CB 39 CB 1A CB 1C CB 1D 10 F6 DD 75 E4 DD
R 00 00 04 00
T 48 00 36 E5 00 DD 6E F8 DD 66 F9 DD 4E FA CB B9
R 00 00 04 00
T 56 00 06 00 79 CB FF 57 F5 DD 75 EA DD 74 EB DD
R 00 00 04 00
T 64 00 72 EC DD 70 ED F1 3E 04
R 00 00 04 00
T 6C 00
R 00 00 04 00
T 6C 00 DD CB EA 26 DD CB EB 16 DD CB EC 16 DD CB
R 00 00 04 00
T 7A 00 ED 16 3D 20 ED DD 7E FB CB 07 E6 01 28 1F
R 00 00 04 00
T 88 00 AF DD 96 EA DD 77 EA 3E 00 DD 9E EB DD 77
R 00 00 04 00
T 96 00 EB 3E 00 DD 9E EC DD 77 EC 3E 00 DD 9E ED
R 00 00 04 00
T A4 00 DD 77 ED
R 00 00 04 00
T A7 00
R 00 00 04 00
T A7 00 DD 7E F5 DD B6 F4 DD B6 F3 DD B6 F2 20 0F
R 00 00 04 00
T B5 00 DD 6E 04 DD 66 05 DD 5E 06 DD 56 07 C3
R 00 00 04 00
T C2 00 50 04
R 00 00 04 00 00 02 04 00
T C4 00
R 00 00 04 00
T C4 00 21 23 00 39 DD 75 F8 DD 74 F9 DD 7E F8 DD
R 00 00 04 00
T D2 00 77 E8 DD 7E F9 DD 77 E9 DD 5E E8 DD 56 E9
R 00 00 04 00
T E0 00 21 17 00 39 EB 01 04 00 ED B0 21 11 00 39
R 00 00 04 00
T EE 00 EB 21 17 00 39 01 04 00 ED B0 F5 DD 6E F2
R 00 00 04 00
T FC 00 DD 66 F3 DD 5E F4 DD 56 F5 F1 06 17
R 00 00 04 00
T 08 01
R 00 00 04 00
T 08 01 CB 3A CB 1B CB 1C CB 1D 10 F6 26 00 1E 00
R 00 00 04 00
T 16 01 DD 75 F6 DD 74 F7 DD 6E F2 DD 66 F3 DD 4E
R 00 00 04 00
T 24 01 F4 CB B9 06 00 79 CB FF 57 F5 DD 75 FC DD
R 00 00 04 00
T 32 01 74 FD DD 72 FE DD 70 FF F1 3E 04
R 00 00 04 00
T 3D 01
R 00 00 04 00
T 3D 01 DD CB FC 26 DD CB FD 16 DD CB FE 16 DD CB
R 00 00 04 00
T 4B 01 FF 16 3D 20 ED DD 7E F5 CB 07 E6 01 28 25
R 00 00 04 00
T 59 01 DD CB F5 7E 28 1F AF DD 96 FC DD 77 FC 3E
R 00 00 04 00
T 67 01 00 DD 9E FD DD 77 FD 3E 00 DD 9E FE DD 77
R 00 00 04 00
T 75 01 FE 3E 00 DD 9E FF DD 77 FF
R 00 00 04 00
T 7E 01
R 00 00 04 00
T 7E 01 DD 7E FB DD B6 FA DD B6 F9 DD B6 F8 20 0F
R 00 00 04 00
T 8C 01 DD 6E 08 DD 66 09 DD 5E 0A DD 56 0B C3
R 00 00 04 00
T 99 01 50 04
R 00 00 04 00 00 02 04 00
T 9B 01
R 00 00 04 00
T 9B 01 DD 7E F6 DD 96 E4 DD 77 F8 DD 7E F7 DD 9E
R 00 00 04 00
T A9 01 E5 DD 77 F9 3E 19 DD BE F8 3E 00 DD 9E F9
R 00 00 04 00
T B7 01 E2 BC 01 EE 80
R 00 00 04 00 00 03 04 00
T BC 01
R 00 00 04 00
T BC 01 F2 CE 01 DD 6E 04 DD 66 05 DD 5E 06 DD 56
R 00 00 04 00 00 03 04 00
T CA 01 07 C3 50 04
R 00 00 04 00 00 04 04 00
T CE 01
R 00 00 04 00
T CE 01 DD 7E F8 D6 E7 DD 7E F9 17 3F 1F DE 7F 30
R 00 00 04 00
T DC 01 0F DD 6E 08 DD 66 09 DD 5E 0A DD 56 0B C3
R 00 00 04 00
T EA 01 50 04
R 00 00 04 00 00 02 04 00
T EC 01
R 00 00 04 00
T EC 01 DD CB F9 7E 28 49 AF DD 96 F8 DD 77 F2 3E
R 00 00 04 00
T FA 01 00 DD 9E F9 DD 77 F3 DD 7E F2 DD 77 E2 DD
R 00 00 04 00
T 08 02 7E F3 DD 77 E3 DD 7E F6 DD 86 E2 DD 77 F6
R 00 00 04 00
T 16 02 DD 7E F7 DD 8E E3 DD 77 F7 DD 46 E2 F5 F1
R 00 00 04 00
T 24 02 04 18 10
R 00 00 04 00
T 27 02
R 00 00 04 00
T 27 02 DD CB FF 2E DD CB FE 1E DD CB FD 1E DD CB
R 00 00 04 00
T 35 02 FC 1E
R 00 00 04 00
T 37 02
R 00 00 04 00
T 37 02 10 EE 18 1A
R 00 00 04 00
T 3B 02
R 00 00 04 00
T 3B 02 DD 46 F8 F5 F1 04 18 10
R 00 00 04 00
T 43 02
R 00 00 04 00
T 43 02 DD CB ED 2E DD CB EC 1E DD CB EB 1E DD CB
R 00 00 04 00
T 51 02 EA 1E
R 00 00 04 00
T 53 02
R 00 00 04 00
T 53 02 10 EE
R 00 00 04 00
T 55 02
R 00 00 04 00
T 55 02 DD 7E FC DD 86 EA 6F DD 7E FD DD 8E EB 67
R 00 00 04 00
T 63 02 DD 7E FE DD 8E EC 5F DD 7E FF DD 8E ED 57
R 00 00 04 00
T 71 02 DD 75 EE DD 74 EF DD 73 F0 DD 72 F1 DD 36
R 00 00 04 00
T 7F 02 E1 00 DD CB F1 7E 28 25 AF DD 96 EE DD 77
R 00 00 04 00
T 8D 02 EE 3E 00 DD 9E EF DD 77 EF 3E 00 DD 9E F0
R 00 00 04 00
T 9B 02 DD 77 F0 3E 00 DD 9E F1 DD 77 F1 DD 36 E1
R 00 00 04 00
T A9 02 01 18 16
R 00 00 04 00
T AC 02
R 00 00 04 00
T AC 02 DD 7E F1 DD B6 F0 DD B6 EF DD B6 EE 20 08
R 00 00 04 00
T BA 02 21 00 00 5D 54 C3 50 04
R 00 00 04 00 00 08 04 00
T C2 02
R 00 00 04 00
T C2 02 DD 4E F6 DD 46 F7
R 00 00 04 00
T C8 02
R 00 00 04 00
T C8 02 DD 56 F0 DD 5E F1 7B D6 08 30 15 F5 F1 DD
R 00 00 04 00
T D6 02 CB EE 26 DD CB EF 16 DD CB F0 16 DD CB F1
R 00 00 04 00
T E4 02 16 0B 18 E0
R 00 00 04 00
T E8 02
R 00 00 04 00
T E8 02 DD 71 E6 DD 70 E7
R 00 00 04 00
T EE 02
R 00 00 04 00
T EE 02 21 1B 00 39 EB 21 0D 00 39 01 04 00 ED B0
R 00 00 04 00
T FC 02 DD 7E FF E6 F0 28 44 DD CB EE 46 28 20 DD
R 00 00 04 00
T 0A 03 7E EE C6 02 DD 77 EE DD 7E EF CE 00 DD 77
R 00 00 04 00
T 18 03 EF DD 7E F0 CE 00 DD 77 F0 DD 7E F1 CE 00
R 00 00 04 00
T 26 03 DD 77 F1
R 00 00 04 00
T 29 03
R 00 00 04 00
T 29 03 F5 F1 06 01 DD CB F1 2E DD CB F0 1E DD CB
R 00 00 04 00
T 37 03 EF 1E DD CB EE 1E DD 34 E6 20 AC DD 34 E7
R 00 00 04 00
T 45 03 18 A7
R 00 00 04 00
T 47 03
R 00 00 04 00
T 47 03 DD 7E E6 DD 77 F6 DD 7E E7 DD 77 F7 DD CB
R 00 00 04 00
T 55 03 FF 9E DD 7E E7 EE 80 D6 81 38 3A DD CB E1
R 00 00 04 00
T 63 03 46 28 12 DD 36 F8 00 DD 36 F9 00 DD 36 FA
R 00 00 04 00
T 71 03 80 DD 36 FB FF 18 10
R 00 00 04 00
T 78 03
R 00 00 04 00
T 78 03 DD 36 F8 00 DD 36 F9 00 DD 36 FA 80 DD 36
R 00 00 04 00
T 86 03 FB 7F
R 00 00 04 00
T 88 03
R 00 00 04 00
T 88 03 DD 5E E8 DD 56 E9 21 17 00 39 01 04 00 ED
R 00 00 04 00
T 96 03 B0 C3 44 04
R 00 00 04 00 00 04 04 00
T 9A 03
R 00 00 04 00
T 9A 03 DD CB E7 7E 28 12 DD 6E E8 DD 66 E9 AF 77
R 00 00 04 00
T A8 03 23 77 23 AF 77 23 77 C3 44 04
R 00 00 04 00 00 0A 04 00
T B2 03
R 00 00 04 00
T B2 03 DD CB E1 46 28 12 DD 36 F8 00 DD 36 F9 00
R 00 00 04 00
T C0 03 DD 36 FA 00 DD 36 FB 80 18 0D
R 00 00 04 00
T CA 03
R 00 00 04 00
T CA 03 AF DD 77 F8 DD 77 F9 DD 77 FA DD 77 FB
R 00 00 04 00
T D7 03
R 00 00 04 00
T D7 03 DD 6E F6 DD 66 F7 DD 7E F7 17 9F 5F 57 06
R 00 00 04 00
T E5 03 17
R 00 00 04 00
T E6 03
R 00 00 04 00
T E6 03 29 CB 13 CB 12 10 F9 DD 7E F8 B5 DD 77 F8
R 00 00 04 00
T F4 03 DD 7E F9 B4 DD 77 F9 DD 7E FA B3 DD 77 FA
R 00 00 04 00
T 02 04 DD 7E FB B2 DD 77 FB F5 DD 5E FC DD 56 FD
R 00 00 04 00
T 10 04 DD 6E FE DD 66 FF F1 06 04
R 00 00 04 00
T 19 04
R 00 00 04 00
T 19 04 CB 2C CB 1D CB 1A CB 1B 10 F6 DD 7E F8 B3
R 00 00 04 00
T 27 04 5F DD 7E F9 B2 57 DD 7E FA B5 4F DD 7E FB
R 00 00 04 00
T 35 04 B4 47 DD 6E E8 DD 66 E9 73 23 72 23 71 23
R 00 00 04 00
T 43 04 70
R 00 00 04 00
T 44 04
R 00 00 04 00
T 44 04 DD 6E 04 DD 66 05 DD 5E 06 DD 56 07
R 00 00 04 00
T 50 04
R 00 00 04 00
T 50 04 DD F9 DD E1 C9
R 00 00 04 00
_fsdiv.rel/     1458795410  2001  2501  100664  5334      `
XL2
H 9 areas 2 global symbols
M _fsdiv
O -mz80
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 385 flags 0 addr 0
S ___fsdiv Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 DE FF 39 F9 21
R 00 00 04 00
T 0E 00 16 00 39 EB 21 26 00 39 01 04 00 ED B0 21
R 00 00 04 00
T 1C 00 12 00 39 EB 21 2A 00 39 01 04 00 ED B0 21
R 00 00 04 00
T 2A 00 16 00 39 5E 23 56 23 4E 23 46 3E 17
R 00 00 04 00
T 36 00
R 00 00 04 00
T 36 00 CB 38 CB 19 CB 1A CB 1B 3D 20 F5 DD 73 DE
R 00 00 04 00
T 44 00 DD 36 DF 00 21 12 00 39 5E 23 56 23 4E 23
R 00 00 04 00
T 52 00 46 3E 17
R 00 00 04 00
T 55 00
R 00 00 04 00
T 55 00 CB 38 CB 19 CB 1A CB 1B 3D 20 F5 DD 73 FC
R 00 00 04 00
T 63 00 DD 36 FD 00 DD 36 FE 00 DD 36 FF 00 DD 6E
R 00 00 04 00
T 71 00 DE DD 66 DF DD 7E DF 17 9F 4F 47 7D DD 96
R 00 00 04 00
T 7F 00 FC 6F 7C DD 9E FD 67 79 DD 9E FE 78 DD 9E
R 00 00 04 00
T 8D 00 FF 5F DD 75 DE DD 74 DF DD 7E DE C6 7E DD
R 00 00 04 00
T 9B 00 77 DE DD 7E DF CE 00 DD 77 DF 21 16 00 39
R 00 00 04 00
T A9 00 5E 23 56 23 4E 23 7E CB 07 E6 01 DD 77 FC
R 00 00 04 00
T B7 00 21 12 00 39 5E 23 56 23 4E 23 46 78 CB 07
R 00 00 04 00
T C5 00 E6 01 DD AE FC 4F 21 12 00 39 C5 EB 21
R 00 00 04 00
T D2 00 20 00 39 EB 01 04 00 ED B0 C1 DD 7E FF DD
R 00 00 04 00
T E0 00 B6 FE DD B6 FD DD B6 FC 20 1E 21 12 00 39
R 00 00 04 00
T EE 00 AF 77 23 77 23 36 C0 23 36 7F 21 12 00 39
R 00 00 04 00
T FC 00 46 23 4E 23 5E 23 56 68 61 C3 80 03
R 00 00 04 00 00 0C 04 00
T 08 01
R 00 00 04 00
T 08 01 21 16 00 39 56 23 5E 23 46 23 7E B0 B3 B2
R 00 00 04 00
T 16 01 20 08 21 00 00 5D 54 C3 80 03
R 00 00 04 00 00 0A 04 00
T 20 01
R 00 00 04 00
T 20 01 21 16 00 39 5E 23 56 23 46 23 66 68 CB BD
R 00 00 04 00
T 2E 01 26 00 DD 73 E4 DD 72 E5 7D CB FF DD 77 E6
R 00 00 04 00
T 3C 01 DD 74 E7 21 12 00 39 5E 23 56 23 46 23 66
R 00 00 04 00
T 4A 01 68 CB BD 26 00 DD 73 E0 DD 72 E1 7D CB FF
R 00 00 04 00
T 58 01 DD 77 E2 DD 74 E3 DD 7E E4 DD 96 E0 DD 7E
R 00 00 04 00
T 66 01 E5 DD 9E E1 DD 7E E6 DD 9E E2 DD 7E E7 DD
R 00 00 04 00
T 74 01 9E E3 E2 7B 01 EE 80
R 00 00 04 00 00 05 04 00
T 7B 01
R 00 00 04 00
T 7B 01 F2 96 01 F5 F1 06 01 DD CB E4 26 DD CB E5
R 00 00 04 00 00 03 04 00
T 89 01 16 DD CB E6 16 DD CB E7 16 E1 E5 2B E3
R 00 00 04 00
T 96 01
R 00 00 04 00
T 96 01 DD 36 E8 00 DD 36 E9 00 DD 36 EA 00 DD 36
R 00 00 04 00
T A4 01 EB 01 AF DD 77 EC DD 77 ED DD 77 EE DD 77
R 00 00 04 00
T B2 01 EF
R 00 00 04 00
T B3 01
R 00 00 04 00
T B3 01 DD 7E EB DD B6 EA DD B6 E9 DD B6 E8 CA
R 00 00 04 00
T C0 01 5B 02 DD 7E E4 DD 96 E0 DD 7E E5 DD 9E E1
R 00 00 04 00 00 02 04 00
T CE 01 DD 7E E6 DD 9E E2 DD 7E E7 DD 9E E3 E2
R 00 00 04 00
T DB 01 DF 01 EE 80
R 00 00 04 00 00 02 04 00
T DF 01
R 00 00 04 00
T DF 01 FA 32 02 DD 66 EC DD 56 ED DD 6E EE DD 46
R 00 00 04 00 00 03 04 00
T ED 01 EF 7C DD B6 E8 5F 7A DD B6 E9 57 7D DD B6
R 00 00 04 00
T FB 01 EA 6F 78 DD B6 EB 67 DD 73 EC DD 72 ED DD
R 00 00 04 00
T 09 02 75 EE DD 74 EF DD 7E E4 DD 96 E0 DD 77 E4
R 00 00 04 00
T 17 02 DD 7E E5 DD 9E E1 DD 77 E5 DD 7E E6 DD 9E
R 00 00 04 00
T 25 02 E2 DD 77 E6 DD 7E E7 DD 9E E3 DD 77 E7
R 00 00 04 00
T 32 02
R 00 00 04 00
T 32 02 F5 F1 DD CB E4 26 DD CB E5 16 DD CB E6 16
R 00 00 04 00
T 40 02 DD CB E7 16 F5 F1 06 01 DD CB EB 3E DD CB
R 00 00 04 00
T 4E 02 EA 1E DD CB E9 1E DD CB E8 1E C3 B3 01
R 00 00 04 00 00 0D 04 00
T 5B 02
R 00 00 04 00
T 5B 02 DD 34 EC 20 0D DD 34 ED 20 08 DD 34 EE 20
R 00 00 04 00
T 69 02 03 DD 34 EF
R 00 00 04 00
T 6D 02
R 00 00 04 00
T 6D 02 DD 34 DE 20 03 DD 34 DF
R 00 00 04 00
T 75 02
R 00 00 04 00
T 75 02 F5 F1 DD CB EF 2E DD CB EE 1E DD CB ED 1E
R 00 00 04 00
T 83 02 DD CB EC 1E DD 66 EC DD 6E ED DD 56 EE DD
R 00 00 04 00
T 91 02 5E EF DD 74 EC DD 75 ED 7A E6 7F DD 77 EE
R 00 00 04 00
T 9F 02 DD 73 EF DD 7E DF EE 80 D6 81 38 26 21
R 00 00 04 00
T AC 02 16 00 39 79 B7 28 08 01 00 00 11 00 80 18
R 00 00 04 00
T BA 02 06
R 00 00 04 00
T BB 02
R 00 00 04 00
T BB 02 01 00 00 11 00 00
R 00 00 04 00
T C1 02
R 00 00 04 00
T C1 02 CB FB 7A F6 7F 57 71 23 70 23 73 23 72 C3
R 00 00 04 00
T CF 02 73 03
R 00 00 04 00 00 02 04 00
T D1 02
R 00 00 04 00
T D1 02 DD CB DF 7E 28 10 21 16 00 39 AF 77 23 77
R 00 00 04 00
T DF 02 23 AF 77 23 77 C3 73 03
R 00 00 04 00 00 08 04 00
T E7 02
R 00 00 04 00
T E7 02 21 16 00 39 DD 75 FC DD 74 FD 79 B7 28 12
R 00 00 04 00
T F5 02 DD 36 F8 00 DD 36 F9 00 DD 36 FA 00 DD 36
R 00 00 04 00
T 03 03 FB 80 18 0D
R 00 00 04 00
T 07 03
R 00 00 04 00
T 07 03 AF DD 77 F8 DD 77 F9 DD 77 FA DD 77 FB
R 00 00 04 00
T 14 03
R 00 00 04 00
T 14 03 DD 6E DE DD 66 DF DD 7E DF 17 9F 5F 57 06
R 00 00 04 00
T 22 03 17
R 00 00 04 00
T 23 03
R 00 00 04 00
T 23 03 29 CB 13 CB 12 10 F9 DD 7E F8 B5 DD 77 F8
R 00 00 04 00
T 31 03 DD 7E F9 B4 DD 77 F9 DD 7E FA B3 DD 77 FA
R 00 00 04 00
T 3F 03 DD 7E FB B2 DD 77 FB DD 4E EC DD 46 ED DD
R 00 00 04 00
T 4D 03 6E EE DD 66 EF DD 7E F8 B1 57 DD 7E F9 B0
R 00 00 04 00
T 5B 03 5F DD 7E FA B5 4F DD 7E FB B4 47 DD 6E FC
R 00 00 04 00
T 69 03 DD 66 FD 72 23 73 23 71 23 70
R 00 00 04 00
T 73 03
R 00 00 04 00
T 73 03 21 16 00 39 46 23 4E 23 5E 23 56 68 61
R 00 00 04 00
T 80 03
R 00 00 04 00
T 80 03 DD F9 DD E1 C9
R 00 00 04 00
_fsmul.rel/     1458795412  2001  2501  100664  5895      `
XL2
H 9 areas 3 global symbols
M _fsmul
O -mz80
S .__.ABS. Def0000
S __mullong Ref0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 3EE flags 0 addr 0
S ___fsmul Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 EC FF 39 F9 21
R 00 00 04 00
T 0E 00 0B 00 39 EB 21 18 00 39 01 04 00 ED B0 21
R 00 00 04 00
T 1C 00 07 00 39 EB 21 1C 00 39 01 04 00 ED B0 21
R 00 00 04 00
T 2A 00 0B 00 39 4E 23 46 23 5E 23 7E B3 B0 B1 28
R 00 00 04 00
T 38 00 10 21 07 00 39 5E 23 56 23 46 23 7E B0 B2
R 00 00 04 00
T 46 00 B3 20 08
R 00 00 04 00
T 49 00
R 00 00 04 00
T 49 00 21 00 00 5D 54 C3 E9 03
R 00 00 04 00 00 08 04 00
T 51 00
R 00 00 04 00
T 51 00 21 0B 00 39 56 23 5E 23 4E 23 7E CB 07 E6
R 00 00 04 00
T 5F 00 01 DD 77 FB 21 07 00 39 5E 23 56 23 46 23
R 00 00 04 00
T 6D 00 7E CB 07 E6 01 DD AE FB DD 77 EC 21 0B 00
R 00 00 04 00
T 7B 00 39 5E 23 56 23 4E 23 46 3E 17
R 00 00 04 00
T 85 00
R 00 00 04 00
T 85 00 CB 38 CB 19 CB 1A CB 1B 3D 20 F5 16 00 01
R 00 00 04 00
T 93 00 00 00 7B C6 82 6F 7A CE FF 67 79 CE FF 78
R 00 00 04 00
T A1 00 CE FF DD 75 ED DD 74 EE 21 07 00 39 5E 23
R 00 00 04 00
T AF 00 56 23 4E 23 46 3E 17
R 00 00 04 00
T B6 00
R 00 00 04 00
T B6 00 CB 38 CB 19 CB 1A CB 1B 3D 20 F5 DD 73 FC
R 00 00 04 00
T C4 00 DD 36 FD 00 DD 36 FE 00 DD 36 FF 00 DD 6E
R 00 00 04 00
T D2 00 ED DD 66 EE DD 7E EE 17 9F 4F 47 7D DD 86
R 00 00 04 00
T E0 00 FC 6F 7C DD 8E FD 67 79 DD 8E FE 78 DD 8E
R 00 00 04 00
T EE 00 FF DD 75 ED DD 74 EE 21 0B 00 39 DD 75 FC
R 00 00 04 00
T FC 00 DD 74 FD 21 0B 00 39 5E 23 56 23 4E 23 46
R 00 00 04 00
T 0A 01 CB B9 06 00 CB F9 DD 6E FC DD 66 FD 73 23
R 00 00 04 00
T 18 01 72 23 71 23 70 21 07 00 39 DD 75 FC DD 74
R 00 00 04 00
T 26 01 FD 21 07 00 39 5E 23 56 23 4E 23 46 CB B9
R 00 00 04 00
T 34 01 06 00 CB F9 79 DD 6E FC DD 66 FD 73 23 72
R 00 00 04 00
T 42 01 23 71 23 70 21 0B 00 39 5E 23 56 23 4E 23
R 00 00 04 00
T 50 01 46 F5 DD 73 FC DD 72 FD DD 71 FE DD 70 FF
R 00 00 04 00
T 5E 01 F1 3E 08
R 00 00 04 00
T 61 01
R 00 00 04 00
T 61 01 DD CB FF 3E DD CB FE 1E DD CB FD 1E DD CB
R 00 00 04 00
T 6F 01 FC 1E 3D 20 ED 21 07 00 39 5E 23 56 23 4E
R 00 00 04 00
T 7D 01 23 46 3E 08
R 00 00 04 00
T 81 01
R 00 00 04 00
T 81 01 CB 38 CB 19 CB 1A CB 1B 3D 20 F5 C5 D5 DD
R 00 00 04 00
T 8F 01 6E FE DD 66 FF E5 DD 6E FC DD 66 FD E5 CD
R 00 00 04 00
T 9D 01 00 00 F1 F1 F1 F1 DD 75 EF DD 74 F0 DD 73
R 00 00 04 00 02 02 01 00
T AB 01 F1 DD 72 F2 21 0B 00 39 5E 23 56 23 4E 23
R 00 00 04 00
T B9 01 46 DD 73 FC DD 36 FD 00 DD 36 FE 00 DD 36
R 00 00 04 00
T C7 01 FF 00 21 07 00 39 5E 23 56 23 4E 23 46 3E
R 00 00 04 00
T D5 01 08
R 00 00 04 00
T D6 01
R 00 00 04 00
T D6 01 CB 38 CB 19 CB 1A CB 1B 3D 20 F5 C5 D5 DD
R 00 00 04 00
T E4 01 6E FE DD 66 FF E5 DD 6E FC DD 66 FD E5 CD
R 00 00 04 00
T F2 01 00 00 F1 F1 F1 F1 45 4C 3E 08
R 00 00 04 00 02 02 01 00
T FC 01
R 00 00 04 00
T FC 01 CB 3A CB 1B CB 19 CB 18 3D 20 F5 DD 7E EF
R 00 00 04 00
T 0A 02 80 DD 77 EF DD 7E F0 89 DD 77 F0 DD 7E F1
R 00 00 04 00
T 18 02 8B DD 77 F1 DD 7E F2 8A DD 77 F2 21 07 00
R 00 00 04 00
T 26 02 39 5E 23 56 23 4E 23 46 DD 73 FC DD 36 FD
R 00 00 04 00
T 34 02 00 DD 36 FE 00 DD 36 FF 00 21 0B 00 39 5E
R 00 00 04 00
T 42 02 23 56 23 4E 23 46 3E 08
R 00 00 04 00
T 4A 02
R 00 00 04 00
T 4A 02 CB 38 CB 19 CB 1A CB 1B 3D 20 F5 C5 D5 DD
R 00 00 04 00
T 58 02 6E FE DD 66 FF E5 DD 6E FC DD 66 FD E5 CD
R 00 00 04 00
T 66 02 00 00 F1 F1 F1 F1 45 4C 3E 08
R 00 00 04 00 02 02 01 00
T 70 02
R 00 00 04 00
T 70 02 CB 3A CB 1B CB 19 CB 18 3D 20 F5 DD 7E EF
R 00 00 04 00
T 7E 02 80 DD 77 EF DD 7E F0 89 DD 77 F0 DD 7E F1
R 00 00 04 00
T 8C 02 8B DD 77 F1 DD 7E F2 8A DD 77 F2 DD 7E EF
R 00 00 04 00
T 9A 02 C6 40 DD 77 EF DD 7E F0 CE 00 DD 77 F0 DD
R 00 00 04 00
T A8 02 7E F1 CE 00 DD 77 F1 DD 7E F2 CE 00 DD 77
R 00 00 04 00
T B6 02 F2 DD CB F2 7E 28 38 DD 7E EF C6 40 DD 77
R 00 00 04 00
T C4 02 EF DD 7E F0 CE 00 DD 77 F0 DD 7E F1 CE 00
R 00 00 04 00
T D2 02 DD 77 F1 DD 7E F2 CE 00 DD 77 F2 F5 F1 06
R 00 00 04 00
T E0 02 08
R 00 00 04 00
T E1 02
R 00 00 04 00
T E1 02 DD CB F2 3E DD CB F1 1E DD CB F0 1E DD CB
R 00 00 04 00
T EF 02 EF 1E 10 EE 18 23
R 00 00 04 00
T F5 02
R 00 00 04 00
T F5 02 F5 F1 06 07
R 00 00 04 00
T F9 02
R 00 00 04 00
T F9 02 DD CB F2 3E DD CB F1 1E DD CB F0 1E DD CB
R 00 00 04 00
T 07 03 EF 1E 10 EE DD 6E ED DD 66 EE 2B DD 75 ED
R 00 00 04 00
T 15 03 DD 74 EE
R 00 00 04 00
T 18 03
R 00 00 04 00
T 18 03 DD CB F1 BE DD 7E EE EE 80 D6 81 38 28 21
R 00 00 04 00
T 26 03 0B 00 39 DD 7E EC B7 28 08 01 00 00 11
R 00 00 04 00
T 33 03 00 80 18 06
R 00 00 04 00
T 37 03
R 00 00 04 00
T 37 03 01 00 00 11 00 00
R 00 00 04 00
T 3D 03
R 00 00 04 00
T 3D 03 CB FB 7A F6 7F 57 71 23 70 23 73 23 72 C3
R 00 00 04 00
T 4B 03 DC 03
R 00 00 04 00 00 02 04 00
T 4D 03
R 00 00 04 00
T 4D 03 DD CB EE 7E 28 0F 21 0B 00 39 AF 77 23 77
R 00 00 04 00
T 5B 03 23 AF 77 23 77 18 7A
R 00 00 04 00
T 62 03
R 00 00 04 00
T 62 03 21 0B 00 39 EB DD 7E EC B7 28 12 DD 36 FC
R 00 00 04 00
T 70 03 00 DD 36 FD 00 DD 36 FE 00 DD 36 FF 80 18
R 00 00 04 00
T 7E 03 0D
R 00 00 04 00
T 7F 03
R 00 00 04 00
T 7F 03 AF DD 77 FC DD 77 FD DD 77 FE DD 77 FF
R 00 00 04 00
T 8C 03
R 00 00 04 00
T 8C 03 DD 6E ED DD 66 EE DD 7E EE 17 9F 4F 47 3E
R 00 00 04 00
T 9A 03 17
R 00 00 04 00
T 9B 03
R 00 00 04 00
T 9B 03 29 CB 11 CB 10 3D 20 F8 7D DD B6 FC 6F 7C
R 00 00 04 00
T A9 03 DD B6 FD 67 79 DD B6 FE 4F 78 DD B6 FF 47
R 00 00 04 00
T B7 03 7D DD B6 EF DD 77 FC 7C DD B6 F0 DD 77 FD
R 00 00 04 00
T C5 03 79 DD B6 F1 DD 77 FE 78 DD B6 F2 DD 77 FF
R 00 00 04 00
T D3 03 21 10 00 39 01 04 00 ED B0
R 00 00 04 00
T DC 03
R 00 00 04 00
T DC 03 21 0B 00 39 46 23 4E 23 5E 23 56 68 61
R 00 00 04 00
T E9 03
R 00 00 04 00
T E9 03 DD F9 DD E1 C9
R 00 00 04 00

_fssub.rel/     1458795412  2001  2501  100664  676       `
XL2
H 9 areas 3 global symbols
M _fssub
O -mz80
S .__.ABS. Def0000
S ___fsadd Ref0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 35 flags 0 addr 0
S ___fssub Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 DD 7E 07 EE 80 47
R 00 00 04 00
T 0E 00 DD 5E 04 DD 56 05 DD 4E 06 DD 6E 0A DD 66
R 00 00 04 00
T 1C 00 0B E5 DD 6E 08 DD 66 09 E5 C5 D5 CD 00 00
R 00 00 04 00 02 0E 01 00
T 2A 00 F1 F1 F1 F1 7A EE 80 57 DD E1 C9
R 00 00 04 00
_fseq.rel/      1458795412  2001  2501  100664  1262      `
XL2
H 9 areas 2 global symbols
M _fseq
O -mz80
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size A4 flags 0 addr 0
S ___fseq Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 F4 FF 39 F9 21
R 00 00 04 00
T 0E 00 04 00 39 EB 21 10 00 39 01 04 00 ED B0 21
R 00 00 04 00
T 1C 00 00 00 39 EB 21 14 00 39 01 04 00 ED B0 21
R 00 00 04 00
T 2A 00 04 00 39 EB 21 08 00 39 EB 01 04 00 ED B0
R 00 00 04 00
T 38 00 21 00 00 39 56 23 5E 23 4E 23 46 DD 7E FC
R 00 00 04 00
T 46 00 92 20 16 DD 7E FD 93 20 10 DD 7E FE 91 20
R 00 00 04 00
T 54 00 0A DD 7E FF 90 20 04 2E 01 18 40
R 00 00 04 00
T 5F 00
R 00 00 04 00
T 5F 00 21 04 00 39 EB 21 08 00 39 EB 01 04 00 ED
R 00 00 04 00
T 6D 00 B0 21 00 00 39 5E 23 56 23 4E 23 46 DD 7E
R 00 00 04 00
T 7B 00 FC B3 5F DD 7E FD B2 57 DD 7E FE B1 6F DD
R 00 00 04 00
T 89 00 7E FF B0 67 7B B7 20 0C B2 20 09 BF ED 6A
R 00 00 04 00
T 97 00 20 04 2E 01 18 02
R 00 00 04 00
T 9D 00
R 00 00 04 00
T 9D 00 2E 00
R 00 00 04 00
T 9F 00
R 00 00 04 00
T 9F 00 DD F9 DD E1 C9
R 00 00 04 00
_fsgt.rel/      1458795413  2001  2501  100664  1875      `
XL2
H 9 areas 2 global symbols
M _fsgt
O -mz80
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size FD flags 0 addr 0
S ___fsgt Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 F4 FF 39 F9 21
R 00 00 04 00
T 0E 00 04 00 39 EB 21 10 00 39 01 04 00 ED B0 21
R 00 00 04 00
T 1C 00 00 00 39 EB 21 14 00 39 01 04 00 ED B0 21
R 00 00 04 00
T 2A 00 04 00 39 EB 21 08 00 39 EB 01 04 00 ED B0
R 00 00 04 00
T 38 00 21 00 00 39 5E 23 56 23 4E 23 46 DD 7E FC
R 00 00 04 00
T 46 00 B3 5F DD 7E FD B2 57 DD 7E FE B1 6F DD 7E
R 00 00 04 00
T 54 00 FF B0 67 7B B7 20 0D B2 20 0A BF ED 6A 20
R 00 00 04 00
T 62 00 05 2E 00 C3 F8 00
R 00 00 04 00 00 06 04 00
T 68 00
R 00 00 04 00
T 68 00 21 04 00 39 56 23 5E 23 4E 23 66 CB 7C 28
R 00 00 04 00
T 76 00 49 21 00 00 39 56 23 5E 23 4E 23 66 CB 7C
R 00 00 04 00
T 84 00 28 3A 21 00 00 39 EB 21 08 00 39 EB 01
R 00 00 04 00
T 91 00 04 00 ED B0 21 04 00 39 56 23 5E 23 4E 23
R 00 00 04 00
T 9F 00 66 7A DD 96 FC 7B DD 9E FD 79 DD 9E FE 7C
R 00 00 04 00
T AD 00 DD 9E FF E2 B5 00 EE 80
R 00 00 04 00 00 06 04 00
T B5 00
R 00 00 04 00
T B5 00 F2 BC 00 2E 01 18 3C
R 00 00 04 00 00 03 04 00
T BC 00
R 00 00 04 00
T BC 00 2E 00 18 38
R 00 00 04 00
T C0 00
R 00 00 04 00
T C0 00 21 04 00 39 EB 21 08 00 39 EB 01 04 00 ED
R 00 00 04 00
T CE 00 B0 21 00 00 39 56 23 5E 23 4E 23 66 7A DD
R 00 00 04 00
T DC 00 96 FC 7B DD 9E FD 79 DD 9E FE 7C DD 9E FF
R 00 00 04 00
T EA 00 E2 EF 00 EE 80
R 00 00 04 00 00 03 04 00
T EF 00
R 00 00 04 00
T EF 00 F2 F6 00 2E 01 18 02
R 00 00 04 00 00 03 04 00
T F6 00
R 00 00 04 00
T F6 00 2E 00
R 00 00 04 00
T F8 00
R 00 00 04 00
T F8 00 DD F9 DD E1 C9
R 00 00 04 00

_fslt.rel/      1458795413  2001  2501  100664  1875      `
XL2
H 9 areas 2 global symbols
M _fslt
O -mz80
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size FD flags 0 addr 0
S ___fslt Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 F4 FF 39 F9 21
R 00 00 04 00
T 0E 00 04 00 39 EB 21 10 00 39 01 04 00 ED B0 21
R 00 00 04 00
T 1C 00 00 00 39 EB 21 14 00 39 01 04 00 ED B0 21
R 00 00 04 00
T 2A 00 04 00 39 EB 21 08 00 39 EB 01 04 00 ED B0
R 00 00 04 00
T 38 00 21 00 00 39 5E 23 56 23 4E 23 46 DD 7E FC
R 00 00 04 00
T 46 00 B3 5F DD 7E FD B2 57 DD 7E FE B1 6F DD 7E
R 00 00 04 00
T 54 00 FF B0 67 7B B7 20 0D B2 20 0A BF ED 6A 20
R 00 00 04 00
T 62 00 05 2E 00 C3 F8 00
R 00 00 04 00 00 06 04 00
T 68 00
R 00 00 04 00
T 68 00 21 04 00 39 56 23 5E 23 4E 23 66 CB 7C 28
R 00 00 04 00
T 76 00 49 21 00 00 39 56 23 5E 23 4E 23 66 CB 7C
R 00 00 04 00
T 84 00 28 3A 21 00 00 39 EB 21 08 00 39 EB 01
R 00 00 04 00
T 91 00 04 00 ED B0 21 04 00 39 56 23 5E 23 4E 23
R 00 00 04 00
T 9F 00 66 DD 7E FC 92 DD 7E FD 9B DD 7E FE 99 DD
R 00 00 04 00
T AD 00 7E FF 9C E2 B5 00 EE 80
R 00 00 04 00 00 06 04 00
T B5 00
R 00 00 04 00
T B5 00 F2 BC 00 2E 01 18 3C
R 00 00 04 00 00 03 04 00
T BC 00
R 00 00 04 00
T BC 00 2E 00 18 38
R 00 00 04 00
T C0 00
R 00 00 04 00
T C0 00 21 04 00 39 EB 21 08 00 39 EB 01 04 00 ED
R 00 00 04 00
T CE 00 B0 21 00 00 39 56 23 5E 23 4E 23 66 DD 7E
R 00 00 04 00
T DC 00 FC 92 DD 7E FD 9B DD 7E FE 99 DD 7E FF 9C
R 00 00 04 00
T EA 00 E2 EF 00 EE 80
R 00 00 04 00 00 03 04 00
T EF 00
R 00 00 04 00
T EF 00 F2 F6 00 2E 01 18 02
R 00 00 04 00 00 03 04 00
T F6 00
R 00 00 04 00
T F6 00 2E 00
R 00 00 04 00
T F8 00
R 00 00 04 00
T F8 00 DD F9 DD E1 C9
R 00 00 04 00

_fsneq.rel/     1458795413  2001  2501  100664  1261      `
XL2
H 9 areas 2 global symbols
M _fsneq
O -mz80
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size A3 flags 0 addr 0
S ___fsneq Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 F4 FF 39 F9 21
R 00 00 04 00
T 0E 00 04 00 39 EB 21 10 00 39 01 04 00 ED B0 21
R 00 00 04 00
T 1C 00 00 00 39 EB 21 14 00 39 01 04 00 ED B0 21
R 00 00 04 00
T 2A 00 04 00 39 EB 21 08 00 39 EB 01 04 00 ED B0
R 00 00 04 00
T 38 00 21 00 00 39 56 23 5E 23 4E 23 46 DD 7E FC
R 00 00 04 00
T 46 00 92 20 15 DD 7E FD 93 20 0F DD 7E FE 91 20
R 00 00 04 00
T 54 00 09 DD 7E FF 90 20 03 6F 18 40
R 00 00 04 00
T 5E 00
R 00 00 04 00
T 5E 00 21 04 00 39 EB 21 08 00 39 EB 01 04 00 ED
R 00 00 04 00
T 6C 00 B0 21 00 00 39 5E 23 56 23 4E 23 46 DD 7E
R 00 00 04 00
T 7A 00 FC B3 5F DD 7E FD B2 57 DD 7E FE B1 6F DD
R 00 00 04 00
T 88 00 7E FF B0 67 7B B7 20 0C B2 20 09 BF ED 6A
R 00 00 04 00
T 96 00 20 04 2E 00 18 02
R 00 00 04 00
T 9C 00
R 00 00 04 00
T 9C 00 2E 01
R 00 00 04 00
T 9E 00
R 00 00 04 00
T 9E 00 DD F9 DD E1 C9
R 00 00 04 00

fabsf.rel/      1458795413  2001  2501  100664  697       `
XL2
H 9 areas 2 global symbols
M fabsf
O -mz80
S .__.ABS. Def0000
A _CODE size 40 flags 0 addr 0
S _fabsf Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 F5 F5 21 00 00 39
R 00 00 00 00
T 0E 00 EB 21 08 00 39 01 04 00 ED B0 21 00 00 39
R 00 00 00 00
T 1C 00 E5 5E 23 56 23 4E 23 46 E1 CB B8 73 23 72
R 00 00 00 00
T 2A 00 23 71 23 70 21 00 00 39 46 23 4E 23 5E 23
R 00 00 00 00
T 38 00 56 68 61 DD F9 DD E1 C9
R 00 00 00 00

frexpf.rel/     1458795414  2001  2501  100664  1108      `
XL2
H 9 areas 2 global symbols
M frexpf
O -mz80
S .__.ABS. Def0000
A _CODE size 95 flags 0 addr 0
S _frexpf Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 F5 F5 21 00 00 39
R 00 00 00 00
T 0E 00 EB 21 08 00 39 01 04 00 ED B0 21 00 00 39
R 00 00 00 00
T 1C 00 E5 5E 23 56 23 4E 23 46 E1 3E 17
R 00 00 00 00
T 27 00
R 00 00 00 00
T 27 00 CB 28 CB 19 CB 1A CB 1B 3D 20 F5 16 00 01
R 00 00 00 00
T 35 00 00 00 7B C6 82 5F 7A CE FF 57 79 CE FF 78
R 00 00 00 00
T 43 00 CE FF E5 DD 6E 08 DD 66 09 E5 FD E1 E1 FD
R 00 00 00 00
T 51 00 73 00 FD 72 01 E5 5E 23 56 23 4E 23 46 E1
R 00 00 00 00
T 5F 00 CB B9 78 E6 80 47 73 23 72 23 71 23 70 2B
R 00 00 00 00
T 6D 00 2B 2B E5 5E 23 56 23 4E 23 46 E1 78 F6 3F
R 00 00 00 00
T 7B 00 47 73 23 72 23 71 23 70 21 00 00 39 46 23
R 00 00 00 00
T 89 00 4E 23 5E 23 56 68 61 DD F9 DD E1 C9
R 00 00 00 00
ldexpf.rel/     1458795414  2001  2501  100664  1567      `
XL2
H 9 areas 2 global symbols
M ldexpf
O -mz80
S .__.ABS. Def0000
A _CODE size EC flags 0 addr 0
S _ldexpf Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 F4 FF 39 F9 21
R 00 00 00 00
T 0E 00 00 00 39 EB 21 10 00 39 01 04 00 ED B0 21
R 00 00 00 00
T 1C 00 00 00 39 5D 54 4E 23 46 23 23 7E 2B 6E 67
R 00 00 00 00
T 2A 00 3E 17
R 00 00 00 00
T 2C 00
R 00 00 00 00
T 2C 00 CB 2C CB 1D CB 18 CB 19 3D 20 F5 DD 71 F8
R 00 00 00 00
T 3A 00 DD 36 F9 00 DD 36 FA 00 DD 36 FB 00 DD 6E
R 00 00 00 00
T 48 00 08 DD 66 09 DD 7E 09 17 9F 4F 47 DD 7E F8
R 00 00 00 00
T 56 00 85 6F DD 7E F9 8C DD 7E FA 89 DD 7E FB 88
R 00 00 00 00
T 64 00 26 00 01 00 00 F5 DD 75 F8 DD 74 F9 DD 71
R 00 00 00 00
T 72 00 FA DD 70 FB F1 3E 17
R 00 00 00 00
T 79 00
R 00 00 00 00
T 79 00 DD CB F8 26 DD CB F9 16 DD CB FA 16 DD CB
R 00 00 00 00
T 87 00 FB 16 3D 20 ED 6B 62 4E 23 46 23 23 7E 2B
R 00 00 00 00
T 95 00 6E 67 DD 71 FC DD 70 FD 7D E6 7F DD 77 FE
R 00 00 00 00
T A3 00 7C E6 80 DD 77 FF DD 6E F8 DD 66 F9 DD 46
R 00 00 00 00
T B1 00 FA DD 4E FB DD 7E FC B5 DD 77 FC DD 7E FD
R 00 00 00 00
T BF 00 B4 DD 77 FD DD 7E FE B0 DD 77 FE DD 7E FF
R 00 00 00 00
T CD 00 B1 DD 77 FF 21 08 00 39 01 04 00 ED B0 21
R 00 00 00 00
T DB 00 00 00 39 46 23 4E 23 5E 23 56 68 61 DD F9
R 00 00 00 00
T E9 00 DD E1 C9
R 00 00 00 00

expf.rel/       1458795415  2001  2501  100664  6402      `
XL2
H 9 areas C global symbols
M expf
O -mz80
S ___fssub Ref0000
S ___fsmul Ref0000
S _errno Ref0000
S ___fsgt Ref0000
S ___fslt Ref0000
S .__.ABS. Def0000
S ___fsadd Ref0000
S _ldexpf Ref0000
S ___sint2fs Ref0000
S ___fs2sint Ref0000
S ___fsdiv Ref0000
A _CODE size 46B flags 0 addr 0
S _expf Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 E2 FF 39 F9 21
R 00 00 00 00
T 0E 00 00 00 E5 21 00 00 E5 DD 6E 06 DD 66 07 E5
R 00 00 00 00
T 1C 00 DD 6E 04 DD 66 05 E5 CD 00 00 F1 F1 F1 F1
R 00 00 00 00 02 0A 04 00
T 2A 00 DD 75 F5 7D B7 20 14 21 01 00 39 EB 21
R 00 00 00 00
T 37 00 22 00 39 01 04 00 ED B0 DD 36 E2 00 18 2C
R 00 00 00 00
T 45 00
R 00 00 00 00
T 45 00 DD 7E 07 EE 80 DD 77 FF DD 7E 04 DD 77 FC
R 00 00 00 00
T 53 00 DD 7E 05 DD 77 FD DD 7E 06 DD 77 FE 21
R 00 00 00 00
T 60 00 01 00 39 EB 21 1A 00 39 01 04 00 ED B0 DD
R 00 00 00 00
T 6E 00 36 E2 01
R 00 00 00 00
T 71 00
R 00 00 00 00
T 71 00 21 D6 33 E5 21 95 BF E5 DD 6E E5 DD 66 E6
R 00 00 00 00
T 7F 00 E5 DD 6E E3 DD 66 E4 E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 04 00
T 8D 00 F1 DD 75 FC 7D B7 28 09 21 00 00 11 80 3F
R 00 00 00 00
T 9B 00 C3 66 04
R 00 00 00 00 00 03 00 00
T 9E 00
R 00 00 00 00
T 9E 00 21 B1 42 E5 21 18 72 E5 DD 6E E5 DD 66 E6
R 00 00 00 00
T AC 00 E5 DD 6E E3 DD 66 E4 E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 03 00
T BA 00 F1 7D B7 28 1D DD CB E2 46 28 0F 21 22 00
R 00 00 00 00
T C8 00 22 00 00 21 FF FF 11 7F 7F C3 66 04
R 00 00 00 00 02 03 02 00 00 0C 00 00
T D4 00
R 00 00 00 00
T D4 00 21 00 00 5D 54 C3 66 04
R 00 00 00 00 00 08 00 00
T DC 00
R 00 00 00 00
T DC 00 DD 6E E5 DD 66 E6 E5 DD 6E E3 DD 66 E4 E5
R 00 00 00 00
T EA 00 21 B8 3F E5 21 3B AA E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 01 00
T F8 00 F1 DD 72 EA DD 73 E9 DD 74 E8 DD 75 E7 21
R 00 00 00 00
T 06 01 1A 00 39 EB 21 05 00 39 01 04 00 ED B0 DD
R 00 00 00 00
T 14 01 6E FE DD 66 FF E5 DD 6E FC DD 66 FD E5 CD
R 00 00 00 00
T 22 01 00 00 F1 F1 DD 74 F4 DD 75 F3 DD 75 F6 DD
R 00 00 00 00 02 02 09 00
T 30 01 7E F4 DD 77 F7 DD CB F7 7E 28 0D DD 6E F6
R 00 00 00 00
T 3E 01 DD 66 F7 2B DD 75 F6 DD 74 F7
R 00 00 00 00
T 48 01
R 00 00 00 00
T 48 01 DD 6E F6 DD 66 F7 E5 CD 00 00 F1 EB E5 D5
R 00 00 00 00 02 0A 08 00
T 56 01 DD 6E FE DD 66 FF E5 DD 6E FC DD 66 FD E5
R 00 00 00 00
T 64 01 CD 00 00 F1 F1 F1 F1 4D 44 21 00 3F E5 21
R 00 00 00 00 02 03 00 00
T 72 01 00 00 E5 D5 C5 CD 00 00 F1 F1 F1 F1 DD 75
R 00 00 00 00 02 08 04 00
T 80 01 FC 7D B7 20 08 DD 34 F6 20 03 DD 34 F7
R 00 00 00 00
T 8D 01
R 00 00 00 00
T 8D 01
R 00 00 00 00
T 8D 01 DD 6E F6 DD 66 F7 E5 CD 00 00 F1 4D 44 C5
R 00 00 00 00 02 0A 08 00
T 9B 01 D5 D5 C5 21 31 3F E5 21 00 80 E5 CD 00 00
R 00 00 00 00 02 0E 01 00
T A9 01 F1 F1 F1 F1 DD 72 FF DD 73 FE DD 74 FD DD
R 00 00 00 00
T B7 01 75 FC DD 6E FE DD 66 FF E5 DD 6E FC DD 66
R 00 00 00 00
T C5 01 FD E5 DD 6E E5 DD 66 E6 E5 DD 6E E3 DD 66
R 00 00 00 00
T D3 01 E4 E5 CD 00 00 F1 F1 F1 F1 DD 72 FF DD 73
R 00 00 00 00 02 05 00 00
T E1 01 FE DD 74 FD DD 75 FC D1 C1 D5 C5 21 5E B9
R 00 00 00 00
T EF 01 E5 21 83 80 E5 CD 00 00 F1 F1 F1 F1 DD 72
R 00 00 00 00 02 08 01 00
T FD 01 FB DD 73 FA DD 74 F9 DD 75 F8 DD 6E FA DD
R 00 00 00 00
T 0B 02 66 FB E5 DD 6E F8 DD 66 F9 E5 DD 6E FE DD
R 00 00 00 00
T 19 02 66 FF E5 DD 6E FC DD 66 FD E5 CD 00 00 F1
R 00 00 00 00 02 0D 00 00
T 27 02 F1 F1 F1 DD 72 F2 DD 73 F1 DD 74 F0 DD 75
R 00 00 00 00
T 35 02 EF DD 6E F1 DD 66 F2 E5 DD 6E EF DD 66 F0
R 00 00 00 00
T 43 02 E5 DD 6E F1 DD 66 F2 E5 DD 6E EF DD 66 F0
R 00 00 00 00
T 51 02 E5 CD 00 00 F1 F1 F1 F1 DD 72 FB DD 73 FA
R 00 00 00 00 02 04 01 00
T 5F 02 DD 74 F9 DD 75 F8 21 05 00 39 EB 21 16 00
R 00 00 00 00
T 6D 02 39 01 04 00 ED B0 DD 6E E9 DD 66 EA E5 DD
R 00 00 00 00
T 7B 02 6E E7 DD 66 E8 E5 21 88 3B E5 21 08 53 E5
R 00 00 00 00
T 89 02 CD 00 00 F1 F1 F1 F1 DD 72 FB DD 73 FA DD
R 00 00 00 00 02 03 01 00
T 97 02 74 F9 DD 75 F8 21 80 3E E5 21 00 00 E5 DD
R 00 00 00 00
T A5 02 6E FA DD 66 FB E5 DD 6E F8 DD 66 F9 E5 CD
R 00 00 00 00
T B3 02 00 00 F1 F1 F1 F1 DD 72 FB DD 73 FA DD 74
R 00 00 00 00 02 02 06 00
T C1 02 F9 DD 75 F8 DD 6E F1 DD 66 F2 E5 DD 6E EF
R 00 00 00 00
T CF 02 DD 66 F0 E5 DD 6E FA DD 66 FB E5 DD 6E F8
R 00 00 00 00
T DD 02 DD 66 F9 E5 CD 00 00 F1 F1 F1 F1 DD 72 EE
R 00 00 00 00 02 07 01 00
T EB 02 DD 73 ED DD 74 EC DD 75 EB 21 16 00 39 EB
R 00 00 00 00
T F9 02 21 09 00 39 01 04 00 ED B0 DD 6E E9 DD 66
R 00 00 00 00
T 07 03 EA E5 DD 6E E7 DD 66 E8 E5 21 4C 3D E5 21
R 00 00 00 00
T 15 03 5B BF E5 CD 00 00 F1 F1 F1 F1 DD 72 FF DD
R 00 00 00 00 02 06 01 00
T 23 03 73 FE DD 74 FD DD 75 FC 21 00 3F E5 21
R 00 00 00 00
T 30 03 00 00 E5 DD 6E FE DD 66 FF E5 DD 6E FC DD
R 00 00 00 00
T 3E 03 66 FD E5 CD 00 00 F1 F1 F1 F1 DD 72 FF DD
R 00 00 00 00 02 06 06 00
T 4C 03 73 FE DD 74 FD DD 75 FC DD 6E FA DD 66 FB
R 00 00 00 00
T 5A 03 E5 DD 6E F8 DD 66 F9 E5 DD 6E FE DD 66 FF
R 00 00 00 00
T 68 03 E5 DD 6E FC DD 66 FD E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 00 00
T 76 03 F1 DD 72 FF DD 73 FE DD 74 FD DD 75 FC DD
R 00 00 00 00
T 84 03 6E FE DD 66 FF E5 DD 6E FC DD 66 FD E5 DD
R 00 00 00 00
T 92 03 6E FA DD 66 FB E5 DD 6E F8 DD 66 F9 E5 CD
R 00 00 00 00
T A0 03 00 00 F1 F1 F1 F1 DD 72 FB DD 73 FA DD 74
R 00 00 00 00 02 02 0A 00
T AE 03 F9 DD 75 F8 21 00 3F E5 21 00 00 E5 DD 6E
R 00 00 00 00
T BC 03 FA DD 66 FB E5 DD 6E F8 DD 66 F9 E5 CD
R 00 00 00 00
T C9 03 00 00 F1 F1 F1 F1 DD 72 FB DD 73 FA DD 74
R 00 00 00 00 02 02 06 00
T D7 03 F9 DD 75 F8 21 09 00 39 EB 21 16 00 39 01
R 00 00 00 00
T E5 03 04 00 ED B0 DD 7E F6 C6 01 DD 77 F3 DD 7E
R 00 00 00 00
T F3 03 F7 CE 00 DD 77 F4 DD 6E F3 DD 66 F4 E5 DD
R 00 00 00 00
T 01 04 6E ED DD 66 EE E5 DD 6E EB DD 66 EC E5 CD
R 00 00 00 00
T 0F 04 00 00 F1 F1 F1 DD 72 FB DD 73 FA DD 74 F9
R 00 00 00 00 02 02 07 00
T 1D 04 DD 75 F8 DD CB E2 46 28 34 DD 6E FA DD 66
R 00 00 00 00
T 2B 04 FB E5 DD 6E F8 DD 66 F9 E5 21 80 3F E5 21
R 00 00 00 00
T 39 04 00 00 E5 CD 00 00 F1 F1 F1 F1 DD 72 FF DD
R 00 00 00 00 02 06 0A 00
T 47 04 73 FE DD 74 FD DD 75 FC DD 66 FD DD 5E FE
R 00 00 00 00
T 55 04 DD 56 FF 18 0C
R 00 00 00 00
T 5A 04
R 00 00 00 00
T 5A 04 DD 6E F8 DD 66 F9 DD 5E FA DD 56 FB
R 00 00 00 00
T 66 04
R 00 00 00 00
T 66 04 DD F9 DD E1 C9
R 00 00 00 00
powf.rel/       1458795415  2001  2501  100664  1492      `
XL2
H 9 areas 7 global symbols
M powf
O -mz80
S ___fsmul Ref0000
S _logf Ref0000
S ___fseq Ref0000
S ___fsgt Ref0000
S _expf Ref0000
S .__.ABS. Def0000
A _CODE size AE flags 0 addr 0
S _powf Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 DD 7E 0B CB BF DD
R 00 00 00 00
T 0E 00 B6 0A DD B6 09 DD B6 08 20 09 21 00 00 11
R 00 00 00 00
T 1C 00 80 3F C3 AB 00
R 00 00 00 00 00 05 00 00
T 21 00
R 00 00 00 00
T 21 00 21 80 3F E5 21 00 00 E5 DD 6E 0A DD 66 0B
R 00 00 00 00
T 2F 00 E5 DD 6E 08 DD 66 09 E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 02 00
T 3D 00 F1 7D B7 28 0E DD 6E 04 DD 66 05 DD 5E 06
R 00 00 00 00
T 4B 00 DD 56 07 18 5B
R 00 00 00 00
T 50 00
R 00 00 00 00
T 50 00 21 00 00 E5 21 00 00 E5 DD 6E 06 DD 66 07
R 00 00 00 00
T 5E 00 E5 DD 6E 04 DD 66 05 E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 03 00
T 6C 00 F1 7D B7 20 07 21 00 00 5D 54 18 33
R 00 00 00 00
T 78 00
R 00 00 00 00
T 78 00 DD 6E 06 DD 66 07 E5 DD 6E 04 DD 66 05 E5
R 00 00 00 00
T 86 00 CD 00 00 F1 F1 4D 44 DD 6E 0A DD 66 0B E5
R 00 00 00 00 02 03 01 00
T 94 00 DD 6E 08 DD 66 09 E5 D5 C5 CD 00 00 F1 F1
R 00 00 00 00 02 0C 00 00
T A2 00 F1 F1 D5 E5 CD 00 00 F1 F1
R 00 00 00 00 02 07 04 00
T AB 00
R 00 00 00 00
T AB 00 DD E1 C9
R 00 00 00 00
sincosf.rel/    1458795416  2001  2501  100664  6098      `
XL2
H 9 areas B global symbols
M sincosf
O -mz80
S ___fssub Ref0000
S ___fsmul Ref0000
S _errno Ref0000
S ___fsgt Ref0000
S ___fslt Ref0000
S .__.ABS. Def0000
S ___fsadd Ref0000
S _fabsf Ref0000
S ___sint2fs Ref0000
S ___fs2sint Ref0000
A _CODE size 41F flags 0 addr 0
S _sincosf Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 E4 FF 39 F9 DD
R 00 00 00 00
T 0E 00 CB 08 46 28 38 DD 6E 06 DD 66 07 E5 DD 6E
R 00 00 00 00
T 1C 00 04 DD 66 05 E5 CD 00 00 F1 F1 4D 44 21
R 00 00 00 00 02 08 07 00
T 29 00 C9 3F E5 21 DB 0F E5 D5 C5 CD 00 00 F1 F1
R 00 00 00 00 02 0C 06 00
T 37 00 F1 F1 DD 75 FC DD 74 FD DD 73 FE DD 72 FF
R 00 00 00 00
T 45 00 DD 36 E4 00 18 53
R 00 00 00 00
T 4B 00
R 00 00 00 00
T 4B 00 21 00 00 E5 21 00 00 E5 DD 6E 06 DD 66 07
R 00 00 00 00
T 59 00 E5 DD 6E 04 DD 66 05 E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 04 00
T 67 00 F1 7D B7 28 20 DD 7E 07 EE 80 DD 77 FF DD
R 00 00 00 00
T 75 00 7E 04 DD 77 FC DD 7E 05 DD 77 FD DD 7E 06
R 00 00 00 00
T 83 00 DD 77 FE DD 36 E4 01 18 12
R 00 00 00 00
T 8C 00
R 00 00 00 00
T 8C 00 21 18 00 39 EB 21 20 00 39 01 04 00 ED B0
R 00 00 00 00
T 9A 00 DD 36 E4 00
R 00 00 00 00
T 9E 00
R 00 00 00 00
T 9E 00 21 49 46 E5 21 00 0C E5 DD 6E FE DD 66 FF
R 00 00 00 00
T AC 00 E5 DD 6E FC DD 66 FD E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 03 00
T BA 00 F1 DD 75 FB 7D B7 28 0E 21 22 00 22 00 00
R 00 00 00 00 02 0E 02 00
T C8 00 21 00 00 5D 54 C3 1A 04
R 00 00 00 00 00 08 00 00
T D0 00
R 00 00 00 00
T D0 00 DD 6E FE DD 66 FF E5 DD 6E FC DD 66 FD E5
R 00 00 00 00
T DE 00 21 A2 3E E5 21 83 F9 E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 01 00
T EC 00 F1 DD 72 FF DD 73 FE DD 74 FD DD 75 FC 21
R 00 00 00 00
T FA 00 00 3F E5 21 00 00 E5 DD 6E FE DD 66 FF E5
R 00 00 00 00
T 08 01 DD 6E FC DD 66 FD E5 CD 00 00 F1 F1 F1 F1
R 00 00 00 00 02 0A 06 00
T 16 01 DD 72 FF DD 73 FE DD 74 FD DD 75 FC DD 6E
R 00 00 00 00
T 24 01 FE DD 66 FF E5 DD 6E FC DD 66 FD E5 CD
R 00 00 00 00
T 31 01 00 00 F1 F1 DD 74 E6 DD 75 E5 5D DD 56 E6
R 00 00 00 00 02 02 09 00
T 3F 01 CB 43 28 08 DD 7E E4 EE 01 DD 77 E4
R 00 00 00 00
T 4B 01
R 00 00 00 00
T 4B 01 D5 CD 00 00 F1 DD 75 E7 DD 74 E8 DD 73 E9
R 00 00 00 00 02 04 08 00
T 59 01 DD 72 EA DD CB 08 46 28 37 21 00 3F E5 21
R 00 00 00 00
T 67 01 00 00 E5 DD 6E E9 DD 66 EA E5 DD 6E E7 DD
R 00 00 00 00
T 75 01 66 E8 E5 CD 00 00 F1 F1 F1 F1 DD 72 FF DD
R 00 00 00 00 02 06 00 00
T 83 01 73 FE DD 74 FD DD 75 FC 21 03 00 39 EB 21
R 00 00 00 00
T 91 01 18 00 39 01 04 00 ED B0
R 00 00 00 00
T 99 01
R 00 00 00 00
T 99 01 DD 6E 06 DD 66 07 E5 DD 6E 04 DD 66 05 E5
R 00 00 00 00
T A7 01 CD 00 00 F1 F1 4D 44 C5 D5 D5 C5 CD 00 00
R 00 00 00 00 02 03 07 00 02 0E 09 00
T B5 01 F1 E3 CD 00 00 F1 DD 72 F2 DD 73 F1 DD 74
R 00 00 00 00 02 05 08 00
T C3 01 F0 DD 75 EF D1 C1 DD 7E EF DD 77 FC DD 7E
R 00 00 00 00
T D1 01 F0 DD 77 FD DD 7E F1 DD 77 FE DD 7E F2 DD
R 00 00 00 00
T DF 01 77 FF DD 6E FE DD 66 FF E5 DD 6E FC DD 66
R 00 00 00 00
T ED 01 FD E5 D5 C5 CD 00 00 F1 F1 F1 F1 DD 75 F7
R 00 00 00 00 02 07 00 00
T FB 01 DD 74 F8 DD 73 F9 DD 72 FA DD 6E E9 DD 66
R 00 00 00 00
T 09 02 EA E5 DD 6E E7 DD 66 E8 E5 21 49 40 E5 21
R 00 00 00 00
T 17 02 00 00 E5 CD 00 00 F1 F1 F1 F1 EB E5 D5 DD
R 00 00 00 00 02 06 01 00
T 25 02 6E FE DD 66 FF E5 DD 6E FC DD 66 FD E5 CD
R 00 00 00 00
T 33 02 00 00 F1 F1 F1 F1 4D 44 DD 6E F9 DD 66 FA
R 00 00 00 00 02 02 00 00
T 41 02 E5 DD 6E F7 DD 66 F8 E5 D5 C5 CD 00 00 F1
R 00 00 00 00 02 0D 06 00
T 4F 02 F1 F1 F1 DD 72 FA DD 73 F9 DD 74 F8 DD 75
R 00 00 00 00
T 5D 02 F7 DD 6E E9 DD 66 EA E5 DD 6E E7 DD 66 E8
R 00 00 00 00
T 6B 02 E5 21 7D 3A E5 21 22 AA E5 CD 00 00 F1 F1
R 00 00 00 00 02 0C 01 00
T 79 02 F1 F1 EB E5 D5 DD 6E F9 DD 66 FA E5 DD 6E
R 00 00 00 00
T 87 02 F7 DD 66 F8 E5 CD 00 00 F1 F1 F1 F1 DD 72
R 00 00 00 00 02 08 00 00
T 95 02 F6 DD 73 F5 DD 74 F4 DD 75 F3 DD 6E F5 DD
R 00 00 00 00
T A3 02 66 F6 E5 DD 6E F3 DD 66 F4 E5 DD 6E F5 DD
R 00 00 00 00
T B1 02 66 F6 E5 DD 6E F3 DD 66 F4 E5 CD 00 00 F1
R 00 00 00 00 02 0D 01 00
T BF 02 F1 F1 F1 DD 75 EB DD 74 EC DD 73 ED DD 72
R 00 00 00 00
T CD 02 EE 21 7F 33 E5 21 F3 FF E5 DD 6E ED DD 66
R 00 00 00 00
T DB 02 EE E5 DD 6E EB DD 66 EC E5 CD 00 00 F1 F1
R 00 00 00 00 02 0C 03 00
T E9 02 F1 F1 DD 75 F7 7D B7 CA DE 03 DD 6E ED DD
R 00 00 00 00 00 0A 00 00
T F7 02 66 EE E5 DD 6E EB DD 66 EC E5 21 2E 36 E5
R 00 00 00 00
T 05 03 21 5B 9C E5 CD 00 00 F1 F1 F1 F1 4D 44 21
R 00 00 00 00 02 07 01 00
T 13 03 4F B9 E5 21 22 B2 E5 D5 C5 CD 00 00 F1 F1
R 00 00 00 00 02 0C 06 00
T 21 03 F1 F1 4D 44 DD 6E ED DD 66 EE E5 DD 6E EB
R 00 00 00 00
T 2F 03 DD 66 EC E5 D5 C5 CD 00 00 F1 F1 F1 F1 4D
R 00 00 00 00 02 09 01 00
T 3D 03 44 21 08 3C E5 21 3E 87 E5 D5 C5 CD 00 00
R 00 00 00 00 02 0E 06 00
T 4B 03 F1 F1 F1 F1 4D 44 DD 6E ED DD 66 EE E5 DD
R 00 00 00 00
T 59 03 6E EB DD 66 EC E5 D5 C5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 01 00
T 67 03 F1 4D 44 21 2A BE E5 21 A4 AA E5 D5 C5 CD
R 00 00 00 00
T 75 03 00 00 F1 F1 F1 F1 4D 44 DD 6E ED DD 66 EE
R 00 00 00 00 02 02 06 00
T 83 03 E5 DD 6E EB DD 66 EC E5 D5 C5 CD 00 00 F1
R 00 00 00 00 02 0D 01 00
T 91 03 F1 F1 F1 EB E5 D5 DD 6E F5 DD 66 F6 E5 DD
R 00 00 00 00
T 9F 03 6E F3 DD 66 F4 E5 CD 00 00 F1 F1 F1 F1 EB
R 00 00 00 00 02 09 01 00
T AD 03 E5 D5 DD 6E F5 DD 66 F6 E5 DD 6E F3 DD 66
R 00 00 00 00
T BB 03 F4 E5 CD 00 00 F1 F1 F1 F1 DD 72 FA DD 73
R 00 00 00 00 02 05 06 00
T C9 03 F9 DD 74 F8 DD 75 F7 21 0F 00 39 EB 21
R 00 00 00 00
T D6 03 13 00 39 01 04 00 ED B0
R 00 00 00 00
T DE 03
R 00 00 00 00
T DE 03 DD CB E4 46 28 1C DD 7E F6 EE 80 DD 77 FA
R 00 00 00 00
T EC 03 DD 7E F3 DD 77 F7 DD 7E F4 DD 77 F8 DD 7E
R 00 00 00 00
T FA 03 F5 DD 77 F9 18 0E
R 00 00 00 00
T 00 04
R 00 00 00 00
T 00 04 21 13 00 39 EB 21 0F 00 39 01 04 00 ED B0
R 00 00 00 00
T 0E 04
R 00 00 00 00
T 0E 04 DD 6E F7 DD 66 F8 DD 5E F9 DD 56 FA
R 00 00 00 00
T 1A 04
R 00 00 00 00
T 1A 04 DD F9 DD E1 C9
R 00 00 00 00
sinf.rel/       1458795416  2001  2501  100664  730       `
XL2
H 9 areas 3 global symbols
M sinf
O -mz80
S _sincosf Ref0000
S .__.ABS. Def0000
A _CODE size 3A flags 0 addr 0
S _sinf Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 FD 21 02 00 FD 39 FD 7E 03 CB BF FD B6 02
R 00 00 00 00
T 0E 00 FD B6 01 FD B6 00 20 06 21 00 00 5D 54 C9
R 00 00 00 00
T 1C 00
R 00 00 00 00
T 1C 00 AF F5 33 FD 21 03 00 FD 39 FD 6E 02 FD 66
R 00 00 00 00
T 2A 00 03 E5 FD 6E 00 FD 66 01 E5 CD 00 00 F1 F1
R 00 00 00 00 02 0C 00 00
T 38 00 33 C9
R 00 00 00 00
cosf.rel/       1458795416  2001  2501  100664  758       `
XL2
H 9 areas 3 global symbols
M cosf
O -mz80
S _sincosf Ref0000
S .__.ABS. Def0000
A _CODE size 3C flags 0 addr 0
S _cosf Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 FD 21 02 00 FD 39 FD 7E 03 CB BF FD B6 02
R 00 00 00 00
T 0E 00 FD B6 01 FD B6 00 20 07 21 00 00 11 80 3F
R 00 00 00 00
T 1C 00 C9
R 00 00 00 00
T 1D 00
R 00 00 00 00
T 1D 00 3E 01 F5 33 FD 21 03 00 FD 39 FD 6E 02 FD
R 00 00 00 00
T 2B 00 66 03 E5 FD 6E 00 FD 66 01 E5 CD 00 00 F1
R 00 00 00 00 02 0D 00 00
T 39 00 F1 33 C9
R 00 00 00 00
logf.rel/       1458795416  2001  2501  100664  3963      `
XL2
H 9 areas A global symbols
M logf
O -mz80
S ___fssub Ref0000
S ___fsmul Ref0000
S _errno Ref0000
S ___fsgt Ref0000
S .__.ABS. Def0000
S ___fsadd Ref0000
S ___sint2fs Ref0000
S _frexpf Ref0000
S ___fsdiv Ref0000
A _CODE size 293 flags 0 addr 0
S _logf Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 EA FF 39 F9 21
R 00 00 00 00
T 0E 00 00 00 E5 21 00 00 E5 DD 6E 06 DD 66 07 E5
R 00 00 00 00
T 1C 00 DD 6E 04 DD 66 05 E5 CD 00 00 F1 F1 F1 F1
R 00 00 00 00 02 0A 03 00
T 2A 00 7D B7 20 0E 21 21 00 22 00 00 21 00 00 5D
R 00 00 00 00 02 0A 02 00
T 38 00 54 C3 8E 02
R 00 00 00 00 00 04 00 00
T 3C 00
R 00 00 00 00
T 3C 00 21 00 00 39 E5 DD 6E 06 DD 66 07 E5 DD 6E
R 00 00 00 00
T 4A 00 04 DD 66 05 E5 CD 00 00 F1 F1 F1 DD 75 F4
R 00 00 00 00 02 08 07 00
T 58 00 DD 74 F5 DD 73 F6 DD 72 F7 21 00 3F E5 21
R 00 00 00 00
T 66 00 00 00 E5 DD 6E F6 DD 66 F7 E5 DD 6E F4 DD
R 00 00 00 00
T 74 00 66 F5 E5 CD 00 00 F1 F1 F1 F1 DD 75 EC DD
R 00 00 00 00 02 06 00 00
T 82 00 74 ED DD 73 EE DD 72 EF 21 35 3F E5 21
R 00 00 00 00
T 8F 00 F3 04 E5 DD 6E F6 DD 66 F7 E5 DD 6E F4 DD
R 00 00 00 00
T 9D 00 66 F5 E5 CD 00 00 F1 F1 F1 F1 7D B7 28 5D
R 00 00 00 00 02 06 03 00
T AB 00 21 00 3F E5 21 00 00 E5 DD 6E EE DD 66 EF
R 00 00 00 00
T B9 00 E5 DD 6E EC DD 66 ED E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 00 00
T C7 00 F1 DD 75 EC DD 74 ED DD 73 EE DD 72 EF DD
R 00 00 00 00
T D5 00 6E F6 DD 66 F7 E5 DD 6E F4 DD 66 F5 E5 21
R 00 00 00 00
T E3 00 00 3F E5 21 00 00 E5 CD 00 00 F1 F1 F1 F1
R 00 00 00 00 02 0A 01 00
T F1 00 4D 44 21 00 3F E5 21 00 00 E5 D5 C5 CD
R 00 00 00 00
T FE 00 00 00 F1 F1 F1 F1 4D 44 18 36
R 00 00 00 00 02 02 05 00
T 08 01
R 00 00 00 00
T 08 01 E1 E5 2B E3 DD 6E EE DD 66 EF E5 DD 6E EC
R 00 00 00 00
T 16 01 DD 66 ED E5 21 00 3F E5 21 00 00 E5 CD
R 00 00 00 00
T 23 01 00 00 F1 F1 F1 F1 4D 44 21 00 3F E5 21
R 00 00 00 00 02 02 01 00
T 30 01 00 00 E5 D5 C5 CD 00 00 F1 F1 F1 F1 4D 44
R 00 00 00 00 02 08 05 00
T 3E 01
R 00 00 00 00
T 3E 01 D5 C5 DD 6E EE DD 66 EF E5 DD 6E EC DD 66
R 00 00 00 00
T 4C 01 ED E5 CD 00 00 F1 F1 F1 F1 DD 75 F0 DD 74
R 00 00 00 00 02 05 08 00
T 5A 01 F1 DD 73 F2 DD 72 F3 DD 6E F2 DD 66 F3 E5
R 00 00 00 00
T 68 01 DD 6E F0 DD 66 F1 E5 DD 6E F2 DD 66 F3 E5
R 00 00 00 00
T 76 01 DD 6E F0 DD 66 F1 E5 CD 00 00 F1 F1 F1 F1
R 00 00 00 00 02 0A 01 00
T 84 01 4D 44 C5 D5 D5 C5 21 0D BF E5 21 3D 7E E5
R 00 00 00 00
T 92 01 CD 00 00 F1 F1 F1 F1 DD 72 FF DD 73 FE DD
R 00 00 00 00 02 03 01 00
T A0 01 74 FD DD 75 FC D1 C1 21 D4 C0 E5 21 3A 3F
R 00 00 00 00
T AE 01 E5 D5 C5 CD 00 00 F1 F1 F1 F1 EB E5 D5 DD
R 00 00 00 00 02 06 05 00
T BC 01 6E FE DD 66 FF E5 DD 6E FC DD 66 FD E5 CD
R 00 00 00 00
T CA 01 00 00 F1 F1 F1 F1 EB E5 D5 DD 6E F2 DD 66
R 00 00 00 00 02 02 08 00
T D8 01 F3 E5 DD 6E F0 DD 66 F1 E5 CD 00 00 F1 F1
R 00 00 00 00 02 0C 01 00
T E6 01 F1 F1 EB E5 D5 DD 6E F2 DD 66 F3 E5 DD 6E
R 00 00 00 00
T F4 01 F0 DD 66 F1 E5 CD 00 00 F1 F1 F1 F1 DD 75
R 00 00 00 00 02 08 05 00
T 02 02 F8 DD 74 F9 DD 73 FA DD 72 FB E1 E5 E5 CD
R 00 00 00 00
T 10 02 00 00 F1 4D 44 C5 D5 D5 C5 21 5E B9 E5 21
R 00 00 00 00 02 02 06 00
T 1E 02 83 80 E5 CD 00 00 F1 F1 F1 F1 DD 72 FF DD
R 00 00 00 00 02 06 01 00
T 2C 02 73 FE DD 74 FD DD 75 FC DD 6E FA DD 66 FB
R 00 00 00 00
T 3A 02 E5 DD 6E F8 DD 66 F9 E5 DD 6E FE DD 66 FF
R 00 00 00 00
T 48 02 E5 DD 6E FC DD 66 FD E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 05 00
T 56 02 F1 DD 72 FF DD 73 FE DD 74 FD DD 75 FC D1
R 00 00 00 00
T 64 02 C1 D5 C5 21 31 3F E5 21 00 80 E5 CD 00 00
R 00 00 00 00 02 0E 01 00
T 72 02 F1 F1 F1 F1 EB E5 D5 DD 6E FE DD 66 FF E5
R 00 00 00 00
T 80 02 DD 6E FC DD 66 FD E5 CD 00 00 F1 F1 F1 F1
R 00 00 00 00 02 0A 05 00
T 8E 02
R 00 00 00 00
T 8E 02 DD F9 DD E1 C9
R 00 00 00 00

log10f.rel/     1458795416  2001  2501  100664  676       `
XL2
H 9 areas 4 global symbols
M log10f
O -mz80
S ___fsmul Ref0000
S _logf Ref0000
S .__.ABS. Def0000
A _CODE size 2C flags 0 addr 0
S _log10f Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 FD 21 02 00 FD 39 FD 6E 02 FD 66 03 E5 FD
R 00 00 00 00
T 0E 00 6E 00 FD 66 01 E5 CD 00 00 F1 F1 EB E5 D5
R 00 00 00 00 02 09 01 00
T 1C 00 21 DE 3E E5 21 D9 5B E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 00 00
T 2A 00 F1 C9
R 00 00 00 00
sqrtf.rel/      1458795417  2001  2501  100664  2856      `
XL2
H 9 areas A global symbols
M sqrtf
O -mz80
S ___fsmul Ref0000
S _errno Ref0000
S ___fseq Ref0000
S ___fslt Ref0000
S .__.ABS. Def0000
S ___fsadd Ref0000
S _ldexpf Ref0000
S _frexpf Ref0000
S ___fsdiv Ref0000
A _CODE size 19E flags 0 addr 0
S _sqrtf Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 F6 FF 39 F9 DD
R 00 00 00 00
T 0E 00 7E 07 CB BF DD B6 06 DD B6 05 DD B6 04 20
R 00 00 00 00
T 1C 00 0F DD 6E 04 DD 66 05 DD 5E 06 DD 56 07 C3
R 00 00 00 00
T 2A 00 99 01
R 00 00 00 00 00 02 00 00
T 2C 00
R 00 00 00 00
T 2C 00 21 80 3F E5 21 00 00 E5 DD 6E 06 DD 66 07
R 00 00 00 00
T 3A 00 E5 DD 6E 04 DD 66 05 E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 02 00
T 48 00 F1 7D B7 28 09 21 00 00 11 80 3F C3 99 01
R 00 00 00 00 00 0E 00 00
T 56 00
R 00 00 00 00
T 56 00 21 00 00 E5 21 00 00 E5 DD 6E 06 DD 66 07
R 00 00 00 00
T 64 00 E5 DD 6E 04 DD 66 05 E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 03 00
T 72 00 F1 7D B7 28 0E 21 21 00 22 00 00 21 00 00
R 00 00 00 00 02 0B 01 00
T 80 00 5D 54 C3 99 01
R 00 00 00 00 00 05 00 00
T 85 00
R 00 00 00 00
T 85 00 21 00 00 39 E5 DD 6E 06 DD 66 07 E5 DD 6E
R 00 00 00 00
T 93 00 04 DD 66 05 E5 CD 00 00 F1 F1 F1 DD 75 F8
R 00 00 00 00 02 08 07 00
T A1 00 DD 74 F9 DD 73 FA DD 72 FB DD 6E FA DD 66
R 00 00 00 00
T AF 00 FB E5 DD 6E F8 DD 66 F9 E5 21 17 3F E5 21
R 00 00 00 00
T BD 00 BA 14 E5 CD 00 00 F1 F1 F1 F1 4D 44 21
R 00 00 00 00 02 06 00 00
T CA 00 D5 3E E5 21 A8 A9 E5 D5 C5 CD 00 00 F1 F1
R 00 00 00 00 02 0C 05 00
T D8 00 F1 F1 4D 44 C5 D5 D5 C5 DD 6E FA DD 66 FB
R 00 00 00 00
T E6 00 E5 DD 6E F8 DD 66 F9 E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 08 00
T F4 00 F1 DD 72 FF DD 73 FE DD 74 FD DD 75 FC D1
R 00 00 00 00
T 02 01 C1 DD 6E FE DD 66 FF E5 DD 6E FC DD 66 FD
R 00 00 00 00
T 10 01 E5 D5 C5 CD 00 00 F1 F1 F1 F1 EB E5 D5 01
R 00 00 00 00 02 06 05 00
T 1E 01 FE FF C5 E5 D5 CD 00 00 F1 F1 F1 DD 72 FF
R 00 00 00 00 02 08 06 00
T 2C 01 DD 73 FE DD 74 FD DD 75 FC DD 6E FA DD 66
R 00 00 00 00
T 3A 01 FB E5 DD 6E F8 DD 66 F9 E5 CD 00 00 F1 F1
R 00 00 00 00 02 0C 08 00
T 48 01 F1 F1 EB E5 D5 DD 6E FE DD 66 FF E5 DD 6E
R 00 00 00 00
T 56 01 FC DD 66 FD E5 CD 00 00 F1 F1 F1 F1 4D 44
R 00 00 00 00 02 08 05 00
T 64 01 DD CB F6 46 28 1B D5 C5 21 35 3F E5 21
R 00 00 00 00
T 71 01 F3 04 E5 CD 00 00 F1 F1 F1 F1 4D 44 DD 34
R 00 00 00 00 02 06 00 00
T 7F 01 F6 20 03 DD 34 F7
R 00 00 00 00
T 85 01
R 00 00 00 00
T 85 01
R 00 00 00 00
T 85 01 E1 E5 CB 7C 28 01 23
R 00 00 00 00
T 8C 01
R 00 00 00 00
T 8C 01 CB 2C CB 1D E5 D5 C5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0A 06 00
T 99 01
R 00 00 00 00
T 99 01 DD F9 DD E1 C9
R 00 00 00 00
tancotf.rel/    1458795418  2001  2501  100664  6525      `
XL2
H 9 areas C global symbols
M tancotf
O -mz80
S ___fssub Ref0000
S ___fsmul Ref0000
S _errno Ref0000
S ___fsgt Ref0000
S ___fslt Ref0000
S .__.ABS. Def0000
S ___fsadd Ref0000
S _fabsf Ref0000
S ___sint2fs Ref0000
S ___fs2sint Ref0000
S ___fsdiv Ref0000
A _CODE size 473 flags 0 addr 0
S _tancotf Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 DD FF 39 F9 DD
R 00 00 00 00
T 0E 00 6E 06 DD 66 07 E5 DD 6E 04 DD 66 05 E5 CD
R 00 00 00 00
T 1C 00 00 00 F1 F1 4D 44 21 C9 45 E5 21 00 08 E5
R 00 00 00 00 02 02 07 00
T 2A 00 D5 C5 CD 00 00 F1 F1 F1 F1 DD 75 FF 7D B7
R 00 00 00 00 02 05 03 00
T 38 00 28 0E 21 22 00 22 00 00 21 00 00 5D 54 C3
R 00 00 00 00 02 08 02 00
T 46 00 6E 04
R 00 00 00 00 00 02 00 00
T 48 00
R 00 00 00 00
T 48 00 DD 6E 06 DD 66 07 E5 DD 6E 04 DD 66 05 E5
R 00 00 00 00
T 56 00 21 22 3F E5 21 83 F9 E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 01 00
T 64 00 F1 DD 72 FE DD 73 FD DD 74 FC DD 75 FB 21
R 00 00 00 00
T 72 00 00 00 E5 21 00 00 E5 DD 6E 06 DD 66 07 E5
R 00 00 00 00
T 80 00 DD 6E 04 DD 66 05 E5 CD 00 00 F1 F1 F1 F1
R 00 00 00 00 02 0A 03 00
T 8E 00 7D B7 28 08 01 00 00 21 00 3F 18 06
R 00 00 00 00
T 9A 00
R 00 00 00 00
T 9A 00 01 00 00 21 00 BF
R 00 00 00 00
T A0 00
R 00 00 00 00
T A0 00 E5 C5 DD 6E FD DD 66 FE E5 DD 6E FB DD 66
R 00 00 00 00
T AE 00 FC E5 CD 00 00 F1 F1 F1 F1 D5 E5 CD 00 00
R 00 00 00 00 02 05 06 00 02 0E 09 00
T BC 00 F1 F1 33 33 E5 E1 E5 E5 CD 00 00 F1 DD 72
R 00 00 00 00 02 0B 08 00
T CA 00 EA DD 73 E9 DD 74 E8 DD 75 E7 DD 6E 06 DD
R 00 00 00 00
T D8 00 66 07 E5 DD 6E 04 DD 66 05 E5 CD 00 00 F1
R 00 00 00 00 02 0D 09 00
T E6 00 F1 DD 74 FC DD 75 FB DD 66 FC E5 CD 00 00
R 00 00 00 00 02 0E 08 00
T F4 00 F1 DD 72 E6 DD 73 E5 DD 74 E4 DD 75 E3 21
R 00 00 00 00
T 02 01 1E 00 39 EB 21 06 00 39 01 04 00 ED B0 DD
R 00 00 00 00
T 10 01 6E FD DD 66 FE E5 DD 6E FB DD 66 FC E5 DD
R 00 00 00 00
T 1E 01 6E 06 DD 66 07 E5 DD 6E 04 DD 66 05 E5 CD
R 00 00 00 00
T 2C 01 00 00 F1 F1 F1 F1 DD 72 E2 DD 73 E1 DD 74
R 00 00 00 00 02 02 00 00
T 3A 01 E0 DD 75 DF 21 1A 00 39 EB 21 02 00 39 01
R 00 00 00 00
T 48 01 04 00 ED B0 DD 6E E9 DD 66 EA E5 DD 6E E7
R 00 00 00 00
T 56 01 DD 66 E8 E5 21 C9 3F E5 21 00 00 E5 CD
R 00 00 00 00
T 63 01 00 00 F1 F1 F1 F1 DD 72 F6 DD 73 F5 DD 74
R 00 00 00 00 02 02 01 00
T 71 01 F4 DD 75 F3 DD 6E F5 DD 66 F6 E5 DD 6E F3
R 00 00 00 00
T 7F 01 DD 66 F4 E5 DD 6E FD DD 66 FE E5 DD 6E FB
R 00 00 00 00
T 8D 01 DD 66 FC E5 CD 00 00 F1 F1 F1 F1 DD 72 F6
R 00 00 00 00 02 07 00 00
T 9B 01 DD 73 F5 DD 74 F4 DD 75 F3 DD 6E F9 DD 66
R 00 00 00 00
T A9 01 FA E5 DD 6E F7 DD 66 F8 E5 DD 6E F5 DD 66
R 00 00 00 00
T B7 01 F6 E5 DD 6E F3 DD 66 F4 E5 CD 00 00 F1 F1
R 00 00 00 00 02 0C 06 00
T C5 01 F1 F1 DD 72 F6 DD 73 F5 DD 74 F4 DD 75 F3
R 00 00 00 00
T D3 01 DD 6E E9 DD 66 EA E5 DD 6E E7 DD 66 E8 E5
R 00 00 00 00
T E1 01 21 FD 39 E5 21 22 AA E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 01 00
T EF 01 F1 DD 72 FA DD 73 F9 DD 74 F8 DD 75 F7 DD
R 00 00 00 00
T FD 01 6E F9 DD 66 FA E5 DD 6E F7 DD 66 F8 E5 DD
R 00 00 00 00
T 0B 02 6E F5 DD 66 F6 E5 DD 6E F3 DD 66 F4 E5 CD
R 00 00 00 00
T 19 02 00 00 F1 F1 F1 F1 DD 72 F2 DD 73 F1 DD 74
R 00 00 00 00 02 02 00 00
T 27 02 F0 DD 75 EF DD 6E F1 DD 66 F2 E5 DD 6E EF
R 00 00 00 00
T 35 02 DD 66 F0 E5 CD 00 00 F1 F1 DD 72 F6 DD 73
R 00 00 00 00 02 07 07 00
T 43 02 F5 DD 74 F4 DD 75 F3 21 80 39 E5 21 00 00
R 00 00 00 00
T 51 02 E5 DD 6E F5 DD 66 F6 E5 DD 6E F3 DD 66 F4
R 00 00 00 00
T 5F 02 E5 CD 00 00 F1 F1 F1 F1 DD 75 F3 7D B7 28
R 00 00 00 00 02 04 04 00
T 6D 02 21 21 06 00 39 EB 21 12 00 39 01 04 00 ED
R 00 00 00 00
T 7B 02 B0 DD 36 DF 00 DD 36 E0 00 DD 36 E1 80 DD
R 00 00 00 00
T 89 02 36 E2 3F C3 81 03
R 00 00 00 00 00 06 00 00
T 8F 02
R 00 00 00 00
T 8F 02 DD 6E F1 DD 66 F2 E5 DD 6E EF DD 66 F0 E5
R 00 00 00 00
T 9D 02 DD 6E F1 DD 66 F2 E5 DD 6E EF DD 66 F0 E5
R 00 00 00 00
T AB 02 CD 00 00 F1 F1 F1 F1 DD 75 EB DD 74 EC DD
R 00 00 00 00 02 03 01 00
T B9 02 73 ED DD 72 EE DD 6E ED DD 66 EE E5 DD 6E
R 00 00 00 00
T C7 02 EB DD 66 EC E5 21 C4 BD E5 21 B8 33 E5 CD
R 00 00 00 00
T D5 02 00 00 F1 F1 F1 F1 4D 44 DD 6E F1 DD 66 F2
R 00 00 00 00 02 02 01 00
T E3 02 E5 DD 6E EF DD 66 F0 E5 D5 C5 CD 00 00 F1
R 00 00 00 00 02 0D 01 00
T F1 02 F1 F1 F1 4D 44 DD 6E F1 DD 66 F2 E5 DD 6E
R 00 00 00 00
T FF 02 EF DD 66 F0 E5 D5 C5 CD 00 00 F1 F1 F1 F1
R 00 00 00 00 02 0A 06 00
T 0D 03 DD 75 E3 DD 74 E4 DD 73 E5 DD 72 E6 DD 6E
R 00 00 00 00
T 1B 03 ED DD 66 EE E5 DD 6E EB DD 66 EC E5 21
R 00 00 00 00
T 28 03 1F 3C E5 21 75 33 E5 CD 00 00 F1 F1 F1 F1
R 00 00 00 00 02 0A 01 00
T 36 03 4D 44 21 DB BE E5 21 AF B7 E5 D5 C5 CD
R 00 00 00 00
T 43 03 00 00 F1 F1 F1 F1 4D 44 DD 6E ED DD 66 EE
R 00 00 00 00 02 02 06 00
T 51 03 E5 DD 6E EB DD 66 EC E5 D5 C5 CD 00 00 F1
R 00 00 00 00 02 0D 01 00
T 5F 03 F1 F1 F1 4D 44 21 80 3F E5 21 00 00 E5 D5
R 00 00 00 00
T 6D 03 C5 CD 00 00 F1 F1 F1 F1 DD 75 DF DD 74 E0
R 00 00 00 00 02 04 06 00
T 7B 03 DD 73 E1 DD 72 E2
R 00 00 00 00
T 81 03
R 00 00 00 00
T 81 03 DD CB DD 46 CA 0B 04 DD CB 08 46 28 29 DD
R 00 00 00 00 00 07 00 00
T 8F 03 7E E6 EE 80 47 DD 5E E3 DD 56 E4 DD 4E E5
R 00 00 00 00
T 9D 03 DD 6E E1 DD 66 E2 E5 DD 6E DF DD 66 E0 E5
R 00 00 00 00
T AB 03 C5 D5 CD 00 00 F1 F1 F1 F1 C3 6E 04
R 00 00 00 00 02 05 0A 00 00 0C 00 00
T B7 03
R 00 00 00 00
T B7 03 DD 7E E2 EE 80 DD 77 F6 DD 7E DF DD 77 F3
R 00 00 00 00
T C5 03 DD 7E E0 DD 77 F4 DD 7E E1 DD 77 F5 DD 6E
R 00 00 00 00
T D3 03 E5 DD 66 E6 E5 DD 6E E3 DD 66 E4 E5 DD 6E
R 00 00 00 00
T E1 03 F5 DD 66 F6 E5 DD 6E F3 DD 66 F4 E5 CD
R 00 00 00 00
T EE 03 00 00 F1 F1 F1 F1 DD 72 F6 DD 73 F5 DD 74
R 00 00 00 00 02 02 0A 00
T FC 03 F4 DD 75 F3 DD 66 F4 DD 5E F5 DD 56 F6 18
R 00 00 00 00
T 0A 04 63
R 00 00 00 00
T 0B 04
R 00 00 00 00
T 0B 04 DD CB 08 46 28 25 DD 6E E5 DD 66 E6 E5 DD
R 00 00 00 00
T 19 04 6E E3 DD 66 E4 E5 DD 6E E1 DD 66 E2 E5 DD
R 00 00 00 00
T 27 04 6E DF DD 66 E0 E5 CD 00 00 F1 F1 F1 F1 18
R 00 00 00 00 02 09 0A 00
T 35 04 38
R 00 00 00 00
T 36 04
R 00 00 00 00
T 36 04 DD 6E E1 DD 66 E2 E5 DD 6E DF DD 66 E0 E5
R 00 00 00 00
T 44 04 DD 6E E5 DD 66 E6 E5 DD 6E E3 DD 66 E4 E5
R 00 00 00 00
T 52 04 CD 00 00 F1 F1 F1 F1 DD 72 F6 DD 73 F5 DD
R 00 00 00 00 02 03 0A 00
T 60 04 74 F4 DD 75 F3 DD 66 F4 DD 5E F5 DD 56 F6
R 00 00 00 00
T 6E 04
R 00 00 00 00
T 6E 04 DD F9 DD E1 C9
R 00 00 00 00

tanf.rel/       1458795418  2001  2501  100664  580       `
XL2
H 9 areas 3 global symbols
M tanf
O -mz80
S _tancotf Ref0000
S .__.ABS. Def0000
A _CODE size 1E flags 0 addr 0
S _tanf Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 AF F5 33 FD 21 03 00 FD 39 FD 6E 02 FD 66
R 00 00 00 00
T 0E 00 03 E5 FD 6E 00 FD 66 01 E5 CD 00 00 F1 F1
R 00 00 00 00 02 0C 00 00
T 1C 00 33 C9
R 00 00 00 00
cotf.rel/       1458795418  2001  2501  100664  1228      `
XL2
H 9 areas 6 global symbols
M cotf
O -mz80
S _errno Ref0000
S _tancotf Ref0000
S ___fslt Ref0000
S .__.ABS. Def0000
S _fabsf Ref0000
A _CODE size 84 flags 0 addr 0
S _cotf Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 DD 6E 06 DD 66 07
R 00 00 00 00
T 0E 00 E5 DD 6E 04 DD 66 05 E5 CD 00 00 F1 F1 4D
R 00 00 00 00 02 0B 04 00
T 1C 00 44 21 A2 0D E5 21 60 42 E5 D5 C5 CD 00 00
R 00 00 00 00 02 0E 02 00
T 2A 00 F1 F1 F1 F1 7D B7 28 37 21 22 00 22 00 00
R 00 00 00 00 02 0E 00 00
T 38 00 21 00 00 E5 21 00 00 E5 DD 6E 06 DD 66 07
R 00 00 00 00
T 46 00 E5 DD 6E 04 DD 66 05 E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 02 00
T 54 00 F1 7D B7 28 08 21 FF FF 11 7F FF 18 20
R 00 00 00 00
T 61 00
R 00 00 00 00
T 61 00 21 FF FF 11 7F 7F 18 18
R 00 00 00 00
T 69 00
R 00 00 00 00
T 69 00 3E 01 F5 33 DD 6E 06 DD 66 07 E5 DD 6E 04
R 00 00 00 00
T 77 00 DD 66 05 E5 CD 00 00 F1 F1 33
R 00 00 00 00 02 07 01 00
T 81 00
R 00 00 00 00
T 81 00 DD E1 C9
R 00 00 00 00
asincosf.rel/   1458795419  2001  2501  100664  6333      `
XL2
H 9 areas C global symbols
M asincosf
O -mz80
S ___fssub Ref0000
S ___fsmul Ref0000
S _errno Ref0000
S _sqrtf Ref0000
S ___fsgt Ref0000
S ___fslt Ref0000
S .__.ABS. Def0000
S ___fsadd Ref0000
S _fabsf Ref0000
S _ldexpf Ref0000
S ___fsdiv Ref0000
A _CODE size 42A flags 0 addr 0
S _asincosf Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 E5 FF 39 F9 DD
R 00 00 00 00
T 0E 00 7E 08 DD 77 E5 DD 6E 06 DD 66 07 E5 DD 6E
R 00 00 00 00
T 1C 00 04 DD 66 05 E5 CD 00 00 F1 F1 DD 75 F7 DD
R 00 00 00 00 02 08 08 00
T 2A 00 74 F8 DD 73 F9 DD 72 FA 21 80 39 E5 21
R 00 00 00 00
T 37 00 00 00 E5 DD 6E F9 DD 66 FA E5 DD 6E F7 DD
R 00 00 00 00
T 45 00 66 F8 E5 CD 00 00 F1 F1 F1 F1 DD 75 FB 7D
R 00 00 00 00 02 06 05 00
T 53 00 B7 28 0F DD 4E F7 DD 46 F8 DD 5E F9 DD 56
R 00 00 00 00
T 61 00 FA C3 B6 02
R 00 00 00 00 00 04 00 00
T 65 00
R 00 00 00 00
T 65 00 21 00 3F E5 21 00 00 E5 DD 6E F9 DD 66 FA
R 00 00 00 00
T 73 00 E5 DD 6E F7 DD 66 F8 E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 04 00
T 81 00 F1 7D B7 CA 9F 01 DD 7E E5 EE 01 DD 77 E5
R 00 00 00 00 00 06 00 00
T 8F 00 21 80 3F E5 21 00 00 E5 DD 6E F9 DD 66 FA
R 00 00 00 00
T 9D 00 E5 DD 6E F7 DD 66 F8 E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 04 00
T AB 00 F1 7D B7 28 0E 21 21 00 22 00 00 21 00 00
R 00 00 00 00 02 0B 02 00
T B9 00 5D 54 C3 15 04
R 00 00 00 00 00 05 00 00
T BE 00
R 00 00 00 00
T BE 00 DD 6E F9 DD 66 FA E5 DD 6E F7 DD 66 F8 E5
R 00 00 00 00
T CC 00 21 80 3F E5 21 00 00 E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 00 00
T DA 00 F1 DD 72 EE DD 73 ED DD 74 EC DD 75 EB 21
R 00 00 00 00
T E8 00 0E 00 39 EB 21 06 00 39 01 04 00 ED B0 21
R 00 00 00 00
T F6 00 FF FF E5 DD 6E F5 DD 66 F6 E5 DD 6E F3 DD
R 00 00 00 00
T 04 01 66 F4 E5 CD 00 00 F1 F1 F1 DD 72 F6 DD 73
R 00 00 00 00 02 06 09 00
T 12 01 F5 DD 74 F4 DD 75 F3 21 06 00 39 EB 21
R 00 00 00 00
T 1F 01 0E 00 39 01 04 00 ED B0 DD 6E ED DD 66 EE
R 00 00 00 00
T 2D 01 E5 DD 6E EB DD 66 EC E5 CD 00 00 F1 F1 DD
R 00 00 00 00 02 0B 03 00
T 3B 01 72 F6 DD 73 F5 DD 74 F4 DD 75 F3 21 0A 00
R 00 00 00 00
T 49 01 39 EB 21 0E 00 39 01 04 00 ED B0 DD 6E F1
R 00 00 00 00
T 57 01 DD 66 F2 E5 DD 6E EF DD 66 F0 E5 DD 6E F1
R 00 00 00 00
T 65 01 DD 66 F2 E5 DD 6E EF DD 66 F0 E5 CD 00 00
R 00 00 00 00 02 0E 07 00
T 73 01 F1 F1 F1 F1 DD 72 F6 DD 73 F5 DD 74 F4 DD
R 00 00 00 00
T 81 01 75 F3 DD 7E F6 EE 80 DD 77 FA DD 7E F3 DD
R 00 00 00 00
T 8F 01 77 F7 DD 7E F4 DD 77 F8 DD 7E F5 DD 77 F9
R 00 00 00 00
T 9D 01 18 2F
R 00 00 00 00
T 9F 01
R 00 00 00 00
T 9F 01 DD 6E F9 DD 66 FA E5 DD 6E F7 DD 66 F8 E5
R 00 00 00 00
T AD 01 DD 6E F9 DD 66 FA E5 DD 6E F7 DD 66 F8 E5
R 00 00 00 00
T BB 01 CD 00 00 F1 F1 F1 F1 DD 75 EB DD 74 EC DD
R 00 00 00 00 02 03 01 00
T C9 01 73 ED DD 72 EE
R 00 00 00 00
T CE 01
R 00 00 00 00
T CE 01 DD 6E ED DD 66 EE E5 DD 6E EB DD 66 EC E5
R 00 00 00 00
T DC 01 21 01 BF E5 21 65 20 E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 01 00
T EA 01 F1 4D 44 21 6F 3F E5 21 6B 16 E5 D5 C5 CD
R 00 00 00 00
T F8 01 00 00 F1 F1 F1 F1 4D 44 DD 6E ED DD 66 EE
R 00 00 00 00 02 02 07 00
T 06 02 E5 DD 6E EB DD 66 EC E5 D5 C5 CD 00 00 F1
R 00 00 00 00 02 0D 01 00
T 14 02 F1 F1 F1 DD 72 F6 DD 73 F5 DD 74 F4 DD 75
R 00 00 00 00
T 22 02 F3 21 B1 C0 E5 21 0B 8D E5 DD 6E ED DD 66
R 00 00 00 00
T 30 02 EE E5 DD 6E EB DD 66 EC E5 CD 00 00 F1 F1
R 00 00 00 00 02 0C 07 00
T 3E 02 F1 F1 4D 44 DD 6E ED DD 66 EE E5 DD 6E EB
R 00 00 00 00
T 4C 02 DD 66 EC E5 D5 C5 CD 00 00 F1 F1 F1 F1 4D
R 00 00 00 00 02 09 01 00
T 5A 02 44 21 B3 40 E5 21 F0 50 E5 D5 C5 CD 00 00
R 00 00 00 00 02 0E 07 00
T 68 02 F1 F1 F1 F1 EB E5 D5 DD 6E F5 DD 66 F6 E5
R 00 00 00 00
T 76 02 DD 6E F3 DD 66 F4 E5 CD 00 00 F1 F1 F1 F1
R 00 00 00 00 02 0A 0A 00
T 84 02 EB E5 D5 DD 6E F9 DD 66 FA E5 DD 6E F7 DD
R 00 00 00 00
T 92 02 66 F8 E5 CD 00 00 F1 F1 F1 F1 EB E5 D5 DD
R 00 00 00 00 02 06 01 00
T A0 02 6E F9 DD 66 FA E5 DD 6E F7 DD 66 F8 E5 CD
R 00 00 00 00
T AE 02 00 00 F1 F1 F1 F1 4D 44
R 00 00 00 00 02 02 07 00
T B6 02
R 00 00 00 00
T B6 02 DD 7E E5 DD 77 E6 C5 D5 21 00 00 E5 21
R 00 00 00 00
T C3 02 00 00 E5 DD 6E 06 DD 66 07 E5 DD 6E 04 DD
R 00 00 00 00
T D1 02 66 05 E5 CD 00 00 F1 F1 F1 F1 DD 75 F3 D1
R 00 00 00 00 02 06 05 00
T DF 02 C1 DD 6E E6 26 00 29 29 DD 75 F7 DD 74 F8
R 00 00 00 00
T ED 02 DD CB 08 46 CA A7 03 DD 7E F3 B7 28 57 DD
R 00 00 00 00 00 07 00 00
T FB 02 7E F7 C6 22 04 67 DD 7E F8 CE 22 04 6F D5
R 00 00 00 00 09 05 00 00 89 0C 00 00
T 07 03 C5 5C 55 21 1B 00 39 EB 01 04 00 ED B0 DD
R 00 00 00 00
T 15 03 6E FE DD 66 FF E5 DD 6E FC DD 66 FD E5 CD
R 00 00 00 00
T 23 03 00 00 F1 F1 F1 F1 4D 44 DD 6E FE DD 66 FF
R 00 00 00 00 02 02 07 00
T 31 03 E5 DD 6E FC DD 66 FD E5 D5 C5 CD 00 00 F1
R 00 00 00 00 02 0D 07 00
T 3F 03 F1 F1 F1 DD 75 E7 DD 74 E8 DD 73 E9 DD 72
R 00 00 00 00
T 4D 03 EA C3 09 04
R 00 00 00 00 00 04 00 00
T 51 03
R 00 00 00 00
T 51 03 DD 7E F7 C6 1A 04 67 DD 7E F8 CE 1A 04 6F
R 00 00 00 00 09 06 00 00 89 0D 00 00
T 5D 03 D5 C5 5C 55 21 1B 00 39 EB 01 04 00 ED B0
R 00 00 00 00
T 6B 03 DD 6E FE DD 66 FF E5 DD 6E FC DD 66 FD E5
R 00 00 00 00
T 79 03 CD 00 00 F1 F1 F1 F1 4D 44 DD 6E FE DD 66
R 00 00 00 00 02 03 00 00
T 87 03 FF E5 DD 6E FC DD 66 FD E5 D5 C5 CD 00 00
R 00 00 00 00 02 0E 07 00
T 95 03 F1 F1 F1 F1 DD 75 E7 DD 74 E8 DD 73 E9 DD
R 00 00 00 00
T A3 03 72 EA 18 62
R 00 00 00 00
T A7 03
R 00 00 00 00
T A7 03 3E 1A 04 DD 86 F7 67 3E 1A 04 DD 8E F8 6F
R 00 00 00 00 09 03 00 00 89 0A 00 00
T B3 03 D5 C5 5C 55 21 1B 00 39 EB 01 04 00 ED B0
R 00 00 00 00
T C1 03 DD 6E FE DD 66 FF E5 DD 6E FC DD 66 FD E5
R 00 00 00 00
T CF 03 CD 00 00 F1 F1 F1 F1 4D 44 DD 6E FE DD 66
R 00 00 00 00 02 03 07 00
T DD 03 FF E5 DD 6E FC DD 66 FD E5 D5 C5 CD 00 00
R 00 00 00 00 02 0E 07 00
T EB 03 F1 F1 F1 F1 DD 75 E7 DD 74 E8 DD 73 E9 DD
R 00 00 00 00
T F9 03 72 EA DD 7E F3 B7 28 08 DD 7E EA EE 80 DD
R 00 00 00 00
T 07 04 77 EA
R 00 00 00 00
T 09 04
R 00 00 00 00
T 09 04 DD 6E E7 DD 66 E8 DD 5E E9 DD 56 EA
R 00 00 00 00
T 15 04
R 00 00 00 00
T 15 04 DD F9 DD E1 C9
R 00 00 00 00
T 1A 04
R 00 00 00 00
T 1A 04 00 00 00 00 DB 0F 49 3F
R 00 00 00 00
T 22 04
R 00 00 00 00
T 22 04 DB 0F C9 3F DB 0F 49 3F
R 00 00 00 00

asinf.rel/      1458795419  2001  2501  100664  1271      `
XL2
H 9 areas 4 global symbols
M asinf
O -mz80
S ___fseq Ref0000
S .__.ABS. Def0000
S _asincosf Ref0000
A _CODE size 96 flags 0 addr 0
S _asinf Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 21 80 3F E5 21 00 00 E5 FD 21 06 00 FD 39
R 00 00 00 00
T 0E 00 FD 6E 02 FD 66 03 E5 FD 6E 00 FD 66 01 E5
R 00 00 00 00
T 1C 00 CD 00 00 F1 F1 F1 F1 7D B7 28 07 21 DB 0F
R 00 00 00 00 02 03 00 00
T 2A 00 11 C9 3F C9
R 00 00 00 00
T 2E 00
R 00 00 00 00
T 2E 00 21 80 BF E5 21 00 00 E5 FD 21 06 00 FD 39
R 00 00 00 00
T 3C 00 FD 6E 02 FD 66 03 E5 FD 6E 00 FD 66 01 E5
R 00 00 00 00
T 4A 00 CD 00 00 F1 F1 F1 F1 7D B7 28 07 21 DB 0F
R 00 00 00 00 02 03 00 00
T 58 00 11 C9 BF C9
R 00 00 00 00
T 5C 00
R 00 00 00 00
T 5C 00 FD 21 02 00 FD 39 FD 7E 03 CB BF FD B6 02
R 00 00 00 00
T 6A 00 FD B6 01 FD B6 00 20 06 21 00 00 5D 54 C9
R 00 00 00 00
T 78 00
R 00 00 00 00
T 78 00 AF F5 33 FD 21 03 00 FD 39 FD 6E 02 FD 66
R 00 00 00 00
T 86 00 03 E5 FD 6E 00 FD 66 01 E5 CD 00 00 F1 F1
R 00 00 00 00 02 0C 02 00
T 94 00 33 C9
R 00 00 00 00

acosf.rel/      1458795419  2001  2501  100664  1296      `
XL2
H 9 areas 4 global symbols
M acosf
O -mz80
S ___fseq Ref0000
S .__.ABS. Def0000
S _asincosf Ref0000
A _CODE size 97 flags 0 addr 0
S _acosf Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 21 80 3F E5 21 00 00 E5 FD 21 06 00 FD 39
R 00 00 00 00
T 0E 00 FD 6E 02 FD 66 03 E5 FD 6E 00 FD 66 01 E5
R 00 00 00 00
T 1C 00 CD 00 00 F1 F1 F1 F1 7D B7 28 06 21 00 00
R 00 00 00 00 02 03 00 00
T 2A 00 5D 54 C9
R 00 00 00 00
T 2D 00
R 00 00 00 00
T 2D 00 21 80 BF E5 21 00 00 E5 FD 21 06 00 FD 39
R 00 00 00 00
T 3B 00 FD 6E 02 FD 66 03 E5 FD 6E 00 FD 66 01 E5
R 00 00 00 00
T 49 00 CD 00 00 F1 F1 F1 F1 7D B7 28 07 21 DB 0F
R 00 00 00 00 02 03 00 00
T 57 00 11 49 40 C9
R 00 00 00 00
T 5B 00
R 00 00 00 00
T 5B 00 FD 21 02 00 FD 39 FD 7E 03 CB BF FD B6 02
R 00 00 00 00
T 69 00 FD B6 01 FD B6 00 20 07 21 DB 0F 11 C9 3F
R 00 00 00 00
T 77 00 C9
R 00 00 00 00
T 78 00
R 00 00 00 00
T 78 00 3E 01 F5 33 FD 21 03 00 FD 39 FD 6E 02 FD
R 00 00 00 00
T 86 00 66 03 E5 FD 6E 00 FD 66 01 E5 CD 00 00 F1
R 00 00 00 00 02 0D 02 00
T 94 00 F1 33 C9
R 00 00 00 00
atanf.rel/      1458795419  2001  2501  100664  4747      `
XL2
H 9 areas 9 global symbols
M atanf
O -mz80
S ___fssub Ref0000
S ___fsmul Ref0000
S ___fsgt Ref0000
S ___fslt Ref0000
S .__.ABS. Def0000
S ___fsadd Ref0000
S _fabsf Ref0000
S ___fsdiv Ref0000
A _CODE size 316 flags 0 addr 0
S _atanf Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 EE FF 39 F9 21
R 00 00 00 00
T 0E 00 00 00 E3 DD 6E 06 DD 66 07 E5 DD 6E 04 DD
R 00 00 00 00
T 1C 00 66 05 E5 CD 00 00 F1 F1 DD 75 F4 DD 74 F5
R 00 00 00 00 02 06 06 00
T 2A 00 DD 73 F6 DD 72 F7 21 80 3F E5 21 00 00 E5
R 00 00 00 00
T 38 00 DD 6E F6 DD 66 F7 E5 DD 6E F4 DD 66 F5 E5
R 00 00 00 00
T 46 00 CD 00 00 F1 F1 F1 F1 7D B7 28 2D DD 6E F6
R 00 00 00 00 02 03 02 00
T 54 00 DD 66 F7 E5 DD 6E F4 DD 66 F5 E5 21 80 3F
R 00 00 00 00
T 62 00 E5 21 00 00 E5 CD 00 00 F1 F1 F1 F1 DD 75
R 00 00 00 00 02 08 07 00
T 70 00 F4 DD 74 F5 DD 73 F6 DD 72 F7 21 02 00 E3
R 00 00 00 00
T 7E 00
R 00 00 00 00
T 7E 00 21 89 3E E5 21 A3 30 E5 DD 6E F6 DD 66 F7
R 00 00 00 00
T 8C 00 E5 DD 6E F4 DD 66 F5 E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 02 00
T 9A 00 F1 7D B7 CA 3E 01 DD 6E F6 DD 66 F7 E5 DD
R 00 00 00 00 00 06 00 00
T A8 00 6E F4 DD 66 F5 E5 21 3B 3F E5 21 AF 67 E5
R 00 00 00 00
T B6 00 CD 00 00 F1 F1 F1 F1 4D 44 21 80 3F E5 21
R 00 00 00 00 02 03 01 00
T C4 00 00 00 E5 D5 C5 CD 00 00 F1 F1 F1 F1 4D 44
R 00 00 00 00 02 08 00 00
T D2 00 DD 6E F6 DD 66 F7 E5 DD 6E F4 DD 66 F5 E5
R 00 00 00 00
T E0 00 D5 C5 CD 00 00 F1 F1 F1 F1 DD 72 FF DD 73
R 00 00 00 00 02 05 05 00
T EE 00 FE DD 74 FD DD 75 FC 21 DD 3F E5 21 D7 B3
R 00 00 00 00
T FC 00 E5 DD 6E F6 DD 66 F7 E5 DD 6E F4 DD 66 F5
R 00 00 00 00
T 0A 01 E5 CD 00 00 F1 F1 F1 F1 EB E5 D5 DD 6E FE
R 00 00 00 00 02 04 05 00
T 18 01 DD 66 FF E5 DD 6E FC DD 66 FD E5 CD 00 00
R 00 00 00 00 02 0E 07 00
T 26 01 F1 F1 F1 F1 DD 75 F4 DD 74 F5 DD 73 F6 DD
R 00 00 00 00
T 34 01 72 F7 DD 34 EE 20 03 DD 34 EF
R 00 00 00 00
T 3E 01
R 00 00 00 00
T 3E 01
R 00 00 00 00
T 3E 01 DD 6E F6 DD 66 F7 E5 DD 6E F4 DD 66 F5 E5
R 00 00 00 00
T 4C 01 CD 00 00 F1 F1 4D 44 21 80 39 E5 21 00 00
R 00 00 00 00 02 03 06 00
T 5A 01 E5 D5 C5 CD 00 00 F1 F1 F1 F1 DD 75 FC 7D
R 00 00 00 00 02 06 03 00
T 68 01 B7 28 11 21 0E 00 39 EB 21 06 00 39 01
R 00 00 00 00
T 75 01 04 00 ED B0 C3 80 02
R 00 00 00 00 00 07 00 00
T 7C 01
R 00 00 00 00
T 7C 01 DD 6E F6 DD 66 F7 E5 DD 6E F4 DD 66 F5 E5
R 00 00 00 00
T 8A 01 DD 6E F6 DD 66 F7 E5 DD 6E F4 DD 66 F5 E5
R 00 00 00 00
T 98 01 CD 00 00 F1 F1 F1 F1 DD 75 F0 DD 74 F1 DD
R 00 00 00 00 02 03 01 00
T A6 01 73 F2 DD 72 F3 DD 6E F2 DD 66 F3 E5 DD 6E
R 00 00 00 00
T B4 01 F0 DD 66 F1 E5 21 50 BD E5 21 91 86 E5 CD
R 00 00 00 00
T C2 01 00 00 F1 F1 F1 F1 4D 44 21 F1 BE E5 21
R 00 00 00 00 02 02 01 00
T CF 01 F6 10 E5 D5 C5 CD 00 00 F1 F1 F1 F1 4D 44
R 00 00 00 00 02 08 05 00
T DD 01 DD 6E F2 DD 66 F3 E5 DD 6E F0 DD 66 F1 E5
R 00 00 00 00
T EB 01 D5 C5 CD 00 00 F1 F1 F1 F1 4D 44 DD 6E F6
R 00 00 00 00 02 05 01 00
T F9 01 DD 66 F7 E5 DD 6E F4 DD 66 F5 E5 D5 C5 CD
R 00 00 00 00
T 07 02 00 00 F1 F1 F1 F1 DD 72 FB DD 73 FA DD 74
R 00 00 00 00 02 02 01 00
T 15 02 F9 DD 75 F8 21 B4 3F E5 21 D3 CC E5 DD 6E
R 00 00 00 00
T 23 02 F2 DD 66 F3 E5 DD 6E F0 DD 66 F1 E5 CD
R 00 00 00 00
T 30 02 00 00 F1 F1 F1 F1 EB E5 D5 DD 6E FA DD 66
R 00 00 00 00 02 02 05 00
T 3E 02 FB E5 DD 6E F8 DD 66 F9 E5 CD 00 00 F1 F1
R 00 00 00 00 02 0C 07 00
T 4C 02 F1 F1 EB E5 D5 DD 6E F6 DD 66 F7 E5 DD 6E
R 00 00 00 00
T 5A 02 F4 DD 66 F5 E5 CD 00 00 F1 F1 F1 F1 DD 72
R 00 00 00 00 02 08 05 00
T 68 02 FB DD 73 FA DD 74 F9 DD 75 F8 21 0E 00 39
R 00 00 00 00
T 76 02 EB 21 0A 00 39 01 04 00 ED B0
R 00 00 00 00
T 80 02
R 00 00 00 00
T 80 02 3E 01 DD BE EE 3E 00 DD 9E EF E2 8F 02 EE
R 00 00 00 00 00 0D 00 00
T 8E 02 80
R 00 00 00 00
T 8F 02
R 00 00 00 00
T 8F 02 F2 9A 02 DD 7E FF EE 80 DD 77 FF
R 00 00 00 00 00 03 00 00
T 9A 02
R 00 00 00 00
T 9A 02 11 06 03 E1 E5 29 29 19 5E 23 56 23 4E 23
R 00 00 00 00 00 03 00 00
T A8 02 46 C5 D5 DD 6E FE DD 66 FF E5 DD 6E FC DD
R 00 00 00 00
T B6 02 66 FD E5 CD 00 00 F1 F1 F1 F1 DD 72 FB DD
R 00 00 00 00 02 06 05 00
T C4 02 73 FA DD 74 F9 DD 75 F8 45 DD 4E F9 DD 5E
R 00 00 00 00
T D2 02 FA DD 56 FB C5 D5 21 00 00 E5 21 00 00 E5
R 00 00 00 00
T E0 02 DD 6E 06 DD 66 07 E5 DD 6E 04 DD 66 05 E5
R 00 00 00 00
T EE 02 CD 00 00 F1 F1 F1 F1 7D D1 C1 B7 28 04 7A
R 00 00 00 00 02 03 03 00
T FC 02 EE 80 57
R 00 00 00 00
T FF 02
R 00 00 00 00
T FF 02 68 61 DD F9 DD E1 C9
R 00 00 00 00
T 06 03
R 00 00 00 00
T 06 03 00 00 00 00 92 0A 06 3F DB 0F C9 3F 92 0A
R 00 00 00 00
T 14 03 86 3F
R 00 00 00 00

atan2f.rel/     1458795420  2001  2501  100664  3132      `
XL2
H 9 areas 8 global symbols
M atan2f
O -mz80
S _errno Ref0000
S ___fslt Ref0000
S .__.ABS. Def0000
S ___fsadd Ref0000
S _fabsf Ref0000
S _atanf Ref0000
S ___fsdiv Ref0000
A _CODE size 1D7 flags 0 addr 0
S _atan2f Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 F4 FF 39 F9 DD
R 00 00 00 00
T 0E 00 7E 07 CB BF DD B6 06 DD B6 05 DD B6 04 20
R 00 00 00 00
T 1C 00 1E DD 7E 0B CB BF DD B6 0A DD B6 09 DD B6
R 00 00 00 00
T 2A 00 08 20 0E 21 21 00 22 00 00 21 00 00 5D 54
R 00 00 00 00 02 09 00 00
T 38 00 C3 D2 01
R 00 00 00 00 00 03 00 00
T 3B 00
R 00 00 00 00
T 3B 00 DD 6E 0A DD 66 0B E5 DD 6E 08 DD 66 09 E5
R 00 00 00 00
T 49 00 CD 00 00 F1 F1 DD 72 FB DD 73 FA DD 74 F9
R 00 00 00 00 02 03 04 00
T 57 00 DD 75 F8 DD 6E 06 DD 66 07 E5 DD 6E 04 DD
R 00 00 00 00
T 65 00 66 05 E5 CD 00 00 F1 F1 DD 72 FF DD 73 FE
R 00 00 00 00 02 06 04 00
T 73 00 DD 74 FD DD 75 FC 21 00 00 E5 21 00 00 E5
R 00 00 00 00
T 81 00 DD 6E 06 DD 66 07 E5 DD 6E 04 DD 66 05 E5
R 00 00 00 00
T 8F 00 CD 00 00 F1 F1 F1 F1 4D C5 DD 6E FE DD 66
R 00 00 00 00 02 03 01 00
T 9D 00 FF E5 DD 6E FC DD 66 FD E5 DD 6E FA DD 66
R 00 00 00 00
T AB 00 FB E5 DD 6E F8 DD 66 F9 E5 CD 00 00 F1 F1
R 00 00 00 00 02 0C 01 00
T B9 00 F1 F1 7D C1 47 B7 C2 55 01 C5 DD 6E 0A DD
R 00 00 00 00 00 09 00 00
T C7 00 66 0B E5 DD 6E 08 DD 66 09 E5 DD 6E 06 DD
R 00 00 00 00
T D5 00 66 07 E5 DD 6E 04 DD 66 05 E5 CD 00 00 F1
R 00 00 00 00 02 0D 06 00
T E3 00 F1 F1 F1 D5 E5 CD 00 00 F1 F1 C1 DD 75 FC
R 00 00 00 00 02 08 05 00
T F1 00 DD 74 FD DD 73 FE DD 72 FF C5 21 00 00 E5
R 00 00 00 00
T FF 00 21 00 00 E5 DD 6E 0A DD 66 0B E5 DD 6E 08
R 00 00 00 00
T 0D 01 DD 66 09 E5 CD 00 00 F1 F1 F1 F1 7D C1 B7
R 00 00 00 00 02 07 01 00
T 1B 01 CA C6 01 79 B7 20 08 11 DB 0F 21 49 40 18
R 00 00 00 00 00 03 00 00
T 29 01 06
R 00 00 00 00
T 2A 01
R 00 00 00 00
T 2A 01 11 DB 0F 21 49 C0
R 00 00 00 00
T 30 01
R 00 00 00 00
T 30 01 E5 D5 DD 6E FE DD 66 FF E5 DD 6E FC DD 66
R 00 00 00 00
T 3E 01 FD E5 CD 00 00 F1 F1 F1 F1 DD 75 FC DD 74
R 00 00 00 00 02 05 03 00
T 4C 01 FD DD 73 FE DD 72 FF 18 71
R 00 00 00 00
T 55 01
R 00 00 00 00
T 55 01 C5 DD 6E 06 DD 66 07 E5 DD 6E 04 DD 66 05
R 00 00 00 00
T 63 01 E5 DD 6E 0A DD 66 0B E5 DD 6E 08 DD 66 09
R 00 00 00 00
T 71 01 E5 CD 00 00 F1 F1 F1 F1 D5 E5 CD 00 00 F1
R 00 00 00 00 02 04 06 00 02 0D 05 00
T 7F 01 F1 C1 7A EE 80 57 DD 75 F4 DD 74 F5 DD 73
R 00 00 00 00
T 8D 01 F6 DD 72 F7 79 B7 28 08 11 DB 0F 21 C9 BF
R 00 00 00 00
T 9B 01 18 06
R 00 00 00 00
T 9D 01
R 00 00 00 00
T 9D 01 11 DB 0F 21 C9 3F
R 00 00 00 00
T A3 01
R 00 00 00 00
T A3 01 E5 D5 DD 6E F6 DD 66 F7 E5 DD 6E F4 DD 66
R 00 00 00 00
T B1 01 F5 E5 CD 00 00 F1 F1 F1 F1 DD 75 FC DD 74
R 00 00 00 00 02 05 03 00
T BF 01 FD DD 73 FE DD 72 FF
R 00 00 00 00
T C6 01
R 00 00 00 00
T C6 01 DD 6E FC DD 66 FD DD 5E FE DD 56 FF
R 00 00 00 00
T D2 01
R 00 00 00 00
T D2 01 DD F9 DD E1 C9
R 00 00 00 00
sincoshf.rel/   1458795420  2001  2501  100664  4840      `
XL2
H 9 areas A global symbols
M sincoshf
O -mz80
S ___fssub Ref0000
S ___fsmul Ref0000
S _errno Ref0000
S ___fsgt Ref0000
S _expf Ref0000
S ___fslt Ref0000
S .__.ABS. Def0000
S ___fsadd Ref0000
S ___fsdiv Ref0000
A _CODE size 313 flags 0 addr 0
S _sincoshf Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 EE FF 39 F9 21
R 00 00 00 00
T 0E 00 09 00 39 EB 21 16 00 39 01 04 00 ED B0 21
R 00 00 00 00
T 1C 00 00 00 E5 21 00 00 E5 DD 6E 06 DD 66 07 E5
R 00 00 00 00
T 2A 00 DD 6E 04 DD 66 05 E5 CD 00 00 F1 F1 F1 F1
R 00 00 00 00 02 0A 05 00
T 38 00 7D B7 28 15 DD 7E 07 EE 80 57 DD 4E 04 DD
R 00 00 00 00
T 46 00 46 05 DD 5E 06 DD 36 EE 01 18 10
R 00 00 00 00
T 51 00
R 00 00 00 00
T 51 00 DD 4E F7 DD 46 F8 DD 5E F9 DD 56 FA DD 36
R 00 00 00 00
T 5F 00 EE 00
R 00 00 00 00
T 61 00
R 00 00 00 00
T 61 00 C5 D5 21 80 3F E5 21 00 00 E5 D5 C5 CD
R 00 00 00 00
T 6E 00 00 00 F1 F1 F1 F1 DD 75 FF D1 C1 DD 7E FF
R 00 00 00 00 02 02 03 00
T 7C 00 B7 20 07 DD CB 08 46 CA D1 01
R 00 00 00 00 00 0A 00 00
T 86 00
R 00 00 00 00
T 86 00 C5 D5 21 10 41 E5 21 00 00 E5 D5 C5 CD
R 00 00 00 00
T 93 00 00 00 F1 F1 F1 F1 DD 75 FF D1 C1 DD 7E FF
R 00 00 00 00 02 02 03 00
T A1 00 B7 CA 3A 01 21 31 3F E5 21 00 73 E5 D5 C5
R 00 00 00 00 00 04 00 00
T AF 00 CD 00 00 F1 F1 F1 F1 4D 44 C5 D5 21 33 42
R 00 00 00 00 02 03 00 00
T BD 00 E5 21 CF BD E5 D5 C5 CD 00 00 F1 F1 F1 F1
R 00 00 00 00 02 0A 03 00
T CB 00 7D D1 C1 B7 28 19 21 22 00 22 00 00 DD 36
R 00 00 00 00 02 0C 02 00
T D9 00 FB FF DD 36 FC FF DD 36 FD 7F DD 36 FE 7F
R 00 00 00 00
T E7 00 C3 BF 01
R 00 00 00 00 00 03 00 00
T EA 00
R 00 00 00 00
T EA 00 D5 C5 CD 00 00 F1 F1 4D 44 C5 D5 D5 C5 21
R 00 00 00 00 02 05 04 00
T F8 00 68 37 E5 21 97 08 E5 CD 00 00 F1 F1 F1 F1
R 00 00 00 00 02 0A 01 00
T 06 01 DD 72 F6 DD 73 F5 DD 74 F4 DD 75 F3 D1 C1
R 00 00 00 00
T 14 01 DD 6E F5 DD 66 F6 E5 DD 6E F3 DD 66 F4 E5
R 00 00 00 00
T 22 01 D5 C5 CD 00 00 F1 F1 F1 F1 DD 75 FB DD 74
R 00 00 00 00 02 05 07 00
T 30 01 FC DD 73 FD DD 72 FE C3 BF 01
R 00 00 00 00 00 0A 00 00
T 3A 01
R 00 00 00 00
T 3A 01 D5 C5 CD 00 00 F1 F1 4D 44 C5 D5 D5 C5 21
R 00 00 00 00 02 05 04 00
T 48 01 80 3F E5 21 00 00 E5 CD 00 00 F1 F1 F1 F1
R 00 00 00 00 02 0A 08 00
T 56 01 DD 72 F6 DD 73 F5 DD 74 F4 DD 75 F3 D1 C1
R 00 00 00 00
T 64 01 DD 7E F3 DD 77 EF DD 7E F4 DD 77 F0 DD 7E
R 00 00 00 00
T 72 01 F5 DD 77 F1 DD 7E F6 DD 77 F2 DD CB 08 46
R 00 00 00 00
T 80 01 20 08 DD 7E F2 EE 80 DD 77 F2
R 00 00 00 00
T 8A 01
R 00 00 00 00
T 8A 01 DD 6E F1 DD 66 F2 E5 DD 6E EF DD 66 F0 E5
R 00 00 00 00
T 98 01 D5 C5 CD 00 00 F1 F1 F1 F1 EB E5 D5 21
R 00 00 00 00 02 05 07 00
T A5 01 00 3F E5 21 00 00 E5 CD 00 00 F1 F1 F1 F1
R 00 00 00 00 02 0A 01 00
T B3 01 DD 75 FB DD 74 FC DD 73 FD DD 72 FE
R 00 00 00 00
T BF 01
R 00 00 00 00
T BF 01 DD CB EE 46 CA 02 03 DD 7E FE EE 80 DD 77
R 00 00 00 00 00 07 00 00
T CD 01 FE C3 02 03
R 00 00 00 00 00 04 00 00
T D1 01
R 00 00 00 00
T D1 01 21 80 39 E5 21 00 00 E5 D5 C5 CD 00 00 F1
R 00 00 00 00 02 0D 05 00
T DF 01 F1 F1 F1 7D B7 28 11 21 0D 00 39 EB 21
R 00 00 00 00
T EC 01 09 00 39 01 04 00 ED B0 C3 02 03
R 00 00 00 00 00 0B 00 00
T F7 01
R 00 00 00 00
T F7 01 DD 6E 06 DD 66 07 E5 DD 6E 04 DD 66 05 E5
R 00 00 00 00
T 05 02 DD 6E 06 DD 66 07 E5 DD 6E 04 DD 66 05 E5
R 00 00 00 00
T 13 02 CD 00 00 F1 F1 F1 F1 DD 75 F3 DD 74 F4 DD
R 00 00 00 00 02 03 01 00
T 21 02 73 F5 DD 72 F6 DD 6E F5 DD 66 F6 E5 DD 6E
R 00 00 00 00
T 2F 02 F3 DD 66 F4 E5 DD 6E 06 DD 66 07 E5 DD 6E
R 00 00 00 00
T 3D 02 04 DD 66 05 E5 CD 00 00 F1 F1 F1 F1 DD 72
R 00 00 00 00 02 08 01 00
T 4B 02 FA DD 73 F9 DD 74 F8 DD 75 F7 DD 6E F5 DD
R 00 00 00 00
T 59 02 66 F6 E5 DD 6E F3 DD 66 F4 E5 21 42 BE E5
R 00 00 00 00
T 67 02 21 EA E6 E5 CD 00 00 F1 F1 F1 F1 4D 44 21
R 00 00 00 00 02 07 01 00
T 75 02 E4 C0 E5 21 F0 69 E5 D5 C5 CD 00 00 F1 F1
R 00 00 00 00 02 0C 07 00
T 83 02 F1 F1 EB E5 D5 DD 6E F9 DD 66 FA E5 DD 6E
R 00 00 00 00
T 91 02 F7 DD 66 F8 E5 CD 00 00 F1 F1 F1 F1 DD 72
R 00 00 00 00 02 08 01 00
T 9F 02 FA DD 73 F9 DD 74 F8 DD 75 F7 21 2B C2 E5
R 00 00 00 00
T AD 02 21 93 4F E5 DD 6E F5 DD 66 F6 E5 DD 6E F3
R 00 00 00 00
T BB 02 DD 66 F4 E5 CD 00 00 F1 F1 F1 F1 EB E5 D5
R 00 00 00 00 02 07 07 00
T C9 02 DD 6E F9 DD 66 FA E5 DD 6E F7 DD 66 F8 E5
R 00 00 00 00
T D7 02 CD 00 00 F1 F1 F1 F1 EB E5 D5 DD 6E 06 DD
R 00 00 00 00 02 03 08 00
T E5 02 66 07 E5 DD 6E 04 DD 66 05 E5 CD 00 00 F1
R 00 00 00 00 02 0D 07 00
T F3 02 F1 F1 F1 DD 75 FB DD 74 FC DD 73 FD DD 72
R 00 00 00 00
T 01 03 FE
R 00 00 00 00
T 02 03
R 00 00 00 00
T 02 03 DD 6E FB DD 66 FC DD 5E FD DD 56 FE DD F9
R 00 00 00 00
T 10 03 DD E1 C9
R 00 00 00 00
sinhf.rel/      1458795420  2001  2501  100664  583       `
XL2
H 9 areas 3 global symbols
M sinhf
O -mz80
S .__.ABS. Def0000
S _sincoshf Ref0000
A _CODE size 1E flags 0 addr 0
S _sinhf Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 AF F5 33 FD 21 03 00 FD 39 FD 6E 02 FD 66
R 00 00 00 00
T 0E 00 03 E5 FD 6E 00 FD 66 01 E5 CD 00 00 F1 F1
R 00 00 00 00 02 0C 01 00
T 1C 00 33 C9
R 00 00 00 00

coshf.rel/      1458795420  2001  2501  100664  586       `
XL2
H 9 areas 3 global symbols
M coshf
O -mz80
S .__.ABS. Def0000
S _sincoshf Ref0000
A _CODE size 1F flags 0 addr 0
S _coshf Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 3E 01 F5 33 FD 21 03 00 FD 39 FD 6E 02 FD
R 00 00 00 00
T 0E 00 66 03 E5 FD 6E 00 FD 66 01 E5 CD 00 00 F1
R 00 00 00 00 02 0D 01 00
T 1C 00 F1 33 C9
R 00 00 00 00
tanhf.rel/      1458795421  2001  2501  100664  3512      `
XL2
H 9 areas A global symbols
M tanhf
O -mz80
S ___fssub Ref0000
S ___fsmul Ref0000
S ___fsgt Ref0000
S _expf Ref0000
S ___fslt Ref0000
S .__.ABS. Def0000
S ___fsadd Ref0000
S _fabsf Ref0000
S ___fsdiv Ref0000
A _CODE size 235 flags 0 addr 0
S _tanhf Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 F4 FF 39 F9 DD
R 00 00 00 00
T 0E 00 6E 06 DD 66 07 E5 DD 6E 04 DD 66 05 E5 CD
R 00 00 00 00
T 1C 00 00 00 F1 F1 4D 44 C5 D5 21 10 41 E5 21
R 00 00 00 00 02 02 07 00
T 29 00 B0 2C E5 D5 C5 CD 00 00 F1 F1 F1 F1 7D D1
R 00 00 00 00 02 08 02 00
T 37 00 C1 B7 28 09 01 00 00 11 80 3F C3 05 02
R 00 00 00 00 00 0D 00 00
T 44 00
R 00 00 00 00
T 44 00 C5 D5 21 0C 3F E5 21 54 9F E5 D5 C5 CD
R 00 00 00 00
T 51 00 00 00 F1 F1 F1 F1 7D D1 C1 B7 28 5A D5 C5
R 00 00 00 00 02 02 02 00
T 5F 00 D5 C5 CD 00 00 F1 F1 F1 F1 D5 E5 CD 00 00
R 00 00 00 00 02 05 06 00 02 0E 03 00
T 6D 00 F1 F1 4D 44 21 80 3F E5 21 00 00 E5 D5 C5
R 00 00 00 00
T 7B 00 CD 00 00 F1 F1 F1 F1 EB E5 D5 21 80 3F E5
R 00 00 00 00 02 03 06 00
T 89 00 21 00 00 E5 CD 00 00 F1 F1 F1 F1 EB E5 D5
R 00 00 00 00 02 07 08 00
T 97 00 21 00 3F E5 21 00 00 E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 00 00
T A5 00 F1 EB E5 D5 E5 D5 CD 00 00 F1 F1 F1 F1 4D
R 00 00 00 00 02 09 06 00
T B3 00 44 C3 05 02
R 00 00 00 00 00 04 00 00
T B7 00
R 00 00 00 00
T B7 00 C5 D5 21 80 39 E5 21 00 00 E5 D5 C5 CD
R 00 00 00 00
T C4 00 00 00 F1 F1 F1 F1 7D D1 C1 B7 C2 05 02 C5
R 00 00 00 00 02 02 04 00 00 0D 00 00
T D2 00 D5 D5 C5 D5 C5 CD 00 00 F1 F1 F1 F1 DD 72
R 00 00 00 00 02 08 01 00
T E0 00 F7 DD 73 F6 DD 74 F5 DD 75 F4 DD 6E F6 DD
R 00 00 00 00
T EE 00 66 F7 E5 DD 6E F4 DD 66 F5 E5 21 7B BB E5
R 00 00 00 00
T FC 00 21 B2 11 E5 CD 00 00 F1 F1 F1 F1 DD 72 FF
R 00 00 00 00 02 07 01 00
T 0A 01 DD 73 FE DD 74 FD DD 75 FC 21 52 BF E5 21
R 00 00 00 00
T 18 01 C6 E2 E5 DD 6E FE DD 66 FF E5 DD 6E FC DD
R 00 00 00 00
T 26 01 66 FD E5 CD 00 00 F1 F1 F1 F1 DD 72 FF DD
R 00 00 00 00 02 06 06 00
T 34 01 73 FE DD 74 FD DD 75 FC DD 6E F6 DD 66 F7
R 00 00 00 00
T 42 01 E5 DD 6E F4 DD 66 F5 E5 DD 6E FE DD 66 FF
R 00 00 00 00
T 50 01 E5 DD 6E FC DD 66 FD E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 01 00
T 5E 01 F1 DD 72 FF DD 73 FE DD 74 FD DD 75 FC 21
R 00 00 00 00
T 6C 01 1E 40 E5 21 1A 2A E5 DD 6E F6 DD 66 F7 E5
R 00 00 00 00
T 7A 01 DD 6E F4 DD 66 F5 E5 CD 00 00 F1 F1 F1 F1
R 00 00 00 00 02 0A 06 00
T 88 01 DD 72 FB DD 73 FA DD 74 F9 DD 75 F8 DD 6E
R 00 00 00 00
T 96 01 FA DD 66 FB E5 DD 6E F8 DD 66 F9 E5 DD 6E
R 00 00 00 00
T A4 01 FE DD 66 FF E5 DD 6E FC DD 66 FD E5 CD
R 00 00 00 00
T B1 01 00 00 F1 F1 F1 F1 DD 72 FB DD 73 FA DD 74
R 00 00 00 00 02 02 08 00
T BF 01 F9 DD 75 F8 D1 C1 C5 D5 DD 6E FA DD 66 FB
R 00 00 00 00
T CD 01 E5 DD 6E F8 DD 66 F9 E5 D5 C5 CD 00 00 F1
R 00 00 00 00 02 0D 01 00
T DB 01 F1 F1 F1 DD 72 FB DD 73 FA DD 74 F9 DD 75
R 00 00 00 00
T E9 01 F8 D1 C1 DD 6E FA DD 66 FB E5 DD 6E F8 DD
R 00 00 00 00
T F7 01 66 F9 E5 D5 C5 CD 00 00 F1 F1 F1 F1 4D 44
R 00 00 00 00 02 08 06 00
T 05 02
R 00 00 00 00
T 05 02 C5 D5 21 00 00 E5 21 00 00 E5 DD 6E 06 DD
R 00 00 00 00
T 13 02 66 07 E5 DD 6E 04 DD 66 05 E5 CD 00 00 F1
R 00 00 00 00 02 0D 04 00
T 21 02 F1 F1 F1 7D D1 C1 B7 28 04 7A EE 80 57
R 00 00 00 00
T 2E 02
R 00 00 00 00
T 2E 02 69 60 DD F9 DD E1 C9
R 00 00 00 00
floorf.rel/     1458795421  2001  2501  100664  1642      `
XL2
H 9 areas 5 global symbols
M floorf
O -mz80
S ___slong2fs Ref0000
S ___fs2slong Ref0000
S ___fsgt Ref0000
S .__.ABS. Def0000
A _CODE size D1 flags 0 addr 0
S _floorf Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 F7 FF 39 F9 DD
R 00 00 00 00
T 0E 00 6E 06 DD 66 07 E5 DD 6E 04 DD 66 05 E5 CD
R 00 00 00 00
T 1C 00 00 00 F1 F1 DD 75 F7 DD 74 F8 DD 73 F9 DD
R 00 00 00 00 02 02 01 00
T 2A 00 72 FA DD 6E F9 DD 66 FA E5 DD 6E F7 DD 66
R 00 00 00 00
T 38 00 F8 E5 CD 00 00 F1 F1 DD 72 FE DD 73 FD DD
R 00 00 00 00 02 05 00 00
T 46 00 74 FC DD 75 FB AF DD BE F7 DD 9E F8 3E 00
R 00 00 00 00
T 54 00 DD 9E F9 3E 00 DD 9E FA E2 61 00 EE 80
R 00 00 00 00 00 0B 00 00
T 61 00
R 00 00 00 00
T 61 00 FA C0 00 DD 6E 06 DD 66 07 E5 DD 6E 04 DD
R 00 00 00 00 00 03 00 00
T 6F 00 66 05 E5 DD 6E FD DD 66 FE E5 DD 6E FB DD
R 00 00 00 00
T 7D 00 66 FC E5 CD 00 00 F1 F1 F1 F1 DD 75 FF 7D
R 00 00 00 00 02 06 02 00
T 8B 00 B7 28 06 DD 36 FF FF 18 04
R 00 00 00 00
T 94 00
R 00 00 00 00
T 94 00 DD 36 FF 00
R 00 00 00 00
T 98 00
R 00 00 00 00
T 98 00 DD 6E FF DD 7E FF 17 9F 67 5F 57 DD 7E F7
R 00 00 00 00
T A6 00 85 6F DD 7E F8 8C 67 DD 7E F9 8B 5F DD 7E
R 00 00 00 00
T B4 00 FA 8A 57 D5 E5 CD 00 00 F1 F1 18 0C
R 00 00 00 00 02 08 00 00
T C0 00
R 00 00 00 00
T C0 00 DD 6E FB DD 66 FC DD 5E FD DD 56 FE
R 00 00 00 00
T CC 00
R 00 00 00 00
T CC 00 DD F9 DD E1 C9
R 00 00 00 00
ceilf.rel/      1458795421  2001  2501  100664  1512      `
XL2
H 9 areas 5 global symbols
M ceilf
O -mz80
S ___slong2fs Ref0000
S ___fs2slong Ref0000
S ___fslt Ref0000
S .__.ABS. Def0000
A _CODE size BD flags 0 addr 0
S _ceilf Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 F8 FF 39 F9 DD
R 00 00 00 00
T 0E 00 6E 06 DD 66 07 E5 DD 6E 04 DD 66 05 E5 CD
R 00 00 00 00
T 1C 00 00 00 F1 F1 DD 75 F8 DD 74 F9 DD 73 FA DD
R 00 00 00 00 02 02 01 00
T 2A 00 72 FB DD 6E FA DD 66 FB E5 DD 6E F8 DD 66
R 00 00 00 00
T 38 00 F9 E5 CD 00 00 F1 F1 DD 72 FF DD 73 FE DD
R 00 00 00 00 02 05 00 00
T 46 00 74 FD DD 75 FC DD CB FB 7E 28 0E DD 6E FC
R 00 00 00 00
T 54 00 DD 66 FD DD 5E FE DD 56 FF 18 59
R 00 00 00 00
T 5F 00
R 00 00 00 00
T 5F 00 DD 6E 06 DD 66 07 E5 DD 6E 04 DD 66 05 E5
R 00 00 00 00
T 6D 00 DD 6E FE DD 66 FF E5 DD 6E FC DD 66 FD E5
R 00 00 00 00
T 7B 00 CD 00 00 F1 F1 F1 F1 DD 75 FC 7D B7 28 06
R 00 00 00 00 02 03 02 00
T 89 00 DD 36 FC 01 18 04
R 00 00 00 00
T 8F 00
R 00 00 00 00
T 8F 00 DD 36 FC 00
R 00 00 00 00
T 93 00
R 00 00 00 00
T 93 00 DD 6E FC 26 00 7C 17 9F 5F 57 DD 7E F8 85
R 00 00 00 00
T A1 00 6F DD 7E F9 8C 67 DD 7E FA 8B 5F DD 7E FB
R 00 00 00 00
T AF 00 8A 57 D5 E5 CD 00 00 F1 F1
R 00 00 00 00 02 07 00 00
T B8 00
R 00 00 00 00
T B8 00 DD F9 DD E1 C9
R 00 00 00 00
modff.rel/      1458795421  2001  2501  100664  857       `
XL2
H 9 areas 5 global symbols
M modff
O -mz80
S ___fssub Ref0000
S ___slong2fs Ref0000
S ___fs2slong Ref0000
S .__.ABS. Def0000
A _CODE size 4D flags 0 addr 0
S _modff Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 DD 6E 08 DD 66 09
R 00 00 00 00
T 0E 00 E5 DD 6E 06 DD 66 07 E5 DD 6E 04 DD 66 05
R 00 00 00 00
T 1C 00 E5 CD 00 00 F1 F1 D5 E5 CD 00 00 F1 F1 4D
R 00 00 00 00 02 04 02 00 02 0B 01 00
T 2A 00 44 E1 71 23 70 23 73 23 72 D5 C5 DD 6E 06
R 00 00 00 00
T 38 00 DD 66 07 E5 DD 6E 04 DD 66 05 E5 CD 00 00
R 00 00 00 00 02 0E 00 00
T 46 00 F1 F1 F1 F1 DD E1 C9
R 00 00 00 00

errno.rel/      1458795421  2001  2501  100664  416       `
XL2
H 9 areas 2 global symbols
M errno
O -mz80
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 2 flags 0 addr 0
S _errno Def0000
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 01 00
T 00 00
R 00 00 01 00
_divslong.rel/  1458795421  2001  2501  100664  1444      `
XL2
H 9 areas 3 global symbols
M _divslong
O -mz80
S .__.ABS. Def0000
S __divulong Ref0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size B6 flags 0 addr 0
S __divslong Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 FA FF 39 F9 DD
R 00 00 04 00
T 0E 00 7E 07 07 E6 01 DD 77 FE B7 28 19 AF DD 96
R 00 00 04 00
T 1C 00 04 4F 3E 00 DD 9E 05 47 3E 00 DD 9E 06 5F
R 00 00 04 00
T 2A 00 3E 00 DD 9E 07 57 18 0C
R 00 00 04 00
T 32 00
R 00 00 04 00
T 32 00 DD 4E 04 DD 46 05 DD 5E 06 DD 56 07
R 00 00 04 00
T 3E 00
R 00 00 04 00
T 3E 00 DD 7E 0B 07 E6 01 DD 77 FF B7 28 21 AF DD
R 00 00 04 00
T 4C 00 96 08 DD 77 FA 3E 00 DD 9E 09 DD 77 FB 3E
R 00 00 04 00
T 5A 00 00 DD 9E 0A DD 77 FC 3E 00 DD 9E 0B DD 77
R 00 00 04 00
T 68 00 FD 18 18
R 00 00 04 00
T 6B 00
R 00 00 04 00
T 6B 00 DD 7E 08 DD 77 FA DD 7E 09 DD 77 FB DD 7E
R 00 00 04 00
T 79 00 0A DD 77 FC DD 7E 0B DD 77 FD
R 00 00 04 00
T 83 00
R 00 00 04 00
T 83 00 DD 6E FC DD 66 FD E5 DD 6E FA DD 66 FB E5
R 00 00 04 00
T 91 00 D5 C5 CD 00 00 F1 F1 F1 F1 DD 7E FE DD AE
R 00 00 04 00 02 05 01 00
T 9F 00 FF 28 0F AF 95 6F 3E 00 9C 67 3E 00 9B 5F
R 00 00 04 00
T AD 00 3E 00 9A 57
R 00 00 04 00
T B1 00
R 00 00 04 00
T B1 00 DD F9 DD E1 C9
R 00 00 04 00
_modslong.rel/  1458795421  2001  2501  100664  1368      `
XL2
H 9 areas 3 global symbols
M _modslong
O -mz80
S .__.ABS. Def0000
S __modulong Ref0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size A4 flags 0 addr 0
S __modslong Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 F5 F5 3B DD 7E 07
R 00 00 04 00
T 0E 00 07 E6 01 DD 77 FB B7 28 19 AF DD 96 04 6F
R 00 00 04 00
T 1C 00 3E 00 DD 9E 05 67 3E 00 DD 9E 06 5F 3E 00
R 00 00 04 00
T 2A 00 DD 9E 07 57 18 0C
R 00 00 04 00
T 30 00
R 00 00 04 00
T 30 00 DD 6E 04 DD 66 05 DD 5E 06 DD 56 07
R 00 00 04 00
T 3C 00
R 00 00 04 00
T 3C 00 DD 75 FC DD 74 FD DD 73 FE DD 72 FF DD CB
R 00 00 04 00
T 4A 00 0B 7E 28 19 AF DD 96 08 4F 3E 00 DD 9E 09
R 00 00 04 00
T 58 00 47 3E 00 DD 9E 0A 6F 3E 00 DD 9E 0B 67 18
R 00 00 04 00
T 66 00 0C
R 00 00 04 00
T 67 00
R 00 00 04 00
T 67 00 DD 4E 08 DD 46 09 DD 6E 0A DD 66 0B
R 00 00 04 00
T 73 00
R 00 00 04 00
T 73 00 E5 C5 DD 6E FE DD 66 FF E5 DD 6E FC DD 66
R 00 00 04 00
T 81 00 FD E5 CD 00 00 F1 F1 F1 F1 DD 7E FB B7 28
R 00 00 04 00 02 05 01 00
T 8F 00 0F AF 95 6F 3E 00 9C 67 3E 00 9B 5F 3E 00
R 00 00 04 00
T 9D 00 9A 57
R 00 00 04 00
T 9F 00
R 00 00 04 00
T 9F 00 DD F9 DD E1 C9
R 00 00 04 00
_modulong.rel/  1458795421  2001  2501  100664  1432      `
XL2
H 9 areas 2 global symbols
M _modulong
O -mz80
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size BD flags 0 addr 0
S __modulong Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 11 00 00
R 00 00 04 00
T 0B 00
R 00 00 04 00
T 0B 00 DD 7E 0B CB 07 E6 01 20 44 F5 F1 DD CB 08
R 00 00 04 00
T 19 00 26 DD CB 09 16 DD CB 0A 16 DD CB 0B 16 DD
R 00 00 04 00
T 27 00 7E 04 DD 96 08 DD 7E 05 DD 9E 09 DD 7E 06
R 00 00 04 00
T 35 00 DD 9E 0A DD 7E 07 DD 9E 0B 30 14 F5 F1 DD
R 00 00 04 00
T 43 00 CB 0B 3E DD CB 0A 1E DD CB 09 1E DD CB 08
R 00 00 04 00
T 51 00 1E 18 04
R 00 00 04 00
T 54 00
R 00 00 04 00
T 54 00 1C 53 18 B3
R 00 00 04 00
T 58 00
R 00 00 04 00
T 58 00
R 00 00 04 00
T 58 00 DD 7E 04 DD 96 08 DD 7E 05 DD 9E 09 DD 7E
R 00 00 04 00
T 66 00 06 DD 9E 0A DD 7E 07 DD 9E 0B 38 24 DD 7E
R 00 00 04 00
T 74 00 04 DD 96 08 DD 77 04 DD 7E 05 DD 9E 09 DD
R 00 00 04 00
T 82 00 77 05 DD 7E 06 DD 9E 0A DD 77 06 DD 7E 07
R 00 00 04 00
T 90 00 DD 9E 0B DD 77 07
R 00 00 04 00
T 96 00
R 00 00 04 00
T 96 00 F5 F1 DD CB 0B 3E DD CB 0A 1E DD CB 09 1E
R 00 00 04 00
T A4 00 DD CB 08 1E 62 15 7C B7 20 AA DD 6E 04 DD
R 00 00 04 00
T B2 00 66 05 DD 5E 06 DD 56 07 DD E1 C9
R 00 00 04 00
_divulong.rel/  1458795421  2001  2501  100664  1073      `
XL2
H 9 areas 2 global symbols
M _divulong
O -mz80
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 80 flags 0 addr 0
S __divulong Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 3B 01 00 00 11
R 00 00 04 00
T 0D 00 00 00 DD 36 FF 20
R 00 00 04 00
T 13 00
R 00 00 04 00
T 13 00 DD 7E 07 CB 07 E6 01 67 F5 F1 DD CB 04 26
R 00 00 04 00
T 21 00 DD CB 05 16 DD CB 06 16 DD CB 07 16 CB 20
R 00 00 04 00
T 2F 00 CB 11 CB 13 CB 12 CB 44 28 02 CB C0
R 00 00 04 00
T 3B 00
R 00 00 04 00
T 3B 00 78 DD 96 08 79 DD 9E 09 7B DD 9E 0A 7A DD
R 00 00 04 00
T 49 00 9E 0B 38 18 78 DD 96 08 47 79 DD 9E 09 4F
R 00 00 04 00
T 57 00 7B DD 9E 0A 5F 7A DD 9E 0B 57 DD CB 04 C6
R 00 00 04 00
T 65 00
R 00 00 04 00
T 65 00 DD 7E FF C6 FF DD 77 FF B7 20 A3 DD 6E 04
R 00 00 04 00
T 73 00 DD 66 05 DD 5E 06 DD 56 07 33 DD E1 C9
R 00 00 04 00

_mullong.rel/   1458795422  2001  2501  100664  2489      `
XL2
H 9 areas 3 global symbols
M _mullong
O -mz80
S __mulint Ref0000
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 184 flags 0 addr 0
S __mullong Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 FA FF 39 F9 21
R 00 00 04 00
T 0E 00 0A 00 39 4D 44 23 23 E3 69 60 23 23 5E 23
R 00 00 04 00
T 1C 00 56 21 0E 00 39 DD 75 FE DD 74 FF DD 6E FE
R 00 00 04 00
T 2A 00 DD 66 FF 7E 23 66 6F C5 E5 D5 CD 00 00 F1
R 00 00 04 00 02 0D 00 00
T 38 00 F1 55 5C C1 E1 E5 72 23 73 69 60 23 23 E3
R 00 00 04 00
T 46 00 69 60 23 23 7E DD 77 FC 23 7E DD 77 FD DD
R 00 00 04 00
T 54 00 6E FE DD 66 FF 23 23 5E 23 56 69 60 7E 23
R 00 00 04 00
T 62 00 66 6F C5 E5 D5 CD 00 00 F1 F1 C1 DD 7E FC
R 00 00 04 00 02 08 00 00
T 70 00 85 57 DD 7E FD 8C 5F E1 E5 72 23 73 69 60
R 00 00 04 00
T 7E 00 23 23 DD 75 FC DD 74 FD 69 60 23 23 5E 23
R 00 00 04 00
T 8C 00 56 69 60 23 7E DD 77 FA DD 6E FE DD 66 FF
R 00 00 04 00
T 9A 00 23 66 D5 C5 DD 5E FA 2E 00 55 06 08
R 00 00 04 00
T A6 00
R 00 00 04 00
T A6 00 29 30 01 19
R 00 00 04 00
T AA 00
R 00 00 04 00
T AA 00 10 FA C1 D1 19 EB DD 6E FC DD 66 FD 73 23
R 00 00 04 00
T B8 00 72 DD 6E FE DD 66 FF 5E 69 60 23 66 C5 2E
R 00 00 04 00
T C6 00 00 55 06 08
R 00 00 04 00
T CA 00
R 00 00 04 00
T CA 00 29 30 01 19
R 00 00 04 00
T CE 00
R 00 00 04 00
T CE 00 10 FA C1 EB DD 6E FE DD 66 FF 23 E5 FD E1
R 00 00 04 00
T DC 00 69 60 7E DD 77 FC DD 6E FE DD 66 FF 23 7E
R 00 00 04 00
T EA 00 D5 C5 5F DD 66 FC 2E 00 55 06 08
R 00 00 04 00
T F5 00
R 00 00 04 00
T F5 00 29 30 01 19
R 00 00 04 00
T F9 00
R 00 00 04 00
T F9 00 10 FA C1 D1 FD 75 00 FD 74 01 DD 6E FE DD
R 00 00 04 00
T 07 01 66 FF 23 23 23 DD 75 FC DD 74 FD DD 6E FE
R 00 00 04 00
T 15 01 DD 66 FF 23 E5 FD E1 DD 6E FE DD 66 FF 23
R 00 00 04 00
T 23 01 7E 23 66 6F 19 FD 75 00 FD 74 01 BF ED 52
R 00 00 04 00
T 31 01 3E 00 17 DD 6E FC DD 66 FD 77 59 50 0A 4F
R 00 00 04 00
T 3F 01 DD 6E FE DD 66 FF 66 D5 59 2E 00 55 06 08
R 00 00 04 00
T 4D 01
R 00 00 04 00
T 4D 01 29 30 01 19
R 00 00 04 00
T 51 01
R 00 00 04 00
T 51 01 10 FA D1 4D 44 79 12 13 78 12 DD 6E FE DD
R 00 00 04 00
T 5F 01 66 FF 36 00 DD 7E 04 DD 86 08 6F DD 7E 05
R 00 00 04 00
T 6D 01 DD 8E 09 67 DD 7E 06 DD 8E 0A 5F DD 7E 07
R 00 00 04 00
T 7B 01 DD 8E 0B 57 DD F9 DD E1 C9
R 00 00 04 00

/40             1458795423  2001  2501  100664  2953      `
XL2
H 9 areas 2 global symbols
M _mullonglong
O -mz80
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 1D5 flags 0 addr 0
S __mullonglong Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 ED FF 39 F9 AF
R 00 00 04 00
T 0E 00 DD 77 EE DD 77 EF DD 77 F0 DD 77 F1 DD 77
R 00 00 04 00
T 1C 00 F2 DD 77 F3 DD 77 F4 DD 77 F5 0E 00
R 00 00 04 00
T 28 00
R 00 00 04 00
T 28 00 59 16 00 6B 62 29 29 29 F5 DD 7E 06 DD 77
R 00 00 04 00
T 36 00 F8 DD 7E 07 DD 77 F9 DD 7E 08 DD 77 FA DD
R 00 00 04 00
T 44 00 7E 09 DD 77 FB DD 7E 0A DD 77 FC DD 7E 0B
R 00 00 04 00
T 52 00 DD 77 FD DD 7E 0C DD 77 FE DD 7E 0D DD 77
R 00 00 04 00
T 60 00 FF F1 2C 18 20
R 00 00 04 00
T 65 00
R 00 00 04 00
T 65 00 DD CB FF 2E DD CB FE 1E DD CB FD 1E DD CB
R 00 00 04 00
T 73 00 FC 1E DD CB FB 1E DD CB FA 1E DD CB F9 1E
R 00 00 04 00
T 81 00 DD CB F8 1E
R 00 00 04 00
T 85 00
R 00 00 04 00
T 85 00 2D 20 DD DD 46 F8 DD 36 ED 00
R 00 00 04 00
T 8F 00
R 00 00 04 00
T 8F 00 DD 6E ED 26 00 7D 83 DD 77 F6 7C 8A DD 77
R 00 00 04 00
T 9D 00 F7 DD 7E F6 D6 08 DD 7E F7 17 3F 1F DE 80
R 00 00 04 00
T AB 00 D2 B9 01 29 29 29 F5 DD 7E 0E DD 77 F8 DD
R 00 00 04 00 00 03 04 00
T B9 00 7E 0F DD 77 F9 DD 7E 10 DD 77 FA DD 7E 11
R 00 00 04 00
T C7 00 DD 77 FB DD 7E 12 DD 77 FC DD 7E 13 DD 77
R 00 00 04 00
T D5 00 FD DD 7E 14 DD 77 FE DD 7E 15 DD 77 FF F1
R 00 00 04 00
T E3 00 2C 18 20
R 00 00 04 00
T E6 00
R 00 00 04 00
T E6 00 DD CB FF 2E DD CB FE 1E DD CB FD 1E DD CB
R 00 00 04 00
T F4 00 FC 1E DD CB FB 1E DD CB FA 1E DD CB F9 1E
R 00 00 04 00
T 02 01 DD CB F8 1E
R 00 00 04 00
T 06 01
R 00 00 04 00
T 06 01 2D 20 DD DD 66 F8 D5 C5 58 2E 00 55 06 08
R 00 00 04 00
T 14 01
R 00 00 04 00
T 14 01 29 30 01 19
R 00 00 04 00
T 18 01
R 00 00 04 00
T 18 01 10 FA C1 D1 DD 75 F8 DD 74 F9 DD 36 FA 00
R 00 00 04 00
T 26 01 DD 36 FB 00 DD 36 FC 00 DD 36 FD 00 DD 36
R 00 00 04 00
T 34 01 FE 00 DD 36 FF 00 DD 6E F6 DD 66 F7 29 29
R 00 00 04 00
T 42 01 29 F5 F1 2C 18 20
R 00 00 04 00
T 48 01
R 00 00 04 00
T 48 01 DD CB F8 26 DD CB F9 16 DD CB FA 16 DD CB
R 00 00 04 00
T 56 01 FB 16 DD CB FC 16 DD CB FD 16 DD CB FE 16
R 00 00 04 00
T 64 01 DD CB FF 16
R 00 00 04 00
T 68 01
R 00 00 04 00
T 68 01 2D 20 DD DD 7E EE DD 86 F8 DD 77 EE DD 7E
R 00 00 04 00
T 76 01 EF DD 8E F9 DD 77 EF DD 7E F0 DD 8E FA DD
R 00 00 04 00
T 84 01 77 F0 DD 7E F1 DD 8E FB DD 77 F1 DD 7E F2
R 00 00 04 00
T 92 01 DD 8E FC DD 77 F2 DD 7E F3 DD 8E FD DD 77
R 00 00 04 00
T A0 01 F3 DD 7E F4 DD 8E FE DD 77 F4 DD 7E F5 DD
R 00 00 04 00
T AE 01 8E FF DD 77 F5 DD 34 ED C3 8F 00
R 00 00 04 00 00 0B 04 00
T B9 01
R 00 00 04 00
T B9 01 0C 79 D6 08 DA 28 00 21 17 00 39 5E 23 56
R 00 00 04 00 00 07 04 00
T C7 01 21 01 00 39 01 08 00 ED B0 DD F9 DD E1 C9
R 00 00 04 00

/58             1458795423  2001  2501  100664  2266      `
XL2
H 9 areas 3 global symbols
M _divslonglong
O -mz80
S __divulonglong Ref0000
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 173 flags 0 addr 0
S __divslonglong Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 E8 FF 39 F9 DD
R 00 00 04 00
T 0E 00 7E 0D 07 E6 01 57 DD 7E 15 07 E6 01 5F CB
R 00 00 04 00
T 1C 00 42 28 3F AF DD 96 06 DD 77 06 3E 00 DD 9E
R 00 00 04 00
T 2A 00 07 DD 77 07 3E 00 DD 9E 08 DD 77 08 3E 00
R 00 00 04 00
T 38 00 DD 9E 09 DD 77 09 3E 00 DD 9E 0A DD 77 0A
R 00 00 04 00
T 46 00 3E 00 DD 9E 0B DD 77 0B 3E 00 DD 9E 0C DD
R 00 00 04 00
T 54 00 77 0C 3E 00 DD 9E 0D DD 77 0D
R 00 00 04 00
T 5E 00
R 00 00 04 00
T 5E 00 CB 43 28 3F AF DD 96 0E DD 77 0E 3E 00 DD
R 00 00 04 00
T 6C 00 9E 0F DD 77 0F 3E 00 DD 9E 10 DD 77 10 3E
R 00 00 04 00
T 7A 00 00 DD 9E 11 DD 77 11 3E 00 DD 9E 12 DD 77
R 00 00 04 00
T 88 00 12 3E 00 DD 9E 13 DD 77 13 3E 00 DD 9E 14
R 00 00 04 00
T 96 00 DD 77 14 3E 00 DD 9E 15 DD 77 15
R 00 00 04 00
T A1 00
R 00 00 04 00
T A1 00 D5 21 12 00 39 EB 21 20 00 39 01 08 00 ED
R 00 00 04 00
T AF 00 B0 D1 D5 21 0A 00 39 EB 21 28 00 39 01
R 00 00 04 00
T BC 00 08 00 ED B0 DD 66 F7 DD 6E F6 E5 DD 66 F5
R 00 00 04 00
T CA 00 DD 6E F4 E5 DD 66 F3 DD 6E F2 E5 DD 66 F1
R 00 00 04 00
T D8 00 DD 6E F0 E5 DD 66 FF DD 6E FE E5 DD 66 FD
R 00 00 04 00
T E6 00 DD 6E FC E5 DD 66 FB DD 6E FA E5 DD 66 F9
R 00 00 04 00
T F4 00 DD 6E F8 E5 21 12 00 39 E5 CD 00 00 FD 21
R 00 00 04 00 02 0C 00 00
T 02 01 12 00 FD 39 FD F9 D1 7A AB CB 47 28 41 AF
R 00 00 04 00
T 10 01 DD 96 E8 DD 77 F0 3E 00 DD 9E E9 DD 77 F1
R 00 00 04 00
T 1E 01 3E 00 DD 9E EA DD 77 F2 3E 00 DD 9E EB DD
R 00 00 04 00
T 2C 01 77 F3 3E 00 DD 9E EC DD 77 F4 3E 00 DD 9E
R 00 00 04 00
T 3A 01 ED DD 77 F5 3E 00 DD 9E EE DD 77 F6 3E 00
R 00 00 04 00
T 48 01 DD 9E EF DD 77 F7 18 0E
R 00 00 04 00
T 50 01
R 00 00 04 00
T 50 01 21 08 00 39 EB 21 00 00 39 01 08 00 ED B0
R 00 00 04 00
T 5E 01
R 00 00 04 00
T 5E 01 21 1C 00 39 5E 23 56 21 08 00 39 01 08 00
R 00 00 04 00
T 6C 01 ED B0 DD F9 DD E1 C9
R 00 00 04 00
/77             1458795423  2001  2501  100664  1789      `
XL2
H 9 areas 2 global symbols
M _divulonglong
O -mz80
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 117 flags 0 addr 0
S __divulonglong Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 F8 FF 39 F9 AF
R 00 00 04 00
T 0E 00 DD 77 F8 DD 77 F9 DD 77 FA DD 77 FB DD 77
R 00 00 04 00
T 1C 00 FC DD 77 FD DD 77 FE DD 77 FF 16 40
R 00 00 04 00
T 28 00
R 00 00 04 00
T 28 00 DD 7E 0D CB 07 E6 01 67 F5 F1 DD CB 06 26
R 00 00 04 00
T 36 00 DD CB 07 16 DD CB 08 16 DD CB 09 16 DD CB
R 00 00 04 00
T 44 00 0A 16 DD CB 0B 16 DD CB 0C 16 DD CB 0D 16
R 00 00 04 00
T 52 00 F5 F1 DD CB F8 26 DD CB F9 16 DD CB FA 16
R 00 00 04 00
T 60 00 DD CB FB 16 DD CB FC 16 DD CB FD 16 DD CB
R 00 00 04 00
T 6E 00 FE 16 DD CB FF 16 CB 44 28 04 DD CB F8 C6
R 00 00 04 00
T 7C 00
R 00 00 04 00
T 7C 00 DD 7E F8 DD 96 0E DD 7E F9 DD 9E 0F DD 7E
R 00 00 04 00
T 8A 00 FA DD 9E 10 DD 7E FB DD 9E 11 DD 7E FC DD
R 00 00 04 00
T 98 00 9E 12 DD 7E FD DD 9E 13 DD 7E FE DD 9E 14
R 00 00 04 00
T A6 00 DD 7E FF DD 9E 15 38 4C DD 7E F8 DD 96 0E
R 00 00 04 00
T B4 00 DD 77 F8 DD 7E F9 DD 9E 0F DD 77 F9 DD 7E
R 00 00 04 00
T C2 00 FA DD 9E 10 DD 77 FA DD 7E FB DD 9E 11 DD
R 00 00 04 00
T D0 00 77 FB DD 7E FC DD 9E 12 DD 77 FC DD 7E FD
R 00 00 04 00
T DE 00 DD 9E 13 DD 77 FD DD 7E FE DD 9E 14 DD 77
R 00 00 04 00
T EC 00 FE DD 7E FF DD 9E 15 DD 77 FF DD CB 06 C6
R 00 00 04 00
T FA 00
R 00 00 04 00
T FA 00 7A C6 FF 57 B7 C2 28 00 21 0C 00 39 5E 23
R 00 00 04 00 00 08 04 00
T 08 01 56 21 0E 00 39 01 08 00 ED B0 DD F9 DD E1
R 00 00 04 00
T 16 01 C9
R 00 00 04 00

/96             1458795423  2001  2501  100664  2266      `
XL2
H 9 areas 3 global symbols
M _modslonglong
O -mz80
S __modulonglong Ref0000
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 173 flags 0 addr 0
S __modslonglong Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 E8 FF 39 F9 DD
R 00 00 04 00
T 0E 00 7E 0D 07 E6 01 57 DD 7E 15 07 E6 01 5F CB
R 00 00 04 00
T 1C 00 42 28 3F AF DD 96 06 DD 77 06 3E 00 DD 9E
R 00 00 04 00
T 2A 00 07 DD 77 07 3E 00 DD 9E 08 DD 77 08 3E 00
R 00 00 04 00
T 38 00 DD 9E 09 DD 77 09 3E 00 DD 9E 0A DD 77 0A
R 00 00 04 00
T 46 00 3E 00 DD 9E 0B DD 77 0B 3E 00 DD 9E 0C DD
R 00 00 04 00
T 54 00 77 0C 3E 00 DD 9E 0D DD 77 0D
R 00 00 04 00
T 5E 00
R 00 00 04 00
T 5E 00 CB 43 28 3F AF DD 96 0E DD 77 0E 3E 00 DD
R 00 00 04 00
T 6C 00 9E 0F DD 77 0F 3E 00 DD 9E 10 DD 77 10 3E
R 00 00 04 00
T 7A 00 00 DD 9E 11 DD 77 11 3E 00 DD 9E 12 DD 77
R 00 00 04 00
T 88 00 12 3E 00 DD 9E 13 DD 77 13 3E 00 DD 9E 14
R 00 00 04 00
T 96 00 DD 77 14 3E 00 DD 9E 15 DD 77 15
R 00 00 04 00
T A1 00
R 00 00 04 00
T A1 00 D5 21 12 00 39 EB 21 20 00 39 01 08 00 ED
R 00 00 04 00
T AF 00 B0 D1 D5 21 0A 00 39 EB 21 28 00 39 01
R 00 00 04 00
T BC 00 08 00 ED B0 DD 66 F7 DD 6E F6 E5 DD 66 F5
R 00 00 04 00
T CA 00 DD 6E F4 E5 DD 66 F3 DD 6E F2 E5 DD 66 F1
R 00 00 04 00
T D8 00 DD 6E F0 E5 DD 66 FF DD 6E FE E5 DD 66 FD
R 00 00 04 00
T E6 00 DD 6E FC E5 DD 66 FB DD 6E FA E5 DD 66 F9
R 00 00 04 00
T F4 00 DD 6E F8 E5 21 12 00 39 E5 CD 00 00 FD 21
R 00 00 04 00 02 0C 00 00
T 02 01 12 00 FD 39 FD F9 D1 7A AB CB 47 28 41 AF
R 00 00 04 00
T 10 01 DD 96 E8 DD 77 F0 3E 00 DD 9E E9 DD 77 F1
R 00 00 04 00
T 1E 01 3E 00 DD 9E EA DD 77 F2 3E 00 DD 9E EB DD
R 00 00 04 00
T 2C 01 77 F3 3E 00 DD 9E EC DD 77 F4 3E 00 DD 9E
R 00 00 04 00
T 3A 01 ED DD 77 F5 3E 00 DD 9E EE DD 77 F6 3E 00
R 00 00 04 00
T 48 01 DD 9E EF DD 77 F7 18 0E
R 00 00 04 00
T 50 01
R 00 00 04 00
T 50 01 21 08 00 39 EB 21 00 00 39 01 08 00 ED B0
R 00 00 04 00
T 5E 01
R 00 00 04 00
T 5E 01 21 1C 00 39 5E 23 56 21 08 00 39 01 08 00
R 00 00 04 00
T 6C 01 ED B0 DD F9 DD E1 C9
R 00 00 04 00
/115            1458795423  2001  2501  100664  2114      `
XL2
H 9 areas 2 global symbols
M _modulonglong
O -mz80
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 148 flags 0 addr 0
S __modulonglong Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 DD E5 DD 21 00 00 DD 39 11 00 00
R 00 00 04 00
T 0B 00
R 00 00 04 00
T 0B 00 DD 7E 15 CB 07 E6 01 C2 92 00 F5 F1 DD CB
R 00 00 04 00 00 0A 04 00
T 19 00 0E 26 DD CB 0F 16 DD CB 10 16 DD CB 11 16
R 00 00 04 00
T 27 00 DD CB 12 16 DD CB 13 16 DD CB 14 16 DD CB
R 00 00 04 00
T 35 00 15 16 DD 7E 06 DD 96 0E DD 7E 07 DD 9E 0F
R 00 00 04 00
T 43 00 DD 7E 08 DD 9E 10 DD 7E 09 DD 9E 11 DD 7E
R 00 00 04 00
T 51 00 0A DD 9E 12 DD 7E 0B DD 9E 13 DD 7E 0C DD
R 00 00 04 00
T 5F 00 9E 14 DD 7E 0D DD 9E 15 30 24 F5 F1 DD CB
R 00 00 04 00
T 6D 00 15 3E DD CB 14 1E DD CB 13 1E DD CB 12 1E
R 00 00 04 00
T 7B 00 DD CB 11 1E DD CB 10 1E DD CB 0F 1E DD CB
R 00 00 04 00
T 89 00 0E 1E 18 05
R 00 00 04 00
T 8D 00
R 00 00 04 00
T 8D 00 1C 53 C3 0B 00
R 00 00 04 00 00 05 04 00
T 92 00
R 00 00 04 00
T 92 00
R 00 00 04 00
T 92 00 DD 7E 06 DD 96 0E DD 7E 07 DD 9E 0F DD 7E
R 00 00 04 00
T A0 00 08 DD 9E 10 DD 7E 09 DD 9E 11 DD 7E 0A DD
R 00 00 04 00
T AE 00 9E 12 DD 7E 0B DD 9E 13 DD 7E 0C DD 9E 14
R 00 00 04 00
T BC 00 DD 7E 0D DD 9E 15 38 48 DD 7E 06 DD 96 0E
R 00 00 04 00
T CA 00 DD 77 06 DD 7E 07 DD 9E 0F DD 77 07 DD 7E
R 00 00 04 00
T D8 00 08 DD 9E 10 DD 77 08 DD 7E 09 DD 9E 11 DD
R 00 00 04 00
T E6 00 77 09 DD 7E 0A DD 9E 12 DD 77 0A DD 7E 0B
R 00 00 04 00
T F4 00 DD 9E 13 DD 77 0B DD 7E 0C DD 9E 14 DD 77
R 00 00 04 00
T 02 01 0C DD 7E 0D DD 9E 15 DD 77 0D
R 00 00 04 00
T 0C 01
R 00 00 04 00
T 0C 01 F5 F1 DD CB 15 3E DD CB 14 1E DD CB 13 1E
R 00 00 04 00
T 1A 01 DD CB 12 1E DD CB 11 1E DD CB 10 1E DD CB
R 00 00 04 00
T 28 01 0F 1E DD CB 0E 1E 62 15 7C B7 C2 92 00 21
R 00 00 04 00 00 0D 04 00
T 36 01 04 00 39 5E 23 56 21 06 00 39 01 08 00 ED
R 00 00 04 00
T 44 01 B0 DD E1 C9
R 00 00 04 00
isalnum.rel/    1458795423  2001  2501  100664  772       `
XL2
H 9 areas 3 global symbols
M isalnum
O -mz80
S _isalpha Ref0000
S .__.ABS. Def0000
A _CODE size 30 flags 0 addr 0
S _isalnum Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 3B 21 03 00 39 4E 23 46 C5 CD 00 00 F1 7C
R 00 00 00 00 02 0C 00 00
T 0E 00 B5 20 17 FD 21 03 00 FD 39 FD 6E 00 7D D6
R 00 00 00 00
T 1C 00 30 38 05 3E 39 95 30 04
R 00 00 00 00
T 24 00
R 00 00 00 00
T 24 00 3E 00 18 02
R 00 00 00 00
T 28 00
R 00 00 00 00
T 28 00 3E 01
R 00 00 00 00
T 2A 00
R 00 00 00 00
T 2A 00 6F 17 9F 67 33 C9
R 00 00 00 00
isalpha.rel/    1458795423  2001  2501  100664  745       `
XL2
H 9 areas 2 global symbols
M isalpha
O -mz80
S .__.ABS. Def0000
A _CODE size 2A flags 0 addr 0
S _isalpha Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 3B FD 21 03 00 FD 39 FD 6E 00 7D D6 41 38
R 00 00 00 00
T 0E 00 05 3E 5A 95 30 0E
R 00 00 00 00
T 14 00
R 00 00 00 00
T 14 00 7D D6 61 38 05 3E 7A 95 30 04
R 00 00 00 00
T 1E 00
R 00 00 00 00
T 1E 00 3E 00 18 02
R 00 00 00 00
T 22 00
R 00 00 00 00
T 22 00 3E 01
R 00 00 00 00
T 24 00
R 00 00 00 00
T 24 00 6F 17 9F 67 33 C9
R 00 00 00 00

isblank.rel/    1458795423  2001  2501  100664  603       `
XL2
H 9 areas 2 global symbols
M isblank
O -mz80
S .__.ABS. Def0000
A _CODE size 18 flags 0 addr 0
S _isblank Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 21 02 00 39 7E FE 20 28 08 D6 09 28 04 3E
R 00 00 00 00
T 0E 00 00 18 02
R 00 00 00 00
T 11 00
R 00 00 00 00
T 11 00 3E 01
R 00 00 00 00
T 13 00
R 00 00 00 00
T 13 00 6F 17 9F 67 C9
R 00 00 00 00

iscntrl.rel/    1458795423  2001  2501  100664  732       `
XL2
H 9 areas 2 global symbols
M iscntrl
O -mz80
S .__.ABS. Def0000
A _CODE size 2D flags 0 addr 0
S _iscntrl Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 FD 21 02 00 FD 39 FD 7E 00 D6 20 FD 7E 01
R 00 00 00 00
T 0E 00 17 3F 1F DE 80 38 11 FD 7E 00 D6 7F 20 06
R 00 00 00 00
T 1C 00 FD 7E 01 B7 28 04
R 00 00 00 00
T 22 00
R 00 00 00 00
T 22 00 3E 00 18 02
R 00 00 00 00
T 26 00
R 00 00 00 00
T 26 00 3E 01
R 00 00 00 00
T 28 00
R 00 00 00 00
T 28 00 6F 17 9F 67 C9
R 00 00 00 00
isdigit.rel/    1458795423  2001  2501  100664  671       `
XL2
H 9 areas 2 global symbols
M isdigit
O -mz80
S .__.ABS. Def0000
A _CODE size 20 flags 0 addr 0
S _isdigit Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 3B FD 21 03 00 FD 39 FD 66 00 7C D6 30 38
R 00 00 00 00
T 0E 00 05 3E 39 94 30 04
R 00 00 00 00
T 14 00
R 00 00 00 00
T 14 00 3E 00 18 02
R 00 00 00 00
T 18 00
R 00 00 00 00
T 18 00 3E 01
R 00 00 00 00
T 1A 00
R 00 00 00 00
T 1A 00 6F 17 9F 67 33 C9
R 00 00 00 00

isgraph.rel/    1458795423  2001  2501  100664  916       `
XL2
H 9 areas 2 global symbols
M isgraph
O -mz80
S .__.ABS. Def0000
A _CODE size 3D flags 0 addr 0
S _isgraph Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 3B 3E 20 FD 21 03 00 FD 39 FD BE 00 3E 00
R 00 00 00 00
T 0E 00 FD 9E 01 E2 16 00 EE 80
R 00 00 00 00 00 06 00 00
T 16 00
R 00 00 00 00
T 16 00 F2 31 00 3E 7E FD 21 03 00 FD 39 FD BE 00
R 00 00 00 00 00 03 00 00
T 24 00 3E 00 FD 9E 01 E2 2E 00 EE 80
R 00 00 00 00 00 08 00 00
T 2E 00
R 00 00 00 00
T 2E 00 F2 35 00
R 00 00 00 00 00 03 00 00
T 31 00
R 00 00 00 00
T 31 00 3E 00 18 02
R 00 00 00 00
T 35 00
R 00 00 00 00
T 35 00 3E 01
R 00 00 00 00
T 37 00
R 00 00 00 00
T 37 00 6F 17 9F 67 33 C9
R 00 00 00 00
islower.rel/    1458795423  2001  2501  100664  671       `
XL2
H 9 areas 2 global symbols
M islower
O -mz80
S .__.ABS. Def0000
A _CODE size 20 flags 0 addr 0
S _islower Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 3B FD 21 03 00 FD 39 FD 66 00 7C D6 61 38
R 00 00 00 00
T 0E 00 05 3E 7A 94 30 04
R 00 00 00 00
T 14 00
R 00 00 00 00
T 14 00 3E 00 18 02
R 00 00 00 00
T 18 00
R 00 00 00 00
T 18 00 3E 01
R 00 00 00 00
T 1A 00
R 00 00 00 00
T 1A 00 6F 17 9F 67 33 C9
R 00 00 00 00

isprint.rel/    1458795423  2001  2501  100664  821       `
XL2
H 9 areas 2 global symbols
M isprint
O -mz80
S .__.ABS. Def0000
A _CODE size 34 flags 0 addr 0
S _isprint Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 3B FD 21 03 00 FD 39 FD 7E 00 D6 20 FD 7E
R 00 00 00 00
T 0E 00 01 17 3F 1F DE 80 38 12 3E 7E FD BE 00 3E
R 00 00 00 00
T 1C 00 00 FD 9E 01 E2 25 00 EE 80
R 00 00 00 00 00 07 00 00
T 25 00
R 00 00 00 00
T 25 00 F2 2C 00
R 00 00 00 00 00 03 00 00
T 28 00
R 00 00 00 00
T 28 00 3E 00 18 02
R 00 00 00 00
T 2C 00
R 00 00 00 00
T 2C 00 3E 01
R 00 00 00 00
T 2E 00
R 00 00 00 00
T 2E 00 6F 17 9F 67 33 C9
R 00 00 00 00

ispunct.rel/    1458795423  2001  2501  100664  840       `
XL2
H 9 areas 5 global symbols
M ispunct
O -mz80
S _isspace Ref0000
S _isalnum Ref0000
S .__.ABS. Def0000
S _isprint Ref0000
A _CODE size 32 flags 0 addr 0
S _ispunct Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 C1 E1 E5 C5 E5 CD 00 00 F1 7C B5 28 1A C1
R 00 00 00 00 02 08 03 00
T 0E 00 E1 E5 C5 E5 CD 00 00 F1 7C B5 20 0D C1 E1
R 00 00 00 00 02 07 00 00
T 1C 00 E5 C5 E5 CD 00 00 F1 7C B5 28 04
R 00 00 00 00 02 06 01 00
T 27 00
R 00 00 00 00
T 27 00 3E 00 18 02
R 00 00 00 00
T 2B 00
R 00 00 00 00
T 2B 00 3E 01
R 00 00 00 00
T 2D 00
R 00 00 00 00
T 2D 00 6F 17 9F 67 C9
R 00 00 00 00
isspace.rel/    1458795423  2001  2501  100664  1092      `
XL2
H 9 areas 2 global symbols
M isspace
O -mz80
S .__.ABS. Def0000
A _CODE size 63 flags 0 addr 0
S _isspace Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 DD 7E 04 D6 20 20
R 00 00 00 00
T 0E 00 06 DD 7E 05 B7 28 45
R 00 00 00 00
T 15 00
R 00 00 00 00
T 15 00 DD 7E 04 D6 0C 20 06 DD 7E 05 B7 28 38
R 00 00 00 00
T 22 00
R 00 00 00 00
T 22 00 DD 7E 04 D6 0A 20 06 DD 7E 05 B7 28 2B
R 00 00 00 00
T 2F 00
R 00 00 00 00
T 2F 00 DD 7E 04 D6 0D 20 06 DD 7E 05 B7 28 1E
R 00 00 00 00
T 3C 00
R 00 00 00 00
T 3C 00 DD 7E 04 D6 09 20 06 DD 7E 05 B7 28 11
R 00 00 00 00
T 49 00
R 00 00 00 00
T 49 00 DD 7E 04 D6 0B 20 06 DD 7E 05 B7 28 04
R 00 00 00 00
T 56 00
R 00 00 00 00
T 56 00 3E 00 18 02
R 00 00 00 00
T 5A 00
R 00 00 00 00
T 5A 00 3E 01
R 00 00 00 00
T 5C 00
R 00 00 00 00
T 5C 00 6F 17 9F 67 DD E1 C9
R 00 00 00 00
isupper.rel/    1458795423  2001  2501  100664  671       `
XL2
H 9 areas 2 global symbols
M isupper
O -mz80
S .__.ABS. Def0000
A _CODE size 20 flags 0 addr 0
S _isupper Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 3B FD 21 03 00 FD 39 FD 66 00 7C D6 41 38
R 00 00 00 00
T 0E 00 05 3E 5A 94 30 04
R 00 00 00 00
T 14 00
R 00 00 00 00
T 14 00 3E 00 18 02
R 00 00 00 00
T 18 00
R 00 00 00 00
T 18 00 3E 01
R 00 00 00 00
T 1A 00
R 00 00 00 00
T 1A 00 6F 17 9F 67 33 C9
R 00 00 00 00

isxdigit.rel/   1458795423  2001  2501  100664  1345      `
XL2
H 9 areas 2 global symbols
M isxdigit
O -mz80
S .__.ABS. Def0000
A _CODE size 7A flags 0 addr 0
S _isxdigit Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 3B DD 7E 04 D6 30
R 00 00 00 00
T 0E 00 DD 7E 05 17 3F 1F DE 80 38 12 3E 39 DD BE
R 00 00 00 00
T 1C 00 04 3E 00 DD 9E 05 E2 27 00 EE 80
R 00 00 00 00 00 09 00 00
T 27 00
R 00 00 00 00
T 27 00 F2 70 00
R 00 00 00 00 00 03 00 00
T 2A 00
R 00 00 00 00
T 2A 00 DD 7E 04 D6 61 DD 7E 05 17 3F 1F DE 80 38
R 00 00 00 00
T 38 00 12 3E 66 DD BE 04 3E 00 DD 9E 05 E2 48 00
R 00 00 00 00 00 0E 00 00
T 46 00 EE 80
R 00 00 00 00
T 48 00
R 00 00 00 00
T 48 00 F2 70 00
R 00 00 00 00 00 03 00 00
T 4B 00
R 00 00 00 00
T 4B 00 DD 7E 04 D6 41 DD 7E 05 17 3F 1F DE 80 38
R 00 00 00 00
T 59 00 12 3E 46 DD BE 04 3E 00 DD 9E 05 E2 69 00
R 00 00 00 00 00 0E 00 00
T 67 00 EE 80
R 00 00 00 00
T 69 00
R 00 00 00 00
T 69 00 F2 70 00
R 00 00 00 00 00 03 00 00
T 6C 00
R 00 00 00 00
T 6C 00 3E 00 18 02
R 00 00 00 00
T 70 00
R 00 00 00 00
T 70 00 3E 01
R 00 00 00 00
T 72 00
R 00 00 00 00
T 72 00 6F 17 9F 67 33 DD E1 C9
R 00 00 00 00

tolower.rel/    1458795423  2001  2501  100664  565       `
XL2
H 9 areas 2 global symbols
M tolower
O -mz80
S .__.ABS. Def0000
A _CODE size 1A flags 0 addr 0
S _tolower Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 3B 21 03 00 39 7E 23 66 6F 55 7A D6 41 38
R 00 00 00 00
T 0E 00 09 3E 5A 92 38 04 01 20 00 09
R 00 00 00 00
T 18 00
R 00 00 00 00
T 18 00 33 C9
R 00 00 00 00

toupper.rel/    1458795423  2001  2501  100664  565       `
XL2
H 9 areas 2 global symbols
M toupper
O -mz80
S .__.ABS. Def0000
A _CODE size 1A flags 0 addr 0
S _toupper Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 3B 21 03 00 39 7E 23 66 6F 55 7A D6 61 38
R 00 00 00 00
T 0E 00 09 3E 7A 92 38 04 01 E0 FF 09
R 00 00 00 00
T 18 00
R 00 00 00 00
T 18 00 33 C9
R 00 00 00 00

atoi.rel/       1458795424  2001  2501  100664  1539      `
XL2
H 9 areas 2 global symbols
M atoi
O -mz80
S .__.ABS. Def0000
A _CODE size A2 flags 0 addr 0
S _atoi Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 F5 F5 DD 36 FD 00
R 00 00 00 00
T 0E 00 DD 36 FE 00 DD 5E 04 DD 56 05
R 00 00 00 00
T 18 00
R 00 00 00 00
T 18 00 1A 67 6F 17 9F 47 7D FE 20 28 04 D6 09 20
R 00 00 00 00
T 26 00 03
R 00 00 00 00
T 27 00
R 00 00 00 00
T 27 00 13 18 EE
R 00 00 00 00
T 2A 00
R 00 00 00 00
T 2A 00 DD 73 04 DD 72 05 7C D6 2D 20 04 3E 01 18
R 00 00 00 00
T 38 00 01
R 00 00 00 00
T 39 00
R 00 00 00 00
T 39 00 AF
R 00 00 00 00
T 3A 00
R 00 00 00 00
T 3A 00 DD 77 FC CB 47 20 05 7C D6 2B 20 07
R 00 00 00 00
T 46 00
R 00 00 00 00
T 46 00 13 DD 73 04 DD 72 05
R 00 00 00 00
T 4D 00
R 00 00 00 00
T 4D 00 DD 4E 04 DD 46 05
R 00 00 00 00
T 53 00
R 00 00 00 00
T 53 00 0A 5F 17 9F 57 6B 7D D6 30 38 25 3E 39 95
R 00 00 00 00
T 61 00 38 20 D5 DD 5E FD DD 56 FE 6B 62 29 29 19
R 00 00 00 00
T 6F 00 29 D1 03 7B C6 D0 5F 7A CE FF 57 19 DD 75
R 00 00 00 00
T 7D 00 FD DD 74 FE 18 D0
R 00 00 00 00
T 83 00
R 00 00 00 00
T 83 00 DD CB FC 46 28 0D AF DD 96 FD 6F 3E 00 DD
R 00 00 00 00
T 91 00 9E FE 47 18 06
R 00 00 00 00
T 96 00
R 00 00 00 00
T 96 00 DD 6E FD DD 46 FE
R 00 00 00 00
T 9C 00
R 00 00 00 00
T 9C 00 60 DD F9 DD E1 C9
R 00 00 00 00

atol.rel/       1458795424  2001  2501  100664  1958      `
XL2
H 9 areas 3 global symbols
M atol
O -mz80
S .__.ABS. Def0000
S __mullong Ref0000
A _CODE size F7 flags 0 addr 0
S _atol Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 F6 FF 39 F9 AF
R 00 00 00 00
T 0E 00 DD 77 F7 DD 77 F8 DD 77 F9 DD 77 FA DD 5E
R 00 00 00 00
T 1C 00 04 DD 56 05
R 00 00 00 00
T 20 00
R 00 00 00 00
T 20 00 1A 6F 67 17 9F 47 7C FE 20 28 04 D6 09 20
R 00 00 00 00
T 2E 00 03
R 00 00 00 00
T 2F 00
R 00 00 00 00
T 2F 00 13 18 EE
R 00 00 00 00
T 32 00
R 00 00 00 00
T 32 00 DD 73 04 DD 72 05 7D D6 2D 20 04 3E 01 18
R 00 00 00 00
T 40 00 01
R 00 00 00 00
T 41 00
R 00 00 00 00
T 41 00 AF
R 00 00 00 00
T 42 00
R 00 00 00 00
T 42 00 DD 77 F6 CB 47 20 05 7D D6 2B 20 07
R 00 00 00 00
T 4E 00
R 00 00 00 00
T 4E 00 13 DD 73 04 DD 72 05
R 00 00 00 00
T 55 00
R 00 00 00 00
T 55 00 DD 4E 04 DD 46 05
R 00 00 00 00
T 5B 00
R 00 00 00 00
T 5B 00 0A 5F 17 9F 57 6B 7D D6 30 38 61 3E 39 95
R 00 00 00 00
T 69 00 38 5C C5 D5 DD 6E F9 DD 66 FA E5 DD 6E F7
R 00 00 00 00
T 77 00 DD 66 F8 E5 21 00 00 E5 21 0A 00 E5 CD
R 00 00 00 00
T 84 00 00 00 F1 F1 F1 F1 DD 72 FE DD 73 FD DD 74
R 00 00 00 00 02 02 01 00
T 92 00 FC DD 75 FB D1 C1 03 7B C6 D0 6F 7A CE FF
R 00 00 00 00
T A0 00 67 17 9F 5F 57 DD 7E FB 85 6F DD 7E FC 8C
R 00 00 00 00
T AE 00 67 DD 7E FD 8B 5F DD 7E FE 8A 57 DD 75 F7
R 00 00 00 00
T BC 00 DD 74 F8 DD 73 F9 DD 72 FA 18 94
R 00 00 00 00
T C7 00
R 00 00 00 00
T C7 00 DD CB F6 46 28 19 AF DD 96 F7 6F 3E 00 DD
R 00 00 00 00
T D5 00 9E F8 67 3E 00 DD 9E F9 5F 3E 00 DD 9E FA
R 00 00 00 00
T E3 00 57 18 0C
R 00 00 00 00
T E6 00
R 00 00 00 00
T E6 00 DD 6E F7 DD 66 F8 DD 5E F9 DD 56 FA
R 00 00 00 00
T F2 00
R 00 00 00 00
T F2 00 DD F9 DD E1 C9
R 00 00 00 00
atoll.rel/      1458795424  2001  2501  100664  355       `
XL2
H 9 areas 1 global symbols
M atoll
O -mz80
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0

abs.rel/        1458795406  2001  2501  100664  175       `
XL2
H 1 areas 2 global symbols
S .__.ABS. Def0000
A _CODE size C flags 0 addr 0
S _abs Def0000
T 00 00
R 00 00 00 00
T 00 00 E1 D1 D5 E5 AF 6F 67 ED 52 F0 EB C9
R 00 00 00 00

labs.rel/       1458795424  2001  2501  100664  690       `
XL2
H 9 areas 2 global symbols
M labs
O -mz80
S .__.ABS. Def0000
A _CODE size 37 flags 0 addr 0
S _labs Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 FD 21 02 00 FD 39 FD CB 03 7E 28 18 AF FD
R 00 00 00 00
T 0E 00 96 00 6F 3E 00 FD 9E 01 67 3E 00 FD 9E 02
R 00 00 00 00
T 1C 00 5F 3E 00 FD 9E 03 57 C9
R 00 00 00 00
T 24 00
R 00 00 00 00
T 24 00 FD 21 02 00 FD 39 FD 6E 00 FD 66 01 FD 5E
R 00 00 00 00
T 32 00 02 FD 56 03 C9
R 00 00 00 00
rand.rel/       1458795424  2001  2501  100664  1273      `
XL2
H 9 areas 4 global symbols
M rand
O -mz80
S .__.ABS. Def0000
S __mullong Ref0000
A _CODE size 77 flags 0 addr 0
S _rand Def0000
S _srand Def005C
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 4 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 4 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 02 00
T 00 00
R 00 00 02 00
T 00 00
R 00 00 00 00
T 00 00 2A 02 00 E5 2A 00 00 E5 21 C6 41 E5 21
R 00 00 00 00 00 03 02 00 00 07 02 00
T 0D 00 6D 4E E5 CD 00 00 F1 F1 F1 F1 4D 44 79 21
R 00 00 00 00 02 06 01 00
T 1B 00 00 00 C6 39 77 78 CE 30 23 77 7B CE 00 23
R 00 00 00 00 00 02 02 00
T 29 00 77 7A CE 00 23 77 F5 FD 21 00 00 FD 6E 00
R 00 00 00 00 00 0B 02 00
T 37 00 FD 21 00 00 FD 66 01 FD 21 00 00 FD 5E 02
R 00 00 00 00 00 04 02 00 00 0B 02 00
T 45 00 FD 21 00 00 FD 56 03 F1 06 10
R 00 00 00 00 00 04 02 00
T 4F 00
R 00 00 00 00
T 4F 00 CB 3A CB 1B CB 1C CB 1D 10 F6 CB BC C9
R 00 00 00 00
T 5C 00
R 00 00 00 00
T 5C 00 21 02 00 39 7E 32 00 00 21 03 00 39 7E 32
R 00 00 00 00 00 08 02 00
T 6A 00 01 00 21 02 00 36 00 21 03 00 36 00 C9
R 00 00 00 00 00 02 02 00 00 05 02 00 00 0A 02 00
T 00 00
R 00 00 07 00
T 00 00 01 00 00 00
R 00 00 07 00

_strcat.rel/    1458795424  2001  2501  100664  703       `
XL2
H 9 areas 2 global symbols
M _strcat
O -mz80
S .__.ABS. Def0000
A _CODE size 2B flags 0 addr 0
S _strcat Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 DD 4E 04 DD 46 05
R 00 00 00 00
T 0E 00
R 00 00 00 00
T 0E 00 0A B7 28 03 03 18 F9
R 00 00 00 00
T 15 00
R 00 00 00 00
T 15 00 DD 5E 06 DD 56 07
R 00 00 00 00
T 1B 00
R 00 00 00 00
T 1B 00 1A 13 02 03 B7 20 F9 DD 6E 04 DD 66 05 DD
R 00 00 00 00
T 29 00 E1 C9
R 00 00 00 00

_strchr.rel/    1458795424  2001  2501  100664  944       `
XL2
H 9 areas 2 global symbols
M _strchr
O -mz80
S .__.ABS. Def0000
A _CODE size 48 flags 0 addr 0
S _strchr Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 3B DD 4E 04 DD 46
R 00 00 00 00
T 0E 00 05
R 00 00 00 00
T 0F 00
R 00 00 00 00
T 0F 00 0A DD 77 FF 57 DD 7E FF 17 9F 5F DD 7E 06
R 00 00 00 00
T 1D 00 92 20 0A DD 7E 07 93 20 04 3E 01 18 01
R 00 00 00 00
T 2A 00
R 00 00 00 00
T 2A 00 AF
R 00 00 00 00
T 2B 00
R 00 00 00 00
T 2B 00 57 DD 7E FF B7 28 07 7A B7 20 03 03 18 D6
R 00 00 00 00
T 39 00
R 00 00 00 00
T 39 00 7A B7 28 04 69 60 18 03
R 00 00 00 00
T 41 00
R 00 00 00 00
T 41 00 21 00 00
R 00 00 00 00
T 44 00
R 00 00 00 00
T 44 00 33 DD E1 C9
R 00 00 00 00
_strcmp.rel/    1458795424  2001  2501  100664  772       `
XL2
H 9 areas 2 global symbols
M _strcmp
O -mz80
S .__.ABS. Def0000
A _CODE size 42 flags 0 addr 0
S _strcmp Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 3B DD 4E 04 DD 46
R 00 00 00 00
T 0E 00 05 DD 5E 06 DD 56 07 D5 FD E1
R 00 00 00 00
T 18 00
R 00 00 00 00
T 18 00 0A 5F 17 9F 57 FD 7E 00 DD 77 FF 6F DD 7E
R 00 00 00 00
T 26 00 FF 17 9F 67 7B 95 6F 7A 9C 67 B5 20 0B DD
R 00 00 00 00
T 34 00 7E FF B7 28 05 03 FD 23 18 DA
R 00 00 00 00
T 3E 00
R 00 00 00 00
T 3E 00 33 DD E1 C9
R 00 00 00 00
_strcspn.rel/   1458795424  2001  2501  100664  807       `
XL2
H 9 areas 2 global symbols
M _strcspn
O -mz80
S .__.ABS. Def0000
A _CODE size 37 flags 0 addr 0
S _strcspn Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 11 00 00 DD 4E 04
R 00 00 00 00
T 0E 00 DD 46 05
R 00 00 00 00
T 11 00
R 00 00 00 00
T 11 00 0A 67 B7 28 1D 17 9F D5 54 DD 6E 06 DD 66
R 00 00 00 00
T 1F 00 07
R 00 00 00 00
T 20 00
R 00 00 00 00
T 20 00 7E BA 28 06 B7 23 20 F8 6F 67
R 00 00 00 00
T 2A 00
R 00 00 00 00
T 2A 00 D1 7C B5 20 04 13 03 18 DE
R 00 00 00 00
T 33 00
R 00 00 00 00
T 33 00 EB DD E1 C9
R 00 00 00 00

_strncat.rel/   1458795425  2001  2501  100664  1262      `
XL2
H 9 areas 2 global symbols
M _strncat
O -mz80
S .__.ABS. Def0000
A _CODE size 94 flags 0 addr 0
S _strncat Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 F5 F5 3B DD 4E 04
R 00 00 00 00
T 0E 00 DD 46 05 69 60
R 00 00 00 00
T 13 00
R 00 00 00 00
T 13 00 7E 23 B7 20 FB 7D C6 FF DD 77 04 7C CE FF
R 00 00 00 00
T 21 00 DD 77 05 DD 5E 06 DD 56 07 DD 7E 04 DD 77
R 00 00 00 00
T 2F 00 FB DD 7E 05 DD 77 FC DD 7E 08 DD 77 FE DD
R 00 00 00 00
T 3D 00 7E 09 DD 77 FF
R 00 00 00 00
T 42 00
R 00 00 00 00
T 42 00 DD 6E FE DD 66 FF DD 7E FE C6 FF DD 77 FE
R 00 00 00 00
T 50 00 DD 7E FF CE FF DD 77 FF 7C B5 28 29 1A DD
R 00 00 00 00
T 5E 00 77 FD 13 E1 E5 DD 7E FD 77 DD 34 FB 20 03
R 00 00 00 00
T 6C 00 DD 34 FC
R 00 00 00 00
T 6F 00
R 00 00 00 00
T 6F 00 DD 7E FB DD 77 04 DD 7E FC DD 77 05 DD 7E
R 00 00 00 00
T 7D 00 FD B7 20 C1 69 60 18 0A
R 00 00 00 00
T 85 00
R 00 00 00 00
T 85 00 DD 6E 04 DD 66 05 36 00 69 60
R 00 00 00 00
T 8F 00
R 00 00 00 00
T 8F 00 DD F9 DD E1 C9
R 00 00 00 00
_strncmp.rel/   1458795425  2001  2501  100664  1182      `
XL2
H 9 areas 2 global symbols
M _strncmp
O -mz80
S .__.ABS. Def0000
A _CODE size 88 flags 0 addr 0
S _strncmp Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 FA FF 39 F9 DD
R 00 00 00 00
T 0E 00 7E 09 DD B6 08 20 05 21 00 00 18 69
R 00 00 00 00
T 1A 00
R 00 00 00 00
T 1A 00 DD 7E 04 DD 77 FC DD 7E 05 DD 77 FD DD 7E
R 00 00 00 00
T 28 00 06 DD 77 FA DD 7E 07 DD 77 FB DD 7E 08 DD
R 00 00 00 00
T 36 00 77 FE DD 7E 09 DD 77 FF
R 00 00 00 00
T 3E 00
R 00 00 00 00
T 3E 00 DD 6E FE DD 66 FF 2B DD 75 FE DD 74 FF DD
R 00 00 00 00
T 4C 00 6E FC DD 66 FD 5E E1 E5 4E DD 7E FF DD B6
R 00 00 00 00
T 5A 00 FE 28 1A 7B B7 28 16 7B 91 20 12 DD 34 FC
R 00 00 00 00
T 68 00 20 03 DD 34 FD
R 00 00 00 00
T 6D 00
R 00 00 00 00
T 6D 00 DD 34 FA 20 CC DD 34 FB 18 C7
R 00 00 00 00
T 77 00
R 00 00 00 00
T 77 00 7B 6F 17 9F 67 79 17 9F 47 BF ED 42
R 00 00 00 00
T 83 00
R 00 00 00 00
T 83 00 DD F9 DD E1 C9
R 00 00 00 00
strxfrm.rel/    1458795425  2001  2501  100664  686       `
XL2
H 9 areas 4 global symbols
M strxfrm
O -mz80
S .__.ABS. Def0000
S _strncpy Ref0000
S _strlen Ref0000
A _CODE size 2E flags 0 addr 0
S _strxfrm Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 21 06 00 39 4E 23 46 C5 21 06 00 39 4E 23
R 00 00 00 00
T 0E 00 46 C5 21 06 00 39 4E 23 46 C5 CD 00 00 21
R 00 00 00 00 02 0D 01 00
T 1C 00 06 00 39 F9 21 04 00 39 4E 23 46 C5 CD
R 00 00 00 00
T 29 00 00 00 F1 23 C9
R 00 00 00 00 02 02 02 00
_strncpy.rel/   1458795425  2001  2501  100664  870       `
XL2
H 9 areas 2 global symbols
M _strncpy
O -mz80
S .__.ABS. Def0000
A _CODE size 4C flags 0 addr 0
S _strncpy Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 F5 DD 7E 04 DD 77
R 00 00 00 00
T 0E 00 FE DD 7E 05 DD 77 FF DD 5E 08 DD 56 09 DD
R 00 00 00 00
T 1C 00 4E 06 DD 46 07 C5 FD E1 C1 C5
R 00 00 00 00
T 26 00
R 00 00 00 00
T 26 00 7A B3 28 0F FD 66 00 7C B7 28 08 1B 7C FD
R 00 00 00 00
T 34 00 23 02 03 18 ED
R 00 00 00 00
T 39 00
R 00 00 00 00
T 39 00
R 00 00 00 00
T 39 00 63 6A 1B 7D B4 28 05 AF 02 03 18 F4
R 00 00 00 00
T 45 00
R 00 00 00 00
T 45 00 E1 E5 DD F9 DD E1 C9
R 00 00 00 00
_strpbrk.rel/   1458795425  2001  2501  100664  961       `
XL2
H 9 areas 2 global symbols
M _strpbrk
O -mz80
S .__.ABS. Def0000
A _CODE size 4D flags 0 addr 0
S _strpbrk Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 F5 21 00 00 E3 DD
R 00 00 00 00
T 0E 00 6E 06 DD 66 07
R 00 00 00 00
T 13 00
R 00 00 00 00
T 13 00 7E 4F B7 28 2E 17 9F DD 5E 04 DD 56 05
R 00 00 00 00
T 20 00
R 00 00 00 00
T 20 00 1A B9 28 06 B7 13 20 F8 5F 57
R 00 00 00 00
T 2A 00
R 00 00 00 00
T 2A 00 7A B3 28 15 DD 7E FF DD B6 FE 28 0A 7B DD
R 00 00 00 00
T 38 00 96 FE 7A DD 9E FF 30 03
R 00 00 00 00
T 40 00
R 00 00 00 00
T 40 00 33 33 D5
R 00 00 00 00
T 43 00
R 00 00 00 00
T 43 00 23 18 CD
R 00 00 00 00
T 46 00
R 00 00 00 00
T 46 00 E1 E5 DD F9 DD E1 C9
R 00 00 00 00

_strrchr.rel/   1458795425  2001  2501  100664  1070      `
XL2
H 9 areas 2 global symbols
M _strrchr
O -mz80
S .__.ABS. Def0000
A _CODE size 54 flags 0 addr 0
S _strrchr Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 F5 DD 7E 04 DD 77
R 00 00 00 00
T 0E 00 FE DD 7E 05 DD 77 FF C1 C5
R 00 00 00 00
T 17 00
R 00 00 00 00
T 17 00 0A 03 B7 20 FB
R 00 00 00 00
T 1C 00
R 00 00 00 00
T 1C 00 0B 0A 57 17 9F 5F DD 7E 06 92 20 0A DD 7E
R 00 00 00 00
T 2A 00 07 93 20 04 3E 01 18 01
R 00 00 00 00
T 32 00
R 00 00 00 00
T 32 00 AF
R 00 00 00 00
T 33 00
R 00 00 00 00
T 33 00 57 DD 7E FE 91 20 06 DD 7E FF 90 28 04
R 00 00 00 00
T 40 00
R 00 00 00 00
T 40 00 7A B7 28 D8
R 00 00 00 00
T 44 00
R 00 00 00 00
T 44 00 7A B7 28 04 69 60 18 03
R 00 00 00 00
T 4C 00
R 00 00 00 00
T 4C 00 21 00 00
R 00 00 00 00
T 4F 00
R 00 00 00 00
T 4F 00 DD F9 DD E1 C9
R 00 00 00 00
_strspn.rel/    1458795425  2001  2501  100664  805       `
XL2
H 9 areas 2 global symbols
M _strspn
O -mz80
S .__.ABS. Def0000
A _CODE size 37 flags 0 addr 0
S _strspn Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 11 00 00 DD 4E 04
R 00 00 00 00
T 0E 00 DD 46 05
R 00 00 00 00
T 11 00
R 00 00 00 00
T 11 00 0A 67 B7 28 1D 17 9F D5 54 DD 6E 06 DD 66
R 00 00 00 00
T 1F 00 07
R 00 00 00 00
T 20 00
R 00 00 00 00
T 20 00 7E BA 28 06 B7 23 20 F8 6F 67
R 00 00 00 00
T 2A 00
R 00 00 00 00
T 2A 00 D1 7C B5 28 04 13 03 18 DE
R 00 00 00 00
T 33 00
R 00 00 00 00
T 33 00 EB DD E1 C9
R 00 00 00 00

_strstr.rel/    1458795425  2001  2501  100664  1562      `
XL2
H 9 areas 2 global symbols
M _strstr
O -mz80
S .__.ABS. Def0000
A _CODE size B2 flags 0 addr 0
S _strstr Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 F6 FF 39 F9 DD
R 00 00 00 00
T 0E 00 4E 04 DD 46 05 DD 5E 06 DD 56 07 1A B7 20
R 00 00 00 00
T 1C 00 05 69 60 C3 AD 00
R 00 00 00 00 00 06 00 00
T 22 00
R 00 00 00 00
T 22 00 33 33 C5
R 00 00 00 00
T 25 00
R 00 00 00 00
T 25 00 E1 E5 7E B7 CA AA 00 DD 73 FE DD 72 FF DD
R 00 00 00 00 00 07 00 00
T 33 00 7E F6 DD 77 FC DD 7E F7 DD 77 FD
R 00 00 00 00
T 3E 00
R 00 00 00 00
T 3E 00 DD 6E FC DD 66 FD 7E DD 77 FB DD 6E FE DD
R 00 00 00 00
T 4C 00 66 FF 7E DD 77 FA DD 7E FB B7 28 3B DD 7E
R 00 00 00 00
T 5A 00 FA B7 28 35 DD 7E FB DD 77 F8 DD 7E FB 17
R 00 00 00 00
T 68 00 9F DD 77 F9 DD 66 FA DD 7E FA 17 9F 6F DD
R 00 00 00 00
T 76 00 7E F8 94 67 DD 7E F9 9D B4 20 12 DD 34 FC
R 00 00 00 00
T 84 00 20 03 DD 34 FD
R 00 00 00 00
T 89 00
R 00 00 00 00
T 89 00 DD 34 FE 20 B0 DD 34 FF 18 AB
R 00 00 00 00
T 93 00
R 00 00 00 00
T 93 00 DD 7E FA B7 20 04 69 60 18 10
R 00 00 00 00
T 9D 00
R 00 00 00 00
T 9D 00 DD 34 F6 20 03 DD 34 F7
R 00 00 00 00
T A5 00
R 00 00 00 00
T A5 00 C1 C5 C3 25 00
R 00 00 00 00 00 05 00 00
T AA 00
R 00 00 00 00
T AA 00 21 00 00
R 00 00 00 00
T AD 00
R 00 00 00 00
T AD 00 DD F9 DD E1 C9
R 00 00 00 00
_strtok.rel/    1458795425  2001  2501  100664  1807      `
XL2
H 9 areas 2 global symbols
M _strtok
O -mz80
S .__.ABS. Def0000
A _CODE size AF flags 0 addr 0
S _strtok Def0000
A _DATA size 2 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 01 00
T 00 00
R 00 00 01 00
T 00 00
R 00 00 00 00
T 00 00 FD 21 02 00 FD 39 FD 7E 01 FD B6 00 28 0E
R 00 00 00 00
T 0E 00 FD 7E 00 32 00 00 21 03 00 39 7E 32 01 00
R 00 00 00 00 00 06 01 00 00 0E 01 00
T 1C 00
R 00 00 00 00
T 1C 00 3A 01 00 21 00 00 B6 20 04 21 00 00 C9
R 00 00 00 00 00 03 01 00 00 06 01 00
T 29 00
R 00 00 00 00
T 29 00 2A 00 00 7E B7 28 2A 5F 17 9F 57 FD 21
R 00 00 00 00 00 03 01 00
T 36 00 04 00 FD 39 FD 6E 00 FD 66 01
R 00 00 00 00
T 40 00
R 00 00 00 00
T 40 00 7E BB 28 06 B7 23 20 F8 6F 67
R 00 00 00 00
T 4A 00
R 00 00 00 00
T 4A 00 7C B5 28 0C 21 00 00 34 20 D5 21 01 00 34
R 00 00 00 00 00 07 01 00 00 0D 01 00
T 58 00 18 CF
R 00 00 00 00
T 5A 00
R 00 00 00 00
T 5A 00 ED 5B 00 00
R 00 00 00 00 00 04 01 00
T 5E 00
R 00 00 00 00
T 5E 00 2A 00 00 7E B7 28 3A 47 17 9F FD 21 04 00
R 00 00 00 00 00 03 01 00
T 6C 00 FD 39 FD 6E 00 FD 66 01
R 00 00 00 00
T 74 00
R 00 00 00 00
T 74 00 7E B8 28 06 B7 23 20 F8 6F 67
R 00 00 00 00
T 7E 00
R 00 00 00 00
T 7E 00 7C B5 28 11 2A 00 00 36 00 21 00 00 34 20
R 00 00 00 00 00 07 01 00 00 0C 01 00
T 8C 00 04 21 01 00 34
R 00 00 00 00 00 04 01 00
T 91 00
R 00 00 00 00
T 91 00 EB C9
R 00 00 00 00
T 93 00
R 00 00 00 00
T 93 00 21 00 00 34 20 C5 21 01 00 34 18 BF
R 00 00 00 00 00 03 01 00 00 09 01 00
T 9F 00
R 00 00 00 00
T 9F 00 21 00 00 22 00 00 1A B7 28 02 EB C9
R 00 00 00 00 00 06 01 00
T AB 00
R 00 00 00 00
T AB 00 21 00 00 C9
R 00 00 00 00

_memchr.rel/    1458795426  2001  2501  100664  1016      `
XL2
H 9 areas 2 global symbols
M _memchr
O -mz80
S .__.ABS. Def0000
A _CODE size 60 flags 0 addr 0
S _memchr Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 F5 F5 DD 7E 04 DD
R 00 00 00 00
T 0E 00 77 FE DD 7E 05 DD 77 FF DD 7E 08 DD 86 FE
R 00 00 00 00
T 1C 00 67 DD 7E 09 DD 8E FF DD 74 FC DD 77 FD C1
R 00 00 00 00
T 2A 00 D1 D5 C5
R 00 00 00 00
T 2D 00
R 00 00 00 00
T 2D 00 DD 7E FC 93 20 06 DD 7E FD 92 28 1F
R 00 00 00 00
T 39 00
R 00 00 00 00
T 39 00 1A 47 0E 00 DD 7E 06 90 20 0C DD 7E 07 91
R 00 00 00 00
T 47 00 20 06 C1 E1 E5 C5 18 0C
R 00 00 00 00
T 4F 00
R 00 00 00 00
T 4F 00 13 DD 73 FE DD 72 FF 18 D5
R 00 00 00 00
T 58 00
R 00 00 00 00
T 58 00 21 00 00
R 00 00 00 00
T 5B 00
R 00 00 00 00
T 5B 00 DD F9 DD E1 C9
R 00 00 00 00
_memcmp.rel/    1458795426  2001  2501  100664  1088      `
XL2
H 9 areas 2 global symbols
M _memcmp
O -mz80
S .__.ABS. Def0000
A _CODE size 78 flags 0 addr 0
S _memcmp Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 F5 DD 7E 09 DD B6
R 00 00 00 00
T 0E 00 08 20 05 21 00 00 18 5D
R 00 00 00 00
T 16 00
R 00 00 00 00
T 16 00 DD 5E 08 DD 56 09
R 00 00 00 00
T 1C 00
R 00 00 00 00
T 1C 00 1B 7A B3 28 3A DD 4E 04 DD 46 05 C5 FD E1
R 00 00 00 00
T 2A 00 FD 7E 00 DD 77 FE DD 4E 06 DD 46 07 0A DD
R 00 00 00 00
T 38 00 77 FF DD 7E FE DD 96 FF 20 19 FD 23 FD E5
R 00 00 00 00
T 46 00 F1 DD 77 05 FD E5 3B F1 33 DD 77 04 03 DD
R 00 00 00 00
T 54 00 71 06 DD 70 07 18 C1
R 00 00 00 00
T 5B 00
R 00 00 00 00
T 5B 00 DD 6E 04 DD 66 05 5E 16 00 DD 6E 06 DD 66
R 00 00 00 00
T 69 00 07 6E 26 00 7B 95 6F 7A 9C 67
R 00 00 00 00
T 73 00
R 00 00 00 00
T 73 00 DD F9 DD E1 C9
R 00 00 00 00
_memcpy.rel/    1458795426  2001  2501  100664  833       `
XL2
H 9 areas 2 global symbols
M _memcpy
O -mz80
S .__.ABS. Def0000
A _CODE size 4F flags 0 addr 0
S _memcpy Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 F5 F5 DD 7E 04 DD
R 00 00 00 00
T 0E 00 77 FC DD 7E 05 DD 77 FD DD 7E 04 DD 77 FE
R 00 00 00 00
T 1C 00 DD 7E 05 DD 77 FF DD 5E 06 DD 56 07 DD 4E
R 00 00 00 00
T 2A 00 08 DD 46 09
R 00 00 00 00
T 2E 00
R 00 00 00 00
T 2E 00 61 68 0B 7D B4 28 13 1A 13 DD 6E FE DD 66
R 00 00 00 00
T 3C 00 FF 77 DD 34 FE 20 EB DD 34 FF 18 E6
R 00 00 00 00
T 48 00
R 00 00 00 00
T 48 00 E1 E5 DD F9 DD E1 C9
R 00 00 00 00

_memset.rel/    1458795426  2001  2501  100664  659       `
XL2
H 9 areas 2 global symbols
M _memset
O -mz80
S .__.ABS. Def0000
A _CODE size 2B flags 0 addr 0
S _memset Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 DD 6E 04 DD 66 05
R 00 00 00 00
T 0E 00 DD 4E 08 DD 46 09
R 00 00 00 00
T 14 00
R 00 00 00 00
T 14 00 51 58 0B 7B B2 28 07 DD 7E 06 77 23 18 F2
R 00 00 00 00
T 22 00
R 00 00 00 00
T 22 00 DD 6E 04 DD 66 05 DD E1 C9
R 00 00 00 00

_calloc.rel/    1458795426  2001  2501  100664  795       `
XL2
H 9 areas 5 global symbols
M _calloc
O -mz80
S __mulint Ref0000
S _malloc Ref0000
S .__.ABS. Def0000
S _memset Ref0000
A _CODE size 3A flags 0 addr 0
S _calloc Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 DD 6E 06 DD 66 07
R 00 00 00 00
T 0E 00 E5 DD 6E 04 DD 66 05 E5 CD 00 00 F1 F1 EB
R 00 00 00 00 02 0B 00 00
T 1C 00 D5 D5 CD 00 00 F1 D1 7C B5 28 10 E5 D5 01
R 00 00 00 00 02 05 01 00
T 2A 00 00 00 C5 E5 CD 00 00 21 06 00 39 F9 E1
R 00 00 00 00 02 07 03 00
T 37 00
R 00 00 00 00
T 37 00 DD E1 C9
R 00 00 00 00

_malloc.rel/    1458795426  2001  2501  100664  2329      `
XL2
H 9 areas 5 global symbols
M _malloc
O -mz80
S .__.ABS. Def0000
S __sdcc_heap_start Ref0000
S __sdcc_heap_end Ref0000
A _CODE size 133 flags 0 addr 0
S _malloc Def0029
S __sdcc_heap_init Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 21 00 00 11 00 00 BF ED 52 19 7D C6 FA 5F
R 00 00 00 00 02 03 02 00 02 06 01 00
T 0E 00 7C CE FF 57 ED 53 00 00 3E 00 12 13 3E 00
R 00 00 00 00 02 08 01 00
T 1C 00 12 21 00 00 22 02 00 2E 00 22 04 00 C9
R 00 00 00 00 02 07 01 00 02 0C 01 00
T 29 00
R 00 00 00 00
T 29 00 DD E5 DD 21 00 00 DD 39 F5 3E F9 DD BE 04
R 00 00 00 00
T 37 00 3E FF DD 9E 05 30 06 21 00 00 C3 2E 01
R 00 00 00 00 00 0D 00 00
T 44 00
R 00 00 00 00
T 44 00 DD 7E 04 C6 06 DD 77 04 DD 7E 05 CE 00 DD
R 00 00 00 00
T 52 00 77 05 DD 36 FE 00 00 DD 36 FF 00 00 ED 57
R 00 00 00 00 0B 07 01 00 8B 0C 01 00
T 5E 00 F3 F5
R 00 00 00 00
T 60 00
R 00 00 00 00
T 60 00 DD 6E FE DD 66 FF 5E 23 56 6B 62 DD 4E FE
R 00 00 00 00
T 6E 00 DD 46 FF 7D 91 4F 7C 98 47 DD 6E FE DD 66
R 00 00 00 00
T 7C 00 FF 23 23 23 23 7E 23 66 6F 79 95 6F 78 9C
R 00 00 00 00
T 8A 00 67 7D DD 96 04 7C DD 9E 05 38 0E DD 7E FE
R 00 00 00 00
T 98 00 C6 06 4F DD 7E FF CE 00 47 18 16
R 00 00 00 00
T A3 00
R 00 00 00 00
T A3 00 DD 73 FE DD 72 FF DD 6E FE DD 66 FF 5E 23
R 00 00 00 00
T B1 00 56 7A B3 20 AA 01 00 00
R 00 00 00 00
T B9 00
R 00 00 00 00
T B9 00 78 B1 28 6A FD 21 04 00 C5 DD 4E FE DD 46
R 00 00 00 00
T C7 00 FF FD 09 C1 FD 6E 00 FD 66 01 7C B5 20 0E
R 00 00 00 00
T D5 00 DD 7E 04 FD 77 00 DD 7E 05 FD 77 01 18 44
R 00 00 00 00
T E3 00
R 00 00 00 00
T E3 00 DD 4E FE DD 46 FF 09 4D 44 73 23 72 69 60
R 00 00 00 00
T F1 00 23 23 DD 7E FE 77 23 DD 7E FF 77 DD 6E FE
R 00 00 00 00
T FF 00 DD 66 FF 71 23 70 69 60 7E 23 66 6F 7A B3
R 00 00 00 00
T 0D 01 28 05 23 23 71 23 70
R 00 00 00 00
T 14 01
R 00 00 00 00
T 14 01 21 04 00 09 DD 7E 04 77 23 DD 7E 05 77 21
R 00 00 00 00
T 22 01 06 00 09 4D 44
R 00 00 00 00
T 27 01
R 00 00 00 00
T 27 01 F1 E2 2C 01 FB
R 00 00 00 00 00 04 00 00
T 2C 01
R 00 00 00 00
T 2C 01 69 60
R 00 00 00 00
T 2E 01
R 00 00 00 00
T 2E 01 DD F9 DD E1 C9
R 00 00 00 00

_realloc.rel/   1458795427  2001  2501  100664  2658      `
XL2
H 9 areas 8 global symbols
M _realloc
O -mz80
S _free Ref0000
S _memmove Ref0000
S _malloc Ref0000
S .__.ABS. Def0000
S __sdcc_find_memheader Ref0000
S _memcpy Ref0000
S __sdcc_prev_memheader Ref0000
A _CODE size 174 flags 0 addr 0
S _realloc Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 FA FF 39 F9 ED
R 00 00 00 00
T 0E 00 57 F3 F5 DD 6E 04 DD 66 05 E5 CD 00 00 F1
R 00 00 00 00 02 0D 04 00
T 1C 00 4D 44 78 B1 CA 5D 01 3E F9 DD BE 06 3E FF
R 00 00 00 00 00 07 00 00
T 2A 00 DD 9E 07 30 06 11 00 00 C3 69 01
R 00 00 00 00 00 0B 00 00
T 35 00
R 00 00 00 00
T 35 00 DD 7E 06 C6 06 DD 77 06 DD 7E 07 CE 00 DD
R 00 00 00 00
T 43 00 77 07 69 60 5E 23 56 DD 73 FA DD 72 FB 69
R 00 00 00 00
T 51 00 60 DD 7E FA 95 6F DD 7E FB 9C 67 79 C6 04
R 00 00 00 00
T 5F 00 DD 77 FA 78 CE 00 DD 77 FB 7D DD 96 06 7C
R 00 00 00 00
T 6D 00 DD 9E 07 38 18 DD 6E FA DD 66 FB DD 7E 06
R 00 00 00 00
T 7B 00 77 23 DD 7E 07 77 DD 5E 04 DD 56 05 C3
R 00 00 00 00
T 88 00 69 01
R 00 00 00 00 00 02 00 00
T 8A 00
R 00 00 00 00
T 8A 00 3A 01 00 21 00 00 B6 CA 13 01 2A
R 00 00 00 00 02 03 06 00 02 06 06 00 00 0A 00 00
T 95 00 00 00 7B 95 DD 77 FE 7A 9C DD 77 FF 2A
R 00 00 00 00 02 02 06 00
T A2 00 00 00 DD 75 FC DD 74 FD DD 6E FC DD 66 FD
R 00 00 00 00 02 02 06 00
T B0 00 11 04 00 19 5E 23 56 DD 7E FE 93 67 DD 7E
R 00 00 00 00
T BE 00 FF 9A 6F 7C DD 96 06 7D DD 9E 07 38 48 2A
R 00 00 00 00
T CC 00 00 00 19 EB DD 6E FC DD 66 FD 73 23 72 69
R 00 00 00 00 02 02 06 00
T DA 00 60 7E 23 66 6F 23 23 73 23 72 DD 6E FA DD
R 00 00 00 00
T E8 00 66 FB 7E 23 66 6F D5 FD E1 D5 E5 C5 FD E5
R 00 00 00 00
T F6 00 CD 00 00 21 06 00 39 F9 D1 21 04 00 19 DD
R 00 00 00 00 02 03 01 00
T 04 01 7E 06 77 23 DD 7E 07 77 21 06 00 19 EB 18
R 00 00 00 00
T 12 01 56
R 00 00 00 00
T 13 01
R 00 00 00 00
T 13 01 DD 7E 06 C6 FA 6F DD 7E 07 CE FF 67 C5 E5
R 00 00 00 00
T 21 01 CD 00 00 F1 C1 EB 7A B3 28 3E FD 21 06 00
R 00 00 00 00 02 03 02 00
T 2F 01 FD 09 DD 6E FA DD 66 FB 46 23 66 78 C6 FA
R 00 00 00 00
T 3D 01 6F 7C CE FF 67 D5 E5 FD E5 D5 CD 00 00 21
R 00 00 00 00 02 0D 05 00
T 4B 01 06 00 39 F9 DD 6E 04 DD 66 05 E5 CD 00 00
R 00 00 00 00 02 0E 00 00
T 59 01 F1 D1 18 0C
R 00 00 00 00
T 5D 01
R 00 00 00 00
T 5D 01 DD 6E 06 DD 66 07 E5 CD 00 00 F1 EB
R 00 00 00 00 02 0A 02 00
T 69 01
R 00 00 00 00
T 69 01 F1 E2 6E 01 FB
R 00 00 00 00 00 04 00 00
T 6E 01
R 00 00 00 00
T 6E 01 EB DD F9 DD E1 C9
R 00 00 00 00
_free.rel/      1458795427  2001  2501  100664  1388      `
XL2
H 9 areas 4 global symbols
M _free
O -mz80
S .__.ABS. Def0000
A _CODE size 90 flags 0 addr 0
S _free Def002C
S __sdcc_find_memheader Def0000
A _DATA size 2 flags 0 addr 0
S __sdcc_prev_memheader Def0000
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 01 00
T 00 00
R 00 00 01 00
T 00 00
R 00 00 00 00
T 00 00 21 03 00 39 7E 2B B6 20 04 21 00 00 C9
R 00 00 00 00
T 0D 00
R 00 00 00 00
T 0D 00 C1 D1 D5 C5 7B C6 FA 5F 7A CE FF 57 6B 62
R 00 00 00 00
T 1B 00 23 23 7E FD 21 00 00 FD 77 00 23 7E 32
R 00 00 00 00 00 07 01 00
T 28 00 01 00 EB C9
R 00 00 00 00 00 02 01 00
T 2C 00
R 00 00 00 00
T 2C 00 DD E5 DD 21 00 00 DD 39 F5 DD 7E 05 DD B6
R 00 00 00 00
T 3A 00 04 28 4E ED 57 F3 F5 DD 7E 04 DD 66 05 C6
R 00 00 00 00
T 48 00 FA 4F 7C CE FF 47 69 60 23 23 5E 23 56 7A
R 00 00 00 00
T 56 00 B3 28 25 0A DD 77 FE 03 0A DD 77 FF 0B 6B
R 00 00 00 00
T 64 00 62 DD 7E FE 77 23 DD 7E FF 77 69 60 7E 23
R 00 00 00 00
T 72 00 66 6F B4 28 0F 23 23 73 23 72 18 08
R 00 00 00 00
T 7E 00
R 00 00 00 00
T 7E 00 21 04 00 09 AF 77 23 77
R 00 00 00 00
T 86 00
R 00 00 00 00
T 86 00 F1 E2 8B 00 FB
R 00 00 00 00 00 04 00 00
T 8B 00
R 00 00 00 00
T 8B 00
R 00 00 00 00
T 8B 00 DD F9 DD E1 C9
R 00 00 00 00
/134            1458795433  2001  2501  100664  17041     `
XL2
H 9 areas 4 global symbols
M printf_large
O -mz80
S .__.ABS. Def0000
S ___sdcc_call_hl Ref0000
S _strlen Ref0000
A _CODE size B32 flags 0 addr 0
S __print_format Def0111
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 FD 21 02 00 FD 39 FD 7E 00 C6 30 67 3E 39
R 00 00 00 00
T 0E 00 94 30 14 7C C6 07 67 FD 21 03 00 FD 39 FD
R 00 00 00 00
T 1C 00 CB 00 46 28 04 7C C6 20 67
R 00 00 00 00
T 25 00
R 00 00 00 00
T 25 00 FD 21 06 00 FD 39 FD 4E 00 FD 46 01 C5 E5
R 00 00 00 00
T 33 00 33 21 07 00 39 7E 23 66 6F CD 00 00 F1 33
R 00 00 00 00 02 0C 01 00
T 41 00 C9
R 00 00 00 00
T 42 00
R 00 00 00 00
T 42 00 DD E5 DD 21 00 00 DD 39 DD 7E 04 07 07 07
R 00 00 00 00
T 50 00 07 E6 0F 57 DD 6E 08 DD 66 09 E5 DD 6E 06
R 00 00 00 00
T 5E 00 DD 66 07 E5 DD 7E 05 F5 33 D5 33 CD 00 00
R 00 00 00 00 00 0E 00 00
T 6C 00 21 06 00 39 F9 DD 7E 04 E6 0F 57 DD 6E 08
R 00 00 00 00
T 7A 00 DD 66 09 E5 DD 6E 06 DD 66 07 E5 DD 7E 05
R 00 00 00 00
T 88 00 F5 33 D5 33 CD 00 00 21 06 00 39 F9 DD E1
R 00 00 00 00 00 07 00 00
T 96 00 C9
R 00 00 00 00
T 97 00
R 00 00 00 00
T 97 00 DD E5 DD 21 00 00 DD 39 21 F9 FF 39 F9 DD
R 00 00 00 00
T A5 00 5E 04 DD 56 05 D5 21 03 00 39 EB 01 04 00
R 00 00 00 00
T B3 00 ED B0 D1 21 04 00 19 4D 44 DD 36 F9 20
R 00 00 00 00
T C0 00
R 00 00 00 00
T C0 00 0A 87 DD 77 FE DD 7E FD CB 07 E6 01 DD 77
R 00 00 00 00
T CE 00 FF DD 7E FE DD B6 FF 02 F5 F1 DD CB FA 26
R 00 00 00 00
T DC 00 DD CB FB 16 DD CB FC 16 DD CB FD 16 0A 67
R 00 00 00 00
T EA 00 DD 96 06 38 09 7C DD 96 06 02 DD CB FA C6
R 00 00 00 00
T F8 00
R 00 00 00 00
T F8 00 DD 7E F9 C6 FF DD 77 F9 B7 20 BD 21 01 00
R 00 00 00 00
T 06 01 39 01 04 00 ED B0 DD F9 DD E1 C9
R 00 00 00 00
T 11 01
R 00 00 00 00
T 11 01 DD E5 DD 21 00 00 DD 39 21 CA FF 39 F9 DD
R 00 00 00 00
T 1F 01 36 EB 00 DD 36 EC 00 21 0D 00 39 DD 75 F2
R 00 00 00 00
T 2D 01 DD 74 F3 21 05 00 39 DD 75 E2 DD 74 E3 21
R 00 00 00 00
T 3B 01 0D 00 39 DD 75 E9 DD 74 EA DD 7E E9 C6 04
R 00 00 00 00
T 49 01 DD 77 E5 DD 7E EA CE 00 DD 77 E6
R 00 00 00 00
T 54 01
R 00 00 00 00
T 54 01 DD 6E 08 DD 66 09 56 23 DD 75 08 DD 74 09
R 00 00 00 00
T 62 01 DD 72 E4 7A B7 CA 1C 0B DD 7E E4 D6 25 C2
R 00 00 00 00 00 08 00 00
T 70 01 F9 0A DD 36 DD 00 DD 36 D6 00 DD 36 D5 00
R 00 00 00 00 00 02 00 00
T 7E 01 DD 36 E1 00 DD 36 DF 00 DD 36 DE 00 DD 36
R 00 00 00 00
T 8C 01 D1 00 DD 36 D0 00 DD 36 D4 00 DD 36 ED 00
R 00 00 00 00
T 9A 01 DD 36 D3 FF DD 7E 08 DD 77 FC DD 7E 09 DD
R 00 00 00 00
T A8 01 77 FD
R 00 00 00 00
T AA 01
R 00 00 00 00
T AA 01 DD 6E FC DD 66 FD 7E DD 77 FE DD 34 FC 20
R 00 00 00 00
T B8 01 03 DD 34 FD
R 00 00 00 00
T BC 01
R 00 00 00 00
T BC 01 DD 7E FC DD 77 08 DD 7E FD DD 77 09 DD 7E
R 00 00 00 00
T CA 01 FE D6 25 20 23 DD 6E 06 DD 66 07 E5 DD 7E
R 00 00 00 00
T D8 01 FE F5 33 DD 6E 04 DD 66 05 CD 00 00 F1 33
R 00 00 00 00 02 0C 01 00
T E6 01 DD 34 EB C2 54 01 DD 34 EC C3 54 01
R 00 00 00 00 00 06 00 00 00 0C 00 00
T F2 01
R 00 00 00 00
T F2 01 DD 66 FE 7C D6 30 38 3B 3E 39 94 38 36 DD
R 00 00 00 00
T 00 02 7E D3 3C 20 1C DD 7E ED 4F 87 87 81 87 DD
R 00 00 00 00
T 0E 02 77 FF DD 86 FE C6 D0 DD 77 ED B7 20 8F DD
R 00 00 00 00
T 1C 02 36 D6 01 18 89
R 00 00 00 00
T 21 02
R 00 00 00 00
T 21 02 DD 6E D3 4D 29 29 09 29 7D DD 86 FE C6 D0
R 00 00 00 00
T 2F 02 DD 77 D3 C3 AA 01
R 00 00 00 00 00 06 00 00
T 35 02
R 00 00 00 00
T 35 02 DD 7E FE D6 2E 20 0E DD 7E D3 3C C2 AA 01
R 00 00 00 00 00 0E 00 00
T 43 02 DD 36 D3 00 C3 AA 01
R 00 00 00 00 00 07 00 00
T 4A 02
R 00 00 00 00
T 4A 02 DD 6E FE 7D D6 61 38 0F 3E 7A 95 38 0A DD
R 00 00 00 00
T 58 02 CB FE AE DD 36 DC 01 18 04
R 00 00 00 00
T 61 02
R 00 00 00 00
T 61 02 DD 36 DC 00
R 00 00 00 00
T 65 02
R 00 00 00 00
T 65 02 DD 7E FE D6 20 CA 04 03 DD 7E FE D6 2B CA
R 00 00 00 00 00 08 00 00
T 73 02 FD 02 DD 7E FE D6 2D 28 7A DD 7E FE D6 42
R 00 00 00 00 00 02 00 00
T 81 02 CA 0B 03 DD 7E FE D6 43 CA 19 03 DD 7E FE
R 00 00 00 00 00 03 00 00 00 0B 00 00
T 8F 02 D6 44 CA 2E 05 DD 7E FE D6 46 CA 4A 05 DD
R 00 00 00 00 00 05 00 00 00 0D 00 00
T 9D 02 7E FE D6 48 CA AA 01 DD 7E FE D6 49 CA
R 00 00 00 00 00 07 00 00
T AA 02 2E 05 DD 7E FE D6 4A CA AA 01 DD 7E FE D6
R 00 00 00 00 00 02 00 00 00 0A 00 00
T B8 02 4C 28 57 DD 7E FE D6 4F CA 38 05 DD 7E FE
R 00 00 00 00 00 0B 00 00
T C6 02 D6 50 CA 85 04 DD 7E FE D6 53 CA 63 03 DD
R 00 00 00 00 00 05 00 00 00 0D 00 00
T D4 02 7E FE D6 54 CA AA 01 DD 7E FE D6 55 CA
R 00 00 00 00 00 07 00 00
T E1 02 3E 05 DD 7E FE D6 58 CA 44 05 DD 7E FE D6
R 00 00 00 00 00 02 00 00 00 0A 00 00
T EF 02 5A CA AA 01 C3 50 05
R 00 00 00 00 00 04 00 00 00 07 00 00
T F6 02
R 00 00 00 00
T F6 02 DD 36 DD 01 C3 AA 01
R 00 00 00 00 00 07 00 00
T FD 02
R 00 00 00 00
T FD 02 DD 36 D5 01 C3 AA 01
R 00 00 00 00 00 07 00 00
T 04 03
R 00 00 00 00
T 04 03 DD 36 E1 01 C3 AA 01
R 00 00 00 00 00 07 00 00
T 0B 03
R 00 00 00 00
T 0B 03 DD 36 DE 01 C3 AA 01
R 00 00 00 00 00 07 00 00
T 12 03
R 00 00 00 00
T 12 03 DD 36 D1 01 C3 AA 01
R 00 00 00 00 00 07 00 00
T 19 03
R 00 00 00 00
T 19 03 DD CB DE 46 28 11 DD 6E 0A DD 66 0B 23 DD
R 00 00 00 00
T 27 03 75 0A DD 74 0B 2B 56 18 13
R 00 00 00 00
T 30 03
R 00 00 00 00
T 30 03 DD 6E 0A DD 66 0B 23 23 DD 75 0A DD 74 0B
R 00 00 00 00
T 3E 03 2B 2B 56 23 66
R 00 00 00 00
T 43 03
R 00 00 00 00
T 43 03 DD 6E 06 DD 66 07 E5 D5 33 DD 6E 04 DD 66
R 00 00 00 00
T 51 03 05 CD 00 00 F1 33 DD 34 EB C2 7A 05 DD 34
R 00 00 00 00 02 04 01 00 00 0C 00 00
T 5F 03 EC C3 7A 05
R 00 00 00 00 00 04 00 00
T 63 03
R 00 00 00 00
T 63 03 21 0D 00 39 DD 75 FC DD 74 FD DD 6E 0A DD
R 00 00 00 00
T 71 03 66 0B 23 23 DD 75 0A DD 74 0B 2B 2B 5E 23
R 00 00 00 00
T 7F 03 56 DD 6E FC DD 66 FD 73 23 72 D5 CD 00 00
R 00 00 00 00 02 0E 02 00
T 8D 03 F1 5D DD 7E D3 3C 20 03 DD 73 D3
R 00 00 00 00
T 98 03
R 00 00 00 00
T 98 03 DD CB DD 46 20 46 7B DD 96 ED 30 40 DD 7E
R 00 00 00 00
T A6 03 ED 93 DD 77 FF DD 4E EB DD 46 EC
R 00 00 00 00
T B1 03
R 00 00 00 00
T B1 03 DD 66 FF DD 35 FF 7C B7 28 1D C5 D5 DD 6E
R 00 00 00 00
T BF 03 06 DD 66 07 E5 3E 20 F5 33 DD 6E 04 DD 66
R 00 00 00 00
T CD 03 05 CD 00 00 F1 33 D1 C1 03 18 D9
R 00 00 00 00 02 04 01 00
T D8 03
R 00 00 00 00
T D8 03 DD 71 EB DD 70 EC DD 7E FF DD 77 ED
R 00 00 00 00
T E4 03
R 00 00 00 00
T E4 03 DD 56 D3 DD 4E EB DD 46 EC
R 00 00 00 00
T ED 03
R 00 00 00 00
T ED 03 DD 6E FC DD 66 FD 7E 23 66 6F 7E DD 77 FF
R 00 00 00 00
T FB 03 B7 28 4A 62 15 AF 94 E2 07 04 EE 80
R 00 00 00 00 00 0A 00 00
T 07 04
R 00 00 00 00
T 07 04 F2 48 04 C5 D5 DD 6E 06 DD 66 07 E5 DD 7E
R 00 00 00 00 00 03 00 00
T 15 04 FF F5 33 DD 6E 04 DD 66 05 CD 00 00 F1 33
R 00 00 00 00 02 0C 01 00
T 23 04 D1 C1 03 DD 6E FC DD 66 FD 7E 23 66 6F 23
R 00 00 00 00
T 31 04 DD 75 E7 DD 74 E8 DD 6E FC DD 66 FD DD 7E
R 00 00 00 00
T 3F 04 E7 77 23 DD 7E E8 77 18 A5
R 00 00 00 00
T 48 04
R 00 00 00 00
T 48 04 DD 71 EB DD 70 EC DD CB DD 46 CA 7A 05 7B
R 00 00 00 00 00 0D 00 00
T 56 04 DD 96 ED D2 7A 05 DD 7E ED 93 5F
R 00 00 00 00 00 06 00 00
T 61 04
R 00 00 00 00
T 61 04 63 1D 7C B7 CA 71 05 C5 D5 DD 6E 06 DD 66
R 00 00 00 00 00 07 00 00
T 6F 04 07 E5 3E 20 F5 33 DD 6E 04 DD 66 05 CD
R 00 00 00 00
T 7C 04 00 00 F1 33 D1 C1 03 18 DC
R 00 00 00 00 02 02 01 00
T 85 04
R 00 00 00 00
T 85 04 21 0D 00 39 EB DD 6E 0A DD 66 0B 23 23 DD
R 00 00 00 00
T 93 04 75 0A DD 74 0B 2B 2B 4E 23 46 79 12 13 78
R 00 00 00 00
T A1 04 12 DD 6E 06 DD 66 07 E5 3E 30 F5 33 DD 6E
R 00 00 00 00
T AF 04 04 DD 66 05 CD 00 00 F1 33 DD 5E EB DD 56
R 00 00 00 00 02 07 01 00
T BD 04 EC 13 D5 DD 6E 06 DD 66 07 E5 3E 78 F5 33
R 00 00 00 00
T CB 04 DD 6E 04 DD 66 05 CD 00 00 F1 33 D1 13 21
R 00 00 00 00 02 09 01 00
T D9 04 0E 00 39 46 D5 DD 6E 06 DD 66 07 E5 DD 6E
R 00 00 00 00
T E7 04 04 DD 66 05 E5 DD 7E DC F5 33 C5 33 CD
R 00 00 00 00
T F4 04 42 00 21 06 00 39 F9 D1 13 13 DD 6E F2 DD
R 00 00 00 00 00 02 00 00
T 02 05 66 F3 46 D5 DD 6E 06 DD 66 07 E5 DD 6E 04
R 00 00 00 00
T 10 05 DD 66 05 E5 DD 7E DC F5 33 C5 33 CD 42 00
R 00 00 00 00 00 0E 00 00
T 1E 05 21 06 00 39 F9 D1 13 13 DD 73 EB DD 72 EC
R 00 00 00 00
T 2C 05 18 4C
R 00 00 00 00
T 2E 05
R 00 00 00 00
T 2E 05 DD 36 DF 01 DD 36 D4 0A 18 42
R 00 00 00 00
T 38 05
R 00 00 00 00
T 38 05 DD 36 D4 08 18 3C
R 00 00 00 00
T 3E 05
R 00 00 00 00
T 3E 05 DD 36 D4 0A 18 36
R 00 00 00 00
T 44 05
R 00 00 00 00
T 44 05 DD 36 D4 10 18 30
R 00 00 00 00
T 4A 05
R 00 00 00 00
T 4A 05 DD 36 D0 01 18 2A
R 00 00 00 00
T 50 05
R 00 00 00 00
T 50 05 DD 6E 06 DD 66 07 E5 DD 7E FE F5 33 DD 6E
R 00 00 00 00
T 5E 05 04 DD 66 05 CD 00 00 F1 33 DD 34 EB 20 0E
R 00 00 00 00 02 07 01 00
T 6C 05 DD 34 EC 18 09
R 00 00 00 00
T 71 05
R 00 00 00 00
T 71 05 DD 71 EB DD 70 EC DD 73 ED
R 00 00 00 00
T 7A 05
R 00 00 00 00
T 7A 05 DD CB D0 46 CA 3C 06 21 0D 00 39 DD 75 E7
R 00 00 00 00 00 07 00 00
T 88 05 DD 74 E8 DD 7E 0A C6 04 DD 77 FC DD 7E 0B
R 00 00 00 00
T 96 05 CE 00 DD 77 FD DD 7E FC DD 77 0A DD 7E FD
R 00 00 00 00
T A4 05 DD 77 0B DD 7E FC C6 FC DD 77 FC DD 7E FD
R 00 00 00 00
T B2 05 CE FF DD 77 FD DD 5E FC DD 56 FD 21 24 00
R 00 00 00 00
T C0 05 39 EB 01 04 00 ED B0 DD 5E E7 DD 56 E8 21
R 00 00 00 00
T CE 05 24 00 39 01 04 00 ED B0 21 0D 00 39 DD 75
R 00 00 00 00
T DC 05 EE DD 74 EF DD 6E EE DD 66 EF 36 27 0B 23
R 00 00 00 00 09 0D 00 00
T E9 05 36 27 0B DD 7E EB DD 77 E7 DD 7E EC DD 77
R 00 00 00 00 89 03 00 00
T F6 05 E8
R 00 00 00 00
T F7 05
R 00 00 00 00
T F7 05 DD 6E EE DD 66 EF 5E 23 56 4B 42 03 DD 6E
R 00 00 00 00
T 05 06 EE DD 66 EF 71 23 70 1A 67 B7 CA 54 01 DD
R 00 00 00 00 00 0D 00 00
T 13 06 4E 06 DD 46 07 C5 E5 33 DD 6E 04 DD 66 05
R 00 00 00 00
T 21 06 CD 00 00 F1 33 DD 34 E7 20 03 DD 34 E8
R 00 00 00 00 02 03 01 00
T 2E 06
R 00 00 00 00
T 2E 06 DD 7E E7 DD 77 EB DD 7E E8 DD 77 EC 18 BB
R 00 00 00 00
T 3C 06
R 00 00 00 00
T 3C 06 DD 7E D4 B7 CA 54 01 DD 7E E2 DD 77 EE DD
R 00 00 00 00 00 07 00 00
T 4A 06 7E E3 DD 77 EF DD CB DE 46 CA E8 06 21
R 00 00 00 00 00 0C 00 00
T 57 06 0D 00 39 DD 75 E7 DD 74 E8 DD 7E 0A C6 01
R 00 00 00 00
T 65 06 DD 77 FC DD 7E 0B CE 00 DD 77 FD DD 7E FC
R 00 00 00 00
T 73 06 DD 77 0A DD 7E FD DD 77 0B DD 6E FC DD 66
R 00 00 00 00
T 81 06 FD 2B DD 75 FC DD 74 FD DD 6E FC DD 66 FD
R 00 00 00 00
T 8F 06 7E DD 77 FF DD 77 F4 DD 7E FF 17 9F DD 77
R 00 00 00 00
T 9D 06 F5 DD 77 F6 DD 77 F7 DD 5E E7 DD 56 E8 21
R 00 00 00 00
T AB 06 2A 00 39 01 04 00 ED B0 DD CB DF 46 C2
R 00 00 00 00
T B8 06 E7 07 DD 5E E7 DD 56 E8 21 2A 00 39 EB 01
R 00 00 00 00 00 02 00 00
T C6 06 04 00 ED B0 DD 36 F5 00 DD 36 F6 00 DD 36
R 00 00 00 00
T D4 06 F7 00 DD 5E E7 DD 56 E8 21 2A 00 39 01
R 00 00 00 00
T E1 06 04 00 ED B0 C3 E7 07
R 00 00 00 00 00 07 00 00
T E8 06
R 00 00 00 00
T E8 06 DD CB D1 46 28 58 21 0D 00 39 DD 75 F4 DD
R 00 00 00 00
T F6 06 74 F5 DD 7E 0A C6 04 DD 77 E7 DD 7E 0B CE
R 00 00 00 00
T 04 07 00 DD 77 E8 DD 7E E7 DD 77 0A DD 7E E8 DD
R 00 00 00 00
T 12 07 77 0B DD 7E E7 C6 FC DD 77 E7 DD 7E E8 CE
R 00 00 00 00
T 20 07 FF DD 77 E8 DD 5E E7 DD 56 E8 21 2E 00 39
R 00 00 00 00
T 2E 07 EB 01 04 00 ED B0 DD 5E F4 DD 56 F5 21
R 00 00 00 00
T 3B 07 2E 00 39 01 04 00 ED B0 C3 E7 07
R 00 00 00 00 00 0B 00 00
T 46 07
R 00 00 00 00
T 46 07 21 0D 00 39 DD 75 F8 DD 74 F9 DD 7E 0A C6
R 00 00 00 00
T 54 07 02 DD 77 F4 DD 7E 0B CE 00 DD 77 F5 DD 7E
R 00 00 00 00
T 62 07 F4 DD 77 0A DD 7E F5 DD 77 0B DD 7E F4 C6
R 00 00 00 00
T 70 07 FE DD 77 F4 DD 7E F5 CE FF DD 77 F5 DD 7E
R 00 00 00 00
T 7E 07 F4 DD 77 F4 DD 7E F5 DD 77 F5 DD 6E F4 DD
R 00 00 00 00
T 8C 07 66 F5 7E DD 77 F4 23 7E DD 77 F5 DD 7E F4
R 00 00 00 00
T 9A 07 DD 77 F4 DD 7E F5 DD 77 F5 17 9F DD 77 F6
R 00 00 00 00
T A8 07 DD 77 F7 DD 5E F8 DD 56 F9 21 2A 00 39 01
R 00 00 00 00
T B6 07 04 00 ED B0 DD CB DF 46 20 27 DD 5E F8 DD
R 00 00 00 00
T C4 07 56 F9 21 2A 00 39 EB 01 04 00 ED B0 DD 36
R 00 00 00 00
T D2 07 F6 00 DD 36 F7 00 DD 5E F8 DD 56 F9 21
R 00 00 00 00
T DF 07 2A 00 39 01 04 00 ED B0
R 00 00 00 00
T E7 07
R 00 00 00 00
T E7 07 DD CB DF 46 28 4A 21 0D 00 39 DD 75 F8 DD
R 00 00 00 00
T F5 07 74 F9 EB 21 2A 00 39 EB 01 04 00 ED B0 DD
R 00 00 00 00
T 03 08 CB F7 7E 28 2B DD 6E F8 DD 66 F9 5E 23 56
R 00 00 00 00
T 11 08 23 4E 23 46 AF 93 5F 3E 00 9A 57 3E 00 99
R 00 00 00 00
T 1F 08 4F 3E 00 98 47 DD 6E F8 DD 66 F9 73 23 72
R 00 00 00 00
T 2D 08 23 71 23 70 18 04
R 00 00 00 00
T 33 08
R 00 00 00 00
T 33 08 DD 36 DF 00
R 00 00 00 00
T 37 08
R 00 00 00 00
T 37 08 DD 36 E0 01 DD 4E EE DD 46 EF DD 36 D2 00
R 00 00 00 00
T 45 08
R 00 00 00 00
T 45 08 21 11 00 39 36 00 DD 5E E9 DD 56 EA C5 DD
R 00 00 00 00
T 53 08 7E D4 F5 33 D5 CD 97 00 F1 33 C1 DD CB E0
R 00 00 00 00 00 08 00 00
T 61 08 46 20 23 DD 6E E5 DD 66 E6 7E 07 07 07 07
R 00 00 00 00
T 6F 08 E6 F0 57 DD 6E E5 DD 66 E6 7E 07 07 07 07
R 00 00 00 00
T 7D 08 E6 0F B2 57 0A B2 02 0B 18 08
R 00 00 00 00
T 87 08
R 00 00 00 00
T 87 08 DD 6E E5 DD 66 E6 7E 02
R 00 00 00 00
T 8F 08
R 00 00 00 00
T 8F 08 DD 34 D2 DD 7E E0 EE 01 DD 77 E0 DD 6E E9
R 00 00 00 00
T 9D 08 DD 66 EA 5E 23 56 23 23 7E 2B 66 B4 B2 B3
R 00 00 00 00
T AB 08 20 98 DD 71 F8 DD 70 F9 DD 7E D2 DD 77 F4
R 00 00 00 00
T B9 08 DD 7E ED B7 20 04 DD 36 ED 01
R 00 00 00 00
T C3 08
R 00 00 00 00
T C3 08 DD CB D6 46 20 54 DD CB DD 46 20 4E DD 7E
R 00 00 00 00
T D1 08 F4 3C DD 77 EE DD 7E EB DD 77 E7 DD 7E EC
R 00 00 00 00
T DF 08 DD 77 E8 DD 56 ED
R 00 00 00 00
T E5 08
R 00 00 00 00
T E5 08 DD 7E EE 92 30 23 D5 DD 6E 06 DD 66 07 E5
R 00 00 00 00
T F3 08 3E 20 F5 33 DD 6E 04 DD 66 05 CD 00 00 F1
R 00 00 00 00 02 0D 01 00
T 01 09 33 D1 DD 34 E7 20 03 DD 34 E8
R 00 00 00 00
T 0B 09
R 00 00 00 00
T 0B 09 15 18 D7
R 00 00 00 00
T 0E 09
R 00 00 00 00
T 0E 09 DD 7E E7 DD 77 EB DD 7E E8 DD 77 EC DD 72
R 00 00 00 00
T 1C 09 ED
R 00 00 00 00
T 1D 09
R 00 00 00 00
T 1D 09 DD CB DF 46 28 23 DD 6E 06 DD 66 07 E5 3E
R 00 00 00 00
T 2B 09 2D F5 33 DD 6E 04 DD 66 05 CD 00 00 F1 33
R 00 00 00 00 02 0C 01 00
T 39 09 DD 34 EB 20 03 DD 34 EC
R 00 00 00 00
T 41 09
R 00 00 00 00
T 41 09 DD 35 ED 18 56
R 00 00 00 00
T 46 09
R 00 00 00 00
T 46 09 DD 7E F4 B7 28 50 DD CB D5 46 28 23 DD 6E
R 00 00 00 00
T 54 09 06 DD 66 07 E5 3E 2B F5 33 DD 6E 04 DD 66
R 00 00 00 00
T 62 09 05 CD 00 00 F1 33 DD 34 EB 20 03 DD 34 EC
R 00 00 00 00 02 04 01 00
T 70 09
R 00 00 00 00
T 70 09 DD 35 ED 18 27
R 00 00 00 00
T 75 09
R 00 00 00 00
T 75 09 DD CB E1 46 28 21 DD 6E 06 DD 66 07 E5 3E
R 00 00 00 00
T 83 09 20 F5 33 DD 6E 04 DD 66 05 CD 00 00 F1 33
R 00 00 00 00 02 0C 01 00
T 91 09 DD 34 EB 20 03 DD 34 EC
R 00 00 00 00
T 99 09
R 00 00 00 00
T 99 09 DD 35 ED
R 00 00 00 00
T 9C 09
R 00 00 00 00
T 9C 09 DD CB DD 46 20 4F DD 7E EB DD 77 EE DD 7E
R 00 00 00 00
T AA 09 EC DD 77 EF DD 7E ED DD 77 E7
R 00 00 00 00
T B4 09
R 00 00 00 00
T B4 09 DD 66 E7 DD 35 E7 DD 7E F4 94 30 4A DD CB
R 00 00 00 00
T C2 09 D6 46 28 06 DD 36 FF 30 18 04
R 00 00 00 00
T CC 09
R 00 00 00 00
T CC 09 DD 36 FF 20
R 00 00 00 00
T D0 09
R 00 00 00 00
T D0 09 DD 6E 06 DD 66 07 E5 DD 7E FF F5 33 DD 6E
R 00 00 00 00
T DE 09 04 DD 66 05 CD 00 00 F1 33 DD 34 EE 20 C8
R 00 00 00 00 02 07 01 00
T EC 09 DD 34 EF 18 C3
R 00 00 00 00
T F1 09
R 00 00 00 00
T F1 09 DD 7E F4 DD 96 ED 30 0B DD 7E ED DD 96 F4
R 00 00 00 00
T FF 09 DD 77 FF 18 18
R 00 00 00 00
T 04 0A
R 00 00 00 00
T 04 0A DD 36 FF 00 18 12
R 00 00 00 00
T 0A 0A
R 00 00 00 00
T 0A 0A DD 7E EE DD 77 EB DD 7E EF DD 77 EC DD 7E
R 00 00 00 00
T 18 0A E7 DD 77 FF
R 00 00 00 00
T 1C 0A
R 00 00 00 00
T 1C 0A DD 7E F8 DD 77 F8 DD 7E F9 DD 77 F9 DD 7E
R 00 00 00 00
T 2A 0A EB DD 77 EE DD 7E EC DD 77 EF DD 7E F4 DD
R 00 00 00 00
T 38 0A 77 F4
R 00 00 00 00
T 3A 0A
R 00 00 00 00
T 3A 0A DD 66 F4 DD 35 F4 7C B7 28 6A DD 7E E0 EE
R 00 00 00 00
T 48 0A 01 DD 77 E0 DD CB E0 46 20 1E DD 34 F8 20
R 00 00 00 00
T 56 0A 03 DD 34 F9
R 00 00 00 00
T 5A 0A
R 00 00 00 00
T 5A 0A DD 6E F8 DD 66 F9 7E 07 07 07 07 E6 0F DD
R 00 00 00 00
T 68 0A 6E E5 DD 66 E6 77 18 10
R 00 00 00 00
T 70 0A
R 00 00 00 00
T 70 0A DD 6E F8 DD 66 F9 7E E6 0F DD 6E E5 DD 66
R 00 00 00 00
T 7E 0A E6 77
R 00 00 00 00
T 80 0A
R 00 00 00 00
T 80 0A DD 6E E5 DD 66 E6 56 DD 6E 06 DD 66 07 E5
R 00 00 00 00
T 8E 0A DD 6E 04 DD 66 05 E5 DD 7E DC F5 33 D5 33
R 00 00 00 00
T 9C 0A CD 00 00 21 06 00 39 F9 DD 34 EE 20 91 DD
R 00 00 00 00 00 03 00 00
T AA 0A 34 EF 18 8C
R 00 00 00 00
T AE 0A
R 00 00 00 00
T AE 0A DD 7E EE DD 77 EB DD 7E EF DD 77 EC DD CB
R 00 00 00 00
T BC 0A DD 46 CA 54 01 DD 5E EE DD 56 EF DD 7E FF
R 00 00 00 00 00 05 00 00
T CA 0A DD 77 F8
R 00 00 00 00
T CD 0A
R 00 00 00 00
T CD 0A DD 66 F8 DD 35 F8 7C B7 CA 54 01 D5 DD 6E
R 00 00 00 00 00 0B 00 00
T DB 0A 06 DD 66 07 E5 3E 20 F5 33 DD 6E 04 DD 66
R 00 00 00 00
T E9 0A 05 CD 00 00 F1 33 D1 13 DD 73 EB DD 72 EC
R 00 00 00 00 02 04 01 00
T F7 0A 18 D4
R 00 00 00 00
T F9 0A
R 00 00 00 00
T F9 0A DD 6E 06 DD 66 07 E5 DD 7E E4 F5 33 DD 6E
R 00 00 00 00
T 07 0B 04 DD 66 05 CD 00 00 F1 33 DD 34 EB C2
R 00 00 00 00 02 07 01 00
T 14 0B 54 01 DD 34 EC C3 54 01
R 00 00 00 00 00 02 00 00 00 08 00 00
T 1C 0B
R 00 00 00 00
T 1C 0B DD 6E EB DD 66 EC DD F9 DD E1 C9
R 00 00 00 00
T 27 0B
R 00 00 00 00
T 27 0B 3C 4E 4F 20 46 4C 4F 41 54 3E 00
R 00 00 00 00

puts.rel/       1458795433  2001  2501  100664  737       `
XL2
H 9 areas 3 global symbols
M puts
O -mz80
S _putchar Ref0000
S .__.ABS. Def0000
A _CODE size 31 flags 0 addr 0
S _puts Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 DD 6E 04 DD 66 05
R 00 00 00 00
T 0E 00 11 00 00
R 00 00 00 00
T 11 00
R 00 00 00 00
T 11 00 46 13 78 B7 28 0D 23 E5 D5 C5 33 CD 00 00
R 00 00 00 00 02 0E 00 00
T 1F 00 33 D1 E1 18 ED
R 00 00 00 00
T 24 00
R 00 00 00 00
T 24 00 D5 3E 0A F5 33 CD 00 00 33 E1 DD E1 C9
R 00 00 00 00 02 08 00 00

gets.rel/       1458795433  2001  2501  100664  1489      `
XL2
H 9 areas 4 global symbols
M gets
O -mz80
S _putchar Ref0000
S .__.ABS. Def0000
S _getchar Ref0000
A _CODE size AE flags 0 addr 0
S _gets Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 3B 11 00 00
R 00 00 00 00
T 04 00
R 00 00 00 00
T 04 00 D5 CD 00 00 D1 FD 21 00 00 FD 39 FD 75 00
R 00 00 00 00 02 04 02 00
T 12 00 FD 7E 00 D6 08 28 1D 21 03 00 39 46 23 4E
R 00 00 00 00
T 20 00 FD 21 00 00 FD 39 FD 7E 00 D6 0A 28 3D FD
R 00 00 00 00
T 2E 00 7E 00 D6 0D 28 36 18 4E
R 00 00 00 00
T 36 00
R 00 00 00 00
T 36 00 7A B3 28 CA D5 3E 08 F5 33 CD 00 00 33 3E
R 00 00 00 00 02 0C 00 00
T 44 00 20 F5 33 CD 00 00 33 3E 08 F5 33 CD 00 00
R 00 00 00 00 02 06 00 00 02 0E 00 00
T 52 00 33 D1 FD 21 03 00 FD 39 FD 6E 00 FD 66 01
R 00 00 00 00
T 60 00 2B FD 75 00 FD 74 01 1B 18 9A
R 00 00 00 00
T 6A 00
R 00 00 00 00
T 6A 00 C5 3E 0D F5 33 CD 00 00 33 3E 0A F5 33 CD
R 00 00 00 00 02 08 00 00
T 78 00 00 00 33 C1 68 61 36 00 68 61 18 28
R 00 00 00 00 02 02 00 00
T 84 00
R 00 00 00 00
T 84 00 68 61 FD 21 00 00 FD 39 FD 7E 00 77 78 21
R 00 00 00 00
T 92 00 03 00 39 C6 01 77 79 CE 00 23 77 13 D5 FD
R 00 00 00 00
T A0 00 7E 00 F5 33 CD 00 00 33 D1 C3 04 00
R 00 00 00 00 02 07 00 00 00 0C 00 00
T AC 00
R 00 00 00 00
T AC 00 33 C9
R 00 00 00 00

assert.rel/     1458795433  2001  2501  100664  945       `
XL2
H 9 areas 3 global symbols
M assert
O -mz80
S .__.ABS. Def0000
S _printf Ref0000
A _CODE size 5F flags 0 addr 0
S __assert Def0000
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 21 35 00 FD 21 04 00 FD 39 FD 4E 00 FD 46
R 00 00 00 00 00 03 00 00
T 0E 00 01 C5 FD 21 08 00 FD 39 FD 4E 00 FD 46 01
R 00 00 00 00
T 1C 00 C5 FD 21 06 00 FD 39 FD 4E 00 FD 46 01 C5
R 00 00 00 00
T 2A 00 E5 CD 00 00 21 08 00 39 F9
R 00 00 00 00 02 04 01 00
T 33 00
R 00 00 00 00
T 33 00 18 FE
R 00 00 00 00
T 35 00
R 00 00 00 00
T 35 00 41 73 73 65 72 74 28 25 73 29 20 66 61 69
R 00 00 00 00
T 43 00 6C 65 64 20 61 74 20 6C 69 6E 65 20 25 75
R 00 00 00 00
T 51 00 20 69 6E 20 66 69 6C 65 20 25 73 2E 0A 00
R 00 00 00 00

time.rel/       1458795435  2001  2501  100664  11925     `
XL2
H 9 areas F global symbols
M time
O -mz80
S .__.ABS. Def0000
S __modulong Ref0000
S _sprintf Ref0000
S __divulong Ref0000
S __modsint Ref0000
S __mullong Ref0000
A _CODE size 6CF flags 0 addr 0
S _RtcRead Def0000
S _asctime Def00B2
S _time Def0003
S _localtime Def0191
S _gmtime Def019B
S _mktime Def043C
S _ctime Def0183
A _DATA size 2C flags 0 addr 0
A _INITIALIZED size 32 flags 0 addr 0
S ___month Def000C
S ___day Def0024
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 32 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 01 00
T 00 00
R 00 00 01 00
T 20 00
R 00 00 01 00
T 20 00
R 00 00 01 00
T 00 00
R 00 00 02 00
T 00 00
R 00 00 02 00
T 0C 00
R 00 00 02 00
T 0C 00
R 00 00 02 00
T 24 00
R 00 00 02 00
T 24 00
R 00 00 02 00
T 00 00
R 00 00 00 00
T 00 00 2E 00 C9
R 00 00 00 00
T 03 00
R 00 00 00 00
T 03 00 DD E5 DD 21 00 00 DD 39 21 F4 FF 39 F9 01
R 00 00 00 00
T 11 00 FF FF 11 FF FF 21 00 00 39 E5 FD E1 E5 C5
R 00 00 00 00
T 1F 00 D5 FD E5 CD 00 00 F1 7D D1 C1 E1 B7 28 07
R 00 00 00 00 00 06 00 00
T 2D 00 E5 CD 3C 04 F1 4D 44
R 00 00 00 00 00 04 00 00
T 34 00
R 00 00 00 00
T 34 00 DD 7E 05 DD B6 04 28 0D DD 6E 04 DD 66 05
R 00 00 00 00
T 42 00 71 23 70 23 73 23 72
R 00 00 00 00
T 49 00
R 00 00 00 00
T 49 00 69 60 DD F9 DD E1 C9
R 00 00 00 00
T 50 00
R 00 00 00 00
T 50 00 C1 D1 D5 C5 1A 67 3E 3B BC 30 01 12
R 00 00 00 00
T 5C 00
R 00 00 00 00
T 5C 00 6B 62 23 46 3E 3B 90 30 02 36 3B
R 00 00 00 00
T 67 00
R 00 00 00 00
T 67 00 6B 62 23 23 46 3E 17 90 30 02 36 17
R 00 00 00 00
T 73 00
R 00 00 00 00
T 73 00 21 07 00 19 46 3E 06 90 30 02 36 06
R 00 00 00 00
T 7F 00
R 00 00 00 00
T 7F 00 6B 62 23 23 23 46 78 D6 01 30 04 36 01 18
R 00 00 00 00
T 8D 00 07
R 00 00 00 00
T 8E 00
R 00 00 00 00
T 8E 00 3E 1F 90 30 02 36 1F
R 00 00 00 00
T 95 00
R 00 00 00 00
T 95 00 21 04 00 19 46 3E 0B 90 30 02 36 0B
R 00 00 00 00
T A1 00
R 00 00 00 00
T A1 00 21 05 00 19 E5 56 23 5E E1 CB 7B C8 AF 77
R 00 00 00 00
T AF 00 23 77 C9
R 00 00 00 00
T B2 00
R 00 00 00 00
T B2 00 DD E5 DD 21 00 00 DD 39 21 F6 FF 39 F9 DD
R 00 00 00 00
T C0 00 6E 04 DD 66 05 E5 CD 50 00 F1 DD 5E 04 DD
R 00 00 00 00 00 09 00 00
T CE 00 56 05 D5 FD E1 FD 4E 05 FD 46 06 21 6C 07
R 00 00 00 00
T DC 00 09 E3 1A DD 77 F8 DD 36 F9 00 6B 62 23 7E
R 00 00 00 00
T EA 00 DD 77 FC DD 36 FD 00 6B 62 23 23 7E DD 77
R 00 00 00 00
T F8 00 FE DD 36 FF 00 6B 62 23 23 23 7E DD 77 FA
R 00 00 00 00
T 06 01 DD 36 FB 00 6B 62 01 04 00 09 6E 26 00 29
R 00 00 00 00
T 14 01 01 0C 00 09 4E 23 46 EB 11 07 00 19 6E 26
R 00 00 00 00 00 03 02 00
T 22 01 00 29 11 24 00 19 5E 23 56 E1 E5 E5 DD 6E
R 00 00 00 00 00 05 02 00
T 30 01 F8 DD 66 F9 E5 DD 6E FC DD 66 FD E5 DD 6E
R 00 00 00 00
T 3E 01 FE DD 66 FF E5 DD 6E FA DD 66 FB E5 C5 D5
R 00 00 00 00
T 4C 01 21 64 01 E5 21 00 00 E5 CD 00 00 21 12 00
R 00 00 00 00 00 03 00 00 00 07 01 00 02 0B 02 00
T 5A 01 39 F9 21 00 00 DD F9 DD E1 C9
R 00 00 00 00 00 05 01 00
T 64 01
R 00 00 00 00
T 64 01 25 73 20 25 73 20 25 32 64 20 25 30 32 64
R 00 00 00 00
T 72 01 3A 25 30 32 64 3A 25 30 32 64 20 25 30 34
R 00 00 00 00
T 80 01 64 0A 00
R 00 00 00 00
T 83 01
R 00 00 00 00
T 83 01 C1 E1 E5 C5 E5 CD 91 01 E3 CD B2 00 F1 C9
R 00 00 00 00 00 08 00 00 00 0C 00 00
T 91 01
R 00 00 00 00
T 91 01 C1 E1 E5 C5 E5 CD 9B 01 F1 C9
R 00 00 00 00 00 08 00 00
T 9B 01
R 00 00 00 00
T 9B 01 DD E5 DD 21 00 00 DD 39 21 EF FF 39 F9 DD
R 00 00 00 00
T A9 01 6E 04 DD 66 05 5E 23 56 23 4E 23 46 C5 D5
R 00 00 00 00
T B7 01 21 00 00 E5 21 3C 00 E5 C5 D5 CD 00 00 F1
R 00 00 00 00 02 0D 01 00
T C5 01 F1 F1 F1 DD 72 F5 DD 73 F4 DD 74 F3 DD 75
R 00 00 00 00
T D3 01 F2 D1 C1 DD 7E F2 32 20 00 21 00 00 E5 21
R 00 00 00 00 00 09 01 00
T E1 01 3C 00 E5 C5 D5 CD 00 00 F1 F1 F1 F1 4D 44
R 00 00 00 00 02 08 03 00
T EF 01 C5 D5 21 00 00 E5 21 3C 00 E5 D5 C5 CD
R 00 00 00 00
T FC 01 00 00 F1 F1 F1 F1 DD 72 F5 DD 73 F4 DD 74
R 00 00 00 00 02 02 01 00
T 0A 02 F3 DD 75 F2 D1 C1 DD 7E F2 32 21 00 21
R 00 00 00 00 00 0C 01 00
T 17 02 00 00 E5 21 3C 00 E5 D5 C5 CD 00 00 F1 F1
R 00 00 00 00 02 0C 03 00
T 25 02 F1 F1 4D 44 C5 D5 21 00 00 E5 21 18 00 E5
R 00 00 00 00
T 33 02 D5 C5 CD 00 00 F1 F1 F1 F1 DD 72 F5 DD 73
R 00 00 00 00 02 05 01 00
T 41 02 F4 DD 74 F3 DD 75 F2 D1 C1 DD 7E F2 32
R 00 00 00 00
T 4E 02 22 00 21 00 00 E5 21 18 00 E5 D5 C5 CD
R 00 00 00 00 00 02 01 00
T 5B 02 00 00 F1 F1 F1 F1 DD 75 F2 DD 74 F3 DD 73
R 00 00 00 00 02 02 03 00
T 69 02 F4 DD 72 F5 DD 7E F2 C6 04 5F DD 7E F3 CE
R 00 00 00 00
T 77 02 00 57 DD 7E F4 CE 00 4F DD 7E F5 CE 00 47
R 00 00 00 00
T 85 02 21 00 00 E5 21 07 00 E5 C5 D5 CD 00 00 F1
R 00 00 00 00 02 0D 01 00
T 93 02 F1 F1 F1 7D 32 27 00 01 00 00 11 00 00 DD
R 00 00 00 00 00 07 01 00
T A1 02 36 F0 B2 DD 36 F1 07
R 00 00 00 00
T A8 02
R 00 00 00 00
T A8 02 DD 7E F0 E6 03 DD 77 FA DD 36 FB 00 3E 00
R 00 00 00 00
T B6 02 DD B6 FA 20 05 21 6E 01 18 03
R 00 00 00 00
T C0 02
R 00 00 00 00
T C0 02 21 6D 01
R 00 00 00 00
T C3 02
R 00 00 00 00
T C3 02 DD 75 F6 DD 74 F7 7C 17 9F DD 77 F8 DD 77
R 00 00 00 00
T D1 02 F9 79 DD 86 F6 DD 77 F6 78 DD 8E F7 DD 77
R 00 00 00 00
T DF 02 F7 7B DD 8E F8 DD 77 F8 7A DD 8E F9 DD 77
R 00 00 00 00
T ED 02 F9 DD 4E F6 DD 46 F7 DD 5E F8 DD 56 F9 DD
R 00 00 00 00
T FB 02 7E F2 DD 96 F6 DD 7E F3 DD 9E F7 DD 7E F4
R 00 00 00 00
T 09 03 DD 9E F8 DD 7E F5 DD 9E F9 38 0A DD 34 F0
R 00 00 00 00
T 17 03 20 8F DD 34 F1 18 8A
R 00 00 00 00
T 1E 03
R 00 00 00 00
T 1E 03 FD 21 25 00 DD 7E F0 C6 94 67 DD 7E F1 CE
R 00 00 00 00 00 04 01 00
T 2C 03 F8 FD 74 00 FD 77 01 DD 7E FA DD 77 F6 DD
R 00 00 00 00
T 3A 03 7E FB DD 77 F7 DD 7E FB DD B6 FA 20 05 21
R 00 00 00 00
T 48 03 6E 01 18 03
R 00 00 00 00
T 4C 03
R 00 00 00 00
T 4C 03 21 6D 01
R 00 00 00 00
T 4F 03
R 00 00 00 00
T 4F 03 DD 75 FC DD 74 FD 7C 17 9F DD 77 FE DD 77
R 00 00 00 00
T 5D 03 FF 79 DD 96 FC 6F 78 DD 9E FD 67 7B DD 9E
R 00 00 00 00
T 6B 03 FE 5F 7A DD 9E FF 57 DD 7E F2 95 DD 77 FC
R 00 00 00 00
T 79 03 DD 7E F3 9C DD 77 FD DD 7E F4 9B DD 77 FE
R 00 00 00 00
T 87 03 DD 7E F5 9A DD 77 FF DD 5E FC DD 56 FD ED
R 00 00 00 00
T 95 03 53 28 00 DD 36 EF 00
R 00 00 00 00 00 03 01 00
T 9C 03
R 00 00 00 00
T 9C 03 DD 7E EF 3D 20 10 DD 7E F7 DD B6 F6 20 04
R 00 00 00 00
T AA 03 0E 1D 18 1A
R 00 00 00 00
T AE 03
R 00 00 00 00
T AE 03 0E 1C 18 16
R 00 00 00 00
T B2 03
R 00 00 00 00
T B2 03 3E 00 00 DD 86 EF DD 77 FA 3E 00 00 CE 00
R 00 00 00 00 09 03 02 00 89 0C 02 00
T BE 03 DD 77 FB DD 6E FA DD 66 FB 4E
R 00 00 00 00
T C8 03
R 00 00 00 00
T C8 03 DD 71 F2 DD 36 F3 00 DD 36 F4 00 DD 36 F5
R 00 00 00 00
T D6 03 00 DD 7E FC DD 96 F2 DD 7E FD DD 9E F3 DD
R 00 00 00 00
T E4 03 7E FE DD 9E F4 DD 7E FF DD 9E F5 38 2F DD
R 00 00 00 00
T F2 03 7E FC DD 96 F2 DD 77 FC DD 7E FD DD 9E F3
R 00 00 00 00
T 00 04 DD 77 FD DD 7E FE DD 9E F4 DD 77 FE DD 7E
R 00 00 00 00
T 0E 04 FF DD 9E F5 DD 77 FF DD 34 EF DD 7E EF D6
R 00 00 00 00
T 1C 04 0C DA 9C 03
R 00 00 00 00 00 04 00 00
T 20 04
R 00 00 00 00
T 20 04 21 24 00 DD 7E EF 77 21 23 00 DD 7E FC 3C
R 00 00 00 00 00 03 01 00 00 0A 01 00
T 2E 04 77 21 2A 00 36 00 21 20 00 DD F9 DD E1 C9
R 00 00 00 00 00 04 01 00 00 09 01 00
T 3C 04
R 00 00 00 00
T 3C 04 DD E5 DD 21 00 00 DD 39 21 F2 FF 39 F9 DD
R 00 00 00 00
T 4A 04 7E 04 DD 77 F8 DD 7E 05 DD 77 F9 DD 6E F8
R 00 00 00 00
T 58 04 DD 66 F9 11 05 00 19 5E 23 56 21 6C 07 19
R 00 00 00 00
T 66 04 DD 75 F4 DD 74 F5 DD 6E F8 DD 66 F9 11
R 00 00 00 00
T 73 04 04 00 19 7E DD 77 F2 DD 36 F3 00 DD 6E F8
R 00 00 00 00
T 81 04 DD 66 F9 E5 CD 50 00 F1 DD 7E F4 C6 4E 5F
R 00 00 00 00 00 07 00 00
T 8F 04 DD 7E F5 CE F8 57 17 9F 6F 67 E5 D5 21
R 00 00 00 00
T 9C 04 E1 01 E5 21 80 33 E5 CD 00 00 F1 F1 F1 F1
R 00 00 00 00 02 0A 05 00
T AA 04 DD 75 FA DD 74 FB DD 73 FC DD 72 FD DD 36
R 00 00 00 00
T B8 04 F6 B2 DD 36 F7 07
R 00 00 00 00
T BE 04
R 00 00 00 00
T BE 04 DD 7E F6 DD 96 F4 DD 7E F7 DD 9E F5 E2
R 00 00 00 00
T CB 04 CF 04 EE 80
R 00 00 00 00 00 02 00 00
T CF 04
R 00 00 00 00
T CF 04 F2 10 05 21 04 00 E5 DD 6E F6 DD 66 F7 E5
R 00 00 00 00 00 03 00 00
T DD 04 CD 00 00 F1 F1 7C B5 20 20 DD 7E FA C6 80
R 00 00 00 00 02 03 04 00
T EB 04 DD 77 FA DD 7E FB CE 51 DD 77 FB DD 7E FC
R 00 00 00 00
T F9 04 CE 01 DD 77 FC DD 7E FD CE 00 DD 77 FD
R 00 00 00 00
T 06 05
R 00 00 00 00
T 06 05 DD 34 F6 20 B3 DD 34 F7 18 AE
R 00 00 00 00
T 10 05
R 00 00 00 00
T 10 05 21 04 00 E5 DD 6E F4 DD 66 F5 E5 CD 00 00
R 00 00 00 00 02 0E 04 00
T 1E 05 F1 F1 DD 74 FF DD 75 FE 11 00 00
R 00 00 00 00
T 29 05
R 00 00 00 00
T 29 05 7B DD 96 F2 7A DD 9E F3 E2 36 05 EE 80
R 00 00 00 00 00 0B 00 00
T 36 05
R 00 00 00 00
T 36 05 F2 AB 05 7B 3D 20 2E 7A B7 20 2A DD 7E FF
R 00 00 00 00 00 03 00 00
T 44 05 DD B6 FE 20 22 DD 7E FA C6 80 DD 77 FA DD
R 00 00 00 00
T 52 05 7E FB CE 3B DD 77 FB DD 7E FC CE 26 DD 77
R 00 00 00 00
T 60 05 FC DD 7E FD CE 00 DD 77 FD 18 3C
R 00 00 00 00
T 6B 05
R 00 00 00 00
T 6B 05 21 00 00 19 7E 4F 17 9F 47 6F 67 D5 E5 C5
R 00 00 00 00 00 03 02 00
T 79 05 21 01 00 E5 21 80 51 E5 CD 00 00 F1 F1 F1
R 00 00 00 00 02 0B 05 00
T 87 05 F1 43 4A D1 DD 7E FA 85 DD 77 FA DD 7E FB
R 00 00 00 00
T 95 05 8C DD 77 FB DD 7E FC 88 DD 77 FC DD 7E FD
R 00 00 00 00
T A3 05 89 DD 77 FD
R 00 00 00 00
T A7 05
R 00 00 00 00
T A7 05 13 C3 29 05
R 00 00 00 00 00 04 00 00
T AB 05
R 00 00 00 00
T AB 05 DD 6E F8 DD 66 F9 23 23 23 5E 16 00 1B 7A
R 00 00 00 00
T B9 05 17 9F 6F 67 E5 D5 21 01 00 E5 21 80 51 E5
R 00 00 00 00
T C7 05 CD 00 00 F1 F1 F1 F1 DD 7E FA 85 DD 77 FA
R 00 00 00 00 02 03 05 00
T D5 05 DD 7E FB 8C DD 77 FB DD 7E FC 8B DD 77 FC
R 00 00 00 00
T E3 05 DD 7E FD 8A DD 77 FD DD 6E F8 DD 66 F9 23
R 00 00 00 00
T F1 05 23 5E 16 00 21 00 00 E5 D5 21 00 00 E5 21
R 00 00 00 00
T FF 05 10 0E E5 CD 00 00 F1 F1 F1 F1 DD 7E FA 85
R 00 00 00 00 02 06 05 00
T 0D 06 DD 77 FA DD 7E FB 8C DD 77 FB DD 7E FC 8B
R 00 00 00 00
T 1B 06 DD 77 FC DD 7E FD 8A DD 77 FD DD 6E F8 DD
R 00 00 00 00
T 29 06 66 F9 23 4E 06 00 69 60 29 09 29 09 29 09
R 00 00 00 00
T 37 06 29 29 7C 17 9F 5F 57 DD 7E FA 85 4F DD 7E
R 00 00 00 00
T 45 06 FB 8C 47 DD 7E FC 8B 5F DD 7E FD 8A 57 DD
R 00 00 00 00
T 53 06 6E F8 DD 66 F9 6E 26 00 DD 75 FA DD 74 FB
R 00 00 00 00
T 61 06 7C 17 9F DD 77 FC DD 77 FD 79 DD 86 FA 6F
R 00 00 00 00
T 6F 06 78 DD 8E FB 67 7B DD 8E FC 5F 7A DD 8E FD
R 00 00 00 00
T 7D 06 57 DD F9 DD E1 C9
R 00 00 00 00
T 83 06
R 00 00 00 00
T 83 06 4A 61 6E 00
R 00 00 00 00
T 87 06
R 00 00 00 00
T 87 06 46 65 62 00
R 00 00 00 00
T 8B 06
R 00 00 00 00
T 8B 06 4D 61 72 00
R 00 00 00 00
T 8F 06
R 00 00 00 00
T 8F 06 41 70 72 00
R 00 00 00 00
T 93 06
R 00 00 00 00
T 93 06 4D 61 79 00
R 00 00 00 00
T 97 06
R 00 00 00 00
T 97 06 4A 75 6E 00
R 00 00 00 00
T 9B 06
R 00 00 00 00
T 9B 06 4A 75 6C 00
R 00 00 00 00
T 9F 06
R 00 00 00 00
T 9F 06 41 75 67 00
R 00 00 00 00
T A3 06
R 00 00 00 00
T A3 06 53 65 70 00
R 00 00 00 00
T A7 06
R 00 00 00 00
T A7 06 4F 63 74 00
R 00 00 00 00
T AB 06
R 00 00 00 00
T AB 06 4E 6F 76 00
R 00 00 00 00
T AF 06
R 00 00 00 00
T AF 06 44 65 63 00
R 00 00 00 00
T B3 06
R 00 00 00 00
T B3 06 53 75 6E 00
R 00 00 00 00
T B7 06
R 00 00 00 00
T B7 06 4D 6F 6E 00
R 00 00 00 00
T BB 06
R 00 00 00 00
T BB 06 54 75 65 00
R 00 00 00 00
T BF 06
R 00 00 00 00
T BF 06 57 65 64 00
R 00 00 00 00
T C3 06
R 00 00 00 00
T C3 06 54 68 75 00
R 00 00 00 00
T C7 06
R 00 00 00 00
T C7 06 46 72 69 00
R 00 00 00 00
T CB 06
R 00 00 00 00
T CB 06 53 61 74 00
R 00 00 00 00
T 00 00
R 00 00 07 00
T 00 00 1F 1C 1F 1E 1F 1E 1F 1F 1E 1F 1E 1F
R 00 00 07 00
T 0C 00
R 00 00 07 00
T 0C 00 83 06 87 06 8B 06
R 00 00 07 00 00 02 00 00 00 04 00 00 00 06 00 00
T 12 00 8F 06 93 06 97 06
R 00 00 07 00 00 02 00 00 00 04 00 00 00 06 00 00
T 18 00 9B 06 9F 06 A3 06
R 00 00 07 00 00 02 00 00 00 04 00 00 00 06 00 00
T 1E 00 A7 06 AB 06 AF 06
R 00 00 07 00 00 02 00 00 00 04 00 00 00 06 00 00
T 24 00
R 00 00 07 00
T 24 00 B3 06 B7 06 BB 06
R 00 00 07 00 00 02 00 00 00 04 00 00 00 06 00 00
T 2A 00 BF 06 C3 06 C7 06
R 00 00 07 00 00 02 00 00 00 04 00 00 00 06 00 00
T 30 00 CB 06
R 00 00 07 00 00 02 00 00

_itoa.rel/      1458795435  2001  2501  100664  2054      `
XL2
H 9 areas 5 global symbols
M _itoa
O -mz80
S __divuint Ref0000
S .__.ABS. Def0000
S __moduint Ref0000
A _CODE size 116 flags 0 addr 0
S __uitoa Def0000
S __itoa Def00C7
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 F5 3B 0E 00
R 00 00 00 00
T 0C 00
R 00 00 00 00
T 0C 00 DD 7E 06 81 DD 77 FE DD 7E 07 CE 00 DD 77
R 00 00 00 00
T 1A 00 FF DD 5E 08 16 00 C5 D5 D5 DD 6E 04 DD 66
R 00 00 00 00
T 28 00 05 E5 CD 00 00 F1 F1 D1 C1 7D C6 30 47 DD
R 00 00 00 00 02 05 02 00
T 36 00 6E FE DD 66 FF 70 3E 39 90 E2 44 00 EE 80
R 00 00 00 00 00 0C 00 00
T 44 00
R 00 00 00 00
T 44 00 F2 57 00 DD 6E FE DD 66 FF 7E C6 07 DD 6E
R 00 00 00 00 00 03 00 00
T 52 00 FE DD 66 FF 77
R 00 00 00 00
T 57 00
R 00 00 00 00
T 57 00 C5 D5 DD 6E 04 DD 66 05 E5 CD 00 00 F1 F1
R 00 00 00 00 02 0C 00 00
T 65 00 C1 DD 75 04 DD 74 05 0C DD 7E 05 DD B6 04
R 00 00 00 00
T 73 00 20 97 51 15 DD 6E 06 DD 66 07 06 00 09 36
R 00 00 00 00
T 81 00 00 1E 00
R 00 00 00 00
T 84 00
R 00 00 00 00
T 84 00 7B 92 E2 8B 00 EE 80
R 00 00 00 00 00 05 00 00
T 8B 00
R 00 00 00 00
T 8B 00 F2 C2 00 DD 7E 06 83 4F DD 7E 07 CE 00 47
R 00 00 00 00 00 03 00 00
T 99 00 0A DD 77 FD DD 7E 06 82 DD 77 FE DD 7E 07
R 00 00 00 00
T A7 00 CE 00 DD 77 FF DD 6E FE DD 66 FF 7E 02 DD
R 00 00 00 00
T B5 00 6E FE DD 66 FF DD 7E FD 77 1C 15 18 C2
R 00 00 00 00
T C2 00
R 00 00 00 00
T C2 00 DD F9 DD E1 C9
R 00 00 00 00
T C7 00
R 00 00 00 00
T C7 00 DD E5 DD 21 00 00 DD 39 DD CB 05 7E 28 25
R 00 00 00 00
T D5 00 DD 7E 08 D6 0A 20 1E DD 6E 06 DD 66 07 36
R 00 00 00 00
T E3 00 2D 23 DD 75 06 DD 74 07 AF DD 96 04 DD 77
R 00 00 00 00
T F1 00 04 3E 00 DD 9E 05 DD 77 05
R 00 00 00 00
T FA 00
R 00 00 00 00
T FA 00 DD 7E 08 F5 33 DD 6E 06 DD 66 07 E5 DD 6E
R 00 00 00 00
T 08 01 04 DD 66 05 E5 CD 00 00 F1 F1 33 DD E1 C9
R 00 00 00 00 00 08 00 00
_ltoa.rel/      1458795435  2001  2501  100664  2032      `
XL2
H 9 areas 5 global symbols
M _ltoa
O -mz80
S .__.ABS. Def0000
S __modulong Ref0000
S __divulong Ref0000
A _CODE size 130 flags 0 addr 0
S __ultoa Def0000
S __ltoa Def00C8
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 21 DB FF 39 F9 21
R 00 00 00 00
T 0E 00 01 00 39 4D 44 DD 36 DB 20
R 00 00 00 00
T 17 00
R 00 00 00 00
T 17 00 DD 7E 0A DD 77 FC DD 36 FD 00 DD 36 FE 00
R 00 00 00 00
T 25 00 DD 36 FF 00 C5 DD 6E FE DD 66 FF E5 DD 6E
R 00 00 00 00
T 33 00 FC DD 66 FD E5 DD 6E 06 DD 66 07 E5 DD 6E
R 00 00 00 00
T 41 00 04 DD 66 05 E5 CD 00 00 F1 F1 F1 F1 C1 7D
R 00 00 00 00 02 08 01 00
T 4F 00 C6 30 57 3E 39 92 30 04 7A C6 07 57
R 00 00 00 00
T 5B 00
R 00 00 00 00
T 5B 00 DD 35 DB DD 6E DB 26 00 09 72 C5 DD 6E FE
R 00 00 00 00
T 69 00 DD 66 FF E5 DD 6E FC DD 66 FD E5 DD 6E 06
R 00 00 00 00
T 77 00 DD 66 07 E5 DD 6E 04 DD 66 05 E5 CD 00 00
R 00 00 00 00 02 0E 02 00
T 85 00 F1 F1 F1 F1 C1 DD 75 04 DD 74 05 DD 73 06
R 00 00 00 00
T 93 00 DD 72 07 7A DD B6 06 DD B6 05 DD B6 04 C2
R 00 00 00 00
T A1 00 17 00 DD 5E 08 DD 56 09 D5 FD E1 DD 56 DB
R 00 00 00 00 00 02 00 00
T AF 00
R 00 00 00 00
T AF 00 6A 26 00 09 7E FD 77 00 FD 23 14 7A D6 20
R 00 00 00 00
T BD 00 20 F0 FD 36 00 00 DD F9 DD E1 C9
R 00 00 00 00
T C8 00
R 00 00 00 00
T C8 00 DD E5 DD 21 00 00 DD 39 DD CB 07 7E 28 35
R 00 00 00 00
T D6 00 DD 7E 0A D6 0A 20 2E DD 6E 08 DD 66 09 36
R 00 00 00 00
T E4 00 2D 23 DD 75 08 DD 74 09 AF DD 96 04 DD 77
R 00 00 00 00
T F2 00 04 3E 00 DD 9E 05 DD 77 05 3E 00 DD 9E 06
R 00 00 00 00
T 00 01 DD 77 06 3E 00 DD 9E 07 DD 77 07
R 00 00 00 00
T 0B 01
R 00 00 00 00
T 0B 01 DD 7E 0A F5 33 DD 6E 08 DD 66 09 E5 DD 6E
R 00 00 00 00
T 19 01 06 DD 66 07 E5 DD 6E 04 DD 66 05 E5 CD
R 00 00 00 00
T 26 01 00 00 21 07 00 39 F9 DD E1 C9
R 00 00 00 00 00 02 00 00
_startup.rel/   1458795435  2001  2501  100664  445       `
XL2
H 9 areas 2 global symbols
M _startup
O -mz80
S .__.ABS. Def0000
A _CODE size 0 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 3 flags 0 addr 0
S __sdcc_external_startup Def0000
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 04 00
T 00 00 2E 00 C9
R 00 00 04 00

sprintf.rel/    1458795435  2001  2501  100664  1198      `
XL2
H 9 areas 4 global symbols
M sprintf
O -mz80
S __print_format Ref0000
S .__.ABS. Def0000
A _CODE size 8C flags 0 addr 0
S _vsprintf Def0020
S _sprintf Def0055
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 DD E5 DD 21 00 00 DD 39 DD 6E 05 DD 66 06
R 00 00 00 00
T 0E 00 E5 5E 23 56 E1 4B 42 03 71 23 70 DD 7E 04
R 00 00 00 00
T 1C 00 12 DD E1 C9
R 00 00 00 00
T 20 00
R 00 00 00 00
T 20 00 21 02 00 39 FD 21 06 00 FD 39 FD 4E 00 FD
R 00 00 00 00
T 2E 00 46 01 C5 FD 21 06 00 FD 39 FD 4E 00 FD 46
R 00 00 00 00
T 3C 00 01 C5 E5 21 00 00 E5 CD 00 00 F1 F1 F1 F1
R 00 00 00 00 00 06 00 00 02 0A 00 00
T 4A 00 55 5C C1 E1 E5 C5 36 00 6A 63 C9
R 00 00 00 00
T 55 00
R 00 00 00 00
T 55 00 DD E5 DD 21 00 00 DD 39 21 08 00 39 55 5C
R 00 00 00 00
T 63 00 21 04 00 39 4A 43 C5 DD 4E 06 DD 46 07 C5
R 00 00 00 00
T 71 00 E5 21 00 00 E5 CD 00 00 F1 F1 F1 F1 55 5C
R 00 00 00 00 00 04 00 00 02 08 00 00
T 7F 00 DD 6E 04 DD 66 05 36 00 6A 63 DD E1 C9
R 00 00 00 00
vprintf.rel/    1458795436  2001  2501  100664  938       `
XL2
H 9 areas 5 global symbols
M vprintf
O -mz80
S __print_format Ref0000
S _putchar Ref0000
S .__.ABS. Def0000
A _CODE size 49 flags 0 addr 0
S _vprintf Def000C
S _printf Def002C
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _DABS size 0 flags 8 addr 0
A _HOME size 0 flags 0 addr 0
A _GSINIT size 0 flags 0 addr 0
A _GSFINAL size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _CABS size 0 flags 8 addr 0
T 00 00
R 00 00 00 00
T 00 00 21 02 00 39 7E F5 33 CD 00 00 33 C9
R 00 00 00 00 02 0A 01 00
T 0C 00
R 00 00 00 00
T 0C 00 21 04 00 39 4E 23 46 C5 21 04 00 39 4E 23
R 00 00 00 00
T 1A 00 46 C5 21 00 00 E5 21 00 00 E5 CD 00 00 F1
R 00 00 00 00 00 09 00 00 02 0D 00 00
T 28 00 F1 F1 F1 C9
R 00 00 00 00
T 2C 00
R 00 00 00 00
T 2C 00 21 04 00 39 E5 21 04 00 39 4E 23 46 C5 21
R 00 00 00 00
T 3A 00 00 00 E5 21 00 00 E5 CD 00 00 F1 F1 F1 F1
R 00 00 00 00 00 06 00 00 02 0A 00 00
T 48 00 C9
R 00 00 00 00
XL2
H 14 areas 8 global symbols
M crt0
S _main Ref0000
S .__.ABS. Def0000
S s__INITIALIZED Ref0000
S l__INITIALIZER Ref0000
S s__INITIALIZER Ref0000
A _CODE size A flags 0 addr 0
S __clock Def0000
S _exit Def0004
A _HEADER size 0 flags 8 addr 0
A _HEADER0 size 3 flags 8 addr 0
A _HEADER1 size 2 flags 8 addr 8
A _HEADER2 size 2 flags 8 addr 10
A _HEADER3 size 2 flags 8 addr 18
A _HEADER4 size 2 flags 8 addr 20
A _HEADER5 size 2 flags 8 addr 28
A _HEADER6 size 2 flags 8 addr 30
A _HEADER7 size 2 flags 8 addr 38
A _HEADER8 size C flags 8 addr 100
A _HOME size 0 flags 0 addr 0
A _INITIALIZER size 0 flags 0 addr 0
A _GSINIT size F flags 0 addr 0
S gsinit Def0000
A _GSFINAL size 1 flags 0 addr 0
A _DATA size 0 flags 0 addr 0
A _INITIALIZED size 0 flags 0 addr 0
A _BSEG size 0 flags 0 addr 0
A _BSS size 0 flags 0 addr 0
A _HEAP size 0 flags 0 addr 0
T 00 00
R 00 00 02 00
T 00 00 C3 00 01
R 00 00 02 00 00 03 0A 00
T 08 00
R 00 00 03 00
T 08 00 ED 4D
R 00 00 03 00
T 10 00
R 00 00 04 00
T 10 00 ED 4D
R 00 00 04 00
T 18 00
R 00 00 05 00
T 18 00 ED 4D
R 00 00 05 00
T 20 00
R 00 00 06 00
T 20 00 ED 4D
R 00 00 06 00
T 28 00
R 00 00 07 00
T 28 00 ED 4D
R 00 00 07 00
T 30 00
R 00 00 08 00
T 30 00 ED 4D
R 00 00 08 00
T 38 00
R 00 00 09 00
T 38 00 ED 4D
R 00 00 09 00
T 00 01
R 00 00 0A 00
T 00 01
R 00 00 0A 00
T 00 01 31 00 00 CD 00 00 CD 00 00 C3 04 00
R 00 00 0A 00 00 06 0D 00 02 09 00 00 00 0C 00 00
T 00 00
R 00 00 00 00
T 00 00 3E 02 CF C9
R 00 00 00 00
T 04 00
R 00 00 00 00
T 04 00 3E 00 CF
R 00 00 00 00
T 07 00
R 00 00 00 00
T 07 00 76 18 FD
R 00 00 00 00
T 00 00
R 00 00 0D 00
T 00 00 01 00 00 78 B1 28 08 11 00 00 21 00 00 ED
R 00 00 0D 00 02 03 03 00 02 0A 02 00 02 0D 04 00
T 0E 00 B0
R 00 00 0D 00
T 0F 00
R 00 00 0D 00
T 00 00 C9
R 00 00 0E 00

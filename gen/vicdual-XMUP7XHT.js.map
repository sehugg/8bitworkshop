{
  "version": 3,
  "sources": ["../src/machine/vicdual.ts", "../src/platform/vicdual.ts"],
  "sourcesContent": ["\nimport { Z80, Z80State } from \"../common/cpu/ZilogZ80\";\nimport { BasicScanlineMachine } from \"../common/devices\";\nimport { KeyFlags, newAddressDecoder, padBytes, Keys, makeKeycodeMap, newKeyboardHandler } from \"../common/emu\";\nimport { TssChannelAdapter, MasterAudio, AY38910_Audio } from \"../common/audio\";\n\nconst CARNIVAL_KEYCODE_MAP = makeKeycodeMap([\n  [Keys.A,        2, -0x20],\n  [Keys.B,        2, -0x40],\n  [Keys.LEFT,     1, -0x10],\n  [Keys.RIGHT,    1, -0x20],\n  [Keys.UP,       1, -0x40],\n  [Keys.DOWN,     1, -0x80],\n  [Keys.START,    2, -0x10],\n  [Keys.P2_START, 3, -0x20],\n  [Keys.SELECT,   3, 0x8],\n]);\n\nconst XTAL = 15468000.0;\nconst scanlinesPerFrame = 0x106;\nconst vblankStart = 0xe0;\nconst vsyncStart = 0xec;\nconst vsyncEnd = 0xf0;\nconst cpuFrequency = XTAL / 8;\nconst hsyncFrequency = XTAL / 3 / scanlinesPerFrame;\nconst vsyncFrequency = hsyncFrequency / 0x148;\nconst cpuCyclesPerLine = cpuFrequency / hsyncFrequency;\nconst timerFrequency = 500; // input 2 bit 0x8\nconst cyclesPerTimerTick = cpuFrequency / (2 * timerFrequency);\nconst audioOversample = 2;\nconst audioSampleRate = 60 * scanlinesPerFrame; // why not hsync?\n\nexport class VicDual extends BasicScanlineMachine {\n\n  cpuFrequency = XTAL / 8; // MHz\n  canvasWidth = 256;\n  numTotalScanlines = 262;\n  numVisibleScanlines = 224;\n  defaultROMSize = 0x4040;\n  sampleRate = audioSampleRate * audioOversample;\n  cpuCyclesPerLine = cpuCyclesPerLine|0;\n  rotate = -90;\n  \n  cpu: Z80 = new Z80();\n  ram = new Uint8Array(0x1000);\n  psg: AY38910_Audio;\n  display: VicDualDisplay;\n  audioadapter;\n\n  constructor() {\n    super();\n    this.connectCPUMemoryBus(this);\n    this.connectCPUIOBus(this.newIOBus());\n    this.inputs.set([0xff, 0xff, 0xff, 0xff ^ 0x8]); // most things active low\n    this.display = new VicDualDisplay();\n    this.handler = newKeyboardHandler(this.inputs, CARNIVAL_KEYCODE_MAP, this.getKeyboardFunction());\n    this.psg = new AY38910_Audio(new MasterAudio());\n    this.audioadapter = new TssChannelAdapter(this.psg.psg, audioOversample, this.sampleRate);\n  }\n\n  getKeyboardFunction() {\n    return (o) => {\n      // reset when coin inserted\n      if (o.index == 3 && o.mask == 0x8) {\n        this.cpu.reset();\n        console.log(\"coin inserted\");\n        console.log(this.inputs)\n      }\n    }\n  };\n\n  read = newAddressDecoder([\n    [0x0000, 0x7fff, 0x3fff, (a) => { return this.rom ? this.rom[a] : null; }],\n    [0x8000, 0xffff, 0x0fff, (a) => { return this.ram[a]; }],\n  ]);\n  \n  write = newAddressDecoder([\n    [0x8000, 0xffff, 0x0fff, (a, v) => { this.ram[a] = v; }],\n  ]);\n\n  newIOBus() {\n    return {\n      read: (addr) => {\n        return this.inputs[addr & 3];\n      },\n      write: (addr, val) => {\n        if (addr & 0x1) { this.psg.selectRegister(val & 0xf); }; // audio 1\n        if (addr & 0x2) { this.psg.setData(val); }; // audio 2\n        if (addr & 0x8) { }; // TODO: assert coin status\n        if (addr & 0x40) { this.display.palbank = val & 3; }; // palette\n      }\n    };\n  }\n\n  reset() {\n    super.reset();\n    this.psg.reset();\n  }\n\n  startScanline() {\n    this.inputs[2] &= ~0x8;\n    this.inputs[2] |= ((this.frameCycles / cyclesPerTimerTick) & 1) << 3;\n    if (this.scanline == vblankStart) this.inputs[1] |= 0x8;\n    if (this.scanline == vsyncEnd) this.inputs[1] &= ~0x8;\n    this.audio && this.audioadapter.generate(this.audio);\n  }\n\n  drawScanline() {\n    this.display.drawScanline(this.ram, this.pixels, this.scanline);\n  }\n\n  loadROM(data) {\n    super.loadROM(data);\n    if (data.length >= 0x4020 && (data[0x4000] || data[0x401f])) {\n      this.display.colorprom = data.slice(0x4000, 0x4020);\n    }\n  }\n\n  loadState(state) {\n    super.loadState(state);\n    this.display.palbank = state.pb;\n  }\n  \n  saveState() {\n    var state = super.saveState();\n    state['pb'] = this.display.palbank;\n    return state;\n  }\n}\n\nclass VicDualDisplay {\n  palbank: number = 0;\n\n  palette = [\n    0xff000000, // black\n    0xff0000ff, // red\n    0xff00ff00, // green\n    0xff00ffff, // yellow\n    0xffff0000, // blue\n    0xffff00ff, // magenta\n    0xffffff00, // cyan\n    0xffffffff  // white\n  ];\n\n  // default PROM\n  colorprom = [\n    0xe0, 0x60, 0x20, 0x60, 0xc0, 0x60, 0x40, 0xc0,\n    0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0x0e,\n    0xe0, 0xe0, 0xe0, 0xe0, 0x60, 0x60, 0x60, 0x60,\n    0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0,\n  ];\n\n  // videoram 0xc000-0xc3ff\n  // RAM      0xc400-0xc7ff\n  // charram  0xc800-0xcfff\n  drawScanline(ram, pixels: Uint32Array, sl: number) {\n    if (sl >= 224) return;\n    var pixofs = sl * 256;\n    var outi = pixofs; // starting output pixel in frame buffer\n    var vramofs = (sl >> 3) << 5; // offset in VRAM\n    var yy = sl & 7; // y offset within tile\n    for (var xx = 0; xx < 32; xx++) {\n      var code = ram[vramofs + xx];\n      var data = ram[0x800 + (code << 3) + yy];\n      var col = (code >> 5) + (this.palbank << 3);\n      var color1 = this.palette[(this.colorprom[col] >> 1) & 7];\n      var color2 = this.palette[(this.colorprom[col] >> 5) & 7];\n      for (var i = 0; i < 8; i++) {\n        var bm = 128 >> i;\n        pixels[outi] = (data & bm) ? color2 : color1;\n        outi++;\n      }\n    }\n  }\n}\n", "\nimport { VicDual } from \"../machine/vicdual\";\nimport { BaseZ80MachinePlatform } from \"../common/baseplatform\";\nimport { Platform } from \"../common/baseplatform\";\nimport { PLATFORMS } from \"../common/emu\";\n\nconst VICDUAL_PRESETS = [\n  { id: 'minimal.c', name: 'Minimal Example' },\n  { id: 'hello.c', name: 'Hello World' },\n  { id: 'gfxtest.c', name: 'Graphics Test' },\n  { id: 'soundtest.c', name: 'Sound Test' },\n  { id: 'snake1.c', name: 'Siege Game (Prototype)' },\n  { id: 'snake2.c', name: 'Siege Game (Full)' },\n  { id: 'music.c', name: 'Music Player' },\n];\n\nclass VicDualPlatform extends BaseZ80MachinePlatform<VicDual> implements Platform {\n\n  newMachine()          { return new VicDual(); }\n  getPresets()          { return VICDUAL_PRESETS; }\n  getDefaultExtension() { return \".c\"; };\n  readAddress(a)        { return this.machine.read(a); }\n  // TODO loadBIOS(bios)\t{ this.machine.loadBIOS(a); }\n  getMemoryMap = function() { return { main:[\n      {name:'Cell RAM',start:0xe000,size:32*32,type:'ram'},\n      {name:'Tile RAM',start:0xe800,size:256*8,type:'ram'},\n  ] } };\n  showHelp() { return \"https://8bitworkshop.com/docs/platforms/arcade/index.html#vic-dual\" }\n}\n\nPLATFORMS['vicdual'] = VicDualPlatform;\n"],
  "mappings": "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",
  "names": []
}

{
  "version": 3,
  "sources": ["../src/machine/chips/antic.ts", "../src/machine/chips/gtia.ts", "../src/machine/chips/pokey.ts", "../src/machine/atari8.ts", "../src/platform/atari8.ts"],
  "sourcesContent": ["import { dumpRAM } from \"../../common/emu\";\nimport { hex, lpad, safe_extend } from \"../../common/util\";\n\n// ANTIC\n// https://www.atarimax.com/jindroush.atari.org/atanttim.html\n// http://www.virtualdub.org/blog/pivot/entry.php?id=243\n// http://www.beipmu.com/Antic_Timings.txt\n// https://user.xmission.com/~trevin/atari/antic_regs.html\n// https://user.xmission.com/~trevin/atari/antic_insns.html\n// http://www.atarimuseum.com/videogames/consoles/5200/conv_to_5200.html\n// https://www.virtualdub.org/downloads/Altirra%20Hardware%20Reference%20Manual.pdf\n\nconst PF_LEFT = [0, 25, 17, 9];\nconst PF_RIGHT = [0, 25 + 64, 17 + 80, 9 + 96];\n\nconst DMACTL = 0;\nconst CHACTL = 1;\nconst DLISTL = 2;\nconst DLISTH = 3;\nconst HSCROL = 4;\nconst VSCROL = 5;\nconst PMBASE = 7;\nconst CHBASE = 9;\nconst WSYNC = 10;\nconst VCOUNT = 11;\nconst PENH = 12;\nconst PENV = 13;\nconst NMIEN = 14;\nconst NMIRES = 15;\nconst NMIST = 15;\n\nconst PFNONE = 0;\nconst PFNARROW = 1;\nconst PFNORMAL = 2;\nconst PFWIDE = 3;\n\nconst NMIST_CYCLE = 12;\nconst NMI_CYCLE = 24;\nconst WSYNC_CYCLE = 212;\n\nconst ANTIC_LEFT = 17 - 4; // gtia 34, 4 cycle delay\nconst ANTIC_RIGHT = 110 - 4; // gtia 221, 4 cycle delay\nconst LAST_DMA_H = 105; // last DMA cycle\n\nexport const MODE_LINES = [0, 0, 8, 10, 8, 16, 8, 16, 8, 4, 4, 2, 1, 2, 1, 1];\n// how many bits before DMA clock repeats?\nconst MODE_PERIOD = [0, 0, 2, 2, 2, 2, 4, 4, 8, 4, 4, 4, 4, 2, 2, 2];\nconst MODE_YPERIOD = [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 2, 1, 0, 0, 0, 0];\n//const MODE_BPP = [0, 0, 1, 1, 2, 2, 1, 1, 2, 1, 2, 1, 1, 2, 2, 1];\n// how many color clocks / pixel * 2\nexport const MODE_SHIFT = [0, 0, 1, 1, 2, 2, 2, 2, 8, 4, 4, 2, 2, 2, 2, 1];\n\nexport class ANTIC {\n    read: (address: number) => number;\t// bus read function\n    nmi: () => void; // generate NMI\n\n    regs = new Uint8Array(0x10);\t\t\t\t// registers\n\n    left: number;\n    right: number;\t\t\t\t\t// left/right clocks for mode\n\n    dma_enabled: boolean = false;\n    dliop: number = 0;    // dli operation\n    mode: number = 0;\t\t\t// current mode\n    jmp = false; // TODO\n    lms = false; // TODO\n    dlarg_lo: number = 0;\n    dlarg_hi: number = 0;\n    period: number = 0;\t\t// current mode period bitmask\n    scanaddr: number = 0;  // Scan Address (via LMS)\n    startaddr: number = 0;\t// Start of line Address\n    pfbyte: number = 0;\t\t// playfield byte fetched\n    ch: number = 0;\t\t\t\t// char read\n    linesleft: number = 0; // # of lines left in mode\n    yofs: number = 0;\t\t\t// yofs fine\n    isfirstline: boolean = false;\n    v: number = 0;\t\t\t\t\t// vertical scanline #\n    h: number = 0;\t\t\t\t\t// horizontal color clock\n\n    linebuf = new Uint8Array(48);\n    dmaclock: number = 0;\n    dmaidx: number = 0;\n    output: number = 0;\n    dramrefresh = false;\n    in_vscroll = 0;\n\n    constructor(readfn, nmifn) {\n        this.read = readfn; // bus read function\n        this.nmi = nmifn; // NMI function\n    }\n    reset() {\n        this.regs.fill(0);\n        this.regs[NMIEN] = 0x00;\n        this.regs[NMIST] = 0x7f;\n        this.regs[PENH] = 0x00;\n        this.regs[PENV] = 0xff;\n        this.setReg(DMACTL, 0x0);\n        this.h = this.v = 0;\n        this.startaddr = this.scanaddr = 0;\n        this.dmaclock = 0;\n    }\n    saveState() {\n        return safe_extend(0, {}, this);\n    }\n    loadState(s) {\n        safe_extend(0, this, s);\n        this.setReg(DMACTL, s.regs[DMACTL]);\n    }\n    static stateToLongString(state): string {\n        let s = \"\";\n        s += \"H: \" + lpad(state.h, 3) + \"  V: \" + lpad(state.v, 3) + \"\\n\";\n        s += \"DLIOp: \" + hex(state.dliop, 2) + \"  Lines: \" + state.yofs + \"/\" + state.linesleft;\n        s += \"   DMA \" + (state.dma_enabled ? \"ON \" : \"off\")\n        if (state.dma_enabled) s += \" idx \" + state.dmaidx + \" clk \" + hex(state.dmaclock) \n        s += \"\\n\"\n        s += \"Addr: \" + hex(state.scanaddr, 4) + \"\\n\";\n        s += dumpRAM(state.regs, 0, 16).replace('$00', 'Regs');\n        return s;\n    }\n    setReg(a: number, v: number) {\n        switch (a) {\n            case WSYNC:\n                this.regs[WSYNC] = 0xff;\n                return; // this is readonly (we reset it)\n            case NMIRES:\n                this.regs[NMIST] = 0x1f;\n                return; // this is readonly, don't mess with it\n        }\n        this.regs[a] = v;\n    }\n    readReg(a: number) {\n        switch (a) {\n            case NMIST:\n                return this.regs[a];\n            case VCOUNT:\n                return this.v >> 1;\n            default:\n                return 0xff;\n        }\n    }\n    processDLIEntry() {\n        if (this.mode == 0) { // N Blank Lines\n            this.linesleft = ((this.dliop >> 4) & 7) + 1;\n            this.dmaclock = 0;\n        } else {\n            this.linesleft = MODE_LINES[this.mode];\n            this.period = MODE_PERIOD[this.mode];\n            if (this.jmp) {\n                this.regs[DLISTL] = this.dlarg_lo;\n                this.regs[DLISTH] = this.dlarg_hi;\n                this.mode = this.period = 0;\n                // JVB (Jump and wait for Vertical Blank)\n                if (this.dliop & 0x40) {\n                    this.linesleft = 1; //(248 - this.v) & 0xff; // TODO?\n                    this.dma_enabled = false;\n                }\n                this.dmaclock = 0;\n            } else if (this.lms) {\n                this.scanaddr = this.dlarg_lo + (this.dlarg_hi << 8);\n                //console.log('scanaddr', hex(this.scanaddr));\n            }\n            this.startaddr = this.scanaddr;\n            // horiz scroll\n            let effwidth = this.regs[DMACTL] & 3;\n            let hscroll = (this.dliop & 0x10) ? (this.regs[HSCROL] & 15) >> 1 : 0;\n            if ((this.dliop & 0x10) && effwidth < 3) effwidth++;\n            this.left = PF_LEFT[effwidth] + hscroll;\n            this.right = PF_RIGHT[effwidth] + hscroll;\n            // vertical scroll\n            let vscrol = this.regs[VSCROL] & 0xf;\n            if ((this.dliop & 0x20) ^ this.in_vscroll) {\n                if (this.in_vscroll) {\n                    this.linesleft = vscrol+1; // exiting\n                } else {\n                    this.linesleft -= vscrol; // entering\n                    this.yofs += vscrol;\n                }\n                this.linesleft &= 0xf;\n                this.in_vscroll ^= 0x20;\n            }\n        }\n    }\n\n    nextLine() {\n        if (this.linesleft > 0) {\n            this.linesleft--;\n            this.yofs++;\n            this.isfirstline = false;\n            if (this.mode >= 8 && this.linesleft) {\n                this.scanaddr = this.startaddr; // reset line addr\n            }\n        }\n    }\n\n    triggerNMI(mask: number) {\n        this.regs[NMIST] = mask | 0x1f;\n        if (this.regs[NMIEN] & mask) {\n            this.nmi();\n        }\n    }\n\n    getDlistAddr() {\n        return this.regs[DLISTL] + (this.regs[DLISTH] << 8);\n    }\n\n    nextInsn(): number {\n        let pc = this.getDlistAddr();\n        let b = this.read(pc);\n        //console.log('nextInsn', hex(pc), hex(b), this.v);\n        pc = ((pc + 1) & 0x3ff) | (pc & ~0x3ff);\n        this.regs[DLISTL] = pc & 0xff;\n        this.regs[DLISTH] = pc >> 8;\n        return b;\n    }\n\n    nextScreen(): number {\n        let b = this.read(this.scanaddr);\n        this.incScanAddr();\n        return b;\n    }\n    incScanAddr() {\n        this.scanaddr = ((this.scanaddr + 1) & 0xfff) | (this.scanaddr & ~0xfff);\n    }\n\n    dlDMAEnabled() { return this.regs[DMACTL] & 0b100000; }\n\n    isVisibleScanline() {\n        return this.v >= 8 && this.v < 248;\n    }\n    isPlayfieldDMAEnabled() {\n        return this.dma_enabled && !this.linesleft;\n    }\n    isPlayerDMAEnabled() {\n        return this.regs[DMACTL] & 0b1000;\n    }\n    isMissileDMAEnabled() {\n        return this.regs[DMACTL] & 0b1100;\n    }\n    isWSYNC() {\n        return this.regs[WSYNC] != 0;\n    }\n\n    clockPulse(): boolean {\n        let did_dma = this.isWSYNC();\n        if (!this.isVisibleScanline()) {\n            this.doVBlank();\n        } else {\n            switch (this.h) {\n                case 0:\n                    if (this.isMissileDMAEnabled()) {\n                        this.doPlayerMissileDMA(3);\n                        did_dma = true;\n                    }\n                    break;\n                case 1:\n                    if (this.isPlayfieldDMAEnabled()) {\n                        let op = this.nextInsn(); // get mode\n                        // TODO: too many booleans\n                        this.jmp = (op & ~0x40) == 0x01; // JMP insn?\n                        this.lms = (op & 0x40) != 0 && (op & 0xf) != 0; // LMS insn?\n                        this.mode = op & 0xf;\n                        this.dliop = op;\n                        this.yofs = 0;\n                        this.isfirstline = true;\n                        did_dma = true;\n                    }\n                    break;\n                case 2: case 3: case 4: case 5:\n                    if (this.isPlayerDMAEnabled()) {\n                        this.doPlayerMissileDMA(this.h + 2);\n                        did_dma = true;\n                    }\n                    break;\n                case 6:\n                case 7:\n                    if (this.isPlayfieldDMAEnabled() && this.isfirstline && (this.jmp || this.lms)) {\n                        if (this.h == 6) this.dlarg_lo = this.nextInsn();\n                        if (this.h == 7) this.dlarg_hi = this.nextInsn();\n                        did_dma = true;\n                    }\n                    break;\n                case 8:\n                    // TODO? is this at cycle 8?\n                    if (this.isfirstline) {\n                        this.processDLIEntry();\n                    }\n                    if (this.dliop & 0x80) { // TODO: what if DLI disabled?\n                        if (this.linesleft == 1) {\n                            this.triggerNMI(0x80); // DLI interrupt\n                        }\n                    }\n                    break;\n                case 9:\n                    break;\n                case 111:\n                    if (this.dma_enabled) this.nextLine();\n                    ++this.v;\n                    break;\n            }\n            this.output = 0; // background color (TODO: only for blank lines)\n            if (this.mode >= 2 && this.period) {\n                let candma = this.h <= LAST_DMA_H;\n                this.dmaclock = (this.dmaclock << 1) & 0x1ff;\n                if (this.dmaclock & (1 << this.period)) {\n                    this.dmaclock |= 1;\n                }\n                if (this.h == this.left) { this.dmaclock |= 1; this.dmaidx = 0; }\n                if (this.h == this.right) { this.dmaclock &= ~1; this.dmaidx++; }\n                if (this.dmaclock & 1) {\n                    if (this.mode < 8 && this.isfirstline) { // only read chars on 1st line\n                        if (candma) {\n                            this.linebuf[this.dmaidx] = this.nextScreen(); // read char name\n                        } else {\n                            this.incScanAddr();\n                        }\n                        did_dma = candma;\n                    }\n                    this.dmaidx++;\n                } else if (this.dmaclock & 8) {\n                    this.ch = this.linebuf[this.dmaidx - 4 / this.period]; // latch char\n                    if (candma) {\n                        this.readBitmapData(); // read bitmap\n                    } else {\n                        if (this.mode >= 8) this.incScanAddr();\n                    }\n                    did_dma = candma;\n                }\n                this.output = this.h >= this.left + 3 && this.h <= this.right + 2 ? 4 : 0;\n            }\n        }\n        if (this.h < ANTIC_LEFT || this.h > ANTIC_RIGHT) this.output = 2;\n        this.incHorizCounter();\n        if (!did_dma && this.dramrefresh) {\n            this.read(0); // to log a VRAM_READ event\n            this.dramrefresh = false;\n            did_dma = true;\n        }\n        return did_dma;\n    }\n    incHorizCounter() {\n        switch (this.h) {\n            case 25: case 25 + 4 * 1: case 25 + 4 * 2: case 25 + 4 * 3: case 25 + 4 * 4:\n            case 25 + 4 * 5: case 25 + 4 * 6: case 25 + 4 * 7: case 25 + 4 * 8:\n                this.dramrefresh = true;\n                break;\n            case 102:\n                this.regs[WSYNC] = 0; // TODO: dram refresh delay to 106?\n                break;\n            case 113:\n                this.h = 0;\n                return\n        }\n        ++this.h;\n    }\n    doVBlank() {\n        this.linesleft = this.mode = this.period = 0;\n        if (this.h == 111) { this.v++; }\n        if (this.v == 248 && this.h == 0) { this.triggerNMI(0x40); } // VBI\n        if (this.v == 262 && this.h == 112) { this.v = 0; }\n        if (this.v == 7 && this.h == 113) { \n            this.dma_enabled = this.dlDMAEnabled() != 0;\n        }\n        this.output = 2; // blank\n        this.dmaclock = 0;\n    }\n\n    doPlayerMissileDMA(section: number) {\n        let oneline = this.regs[DMACTL] & 0x10;\n        let pmaddr = this.regs[PMBASE] << 8;\n        if (oneline) {\n            pmaddr &= 0xf800;\n            pmaddr |= section << 8;\n            pmaddr |= this.v & 0xff;\n        } else {\n            pmaddr &= 0xfc00;\n            pmaddr |= section << 7;\n            pmaddr |= this.v >> 1;\n        }\n        this.read(pmaddr);\n    }\n\n    readBitmapData() {\n        const mode = this.mode;\n        if (mode < 8) {\t// character mode\n            let ch = this.ch;\n            let y = this.yofs >> MODE_YPERIOD[this.mode];\n            let addrofs = y & 7;\n            let chbase = this.regs[CHBASE];\n            // modes 6 & 7\n            if ((mode & 0xe) == 6) { // or 7\n                ch &= 0x3f;\n                chbase &= 0xfe;\n            } else {\n                ch &= 0x7f;\n                chbase &= 0xfc;\n            }\n            let addr = (ch << 3) + (chbase << 8);\n            // modes 2 & 3\n            if ((mode & 0xe) == 2) { // or 3\n                let chactl = this.regs[CHACTL];\n                let mode3lc = mode == 3 && (ch & 0x60) == 0x60;\n                if (chactl & 4)\n                    this.pfbyte = this.read(addr + (addrofs ^ 7)); // mirror\n                else\n                    this.pfbyte = this.read(addr + addrofs);\n                if (mode3lc && y < 2) { this.pfbyte = 0; }\n                if (!mode3lc && y > 7) { this.pfbyte = 0; }\n                if (this.ch & 0x80) {\n                    if (chactl & 1)\n                        this.pfbyte = 0x0; // blank\n                    if (chactl & 2)\n                        this.pfbyte ^= 0xff; // invert\n                }\n            } else {\n                this.pfbyte = this.read(addr + addrofs);\n            }\n        } else {\t// map mode\n            this.pfbyte = this.nextScreen();\n        }\n    }\n\n    shiftout() {\n        if (this.output == 4) { // visible pixel?\n            switch (this.mode) {\n                case 2: case 3:\n                case 15:\n                    {\n                        let v = (this.pfbyte >> 7) & 1;\n                        this.pfbyte <<= 1;\n                        return v ? 8 : 6;\n                    }\n                case 6: case 7:\n                    {\n                        let v = (this.pfbyte >> 7) & 1;\n                        this.pfbyte <<= 1;\n                        return v ? (this.ch >> 6) + 4 : 0;\n                    }\n                case 9: case 11: case 12:\n                    {\n                        let v = (this.pfbyte >> 7) & 1;\n                        this.pfbyte <<= 1;\n                        return v ? 4 : 0;\n                    }\n                case 4: case 5:\n                    {\n                        let v = (this.pfbyte >> 6) & 3;\n                        this.pfbyte <<= 2;\n                        if (this.ch & 0x80)\n                            return [0, 4, 5, 7][v];\n                        else\n                            return [0, 4, 5, 6][v];\n                    }\n                case 8: case 10:\n                case 13: case 14:\n                    {\n                        let v = (this.pfbyte >> 6) & 3;\n                        this.pfbyte <<= 2;\n                        return [0, 4, 5, 6][v];\n                    }\n            }\n        }\n        return this.output;\n    }\n\n}\n", "\n// GTIA\n// https://user.xmission.com/~trevin/atari/gtia_regs.html\n// https://user.xmission.com/~trevin/atari/gtia_pinout.html\n\nimport { dumpRAM, gtia_ntsc_to_rgb } from \"../../common/emu\";\nimport { hex, lpad, safe_extend } from \"../../common/util\";\n\n\n// write regs\nconst HPOSP0 = 0x0;\nconst HPOSM0 = 0x4;\nconst SIZEP0 = 0x8;\nconst SIZEM = 0x0c;\nconst GRAFP0 = 0x0d;\nconst GRAFM = 0x11;\nconst COLPM0 = 0x12;\nconst COLPF0 = 0x16;\nconst COLPF1 = 0x17;\nconst COLPF2 = 0x18;\nconst COLPF3 = 0x19;\nconst COLBK = 0x1a;\nconst PRIOR = 0x1b;\nconst VDELAY = 0x1c; // TODO\nconst GRACTL = 0x1d;\nconst HITCLR = 0x1e;\nconst CONSPK = 0x1f;\n// read regs\nconst M0PF = 0x0;\nconst P0PF = 0x4;\nconst M0PL = 0x8;\nconst P0PL = 0xc;\nexport const TRIG0 = 0x10;\nexport const CONSOL = 0x1f;\n\nconst HOFFSET = -9; // bias to account for antic->gtia delay\n\nconst PRIOR_TABLE : number[] = [\n  0,1,2,3, 7,7,7,7, 8,8,8,8, 4,5,6,7,   // 0001 - 0\n  0,1,2,3, 7,7,7,7, 8,8,8,8, 4,5,6,7,   // 0001\n  0,1,6,7, 5,5,5,5, 8,8,8,8, 2,3,4,5,   // 0010 - 2\n  0,1,6,7, 5,5,5,5, 8,8,8,8, 2,3,4,5,   // 0010\n  4,5,6,7, 3,3,3,3, 8,8,8,8, 0,1,2,3,   // 0100 - 4\n  4,5,6,7, 3,3,3,3, 8,8,8,8, 0,1,2,3,   // 0100\n  4,5,6,7, 3,3,3,3, 8,8,8,8, 0,1,2,3,   // 0100\n  4,5,6,7, 3,3,3,3, 8,8,8,8, 0,1,2,3,   // 0100\n  2,3,4,5, 7,7,7,7, 8,8,8,8, 0,1,6,7,   // 1000 - 8\n  2,3,4,5, 7,7,7,7, 8,8,8,8, 0,1,6,7,   // 1000\n  2,3,4,5, 7,7,7,7, 8,8,8,8, 0,1,6,7,   // 1000\n  2,3,4,5, 7,7,7,7, 8,8,8,8, 0,1,6,7,   // 1000\n  2,3,4,5, 7,7,7,7, 8,8,8,8, 0,1,6,7,   // 1000\n  2,3,4,5, 7,7,7,7, 8,8,8,8, 0,1,6,7,   // 1000\n  2,3,4,5, 7,7,7,7, 8,8,8,8, 0,1,6,7,   // 1000\n  2,3,4,5, 7,7,7,7, 8,8,8,8, 0,1,6,7,   // 1000\n];\n\nconst MODE_9_LOOKUP = [\n    COLPM0+0, COLPM0+1, COLPM0+2, COLPM0+3,\n    COLPF0+0, COLPF0+1, COLPF0+2, COLPF0+3,\n    COLBK, COLBK, COLBK, COLBK,\n    COLPF0+0, COLPF0+1, COLPF0+2, COLPF0+3,\n]\n\nexport class GTIA {\n    regs = new Uint8Array(0x20);\n    readregs = new Uint8Array(0x20);\n    shiftregs = new Uint32Array(8);\n\n    count = 0;\n    an = 0;\n    rgb = 0;\n    pmcol = 0;\n    gtiacol = 0;\n    gtiacol2 = 0;\n    hbias = HOFFSET;\n    pmDebugMask = -1;\n\n    reset() {\n        this.regs.fill(0);\n        this.readregs.fill(0); // TODO?\n        this.readregs[0x14] = 0xf; // NTSC\n        this.readregs.fill(0xf, 0x15); // default value for write-only regs\n        this.count = 0;\n    }\n    saveState() {\n        return safe_extend(0, {}, this);\n    }\n    loadState(s) {\n        safe_extend(0, this, s);\n    }\n    setReg(a: number, v: number) {\n        switch (a) {\n            case COLPM0: case COLPM0+1: case COLPM0+2: case COLPM0+3:\n            case COLPF0: case COLPF0+1: case COLPF0+2: case COLPF0+3:\n            case COLBK:\n                v &= 0xfe; // bit 0 unused in color regs\n                break;\n            case HITCLR:\n                this.readregs.fill(0, 0, 16);\n                return;\n        }\n        this.regs[a] = v;\n    }\n    readReg(a: number) {\n        switch (a) {\n            case CONSOL:\n                return this.readregs[a] & ~this.regs[CONSPK];\n        }\n        return this.readregs[a];\n    }\n    sync() {\n        this.count = 0;\n    }\n    setBias(b: number) {\n        this.hbias = HOFFSET + b;\n    }\n    updateGfx(h: number, v: number, data: number) {\n        switch (h) {\n            case 0:\n                if (this.regs[GRACTL] & 1) {\n                    // TODO: VDELAY\n                    this.regs[GRAFM] = data;\n                }\n                break;\n            case 2: case 3: case 4: case 5:\n                if (this.regs[GRACTL] & 2) {\n                    if (!(v&1) || !(this.regs[VDELAY] & (1<<(h+2))))\n                        this.regs[GRAFP0 - 2 + h] = data;\n                }\n                break;\n        }\n    }\n    getPlayfieldColor(): number {\n        // which GTIA mode?\n        switch (this.regs[PRIOR] >> 6) {\n            // normal mode\n            case 0:\n                switch (this.an) {\n                    case 0:\n                        return COLBK;\n                    case 4: case 5: case 6: case 7:\n                        return COLPF0 + this.an - 4;\n                    case 8:\n                        // combine PF2 hue and PF1 luminance\n                        return (this.regs[COLPF2] & 0xf0) | (this.regs[COLPF1] & 0x0f) | 0x100;\n                }\n                break;\n            // mode 9 -- 16 luminances\n            case 1:\n                return (this.regs[COLBK] & 0xf0) | (this.gtiacol & 0xf) | 0x100;\n            // mode 10 -- 9 colors from registers\n            case 2:\n                return MODE_9_LOOKUP[this.gtiacol];\n            // mode 11 -- 16 hues\n            case 3:\n                return (this.regs[COLBK] & 0xf) | (this.gtiacol << 4) | 0x100;\n        }\n        return 0x100; // black\n    }\n    anySpriteActive() {\n        return this.shiftregs[0] || this.shiftregs[1] || this.shiftregs[2]\n          || this.shiftregs[3] || this.shiftregs[4] || this.shiftregs[5]\n          || this.shiftregs[6] || this.shiftregs[7];\n    }\n    processPlayerMissile() {\n        // no p/m gfx, just evaluate horiz. triggers\n        if (!this.anySpriteActive()) {\n            this.evalTrigger(0);\n            this.evalTrigger(1);\n            this.evalTrigger(2);\n            this.evalTrigger(3);\n            this.evalTrigger(4);\n            this.evalTrigger(5);\n            this.evalTrigger(6);\n            this.evalTrigger(7);\n            this.pmcol = -1;\n            return;\n        }\n        // no collisions in blank area, but shift and trigger anyway\n        if (this.an == 2) {\n            this.shiftObject(0);\n            this.shiftObject(1);\n            this.shiftObject(2);\n            this.shiftObject(3);\n            this.shiftObject(4);\n            this.shiftObject(5);\n            this.shiftObject(6);\n            this.shiftObject(7);\n            this.pmcol = -1;\n            return;\n        }\n        // TODO: gtia, hi-res mode collisions\n        // compute gfx and collisions for players/missiles\n        let priobias = (this.regs[PRIOR] & 15) << 4; // TODO\n        let topprio = PRIOR_TABLE[(this.an & 7) + 8 + priobias];\n        let pfset = this.an - 4; // TODO?\n        let topobj = -1;\n        let ppmask = 0;\n        // players\n        for (let i = 0; i < 4; i++) {\n            let bit = this.shiftObject(i);\n            if (bit) {\n                if (pfset >= 0) { // TODO: hires and GTIA modes\n                    this.readregs[P0PF + i] |= 1 << pfset;\n                }\n                ppmask |= 1 << i;\n                let prio = PRIOR_TABLE[i + priobias];\n                if (prio < topprio) {\n                    topobj = i;\n                    topprio = prio;\n                }\n            }\n        }\n        // missiles\n        for (let i = 0; i < 4; i++) {\n            let bit = this.shiftObject(i + 4);\n            if (bit) {\n                if (pfset >= 0) {\n                    this.readregs[M0PF + i] |= 1 << pfset;\n                }\n                this.readregs[M0PL + i] |= ppmask;\n                let prio = (this.regs[PRIOR] & 0x10) \n                    ? PRIOR_TABLE[priobias + 15]\n                    : PRIOR_TABLE[i + priobias];\n                if (prio < topprio) {\n                    topobj = i + 4;\n                    topprio = prio;\n                }\n            }\n        }\n        // set player-player collision flags\n        // TODO: either as a player or a GTIA mode 2 color\n        if (ppmask & 1) this.readregs[P0PL + 0] |= ppmask & ~1;\n        if (ppmask & 2) this.readregs[P0PL + 1] |= ppmask & ~2;\n        if (ppmask & 4) this.readregs[P0PL + 2] |= ppmask & ~4;\n        if (ppmask & 8) this.readregs[P0PL + 3] |= ppmask & ~8;\n        this.pmcol = topobj >= 0 ? this.getObjectColor(topobj) : -1;\n    }\n    shiftObject(i: number) {\n        let bit = (this.shiftregs[i] & 0x80000000) != 0;\n        this.shiftregs[i] <<= 1;\n        this.evalTrigger(i);\n        return bit;\n    }\n    getObjectColor(i: number) {\n        if ((this.regs[PRIOR] & 0x10) && i >= 4) {\n            return this.regs[COLPF3];\n        } else {\n            return this.regs[COLPM0 + (i & 3)];\n        }\n    }\n    evalTrigger(i: number) {\n        if (this.regs[HPOSP0 + i] + this.hbias == this.count) {\n            this.triggerObject(i);\n        }\n    }\n    triggerObject(i: number) {\n        let size, data;\n        if (!(this.pmDebugMask & (1<<i))) return;\n        if (i < 4) {\n            size = this.regs[SIZEP0 + i] & 3;\n            data = this.regs[GRAFP0 + i];\n        } else {\n            let s = (i - 4) << 1;\n            size = (this.regs[SIZEM] >> s) & 3;\n            data = ((this.regs[GRAFM] >> s) & 3) << 6;\n        }\n        if (size & 1) data = expandBits(data); else data <<= 8;\n        if (size == 3) data = expandBits(data); else data <<= 16;\n        this.shiftregs[i] |= data;\n    }\n\n    clockPulse1(): void {\n        this.processPlayerMissile();\n        this.clockPulse2();\n        this.count++;\n    }\n\n    clockPulse2(): void {\n        var col: number;\n        if (this.pmcol >= 0) {\n            col = this.pmcol;\n        } else {\n            let pf = this.getPlayfieldColor();\n            col = pf & 0x100 ? pf & 0xff : this.regs[pf];\n        }\n        this.rgb = COLORS_RGBA[col];\n        // TODO: hires modes return 8, so other modes wont work\n        this.gtiacol2 = (this.gtiacol2 << 1) | (this.an >> 3);\n    }\n\n    clockPulse4() {\n        // latch GTIA buffer\n        this.gtiacol = this.gtiacol2 & 15;\n    }\n\n    static stateToLongString(state): string {\n        let s = ''\n        s += `X: ${lpad(state.count, 3)}  ANTIC: ${hex(state.an, 1)}  PM: ${hex(state.pmcol, 3)}\\n`;\n        s += \"Write Registers:\\n\";\n        s += dumpRAM(state.regs, 0, 32);\n        s += \"Read Registers:\\n\";\n        s += dumpRAM(state.readregs, 0, 32);\n        return s;\n    }\n}\n\nfunction expandBits(x: number): number {\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n    return x | (x << 1);\n}\n\nvar COLORS_RGBA = new Uint32Array(256);\nfor (var i = 0; i < 256; i++) {\n    COLORS_RGBA[i] = gtia_ntsc_to_rgb(i);\n}\n\n", "/*\n * pokey.c - POKEY sound chip emulation\n *\n * Copyright (C) 1995-1998 David Firth\n * Copyright (C) 1998-2008 Atari800 development team (see DOC/CREDITS)\n *\n * This file is part of the Atari800 emulator project which emulates\n * the Atari 400, 800, 800XL, 130XE, and 5200 8-bit computers.\n *\n * Atari800 is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Atari800 is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Atari800; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\nimport { dumpRAM } from \"../../common/emu\"\nimport { hex, lpad, safe_extend } from \"../../common/util\"\n\nconst AUDF1 = 0x00\nconst AUDC1 = 0x01\nconst AUDF2 = 0x02\nconst AUDC2 = 0x03\nconst AUDF3 = 0x04\nconst AUDC3 = 0x05\nconst AUDF4 = 0x06\nconst AUDC4 = 0x07\nconst AUDCTL = 0x08\nconst STIMER = 0x09\nconst SKRES = 0x0a\nconst POTGO = 0x0b\nconst SEROUT = 0x0d\nconst IRQEN = 0x0e\nconst SKCTL = 0x0f\n\nconst POT0 = 0x00\nconst POT1 = 0x01\nconst POT2 = 0x02\nconst POT3 = 0x03\nconst POT4 = 0x04\nconst POT5 = 0x05\nconst POT6 = 0x06\nconst POT7 = 0x07\nconst ALLPOT = 0x08\nconst KBCODE = 0x09\nconst RANDOM = 0x0a\nconst SERIN = 0x0d\nconst IRQST = 0x0e\nconst SKSTAT = 0x0f\n\n/* definitions for AUDCx (D201, D203, D205, D207) */\nconst NOTPOLY5 = 0x80          /* selects POLY5 or direct CLOCK */\nconst POLY4 = 0x40          /* selects POLY4 or POLY17 */\nconst PURETONE = 0x20          /* selects POLY4/17 or PURE tone */\nconst VOL_ONLY = 0x10          /* selects VOLUME OUTPUT ONLY */\nconst VOLUME_MASK = 0x0f          /* volume mask */\n\n/* definitions for AUDCTL (D208) */\nconst POLY9 = 0x80          /* selects POLY9 or POLY17 */\nconst CH1_179 = 0x40          /* selects 1.78979 MHz for Ch 1 */\nconst CH3_179 = 0x20          /* selects 1.78979 MHz for Ch 3 */\nconst CH1_CH2 = 0x10          /* clocks channel 1 w/channel 2 */\nconst CH3_CH4 = 0x08          /* clocks channel 3 w/channel 4 */\nconst CH1_FILTER = 0x04          /* selects channel 1 high pass filter */\nconst CH2_FILTER = 0x02          /* selects channel 2 high pass filter */\nconst CLOCK_15 = 0x01          /* selects 15.6999kHz or 63.9210kHz */\n\n/* for accuracy, the 64kHz and 15kHz clocks are exact divisions of\n   the 1.79MHz clock */\nconst DIV_64 = 28                    /* divisor for 1.79MHz clock to 64 kHz */\nconst DIV_15 = 114                   /* divisor for 1.79MHz clock to 15 kHz */\n\n/* the size (in entries) of the 4 polynomial tables */\nconst POLY4_SIZE = 0x000f\nconst POLY5_SIZE = 0x001f\nconst POLY9_SIZE = 0x01ff\nconst POLY17_SIZE = 0x0001ffff\n\nconst CHAN1 = 0\nconst CHAN2 = 1\nconst CHAN3 = 2\nconst CHAN4 = 3\n\nconst ANTIC_LINE_C = 114\n\n/* Some defines about the serial I/O timing. Currently fixed! */\nconst SIO_XMTDONE_INTERVAL = 15\nconst SIO_SERIN_INTERVAL = 8\nconst SIO_SEROUT_INTERVAL = 8\nconst SIO_ACK_INTERVAL = 36\n\nvar poly9: Uint8Array;\nvar poly17: Uint8Array;\n\nfunction initPolyTables() {\n    poly9 = new Uint8Array(511);\n    poly17 = new Uint8Array(16385);\n    /* initialise poly9_lookup */\n    let reg = 0x1ff;\n    for (let i = 0; i < 511; i++) {\n        reg = ((((reg >> 5) ^ reg) & 1) << 8) + (reg >> 1);\n        poly9[i] = reg;\n    }\n    /* initialise poly17_lookup */\n    reg = 0x1ffff;\n    for (let i = 0; i < 16385; i++) {\n        reg = ((((reg >> 5) ^ reg) & 0xff) << 9) + (reg >> 8);\n        poly17[i] = (reg >> 1);\n    }\n}\n\nexport class POKEY {\n    regs = new Uint8Array(16);\n    readregs = new Uint8Array(16);\n    divnirq = new Uint32Array(4);\n    divnmax = new Uint32Array(4);\n    pot_inputs = new Uint8Array(8);\n    basemult = 0;\n    pot_scanline = 0;\n    random_scanline_counter = 0;\n    kbcode = 0;\n    DELAYED_SERIN_IRQ = 0;\n    DELAYED_SEROUT_IRQ = 0;\n    DELAYED_XMTDONE_IRQ = 0;\n\n    constructor(\n        public irq: () => void,\n        public antic_xpos: () => number,\n    ) {\n        this.init();\n    }\n\n    saveState() {\n        return safe_extend(0, {}, this);\n    }\n    loadState(s) {\n        safe_extend(0, this, s);\n    }\n\n    init() {\n        /* Initialise Serial Port Interrupts */\n        //DELAYED_SERIN_IRQ = 0;\n        //DELAYED_SEROUT_IRQ = 0;\n        //DELAYED_XMTDONE_IRQ = 0;\n        this.readregs.fill(0xff);\n        this.readregs[SKSTAT] = 0xef;\n        //SERIN = 0x00;\t/* or 0xff ? */\n        //IRQEN = 0x00;\n        //SKCTL = 0x00;\n        this.basemult = DIV_64;\n        this.pot_inputs.fill(128);\n        initPolyTables();\n    }\n\n\n    read(addr: number): number {\n        let byte = this.readregs[addr];\n        addr &= 0xf;\n        switch (addr) {\n            case 0: case 1: case 2: case 3:\n            case 4: case 5: case 6: case 7:\n                byte = this.pot_inputs[addr];\n                return (byte < this.pot_scanline) ? byte : this.pot_scanline;\n            case ALLPOT:\n                for (let i = 0; i < 8; i++) {\n                    if (this.pot_inputs[i] <= this.pot_scanline)\n                        byte &= ~(1 << i);\t\t// reset bit if pot value known\n                }\n                break;\n            case KBCODE:\n                return this.kbcode;\n            case SKSTAT:\n                byte = SKSTAT + (this.CASSETTE_IOLineStatus() << 4);\n                break;\n            case RANDOM:\n                if ((this.regs[SKCTL] & 0x03) != 0) {\n                    let i = this.random_scanline_counter + this.antic_xpos();\n                    if (this.regs[AUDCTL] & POLY9)\n                        byte = poly9[i % POLY9_SIZE];\n                    else {\n                        i %= POLY17_SIZE;\n                        let ptr = i >> 3;\n                        i &= 7;\n                        byte = (poly17[ptr] >> i) + (poly17[ptr + 1] << (8 - i));\n                    }\n                }\n                break;\n        }\n        return byte & 0xff;\n    }\n\n    write(addr: number, byte: number): void {\n        addr &= 0x0f;\n        this.regs[addr] = byte;\n        switch (addr) {\n            case AUDCTL:\n                /* determine the base multiplier for the 'div by n' calculations */\n                if (byte & CLOCK_15)\n                    this.basemult = DIV_15;\n                else\n                    this.basemult = DIV_64;\n                this.update_counter((1 << CHAN1) | (1 << CHAN2) | (1 << CHAN3) | (1 << CHAN4));\n                break;\n            case AUDF1:\n                this.update_counter((this.regs[AUDCTL] & CH1_CH2) ? ((1 << CHAN2) | (1 << CHAN1)) : (1 << CHAN1));\n                break;\n            case AUDF2:\n                this.update_counter(1 << CHAN2);\n                break;\n            case AUDF3:\n                this.update_counter((this.regs[AUDCTL] & CH3_CH4) ? ((1 << CHAN4) | (1 << CHAN3)) : (1 << CHAN3));\n                break;\n            case AUDF4:\n                this.update_counter(1 << CHAN4);\n                break;\n            case IRQEN:\n                this.readregs[IRQST] |= ~byte & 0xf7;\t/* Reset disabled IRQs except XMTDONE */\n                let mask = ~this.readregs[IRQST] & this.regs[IRQEN];\n                if (mask) {\n                    this.generateIRQ(this.readregs[IRQST]);\n                }\n                break;\n            case SKRES:\n                this.readregs[SKSTAT] |= 0xe0;\n                break;\n            case POTGO:\n                if (!(this.regs[SKCTL] & 4))\n                    this.pot_scanline = 0;\t/* slow pot mode */\n                break;\n            case SEROUT:\n                if ((this.regs[SKCTL] & 0x70) == 0x20 && this.siocheck()) {\n                    this.SIO_PutByte(byte);\n                }\n                // check if cassette 2-tone mode has been enabled \n                if ((this.regs[SKCTL] & 0x08) == 0x00) {\n                    // intelligent device\n                    this.DELAYED_SEROUT_IRQ = SIO_SEROUT_INTERVAL;\n                    this.readregs[IRQST] |= 0x08;\n                    this.DELAYED_XMTDONE_IRQ = SIO_XMTDONE_INTERVAL;\n                }\n                else {\n                    // cassette \n                    // some savers patch the cassette baud rate, so we evaluate it here \n                    // scanlines per second*10 bit*audiofrequency/(1.79 MHz/2) \n                    this.DELAYED_SEROUT_IRQ = 312 * 50 * 10 * (this.regs[AUDF3] + this.regs[AUDF4] * 0x100) / 895000;\n                    // safety check \n                    if (this.DELAYED_SEROUT_IRQ >= 3) {\n                        this.readregs[IRQST] |= 0x08;\n                        this.DELAYED_XMTDONE_IRQ = 2 * this.DELAYED_SEROUT_IRQ - 2;\n                    }\n                    else {\n                        this.DELAYED_SEROUT_IRQ = 0;\n                        this.DELAYED_XMTDONE_IRQ = 0;\n                    }\n                };\n                break;\n            case STIMER:\n                this.divnirq[CHAN1] = this.divnmax[CHAN1];\n                this.divnirq[CHAN2] = this.divnmax[CHAN2];\n                this.divnirq[CHAN3] = this.divnmax[CHAN3];\n                this.divnirq[CHAN4] = this.divnmax[CHAN4];\n                //POKEYSND_Update(STIMER, byte, 0, SOUND_GAIN);\n                break;\n            case SKCTL:\n                //VOICEBOX_SKCTLPutByte(byte);\n                //POKEYSND_Update(SKCTL, byte, 0, SOUND_GAIN);\n                if (byte & 4)\n                    this.pot_scanline = 228;\t/* fast pot mode - return results immediately */\n                if ((byte & 0x03) == 0) {\n                    /* POKEY reset. */\n                    /* Stop serial IO. */\n                    this.DELAYED_SERIN_IRQ = 0;\n                    this.DELAYED_SEROUT_IRQ = 0;\n                    this.DELAYED_XMTDONE_IRQ = 0;\n                    // TODO: CASSETTE_ResetPOKEY();\n                    /* TODO other registers should also be reset. */\n                }\n                break;\n        }\n        this.snd_update(addr);\n        //POKEYSND_Update(AUDC1, byte, 0, SOUND_GAIN);\n    }\n\n    /*****************************************************************************/\n    /* Module:  Update_Counter()                                                 */\n    /* Purpose: To process the latest control values stored in the AUDF, AUDC,   */\n    /*          and AUDCTL registers.  It pre-calculates as much information as  */\n    /*          possible for better performance.  This routine has been added    */\n    /*          here again as I need the precise frequency for the pokey timers  */\n    /*          again. The pokey emulation is therefore somewhat sub-optimal     */\n    /*          since the actual pokey emulation should grab the frequency values */\n    /*          directly from here instead of calculating them again.            */\n    /*                                                                           */\n    /* Author:  Ron Fries,Thomas Richter                                         */\n    /* Date:    March 27, 1998                                                   */\n    /*                                                                           */\n    /* Inputs:  chan_mask: Channel mask, one bit per channel.                    */\n    /*          The channels that need to be updated                             */\n    /*                                                                           */\n    /* Outputs: Adjusts local globals - no return value                          */\n    /*                                                                           */\n    /*****************************************************************************/\n\n    update_counter(chan_mask: number): void {\n\n        /************************************************************/\n        /* As defined in the manual, the exact Div_n_cnt values are */\n        /* different depending on the frequency and resolution:     */\n        /*    64 kHz or 15 kHz - AUDF + 1                           */\n        /*    1 MHz, 8-bit -     AUDF + 4                           */\n        /*    1 MHz, 16-bit -    AUDF[CHAN1]+256*AUDF[CHAN2] + 7    */\n        /************************************************************/\n\n        /* only reset the channels that have changed */\n\n        if (chan_mask & (1 << CHAN1)) {\n            /* process channel 1 frequency */\n            if (this.regs[AUDCTL] & CH1_179)\n                this.divnmax[CHAN1] = this.regs[AUDF1 + CHAN1] + 4;\n            else\n                this.divnmax[CHAN1] = (this.regs[AUDF1 + CHAN1] + 1) * this.basemult;\n            if (this.divnmax[CHAN1] < ANTIC_LINE_C)\n                this.divnmax[CHAN1] = ANTIC_LINE_C;\n        }\n\n        if (chan_mask & (1 << CHAN2)) {\n            /* process channel 2 frequency */\n            if (this.regs[AUDCTL] & CH1_CH2) {\n                if (this.regs[AUDCTL] & CH1_179)\n                    this.divnmax[CHAN2] = this.regs[AUDF1 + CHAN2] * 256 + this.regs[AUDF1 + CHAN1] + 7;\n                else\n                    this.divnmax[CHAN2] = (this.regs[AUDF1 + CHAN2] * 256 + this.regs[AUDF1 + CHAN1] + 1) * this.basemult;\n            }\n            else\n                this.divnmax[CHAN2] = (this.regs[AUDF1 + CHAN2] + 1) * this.basemult;\n            if (this.divnmax[CHAN2] < ANTIC_LINE_C)\n                this.divnmax[CHAN2] = ANTIC_LINE_C;\n        }\n\n        if (chan_mask & (1 << CHAN4)) {\n            /* process channel 4 frequency */\n            if (this.regs[AUDCTL] & CH3_CH4) {\n                if (this.regs[AUDCTL] & CH3_179)\n                    this.divnmax[CHAN4] = this.regs[AUDF1 + CHAN4] * 256 + this.regs[AUDF1 + CHAN3] + 7;\n                else\n                    this.divnmax[CHAN4] = (this.regs[AUDF1 + CHAN4] * 256 + this.regs[AUDF1 + CHAN3] + 1) * this.basemult;\n            }\n            else\n                this.divnmax[CHAN4] = (this.regs[AUDF1 + CHAN4] + 1) * this.basemult;\n            if (this.divnmax[CHAN4] < ANTIC_LINE_C)\n                this.divnmax[CHAN4] = ANTIC_LINE_C;\n        }\n\n        //console.log(chan_mask, this.divnmax);\n    }\n\n    snd_update(addr: number) {\n\n    }\n\n    advanceScanline() {\n        /***************************************************************************\n         ** Generate POKEY Timer IRQs if required                                 **\n         ** called on a per-scanline basis, not very precise, but good enough     **\n         ** for most applications                                                 **\n         ***************************************************************************/\n\n\n        /* on nonpatched i/o-operation, enable the cassette timing */\n        /*\n        if (!ESC_enable_sio_patch) {\n            if (CASSETTE_AddScanLine())\n                DELAYED_SERIN_IRQ = 1;\n        }\n        */\n\n        if ((this.regs[SKCTL] & 0x03) == 0)\n            /* Don't process timers when POKEY is in reset mode. */\n            return;\n\n        if (this.pot_scanline < 228)\n            this.pot_scanline++;\n\n        this.random_scanline_counter += ANTIC_LINE_C;\n        this.random_scanline_counter %= (this.regs[AUDCTL] & POLY9) ? POLY9_SIZE : POLY17_SIZE;\n\n        if (this.DELAYED_SERIN_IRQ > 0) {\n            if (--this.DELAYED_SERIN_IRQ == 0) {\n                // Load a byte to SERIN - even when the IRQ is disabled. \n                this.readregs[SERIN] = this.SIO_GetByte();\n                this.generateIRQ(0x20);\n            }\n        }\n\n        if (this.DELAYED_SEROUT_IRQ > 0) {\n            if (--this.DELAYED_SEROUT_IRQ == 0) {\n                this.generateIRQ(0x10);\n            }\n        }\n\n        if (this.DELAYED_XMTDONE_IRQ > 0)\n            if (--this.DELAYED_XMTDONE_IRQ == 0) {\n                this.generateIRQ(0x08);\n            }\n\n        this.advanceIRQTimer(CHAN1, 0x1);\n        this.advanceIRQTimer(CHAN2, 0x2);\n        this.advanceIRQTimer(CHAN4, 0x4);\n    }\n\n    advanceIRQTimer(chan: number, mask: number) {\n        if ((this.divnirq[chan] -= ANTIC_LINE_C) < 0) {\n            this.divnirq[chan] += this.divnmax[chan];\n            this.generateIRQ(mask);\n            //console.log('irq', chan, this.divnirq[chan], this.divnmax[chan])\n        }\n    }\n\n    generateIRQ(mask: number) {\n        if (this.regs[IRQEN] & mask) {\n            this.irq();\n            this.readregs[IRQST] &= ~mask;\n        }\n    }\n\n    static stateToLongString(state): string {\n        let s = ''\n        s += \"Write Registers:\\n\";\n        s += dumpRAM(state.regs, 0, 16);\n        s += \"Read Registers:\\n\";\n        s += dumpRAM(state.readregs, 0, 16);\n        return s;\n    }\n\n    CASSETTE_IOLineStatus() {\n        return 0;\n    }\n\n    siocheck() {\n        return (((this.regs[AUDF1 + CHAN3] == 0x28 || this.regs[AUDF1 + CHAN3] == 0x10\n            || this.regs[AUDF1 + CHAN3] == 0x08 || this.regs[AUDF1 + CHAN3] == 0x0a)\n            && this.regs[AUDF1 + CHAN4] == 0x00) // intelligent peripherals speeds\n            || (this.regs[SKCTL] & 0x78) == 0x28) // cassette save mode\n            && (this.regs[AUDCTL] & 0x28) == 0x28;\n    }\n    SIO_PutByte(byte: number) {\n        // TODO\n        console.log(\"SIO put byte\", byte);\n    }\n    SIO_GetByte() {\n        return 0; // TODO\n    }\n\n}\n\n\n//const SOUND_GAIN 4\n/*\nvoid Frame(void)\n{\n    random_scanline_counter %= (this.regs[AUDCTL] & POLY9) ? POLY9_SIZE : POLY17_SIZE;\n}\n*/\n\n\n\n", "import { newPOKEYAudio, TssChannelAdapter } from \"../common/audio\";\nimport { MOS6502 } from \"../common/cpu/MOS6502\";\nimport { AcceptsPaddleInput, BasicScanlineMachine } from \"../common/devices\";\nimport { KeyFlags, Keys, makeKeycodeMap, newAddressDecoder, newKeyboardHandler } from \"../common/emu\";\nimport { hex } from \"../common/util\";\nimport { ANTIC, MODE_LINES, MODE_SHIFT } from \"./chips/antic\";\nimport { CONSOL, GTIA, TRIG0 } from \"./chips/gtia\";\nimport { POKEY } from \"./chips/pokey\";\n\nconst ATARI8_KEYMATRIX_INTL_NOSHIFT = [\n  Keys.VK_L, Keys.VK_J, Keys.VK_SEMICOLON, Keys.VK_F4, Keys.VK_F5, Keys.VK_K, Keys.VK_BACK_SLASH, Keys.VK_TILDE,\n  Keys.VK_O, null, Keys.VK_P, Keys.VK_U, Keys.VK_ENTER, Keys.VK_I, Keys.VK_MINUS2, Keys.VK_EQUALS2,\n  Keys.VK_V, Keys.VK_F7, Keys.VK_C, Keys.VK_F6, Keys.VK_F4, Keys.VK_B, Keys.VK_X, Keys.VK_Z,\n  Keys.VK_4, null, Keys.VK_3, Keys.VK_6, Keys.VK_ESCAPE, Keys.VK_5, Keys.VK_2, Keys.VK_1,\n  Keys.VK_COMMA, Keys.VK_SPACE, Keys.VK_PERIOD, Keys.VK_N, null, Keys.VK_M, Keys.VK_SLASH, null/*invert*/,\n  Keys.VK_R, null, Keys.VK_E, Keys.VK_Y, Keys.VK_TAB, Keys.VK_T, Keys.VK_W, Keys.VK_Q,\n  Keys.VK_9, null, Keys.VK_0, Keys.VK_7, Keys.VK_BACK_SPACE, Keys.VK_8, null, null,\n  Keys.VK_F, Keys.VK_H, Keys.VK_D, null, Keys.VK_CAPS_LOCK, Keys.VK_G, Keys.VK_S, Keys.VK_A,\n];\n\n//TODO\nvar ATARI8_KEYCODE_MAP = makeKeycodeMap([\n  [Keys.UP, 0, 0x1],\n  [Keys.DOWN, 0, 0x2],\n  [Keys.LEFT, 0, 0x4],\n  [Keys.RIGHT, 0, 0x8],\n  [{ c: 16, n: \"Shift\", plyr: 0, button: 0 }, 2, 0x1],\n  /*\n    [Keys.P2_UP, 0, 0x10],\n    [Keys.P2_DOWN, 0, 0x20],\n    [Keys.P2_LEFT, 0, 0x40],\n    [Keys.P2_RIGHT, 0, 0x80],\n    [Keys.P2_A, 3, 0x1],\n  */\n  [Keys.VK_F1, 3, 0x1],  // START\n  [Keys.VK_F2, 3, 0x2], // SELECT\n  [Keys.VK_F3, 3, 0x4], // OPTION\n]);\n\n\nexport class Atari800 extends BasicScanlineMachine implements AcceptsPaddleInput {\n\n  // http://www.ataripreservation.org/websites/freddy.offenga/megazine/ISSUE5-PALNTSC.html\n  cpuFrequency = 1789773;\n  numTotalScanlines = 262;\n  cpuCyclesPerLine = 114;\n  canvasWidth = 336;\n  numVisibleScanlines = 224;\n  aspectRatio = this.canvasWidth / this.numVisibleScanlines * 0.857;\n  firstVisibleScanline = 16;\n  firstVisibleClock = (44 - 6) * 2; // ... to 215 * 2\n  defaultROMSize = 0x8000;\n  overscan = true;\n  audioOversample = 2;\n  sampleRate = this.numTotalScanlines * 60 * this.audioOversample;\n  run_address = -1;\n\n  cpu: MOS6502;\n  ram: Uint8Array;\n  bios: Uint8Array;\n  bus;\n  audio_pokey;\n  audioadapter;\n  antic: ANTIC;\n  gtia: GTIA;\n  irq_pokey: POKEY;\n  inputs = new Uint8Array(4);\n  linergb = new Uint32Array(this.canvasWidth);\n  lastdmabyte = 0;\n  keycode = 0;\n  cart_80 = false;\n  cart_a0 = false;\n  xexdata = null;\n  keyboard_active = true;\n  d500 = new Uint8Array(0x100);\n  // TODO: save/load vars\n\n  constructor() {\n    super();\n    this.cpu = new MOS6502();\n    this.ram = new Uint8Array(0x10000);\n    this.bios = new Uint8Array(0x2800);\n    this.bus = this.newBus();\n    this.connectCPUMemoryBus(this.bus);\n    // create support chips\n    this.antic = new ANTIC(this.readDMA.bind(this), this.antic_nmi.bind(this));\n    this.gtia = new GTIA();\n    this.irq_pokey = new POKEY(this.pokey_irq.bind(this), () => this.antic.h);\n    this.audio_pokey = newPOKEYAudio(1);\n    this.audioadapter = new TssChannelAdapter(this.audio_pokey.pokey1, this.audioOversample, this.sampleRate);\n    this.handler = newKeyboardHandler(\n      this.inputs, ATARI8_KEYCODE_MAP, this.getKeyboardFunction(), true);\n  }\n  newBus() {\n    return {\n      read: newAddressDecoder([\n        [0x0000, 0x7fff, 0xffff, (a) => { return this.ram[a]; }],\n        [0x8000, 0x9fff, 0xffff, (a) => { return this.cart_80 ? this.rom[a - 0x8000] : this.ram[a]; }],\n        [0xa000, 0xbfff, 0xffff, (a) => { return this.cart_a0 ? this.rom[a - 0x8000] : this.ram[a]; }],\n        [0xd000, 0xd0ff, 0x1f, (a) => { return this.gtia.readReg(a); }],\n        [0xd200, 0xd2ff, 0xf, (a) => { return this.readPokey(a); }],\n        [0xd300, 0xd3ff, 0xf, (a) => { return this.readPIA(a); }],\n        [0xd400, 0xd4ff, 0xf, (a) => { return this.antic.readReg(a); }],\n        [0xd500, 0xd5ff, 0xff, (a) => { return this.d500[a]; }],\n        [0xd800, 0xffff, 0xffff, (a) => { return this.bios[a - 0xd800]; }],\n      ]),\n      write: newAddressDecoder([\n        [0x0000, 0xbffa, 0xffff, (a, v) => { this.ram[a] = v; }],\n        [0xbffb, 0xbfff, 0xffff, (a, v) => { this.ram[a] = v; this.initCartA(); }],\n        [0xd000, 0xd0ff, 0x1f, (a, v) => { this.gtia.setReg(a, v); }],\n        [0xd200, 0xd2ff, 0xf, (a, v) => { this.writePokey(a, v); }],\n        [0xd400, 0xd4ff, 0xf, (a, v) => { this.antic.setReg(a, v); }],\n        [0xd500, 0xd5ff, 0xff, (a, v) => { this.writeMapper(a, v); }],\n      ]),\n    };\n  }\n\n  loadBIOS(bios: Uint8Array) {\n    this.bios.set(bios);\n  }\n\n  reset() {\n    super.reset();\n    this.antic.reset();\n    this.gtia.reset();\n    this.keycode = 0;\n    //if (this.xexdata) this.cart_a0 = true; // TODO\n  }\n\n  read(a) {\n    // TODO: lastdmabyte?\n    return this.bus.read(a);\n  }\n  // used by ANTIC\n  readDMA(a) {\n    let v = this.bus.read(a);\n    this.probe.logDMARead(a, v);\n    this.lastdmabyte = v;\n    return v;\n  }\n  readConst(a) {\n    return a < 0xd000 || a >= 0xd500 ? this.bus.read(a) : 0xff;\n  }\n  write(a, v) {\n    this.bus.write(a, v);\n  }\n  readPokey(a: number) {\n    switch (a & 0xf) {\n      case 9: // KBCODE\n        return this.keycode & 0xff;\n      case 15: // SKSTAT\n        return ((~this.keycode >> 6) & 0x4) | ((~this.keycode >> 3) & 0x8) | 0x12;\n      default:\n        return this.irq_pokey.read(a);\n    }\n  }\n  readPIA(a: number) {\n    if (a == 0 || a == 1) { return ~this.inputs[a]; }\n  }\n  writePokey(a, v) {\n    this.audio_pokey.pokey1.setRegister(a, v);\n    this.irq_pokey.write(a, v);\n  }\n\n  startScanline() {\n    // TODO: if (this.antic.h != 0) throw new Error(this.antic.h+\"\");\n    //if (this.cpu.isHalted()) throw new EmuHalt(\"CPU HALTED\");\n    // set GTIA switch inputs\n    this.gtia.sync();\n    // TODO: trigger latching mode\n    for (let i = 0; i < 4; i++)\n      this.gtia.readregs[TRIG0 + i] = (~this.inputs[2] >> i) & 1;\n    // console switches\n    this.gtia.readregs[CONSOL] = ~this.inputs[3] & 0x7;\n    // advance POKEY audio\n    this.audio && this.audioadapter.generate(this.audio);\n    // advance POKEY IRQ timers\n    this.irq_pokey.advanceScanline();\n  }\n\n  drawScanline() {\n    // TODO\n    let y = this.antic.v - this.firstVisibleScanline;\n    if (y >= 0 && y < this.numVisibleScanlines) {\n      this.pixels.set(this.linergb, y * this.canvasWidth);\n    }\n  }\n\n  advanceCPU(): number {\n    // update ANTIC\n    if (this.antic.clockPulse()) {\n      // ANTIC DMA cycle, update GTIA\n      if (this.antic.h < 8)\n        this.gtia.updateGfx(this.antic.h - 1, this.antic.v, this.lastdmabyte); // HALT pin\n      if (this.antic.isWSYNC())\n        this.probe.logWait(0);\n      this.probe.logClocks(1);\n    } else {\n      super.advanceCPU();\n    }\n    // update GTIA\n    // get X coordinate within scanline\n    let xofs = this.antic.h * 4 - this.firstVisibleClock;\n    // GTIA tick functions\n    let gtiatick1 = () => {\n      this.gtia.clockPulse1();\n      this.linergb[xofs++] = this.gtia.rgb;\n    }\n    let gtiatick2 = () => {\n      this.gtia.clockPulse2();\n      this.linergb[xofs++] = this.gtia.rgb;\n    }\n    // tick 4 GTIA clocks for each CPU/ANTIC cycle\n    this.gtia.clockPulse4();\n    // correct for HSCROL -- bias antic +2, bias gtia -1\n    if ((this.antic.dliop & 0x10) && (this.antic.regs[4] & 1)) {\n      xofs += 2;\n      this.gtia.setBias(-1);\n    } else {\n      this.gtia.setBias(0);\n    }\n    let bp = MODE_SHIFT[this.antic.mode];\n    let odd = this.antic.h & 1;\n    if (bp < 8 || odd) { this.gtia.an = this.antic.shiftout(); }\n    gtiatick1();\n    if (bp == 1) { this.gtia.an = this.antic.shiftout(); }\n    gtiatick2();\n    if (bp <= 2) { this.gtia.an = this.antic.shiftout(); }\n    gtiatick1();\n    if (bp == 1) { this.gtia.an = this.antic.shiftout(); }\n    gtiatick2();\n    return 1;\n  }\n\n  loadState(state: any) {\n    this.loadControlsState(state);\n    this.cpu.loadState(state.c);\n    this.ram.set(state.ram);\n    this.antic.loadState(state.antic);\n    this.gtia.loadState(state.gtia);\n    this.irq_pokey.loadState(state.pokey);\n    this.lastdmabyte = state.lastdmabyte;\n    this.cart_80 = state.cart_80;\n    this.cart_a0 = state.cart_a0;\n  }\n  saveState() {\n    return {\n      c: this.cpu.saveState(),\n      ram: this.ram.slice(0),\n      antic: this.antic.saveState(),\n      gtia: this.gtia.saveState(),\n      pokey: this.irq_pokey.saveState(),\n      inputs: this.inputs.slice(0),\n      lastdmabyte: this.lastdmabyte,\n      keycode: this.keycode,\n      cart_80: this.cart_80,\n      cart_a0: this.cart_a0,\n    };\n  }\n  loadControlsState(state) {\n    this.inputs.set(state.inputs);\n    this.keycode = state.keycode;\n  }\n  saveControlsState() {\n    return {\n      inputs: this.inputs.slice(0),\n      keycode: this.keycode,\n    };\n  }\n  getRasterY() {\n    return this.antic.v;\n  }\n  getRasterX() {\n    return this.antic.h;\n  }\n  getRasterCanvasPosition() {\n    return {\n      x: this.antic.h * 4 - this.firstVisibleClock,\n      y: this.antic.v - this.firstVisibleScanline,\n    }\n  }\n  getDebugCategories() {\n    return ['CPU', 'Stack', 'ANTIC', 'GTIA', 'POKEY'];\n  }\n  getDebugInfo(category, state) {\n    switch (category) {\n      case 'ANTIC': return ANTIC.stateToLongString(state.antic);\n      case 'GTIA': return GTIA.stateToLongString(state.gtia);\n      case 'POKEY': return POKEY.stateToLongString(state.pokey);\n    }\n  }\n  getKeyboardFunction() {\n    return (o, key, code, flags) => {\n      if (!this.keyboard_active) return false;\n      if (flags & (KeyFlags.KeyDown | KeyFlags.KeyUp)) {\n        //console.log(o, key, code, flags, hex(this.keycode));\n        var keymap = ATARI8_KEYMATRIX_INTL_NOSHIFT;\n        if (key == Keys.VK_F9.c) {\n          this.irq_pokey.generateIRQ(0x80); // break IRQ\n          return true;\n        }\n        for (var i = 0; i < keymap.length; i++) {\n          if (keymap[i] && keymap[i].c == key) {\n            this.keycode = i;\n            if (flags & KeyFlags.Shift) { this.keycode |= 0x40; }\n            if (flags & KeyFlags.Ctrl) { this.keycode |= 0x80; }\n            if (flags & KeyFlags.KeyDown) {\n              this.keycode |= 0x100;\n              this.irq_pokey.generateIRQ(0x40); // key pressed IRQ\n              return true;\n            }\n          }\n        }\n      };\n    }\n  }\n  pokey_irq() {\n    this.cpu.IRQ();\n    this.probe.logInterrupt(2);\n  }\n  antic_nmi() {\n    this.cpu.NMI();\n    this.probe.logInterrupt(1);\n  }\n\n  loadROM(rom: Uint8Array, title: string) {\n    if ((rom[0] == 0xff && rom[1] == 0xff) && !title?.endsWith('.rom')) {\n      // XEX file, chill out and wait for BIOS hook\n      this.xexdata = rom;\n    } else {\n      this.loadCartridge(rom);\n    }\n  }\n\n  loadCartridge(rom: Uint8Array) {\n    // TODO: https://github.com/dmlloyd/atari800/blob/master/DOC/cart.txt\n    // strip off header\n    if (rom[0] == 0x43 && rom[1] == 0x41 && rom[2] == 0x52 && rom[3] == 0x54) {\n      rom = rom.slice(16);\n    }\n    if (rom.length != 0x1000 && rom.length != 0x2000 && rom.length != 0x4000 && rom.length != 0x8000)\n      throw new Error(\"Sorry, this platform can only load 4/8/16/32 KB cartridges at the moment.\");\n    // TODO: support other than 8 KB carts\n    // support 4/8/16/32 KB carts\n    let rom2 = new Uint8Array(0x8000);\n    for (let i = 0; i <= rom2.length - rom.length; i += rom.length) {\n      rom2.set(rom, i);\n    }\n    this.run_address = rom2[0x7ffe] + rom2[0x7fff]*256;\n    this.cart_a0 = true; // TODO\n    this.cart_80 = rom.length == 0x4000;\n    super.loadROM(rom2);\n  }\n\n  writeMapper(addr: number, value: number) {\n    // TODO\n    if (addr == 0xff) {\n      if (value == 0x80) this.cart_80 = false;\n      if (value == 0xa0) this.cart_a0 = false;\n    }\n  }\n\n  loadXEX(rom: Uint8Array) {\n    let ofs = 2;\n    let stub = this.d500;\n    let stubofs = 0; // stub routine \n    var runaddr = -1;\n    // load segments into RAM\n    while (ofs < rom.length) {\n      let start = rom[ofs + 0] + rom[ofs + 1] * 256;\n      let end = rom[ofs + 2] + rom[ofs + 3] * 256;\n      console.log('XEX', hex(ofs), hex(start), hex(end));\n      ofs += 4;\n      for (let i = start; i <= end; i++) {\n        this.ram[i] = rom[ofs++];\n      }\n      if (start == 0x2e0 && end == 0x2e1) {\n        runaddr = this.ram[0x2e0] + this.ram[0x2e1] * 256;\n        console.log('XEX run', hex(runaddr));\n      }\n      if (start == 0x2e2 && end == 0x2e3) {\n        var initaddr = this.ram[0x2e2] + this.ram[0x2e3] * 256;\n        console.log('XEX init', hex(initaddr));\n        stub[stubofs++] = 0x20;\n        stub[stubofs++] = initaddr & 0xff;\n        stub[stubofs++] = initaddr >> 8;\n      }\n      if (ofs > rom.length) throw new Error(\"Bad .XEX file format\");\n    }\n    if (runaddr >= 0) {\n      // build stub routine at 0xd500\n      stub[stubofs++] = 0xa9; // lda #$a0\n      stub[stubofs++] = 0xa0;\n      stub[stubofs++] = 0x8d; // sta $d5ff (disable cart)\n      stub[stubofs++] = 0xff;\n      stub[stubofs++] = 0xd5;\n      stub[stubofs++] = 0x4c; // jmp runaddr\n      stub[stubofs++] = runaddr & 0xff;\n      stub[stubofs++] = runaddr >> 8;\n      // set DOSVEC to 0xd500\n      this.ram[0xa] = 0x00;\n      this.ram[0xb] = 0xd5;\n      this.run_address = 0xd500;\n    }\n  }\n\n  initCartA() {\n    if (this.cpu.getPC() == 0xf17f && this.xexdata) {\n      this.loadXEX(this.xexdata);\n    }\n  }\n\n  setPaddleInput(controller: number, value: number): void {\n    this.irq_pokey.pot_inputs[controller] = 255 - value;\n  }\n\n  getDebugDisplayList() {\n    let pc = this.antic.getDlistAddr();\n    const nextInsn = () => {\n      let b = this.read(pc);\n      pc = ((pc + 1) & 0x3ff) | (pc & ~0x3ff);\n      return b;\n    }\n    let dlist = [];\n    let y = 0;\n    for (let i=0; i<256 && y<240; i++) {\n      let pc0 = pc;\n      let op = nextInsn(); // get mode\n      let mode = op & 0xf;\n      let debugmsg = \"\" // \"op=\" + hex(op);\n      let jmp = false;\n      let lines;\n      if (mode == 0) {\n        lines = (((op >> 4) & 7) + 1);\n        debugmsg += \" blank=\" + lines;\n      } else {\n        lines = MODE_LINES[mode];\n        debugmsg += \" mode=\" + hex(mode);\n        debugmsg += \" lines=\" + lines;\n        jmp = (op & ~0x40) == 0x01; // JMP insn?\n        let lms = (op & 0x40) != 0 && (op & 0xf) != 0; // LMS insn?\n        if (op & 0x10) { debugmsg += \" HSCROL\"; }\n        if (op & 0x20) { debugmsg += \" VSCROL\"; }\n        if (op & 0x80) { debugmsg += \" DLI\"; }\n        if (jmp && (op & 0x40)) { debugmsg += \" JVB\"; }\n        else if (jmp) debugmsg += \" JMP\";\n        else if (lms) debugmsg += \" LMS\";\n        if (jmp || lms) {\n          let dlarg_lo = nextInsn();\n          let dlarg_hi = nextInsn();\n          debugmsg += \" $\" + hex(dlarg_hi) + \"\" + hex(dlarg_lo);\n        }\n      }\n      dlist.push(\"$\"+hex(pc0) + \" y=\" + y + \" \" + debugmsg);\n      if (jmp) break;\n      y += lines;\n    }\n    return dlist;\n  }\n\n}\n\nexport class Atari5200 extends Atari800 {\n  newBus() {\n    return {\n      read: newAddressDecoder([\n        [0x0000, 0x3fff, 0xffff, (a) => { return this.ram[a]; }],\n        [0x4000, 0xbfff, 0xffff, (a) => { return this.rom ? this.rom[a - 0x4000] : 0; }],\n        [0xc000, 0xcfff, 0x1f, (a) => { return this.gtia.readReg(a); }],\n        [0xd400, 0xd4ff, 0xf, (a) => { return this.antic.readReg(a); }],\n        [0xe800, 0xefff, 0xf, (a) => { return this.readPokey(a); }],\n        [0xf800, 0xffff, 0x7ff, (a) => { return this.bios[a]; }],\n      ]),\n      write: newAddressDecoder([\n        [0x0000, 0x3fff, 0xffff, (a, v) => { this.ram[a] = v; }],\n        [0xc000, 0xcfff, 0x1f, (a, v) => { this.gtia.setReg(a, v); }],\n        [0xd400, 0xd4ff, 0xf, (a, v) => { this.antic.setReg(a, v); }],\n        [0xe800, 0xefff, 0xf, (a, v) => { this.writePokey(a, v); }],\n      ]),\n    };\n  }\n}\n\n", "\nimport { Platform, getOpcodeMetadata_6502, getToolForFilename_6502, Base6502MachinePlatform, Preset } from \"../common/baseplatform\";\nimport { PLATFORMS } from \"../common/emu\";\nimport { BaseMAME6502Platform } from \"../common/mameplatform\";\nimport { Atari5200, Atari800 } from \"../machine/atari8\";\n\ndeclare var jt; // for 6502\n\nvar Atari8_PRESETS : Preset[] = [\n  {id:'hello.dasm', name:'Hello World (ASM)'},\n  {id:'hellopm.dasm', name:'Hello Sprites (ASM)'},\n  {id:'helloconio.c', name:'Text Mode (C)'},\n  {id:'siegegame.c', name:'Siege Game (C)'},\n  {id:'hellodlist.c', name:'Display List (C)'},\n];\n\nvar Atari800_PRESETS = Atari8_PRESETS.concat([\n  {id:'testmusic.c', name:'POKEY Music (C)'},\n  {id:'sieve.bas', name:'Benchmark (FastBasic)', category:'FastBasic'},\n  {id:'pmtest.bas', name:'Sprites Test (FastBasic)'},\n  {id:'dli.bas', name:'DLI Test (FastBasic)'},\n  {id:'joyas.bas', name:'Match-3 Game (FastBasic)'},\n]);\n\nconst Atari800_MemoryMap = { main:[\n  {name:'RAM',start:0x0,size:0xc000,type:'ram'},\n  {name:'Left Cartridge ROM',start:0xa000,size:0x2000,type:'rom'},\n  {name:'GTIA',start:0xd000,size:0x20,type:'io'},\n  {name:'POKEY',start:0xd200,size:0x10,type:'io'},\n  {name:'PIA',start:0xd300,size:0x04,type:'io'},\n  {name:'ANTIC',start:0xd400,size:0x10,type:'io'},\n  {name:'Cartridge Control Line',start:0xd600,size:0x100,type:'io'},\n  {name:'ROM',start:0xd800,size:0x800,type:'rom'},\n  {name:'Character Set',start:0xe000,size:0x400,type:'rom'},\n  {name:'ROM',start:0xe400,size:0x1c00,type:'rom'},\n] }\n\nfunction getToolForFilename_Atari8(fn:string) {\n  if (fn.endsWith(\".bas\") || fn.endsWith(\".fb\") || fn.endsWith(\".fbi\")) return \"fastbasic\";\n  else return getToolForFilename_6502(fn);\n}\n\nclass Atari800Platform extends Base6502MachinePlatform<Atari800> {\n  newMachine()          { return new Atari800(); }\n  getPresets()          { return Atari800_PRESETS; }\n  getDefaultExtension() { return \".c\"; };\n  getToolForFilename = getToolForFilename_Atari8;\n  readAddress(a)        { return this.machine.readConst(a); }\n  getMemoryMap()        { return Atari800_MemoryMap; }\n  showHelp = atari8_showHelp;\n  getROMExtension = atari8_getROMExtension;\n  \n  async start() {\n    let bios = await this.loadKernel();\n    await super.start();\n    this.machine.loadBIOS(bios);\n  }\n  biosPath = 'res/altirra/kernel.rom';\n  async loadKernel() {\n    var biosResponse = await fetch(this.biosPath);\n    if (biosResponse.status == 200 || (biosResponse as any as Blob).size) {\n      var biosBinary = await biosResponse.arrayBuffer();\n      return new Uint8Array(biosBinary);\n    } else throw new Error('could not load BIOS file');\n  }\n  getDebugTree() {\n    let tree = super.getDebugTree();\n    tree['display_list'] = this.machine.getDebugDisplayList();\n    return tree;\n  }\n}\n\nclass Atari5200Platform extends Atari800Platform {\n  getPresets() { return Atari8_PRESETS; }\n  newMachine() { return new Atari5200(); }\n  biosPath = 'res/altirra/superkernel.rom';\n}\n\n\n/// MAME support\n\nabstract class Atari8MAMEPlatform extends BaseMAME6502Platform {\n  getPresets() { return Atari8_PRESETS; }\n  getToolForFilename = getToolForFilename_Atari8;\n  getOpcodeMetadata = getOpcodeMetadata_6502;\n  getDefaultExtension() { return \".asm\"; };\n  showHelp = atari8_showHelp;\n}\n\nclass Atari800MAMEPlatform extends Atari8MAMEPlatform implements Platform {\n  getPresets() { return Atari800_PRESETS; }\n  loadROM(title, data) {\n    if (!this.started) {\n      this.startModule(this.mainElement, {\n        jsfile:'mame8bitws.js',\n        biosfile:'a800xl.zip',\n        cfgfile:'a800xl.cfg',\n        driver:'a800xl',\n        width:336*2,\n        height:225*2,\n        romfn:'/emulator/cart.rom',\n        romdata:new Uint8Array(data),\n        romsize:0x2000,\n        preInit:function(_self) {\n        },\n      });\n    } else {\n      this.loadROMFile(data);\n      this.loadRegion(\":cartleft:cart:rom\", data);\n    }\n  }\n  start() {\n  }\n  getMemoryMap = function() { return Atari800_MemoryMap };\n}\n\nclass Atari5200MAMEPlatform extends Atari8MAMEPlatform implements Platform {\n  loadROM(title, data) {\n    if (!this.started) {\n      this.startModule(this.mainElement, {\n        jsfile:'mame8bitws.js',\n        biosfile:'a5200/5200.rom',\n        cfgfile:'a5200.cfg',\n        driver:'a5200',\n        width:336*2,\n        height:225*2,\n        romfn:'/emulator/cart.rom',\n        romdata:new Uint8Array(data),\n        romsize:0x8000,\n        preInit:function(_self) {\n        },\n      });\n    } else {\n      this.loadROMFile(data);\n      this.loadRegion(\":cartleft:cart:rom\", data);\n    }\n  }\n  start() {\n  }\n  getMemoryMap = function() { return { main:[\n    {name:'RAM',start:0x0,size:0x4000,type:'ram'},\n    {name:'Cartridge ROM',start:0x4000,size:0x8000,type:'rom'},\n    {name:'GTIA',start:0xc000,size:0x20,type:'io'},\n    {name:'ANTIC',start:0xd400,size:0x10,type:'io'},\n    {name:'POKEY',start:0xe800,size:0x10,type:'io'},\n    {name:'ATARI Character Set',start:0xf800,size:0x400,type:'rom'},\n    {name:'ROM',start:0xfc00,size:0x400,type:'rom'},\n  ] } };\n}\n\nfunction atari8_getROMExtension(rom: Uint8Array) {\n  if (rom == null) return \".bin\";\n  if (rom[0] == 0xff && rom[1] == 0xff) return \".xex\";\n  else return \".rom\";\n}\n\nfunction atari8_showHelp() {\n  return \"https://8bitworkshop.com/docs/platforms/atari8/\";\n}\n\n///\n\nPLATFORMS['atari8-800.xlmame'] = Atari800MAMEPlatform\nPLATFORMS['atari8-800xl.mame'] = Atari800MAMEPlatform // for dithertron\nPLATFORMS['atari8-5200.mame'] = Atari5200MAMEPlatform\nPLATFORMS['atari8-800'] = Atari800Platform\nPLATFORMS['atari8-5200'] = Atari5200Platform\n"],
  "mappings": "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",
  "names": ["PF_LEFT", "PF_RIGHT", "DMACTL", "CHACTL", "DLISTL", "DLISTH", "HSCROL", "VSCROL", "PMBASE", "CHBASE", "WSYNC", "VCOUNT", "PENH", "PENV", "NMIEN", "NMIRES", "NMIST", "ANTIC_LEFT", "ANTIC_RIGHT", "LAST_DMA_H", "MODE_LINES", "MODE_PERIOD", "MODE_YPERIOD", "MODE_SHIFT", "ANTIC", "readfn", "nmifn", "NMIEN", "NMIST", "PENH", "PENV", "DMACTL", "safe_extend", "s", "state", "lpad", "hex", "dumpRAM", "a", "v", "WSYNC", "NMIRES", "VCOUNT", "DLISTL", "DLISTH", "effwidth", "hscroll", "HSCROL", "PF_LEFT", "PF_RIGHT", "vscrol", "VSCROL", "mask", "pc", "b", "did_dma", "op", "candma", "section", "oneline", "pmaddr", "PMBASE", "mode", "ch", "y", "addrofs", "chbase", "CHBASE", "addr", "chactl", "CHACTL", "mode3lc", "HPOSP0", "SIZEP0", "SIZEM", "GRAFP0", "GRAFM", "COLPM0", "COLPF0", "COLPF1", "COLPF2", "COLPF3", "COLBK", "PRIOR", "VDELAY", "GRACTL", "HITCLR", "CONSPK", "M0PF", "P0PF", "M0PL", "P0PL", "TRIG0", "CONSOL", "HOFFSET", "PRIOR_TABLE", "MODE_9_LOOKUP", "GTIA", "safe_extend", "s", "a", "v", "b", "h", "data", "priobias", "topprio", "pfset", "topobj", "ppmask", "i", "prio", "bit", "HPOSP0", "size", "expandBits", "col", "pf", "COLORS_RGBA", "state", "lpad", "hex", "dumpRAM", "x", "gtia_ntsc_to_rgb", "AUDF1", "AUDF2", "AUDF3", "AUDF4", "AUDCTL", "STIMER", "SKRES", "POTGO", "SEROUT", "IRQEN", "SKCTL", "ALLPOT", "KBCODE", "RANDOM", "SERIN", "IRQST", "SKSTAT", "POLY9", "CH1_179", "CH3_179", "CH1_CH2", "CH3_CH4", "CLOCK_15", "DIV_64", "DIV_15", "POLY9_SIZE", "POLY17_SIZE", "CHAN1", "CHAN2", "CHAN3", "CHAN4", "ANTIC_LINE_C", "SIO_XMTDONE_INTERVAL", "SIO_SEROUT_INTERVAL", "poly9", "poly17", "initPolyTables", "reg", "i", "POKEY", "irq", "antic_xpos", "safe_extend", "s", "SKSTAT", "DIV_64", "addr", "byte", "ALLPOT", "KBCODE", "RANDOM", "SKCTL", "AUDCTL", "POLY9", "POLY9_SIZE", "POLY17_SIZE", "ptr", "CLOCK_15", "DIV_15", "CHAN1", "CHAN2", "CHAN3", "CHAN4", "AUDF1", "CH1_CH2", "AUDF2", "AUDF3", "CH3_CH4", "AUDF4", "IRQEN", "IRQST", "SKRES", "POTGO", "SEROUT", "SIO_SEROUT_INTERVAL", "SIO_XMTDONE_INTERVAL", "STIMER", "chan_mask", "CH1_179", "ANTIC_LINE_C", "CH3_179", "SERIN", "chan", "mask", "state", "dumpRAM", "ATARI8_KEYMATRIX_INTL_NOSHIFT", "Keys", "ATARI8_KEYCODE_MAP", "makeKeycodeMap", "Atari800", "BasicScanlineMachine", "MOS6502", "ANTIC", "GTIA", "POKEY", "newPOKEYAudio", "TssChannelAdapter", "newKeyboardHandler", "newAddressDecoder", "a", "v", "bios", "i", "TRIG0", "CONSOL", "y", "xofs", "gtiatick1", "gtiatick2", "bp", "MODE_SHIFT", "odd", "state", "category", "o", "key", "code", "flags", "keymap", "rom", "title", "rom2", "addr", "value", "ofs", "stub", "stubofs", "runaddr", "start", "end", "hex", "initaddr", "controller", "pc", "nextInsn", "b", "dlist", "pc0", "op", "mode", "debugmsg", "jmp", "lines", "MODE_LINES", "lms", "dlarg_lo", "dlarg_hi", "Atari5200", "Atari8_PRESETS", "Atari800_PRESETS", "Atari800_MemoryMap", "getToolForFilename_Atari8", "fn", "getToolForFilename_6502", "Atari800Platform", "Base6502MachinePlatform", "atari8_showHelp", "atari8_getROMExtension", "Atari800", "a", "bios", "biosResponse", "biosBinary", "tree", "Atari5200Platform", "Atari5200", "Atari8MAMEPlatform", "BaseMAME6502Platform", "getOpcodeMetadata_6502", "Atari800MAMEPlatform", "title", "data", "_self", "Atari5200MAMEPlatform", "rom", "PLATFORMS"]
}

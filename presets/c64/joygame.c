
#include "common.h"
//#link "common.c"

#include "sprites.h"
//#link "sprites.c"

#define NUM_SPRITES 3

/*{w:12,h:21,bpp:2,brev:1,wpimg:64,count:3,aspect:2}*/
const char SPRITE_MC_DATA[64*NUM_SPRITES] = {
  0x0A,0xAA,0x80,0x0A,0xAA,0x80,0x2A,0xAA,
  0xA0,0x2A,0xAA,0xA0,0xAA,0xAA,0xAA,0xFF,
  0xD5,0x40,0x0D,0xD7,0x40,0x3D,0xD5,0x54,
  0x37,0x55,0x54,0x37,0x55,0x54,0x35,0x55,
  0x00,0x3A,0xA0,0x00,0xEA,0xA8,0x00,0xAB,
  0xAA,0x00,0xAB,0xAA,0x00,0xAB,0xAA,0x80,
  0xAA,0xEA,0x80,0xAA,0xAA,0x80,0x0F,0xFC,
  0x00,0x0F,0xFC,0x00,0x0F,0xFF,0xC0,0x00,

  0x02,0xAA,0xA0,0x02,0xAA,0xA0,0x0A,0xAA,
  0xA8,0x0A,0xAA,0xA8,0xAA,0xAA,0xAA,0x01,
  0x57,0xFF,0x01,0xD7,0x70,0x15,0x57,0x7C,
  0x15,0x55,0xDC,0x15,0x55,0xDC,0x00,0x55,
  0x5C,0x00,0x0A,0xAC,0x00,0x2A,0xAB,0x00,
  0xAA,0xEA,0x00,0xAA,0xEA,0x02,0xAA,0xEA,
  0x02,0xAB,0xAA,0x02,0xAA,0xAA,0x00,0x3F,
  0xF0,0x00,0x3F,0xF0,0x03,0xFF,0xF0,0x00,

  0x00,0xAA,0x80,0x02,0xAA,0xA0,0x0A,0xAA,0xA8,
  0x0A,0xAE,0xA8,0x0A,0xBB,0xA8,0x0A,0xBA,0xA8,
  0x0A,0xBB,0xA8,0x0A,0xAE,0xA8,0x0A,0xAA,0xA8,
  0x09,0xAA,0x98,0x08,0x6A,0x48,0x08,0x1D,0x08,
  0x02,0x0C,0x20,0x02,0x0C,0x20,0x02,0x0C,0x20,
  0x00,0x8C,0x80,0x00,0x8C,0x80,0x00,0x55,0x40,
  0x00,0x77,0x40,0x00,0x5D,0x40,0x00,0x15,0x00,
  0x80,
};

// starting index for sprites
#define SPRITE_SHAPE 192

// player data
int player_x = 172;
byte player_y = 145;
byte faceleft = 0; // 0 = face right, 1 = face left

void init_sprite_shapes(void) {
  byte i;
  for (i=0; i<NUM_SPRITES; i++) {
    sprite_shape(SPRITE_SHAPE+i, SPRITE_MC_DATA+64*i);
  }
}

void init_sprite_positions(void) {
  byte i;
  // setup sprite positions
  player_x = 172;
  player_y = 145;
  // set random positions for non-players
  // and draw them to sprite shadow buffer
  srand(7);
  for (i=1; i<8; i++) {
    int x = rand() % (320 - 24) + 24;
    byte y = rand() % (229 - 50) + 50;
    sprite_draw(i, x, y, SPRITE_SHAPE + 2);
    sprshad.spr_color[i] = i | 8;
  }
}

void move_player(byte joy) {
  // move sprite based on joystick
  if (JOY_LEFT(joy)) { player_x -= 1; faceleft = 1; }   // move left 1 pixel
  if (JOY_RIGHT(joy)) { player_x += 1; faceleft = 0; }  // move right 1 pixel
  if (JOY_UP(joy)) { player_y -= 1; }     // move up 1 pixel
  if (JOY_DOWN(joy)) { player_y += 1; }   // move down 1 pixel

  // draw player into sprite shadow buffer
  sprite_draw(0, player_x, player_y, SPRITE_SHAPE + faceleft);
}

void move_non_players(void) {
  byte i;
  // wiggle non-player sprites randomly
  for (i=1; i<8; i++) {
    sprshad.spr_pos[i].y += rand() & i;
  }
}

void main(void) {
  // variables
  byte bgcoll;	// sprite background collision flags
  byte sprcoll; // sprite collision flags
  byte joy;	// joystick flags

  clrscr();
  
  // install the joystick driver
  joy_install (joy_static_stddrv);
  
  // set multicolor sprites and colors
  sprshad.spr_mcolor = 0b11111111;
  sprshad.spr_color[0] = SPRITE_MC_DATA[63];
  VIC.spr_mcolor0 = COLOR_GRAY2;
  VIC.spr_mcolor1 = COLOR_BLACK;
  
  // setup sprites
  init_sprite_shapes();
  init_sprite_positions();
  
  // loop forever
  while (1) {
    // wait for end of frame
    waitvsync();
    // update sprite registers from sprite shadow
    // buffer before frame starts drawing
    sprite_update(DEFAULT_SCREEN);
    
    // get joystick bits
    joy = joy_read(1);
    move_player(joy);
    // move other objects
    move_non_players();
    
    // grab and reset collision flags
    sprcoll = VIC.spr_coll;
    bgcoll = VIC.spr_bg_coll;
    // change color when player collides with sprite
    sprshad.spr_color[0] = (sprcoll & 1) ? 10 : 3;
  }
}
